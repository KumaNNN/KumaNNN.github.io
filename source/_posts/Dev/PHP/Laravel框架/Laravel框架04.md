---
title: Laravel框架04
date: 2019-02-28 12:36:17
updated: 2019-02-28 12:36:17 
mathjax: false
categories: 
tags:
typora-root-url: imgs
typora-copy-images-to: imgs
top: 1
---


# 一、==文件上传==

> Laravel框架中提供了一个文件上传操作类，Illuminate\Http\UploadedFile

```
Laravel中，保存上传可以使用$request->file(‘name值’);或 $request->name值来获取上传处理的操作对象。
使用store方法保存文件的默认路径在storage/app目录。
store(‘保存路径’,’存储磁盘空间’);
storeAs(‘保存路径’,’文件名’,’存储磁盘空间’);

storeAs和store的区别：
store会自动根据上传文件的内容生成md5算法的文件名。
而storeAs则需要我们自己设置文件名。
存储磁盘空间，是Laravel默认情况下，会允许我们保存文件在当前项目服务器的磁盘中， 也允许我们把文件保存到第三方存储磁盘中（例如云存储），所以Laravel允许我们在store或storeAs的最后一个参数中，进行存储磁盘空间的设置。
磁盘空间的配置文件在 config/filesystems.php中。（后面我们的文件几乎都是存储在云存储上）
```

## 1、控制器代码

![1539307520759](1539307520759.png)

![1539307567631](1539307567631.png)

效果如下：

![1539307589843](1539307589843.png)

> 问题：
>
>​	因为Laravel的访问入口在public目录下，而我们现在保存的文件是在storage/app/目录下。 我们网站的用户是无法访问到storage/app目录下的内容。
>
>解决方案：
>
>​	Laravel的工匠指令提供了创建==软链接==的命令，让用户在访问入口的public目录下，也可以访问到storage/app/public目录中的内容。

```cmd
php artisan storage:link
```

![1539307782720](1539307782720.png)

执行成功后，会在项目的根目录下生成storage目录，如下图所示：

![1539307801185](1539307801185.png)

访问图片效果如下：

![1539307854145](1539307854145.png)



# 二、==数据填充==


### 1、数据种子填充技术

> 我们手动添加测试数据是不是很麻烦，同时也浪费大把时间。我们可以使用Laravel内置的一个生成数据的数据种子填充技术Seed和Faker插件。
>
> 手册参考： Laravel >> 数据库 >>数据填充

使用工匠指令生成数据种子类文件

```cmd
php artisan make:seed 类名称
```

> 注意：
>
> ​	类名称的命名规范：因为我们都填充数据给数据表的，一般建议使用 表名/模型名称 作为类名称。例如：Admin模型填充数据，那么命名为“AdminTableSeeder”

![1539314927303](1539314927303.png)

> 注意：
>
> ​	数据种子填充类文件存放到/database/seeds目录下

代码如下：

![1539315241800](1539315241800.png)

> 说明：
>
> ​	数据种子填充类文件默认会有一个run方法，在run方法中我们就可以使用数据模型进行批量创建数据了。

执行数据种填充指令

```cmd
php artisan db:seed --class=AdminTablesSeeder
```

![1539315382484](1539315382484.png)

重复执行可能会报以下错误

![1539315466757](1539315466757.png)

### 2、使用数据种子填充生成测试数据

#### 2.1、数据种子填充代码

![1539316041731](1539316041731.png)

#### 2.2、执行种子文件

```cmd
语法：php artisan db:seed  --class=类名
```

![1539315952410](1539315952410.png)

效果

![1539316089010](1539316089010.png)

> 注意：
>
> ​	假如数据中某个字段设置了唯一属性，上面这种生成填充数据只能使用一次或修改内容后再生成。接下来我们可以使用Faker类插件来生成高效的测试数据，Faker类的文件路径：vendor\fzaninotto\faker\src\Faker\Factory.php



# 三、==数据迁移==

> 我们接下来，需要实现功能，必须先有对应的数据表，和以往使用sql语句建表所不同，使用Laravel开发项目，Laravel并不希望我们使用sql语句直接建表，因为sql语句建表，容易在后面开发项目或维护上，因为团队开发项目时，修改表结构会带来一定维护的困难。
> 所以，为了解决上述的这种问题，Laravel提供了一种叫数据迁移的PHP代码建表功能，它可以让我们使用代码来建表，同时Laravel对于应用了这种功能创建的表会自动进行版本管理。
>
> 手册参考：Laravel >> 数据库 >>数据库迁移

## 1、创建数据迁移文件

建议：

1. 一个表对应一个数据迁移类，一个类就是一个文件。
2. 类名建议以“操作表名table”格式命名，那么生成的类文件会在自动存储在/database/migrations目录中，文件名格式：YYYY_mm_dd_HHiiss操作表名_table.php
3. Laravel在默认情况下，database/migrations下，会自动提供两张demo的数据迁移类文件，这个可以删除

```cmd
语法：
php artisan make:migration 类名 
或 
php artisan make:migration 类名 --create=表名
```

![1539333844223](1539333844223.png)

代码如下：

![1539333942881](1539333942881.png)



创建会员迁移文件

```cmd
php artisan make:migration create_user_table
```

![1539333978281](1539333978281.png)

代码如下：

![1539334023579](1539334023579.png)

> 说明：
>
> 上面就是数据迁移类文件的代码，默认情况下，数据迁移类会提供两个操作方法给我们使用，分别为：
> up
>    表示创建/修改表或表结构的操作方法
>    可以理解为，数据库操作的前进步骤，或版本升级
> down
>    表示删除/还原表或表结构
>    可以理解为，数据库操作的后退步骤，或版本降级
>
> 在artisan工匠指令中，就有数据迁移部分的命令migrate，专门控制数据库操作版本的前进和后退操作
> 前进操作的命令（当运行前进操作命令时，Laravel会自动执行所有未执行的迁移类文件中的up方法代码）：
> `php artisan migrate`
>
> 后退操作的命令（当运行后退操作命令时，Laravel会自动执行所有已执行的迁移类文件中的down方法代码）：
> php artisan migrate:rollback     后退一个版本
> php artisan migrate:reset        版本重置，回到最初状态，版本 0 

### 1.1、Schema

> Schema门面类位置：Illuminate\Support\Facades\Schema
>
> 创建数据表
> `Schema::create($table,$callback)`
>    $table：字符串，要创建的表名
>    $callback：匿名函数，在匿名函数中声明表字段代码
>
> 删除数据表
> `Schema::dropIfExists($table);`
>    $table：字符串，要删除的表名
>
> 更改数据表结构
> `Schema::table($table,$callback);`
>    $table：字符串，要创建的表名
>    $callback：匿名函数，在匿名函数中声明表结构代码

### 1.2、Blueprint

> Blueprint类文件位置：Illuminate\Database\Schema\Blueprint.php
>
> Blueprint提供大量以SQL关键词为方法名的方法供我们声明结构。常用方法如下：
> `$table->increments($field);      `
>
> 设置当前字段为主键，并且自动增长，非空，数据类型为无符号int。

## 2、示例代码

迁移文件开发文档：https://laravelacademy.org/post/6964.html



执行迁移文件

```cmd
语法：php artisan migrate
```

![1539334710236](1539334710236.png)

可能会报以下错误：

![1539334446289](1539334446289.png)

> 注意：
>
> ​	是因为我使用$table->strign('nickname', 255); 相当于：MySql里面的char或varchar

> 注意：
>
> ​	如果数据表已经存在，不管你是使用SQL语句创建的还是Laravel框架中的迁移创建数据表，再创建就报以下错误信息

![1539334658728](1539334658728.png)

接下来，我们需要回滚当前的创建user的操作，可以以下两个命令中，任意一个

> php artisan migrate:rollback         # 回滚到上一步操作
> php artisan migrate:reset           # 回滚到最初，相当于清空数据库了

![1539334729023](1539334729023.png)





# 四、案例：完成管理员功能

## 1、管理员列表

### 1.1、控制器代码

![1539307979743](1539307979743.png)

### 1.2、视图

![1539308509190](1539308509190.png)

### 1.3、效果

![1539308518036](1539308518036.png)

## 2、管理员编辑

### 2.1、控制器代码

![1539309902218](1539309902218.png)

### 2.2、视图

复制resources/views/admin/admin/add.blade.php文件，并重命名为edit.blade.php

![1539309940029](1539309940029.png)

数据回显

![1539310292904](1539310292904.png)

![1539310340027](1539310340027.png)

![1539310377835](1539310377835.png)

效果

![1539310405216](1539310405216.png)

### 2.3、数据更新

![1539311810824](1539311810824.png)

![1539311829942](1539311829942.png)

![1539311850787](1539311850787.png)

有可能报以下错误：

![1539311583155](1539311583155.png)

主要是没有把_token与 _method字段排除掉

### 2.4、效果

![1539311911491](1539311911491.png)

### 2.5、文件上传

**控制器代码**

![1539312950825](1539312950825.png)

![1539312989835](1539312989835.png)

## 3、管理员删除

### 3.1、修改视图代码

修改：resources/views/admin/admin/index.blade.php文件代码

![1539314784733](1539314784733.png)

### 3.2、控制器代码

![1539314584534](1539314584534.png)

### 3.3、效果

![1539314738611](1539314738611.png)

## 4、管理员列表实现分页功能



### 4.1、控制器代码

app/Http/Controllers/Admin/AdminController.php

![1539326083681](1539326083681.png)

### 4.2、视图

resources/views/admin/admin/index.blade.php

![1539326169839](1539326169839.png)

效果如下：

![1539326178945](1539326178945.png)

> 注意：
>
> ​	为我们提供了$data->render()与$data->links()方法显示页码

### 4.3、修改分页类样式

引入css样式文件

![1539326288956](1539326288956.png)

```html
<div id="pull_right">
    <div class="pull-right">
        {{$admins->links()}}
    </div>
</div>
```

效果如下：

![1539326314514](1539326314514.png)

显示总共数量

![1539326396404](1539326396404.png)

效果：

![1539326418440](1539326418440.png)

# 三、用户登陆与退出

## 1、用户登陆

> 步骤：
> 1.显示登录页面
> 	1.1显示验证码
> 2.提交登录信息
> 3.控制器接收登录数据
> 4.验证登录信息
> 	4.1 验证成功，保存登录状态，跳转到后台首页
> ​	4.2 验证失败，返回上一页，提示错误信息
> 5.其他页面实现防翻墙功能

### 1.1、显示登陆页面

#### 1.1.1、新建控制器器

```cmd
php artisan make:controller Admin\PublicController
```

![1539326515375](1539326515375.png)

代码如下：

![1539326589316](1539326589316.png)

#### 1.1.2、视图

将视图文件复制到resources/views/admin/public目录下。注意：需要手动创建public目录

![1539326686965](1539326686965.png)

修改静态资源路径

![1539326828348](1539326828348.png)

#### 1.1.3、定义路由

![1539326980463](1539326980463.png)

> 说明：
>
> ​	显示用户登陆表单页面与验证用户信息使用同一个方法，所以这里使用match路由

效果如下

![1539326956154](1539326956154.png)

#### 1.1.4、调整表单信息

![1539327100868](1539327100868.png)



#### 1.1.5、显示验证码

> 注意：
>
> ​	Laravel中默认是没有内置验证码功能的。我们可以通过在github或者composer的安装包列表中找到第三方验证码安装包，使用composer进行安装即可。
>
> https://packagist.org/

![1539327170683](1539327170683.png)

切换镜像源

```cmd
composer config -g repo.packagist composer https://packagist.laravel-china.org
```

![1539327207989](1539327207989.png)

安装验证插件

```cmd
composer require mews/captcha
```

![1539327400989](1539327400989.png)

配置config/app.php

![1539327447924](1539327447924.png)

```php
'providers' => [
        // ...
        Mews\Captcha\CaptchaServiceProvider::class,
 ]
    
 'aliases' => [
        // ...
        'Captcha' => Mews\Captcha\Facades\Captcha::class,
 ]
```

![1539327507965](1539327507965.png)

![1539327550841](1539327550841.png)

生成验证配置文件

```cmd
php artisan vendor:publish
```

![1539327591250](1539327591250.png)

效果

![1539327649586](1539327649586.png)

显示验证

修改resources/views/admin/public/login.blade.php代码如下：

![1539327776073](1539327776073.png)

点击切换验证

![1539328068364](1539328068364.png)

效果如下：

![1539328097366](1539328097366.png)

### 1.2、验证用户信息

#### 1.2.1、接收参数

Http/Controllers/Admin/PublicController.php

![1539328275310](1539328275310.png)

#### 1.2.2、验证用户信息

![1539330306890](1539330306890.png)

![1539330331227](1539330331227.png)

上面已经跳转返回上一页了，接下来我们可以直接在login的视图页面中，显示错误信息。

![1539330390269](1539330390269.png)

#### 1.2.3、实现多条件登陆

> 随着时间的推移，我们用户注册网站、app的信息越来越多，不仅可以通过email来进行，也可以通过手机号码、微信帐号、自定义帐号等。那么登录的时候，这些信息因为具有唯一性，所以也是可以用来做登录的凭证。
>
> 我们这里也可以实现，让管理员可以通过帐号、邮箱和手机号码进行登录。

##### 控制器代码

验证用户名是否正确

![1539330477019](1539330477019.png)

![1539330881248](1539330881248.png)

验证密码是否正确

![1539331117671](1539331117671.png)

保存用户信息到session并跳转

![1539331341772](1539331341772.png)

### 1.3、实现防翻墙功能

> 在以往的项目中，我们都是在公共控制器的构造方法中进行登录状态的验证。
> 其实本质上来说，就是在用户访问到指定控制器之前，先一步进行判断和拦截。
> 在Laravel中，我们不需要使用上面这种方式，Laravel提供了一种中间件的类，这种类会在路由类执行以后，在控制器类执行之前，可以被调用。
> 所以我们可以把类似于验证登录，验证权限的代码，写到中间件中。

#### 1.3.1、middleware-中间件

中间件示意图：

![1539140429646](1539140429646.png)

#### 1.3.2、创建中间件

```cmd
php artisan make:middleware 类名
```

> 注意，中间件的类名建议使用驼峰式，以当前中间件的功能作为命名，例如，检测管理员是否登录的中间件，则类名建议是 CheckAdminLogin

![1539331645528](1539331645528.png)

代码如下：

![1539331682288](1539331682288.png)

> 上面就是我们创建的中间件了，上面handle方法会在中间件被调用的时候自动执行，所以我们一般会把中间件需要执行代码，写在这种方法中。
> 中间件虽然已经创建出来了，但是laravel中并没有识别到，所以接下来，我们需要把中间件注册到项目中。

#### 1.3.3、把中间件注册到项目中

> 在Laravel中， 如果需要在项目中使用某个中间件，则必须把对应的中间件注册到项目中，如何注册呢？
> 就是把中间件的类名写到 \app\Http\Kernel.php文件中。

代码

![1539331788114](1539331788114.png)

#### 1.3.4、在项目中调用中间件

> 在项目中使用中间件有三种方式：
> 1.在控制器的方法中使用【极少用】
>    $this->middleware(‘中间件名称’); 
> 2.在路由规则中使用
>    Route::get()->middleware(‘中间件名称’);
> 3.在路由群组中使用【使用最多】
>    Route::group([ ‘middleware’=>’中间件1:xxx|中间件2|’ ],function(){});
>
> 在开发中，最常用使用的是第3种，接着就是第2种。我们这里使用第3种

路由代码如下：

![1539331902887](1539331902887.png)

#### 1.3.5、在中间件中实现防翻墙

中间件代码如下：

![1539332137050](1539332137050.png)

效果如下：

![1539332151627](1539332151627.png)

## 2、用户退出

### 控制器代码

![1539332290990](1539332290990.png)

### 定义路由

![1539332369770](1539332369770.png)

### 视图

修改resources/views/admin/index/index.blade.php文件代码，如下图所示

![1539332455977](1539332455977.png)

显示登陆的用户名

![1539332554622](1539332554622.png)







