[{"title":"Index","url":"%2Fposts%2F1102202885%2F","content":"\n\n# ���� \n \t\n## GDͼ�������� \n[����Ԥ��](GDͼ��������.md)    [Blog](http://blog.kuma8866.top/posts/81311927/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/GD/GDͼ��������.md)\n\n* GDͼ����������ظ���\n* ����GD��չ\n* GD��չ��ز���\n\n\n \n## GDͼ������������ \n[����Ԥ��](GDͼ������������.md)    [Blog](http://blog.kuma8866.top/posts/2032372126/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/GD/GDͼ������������.md)\n\n* ����ˮӡͼ\n* ��������ͼ\n* ������֤��\n \n","categories":["GD"]},{"title":"Index","url":"%2Fposts%2F1102202886%2F","content":"\n\n# Laravel���\n\n### ����֪ʶ\n\n* [Laravel-����](Laravel���-01.md)\n* [��װ](Laravel���-01.md)\n* [Ŀ¼�ṹ](Laravel���-01.md)\n* [����ָ��](Laravel���-01.md)\n* [·��](Laravel���-01.md)\n* [��ͼ](Laravel���-01.md)\n* [blade(ģ��)�﷨](Laravel���-01.md)\n\n\n\n* [HTTP���������Ӧ](Laravel���-02.md)\n\n* [�Ự����](Laravel���-02.md)\n\n* [���ݿ�](Laravel���-02.md)\n\n  * �������ݿ�\n  * ���ݿ����\n\n* [����](Laravel���-02.md)\n\n* [DB��ѯ������](Laravel���-02.md)\n\n  * ��������\n  * ��ѯ����\n  * ɾ������\n  * �༭����\n  * ������ѯ\n\n  \n\n* [Eloquent ORMģ��](Laravel���-03.md)\n\n  * ʲô��ORMģ��\n  * ����ģ��(ORMģ��)\n  * ��ѯ����\n  * ��������\n  * ��������\n  * ɾ������\n  * ��ɾ��\n\n* [����ģ��](Laravel���-03.md)\n\n  * ���\n  * ʹ�ù���ģ�ͽ��ж������\n\n* [ģ��̳�](Laravel���-03.md)\n\n\n\n* [�ļ��ϴ�](Laravel���-04.md)\n* [�������](Laravel���-04.md)\n* [����Ǩ��](Laravel���-04.md)\n\n\n\n### ����\n\n* [����������Ա����ģ��](Laravel���-03.md)\n* [��������ɹ���Ա����](Laravel���-04.md)\n\n\n\n\n\n \t\n","categories":["Laravel框架"]},{"title":"Index","url":"%2Fposts%2F1102202887%2F","content":"\n\n# ���� \n \t\n## MVC \n[����Ԥ��](MVC.md)    [Blog](http://blog.kuma8866.top/posts/2218208633/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/MVC/MVC.md)\n \n* MVC��������\n* ������ʹ��MVCʵ�����Ź���ϵͳ\n \n","categories":["MVC"]},{"title":"Index","url":"%2Fposts%2F1102202888%2F","content":"\n\n# ���� \n \t\n## MYSQLI��չ \n[����Ԥ��](MYSQLI��չ.md)    [Blog](http://blog.kuma8866.top/posts/3495660076/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/MYSQLI/MYSQLI��չ.md)\n \n* MYSQLI�ĸ���\n* MYSQLI��չ��ʹ��\n\n\n \n## MYSQLI��չ���� \n[����Ԥ��](MYSQLI��չ����.md)    [Blog](http://blog.kuma8866.top/posts/2685337793/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/MYSQLI/MYSQLI��չ����.md)\n \n* MYSQLIʵ�ֺ�̨���Ź���ϵͳ\n \n","categories":["MYSQLI"]},{"title":"Index","url":"%2Fposts%2F1102202889%2F","content":"\n\n# ���� \n \t\n## PDO���쳣 \n[����Ԥ��](PDO���쳣.md)    [Blog](http://blog.kuma8866.top/posts/1712274088/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/PDO/PDO���쳣.md)\n \n* PDO�Ļ�������\n* PDO�Ļ�������\n* PDO�е�����\n* PDO�е�Ԥ��������\n* PDO�е��쳣����\n\n\n \n## PDO���쳣���� \n[����Ԥ��](PDO���쳣����.md)    [Blog](http://blog.kuma8866.top/posts/2958378060/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/PDO/PDO���쳣����.md)\n \n* ��������װPDO������\n \n","categories":["PDO"]},{"title":"Index","url":"%2Fposts%2F1102202890%2F","content":"\n\n# ���� \n \t\n## smartyģ�弼�� \n[����Ԥ��](smartyģ�弼��.md)    [Blog](http://blog.kuma8866.top/posts/3997252698/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/PHPģ������Smarty/smartyģ�弼��.md)\n \n* SMARTY��������\n* SMARTY����\n* SMARTY�������\n  * ��������(����� Ŀ¼ ����)\n* SMARTYģ�����\n  * SMARTYģ��ע��\n  * SMARTYģ�����\n  * SMARTYϵͳ����\n  * SMARTY���ú���\n  * SMARTY����������\n \n","categories":["PHP模板引擎Smarty"]},{"title":"Index","url":"%2Fposts%2F1102202891%2F","content":"\n\n# ���� \n \t\n## �������1 \n[����Ԥ��](�������1.md)    [Blog](http://blog.kuma8866.top/posts/285029296/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/PHP���������/�������1.md)\n \n* �����������ظ���\n* PHP�е��������\n  * ���Ա�Ķ���\n  * ���Ա�ĵ���\n  * self�ؼ���\n  * ���췽��\n  * ����Ĵ�ֵ\n  * ����Ŀ�¡\n\n  \n## �������2 \n[����Ԥ��](�������2.md)    [Blog](http://blog.kuma8866.top/posts/2314494474/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/PHP���������/�������2.md)\n \n* �Զ�����\n* ��ļ̳�\n  * �̳е��﷨\n  * parent�ؼ���\n  * �����޶����η�\n  * �̳е��ص�\n* ��д\n* final�ؼ���\n  * ������\n  * ���շ���\n* ������\n\n\n\n## �������3 \n[����Ԥ��](�������3.md)    [Blog](http://blog.kuma8866.top/posts/4277359260/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/PHP���������/�������3.md)\n \n* PHP�еĽӿ�\n* PHP�е�����\n* ����������������\n* ���ֳ��������˼��\n  * ����ģʽ\n  * ����ģʽ\n \n\n## �������4 \n[����Ԥ��](�������4.md)    [Blog](http://blog.kuma8866.top/posts/1620559679/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/PHP���������/�������4.md)\n \n* ����ı���\n* ��������л��뷴���л�\n* �������\n* �����ռ�\n \n","categories":["PHP面向对象编程"]},{"title":"Index","url":"%2Fposts%2F1102202892%2F","content":"\n\n# ���� \n \t\n## PhalApi��� \n[����Ԥ��](PhalApi���.md)    [Blog](http://blog.kuma8866.top/posts/745665408/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/PhalApi���/PhalApi���.md)\n \n* �п��\n  * ���\n  * Ŀ¼�ṹ\n  * ���ʽӿ�\n  * ������֤\n  * �ĵ�����\n  * ģ��\n\n\n\n* ������ С�����ֲ�ͼ\n \n","categories":["PhalApi框架"]},{"title":"Index","url":"%2Fposts%2F1102202893%2F","content":"\n\n# ���� \n \t\n## TP3��� \n[����Ԥ��](TP3���.md)    [Blog](http://blog.kuma8866.top/posts/551416508/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/TP3���/TP3���.md)\n \n  * ���\n  * ���غͲ���\n  * Ŀ¼�ṹ\n  * ������ѧϰ\n  * ��ͼѧϰ\n  * ģ��ѧϰ\n \n","categories":["TP3框架"]},{"title":"Index","url":"%2Fposts%2F1102202898%2F","content":"\n\n# ���� \n\n## ThinkPHP5�������� \n[����Ԥ��](ThinkPHP5��������.md)    [Blog](http://blog.kuma8866.top/posts/1124976518/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/ThinkPHP5���/ThinkPHP5��������.md)\n \n \n \n \n## ThinkPHP5�������� \n[����Ԥ��](ThinkPHP5��������.md)    [Blog](http://blog.kuma8866.top/posts/2849568870/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/ThinkPHP5���/ThinkPHP5��������.md)\n \n \n \n","categories":["ThinkPHP5框架"]},{"title":"Index","url":"%2Fposts%2F1102202894%2F","content":"\n\n# ���� \n \t\n## httpЭ�����ļ���� \n[����Ԥ��](httpЭ�����ļ����.md)    [Blog](http://blog.kuma8866.top/posts/3647702629/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/httpЭ�����ļ����/httpЭ�����ļ����.md)\n \n* HTTPЭ��\n* �ļ����\n \n \n \n## httpЭ�����ļ���̰��� \n[����Ԥ��](httpЭ�����ļ���̰���.md)    [Blog](http://blog.kuma8866.top/posts/2991748426/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/httpЭ�����ļ����/httpЭ�����ļ���̰���.md)\n \n* �ļ�����\n \n","categories":["http协议与文件编程"]},{"title":"Index","url":"%2Fposts%2F1102202895%2F","content":"\n\n# ���� \n \t\n## �Ự���� \n[����Ԥ��](�Ự����.md)    [Blog](http://blog.kuma8866.top/posts/790821465/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/�Ự����/�Ự����.md)\n \n* �Ự������ظ���\n* COOKIE����\n* SESSION����\n \n","categories":["会话技术"]},{"title":"Index","url":"%2Fposts%2F1102202899%2F","content":"\n\n# ���� \n \t\n## ������Ŀ1 \n[����Ԥ��](������Ŀ1.md)    [Blog](http://blog.kuma8866.top/posts/4006364827/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/������Ŀ/������Ŀ1.md)\n \n \n  \t\n## ������Ŀ2 \n[����Ԥ��](������Ŀ2.md)    [Blog](http://blog.kuma8866.top/posts/2009405217/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/������Ŀ/������Ŀ2.md)\n \n \n \n## ������Ŀ3 \n[����Ԥ��](������Ŀ3.md)    [Blog](http://blog.kuma8866.top/posts/12724151/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/������Ŀ/������Ŀ3.md)\n \n \n \n## ������Ŀ4 \n[����Ԥ��](������Ŀ4.md)    [Blog](http://blog.kuma8866.top/posts/2661724692/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/������Ŀ/������Ŀ4.md)\n \n \n \n","categories":["博客项目"]},{"title":"Index","url":"%2Fposts%2F1102202896%2F","content":"\n\n# ���� \n\n## php \n[����Ԥ��](php.md)    [Blog](http://blog.kuma8866.top/posts/1452351953/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/����֪ʶ/php.md)\n\n* php���\n* ��װ������\n\n\n## PHP ����\n[����Ԥ��](PHP_Array.md)    [Blog](http://blog.kuma8866.top/posts/2612395477/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/����֪ʶ/PHP_Array.md)\n\n  * ������\n  * �������\n  * ����ָ��\n  * ���麯��\n  * �������� \n\n \n\n## php �����﷨\n[����Ԥ��](php_basic_syntax.md)    [Blog](http://blog.kuma8866.top/posts/3316045294/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/����֪ʶ/php_basic_syntax.md)\n\n\n\n## php������\n[����Ԥ��](php_error.md)    [Blog](http://blog.kuma8866.top/posts/2553195674/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/����֪ʶ/php_error.md)\n\n \n\n## PHP ���̿���\n[����Ԥ��](PHP_FlowControl.md)    [Blog](http://blog.kuma8866.top/posts/1870348519/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/����֪ʶ/PHP_FlowControl.md)\n\n  * ѡ��ṹif\n  * ѭ���ṹwhile\n  * ѭ���жϹؼ���\n\n\n## PHP����\n[����Ԥ��](PHP_function.md)    [Blog](http://blog.kuma8866.top/posts/2375644162/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/����֪ʶ/PHP_function.md)\n\n  * �������\n  * �ɱ亯��\n  * ��������\n  * �ַ�������\n  * ʱ�����ں���\n  * ��ѧ����\n\n\n\n����������\n\n������������ \n\n\n\n\n## php����� \n[����Ԥ��](php_operational_character.md)    [Blog](http://blog.kuma8866.top/posts/2259325832/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/����֪ʶ/php_operational_character.md)\n\n \n\n## php����\n[����Ԥ��](php_other.md)    [Blog](http://blog.kuma8866.top/posts/2709295124/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/����֪ʶ/php_other.md)\n\n* �ļ�����\n* ����ת��\n* ��ֹ�ű�ִ��\n* �ݹ�\n* ģ�����ݽṹ\n* �㷨\n\n\n## php�������� \n[����Ԥ��](php_variable_constant.md)    [Blog](http://blog.kuma8866.top/posts/327881324/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/����֪ʶ/php_variable_constant.md)\n\n  * ����\n  * ����\n  * �����������ͼ�ת��\n  * ������صĺ��� \n\n","categories":["基础知识"]},{"title":"Index","url":"%2Fposts%2F1102202897%2F","content":"\n\n# ���� \n \t\n## ������ֵ���ļ��ϴ� \n[����Ԥ��](������ֵ���ļ��ϴ�.md)    [Blog](http://blog.kuma8866.top/posts/2418534610/)     [Github](https://github.com/KumaDocCenter/PHP/blob/master/doc/md/������ֵ���ļ��ϴ�/������ֵ���ļ��ϴ�.md)\n \n* ������ֵ�ĸ���\n* ������ֵ�ķ�ʽ\n  * POST��ʽ\n  * GET��ʽ\n* PHP�������ݵķ�ʽ\n  * $\\_POST��ʽ\n  * $_GET��ʽ\n  * $_REQUEST��ʽ\n* POST��ʽ��GET��ʽ������\n* �ļ��ϴ�\n \n","categories":["表单传值和文件上传"]},{"title":"PDO与异常案例","url":"%2Fposts%2F2958378060%2F","content":"\n\n\n# PDO与异常\n\n\n\n## 案例：封装PDO操作类\n\n### 功能分析\n\n1. 连库基本操作；\n2. 设置操作（增删改）；\n3. 查一条数据；\n4. 查多条数据；\n\n\n\n### 代码实现\n\n构建名为code18.php的程序，代码如下，\n\n```php\n/**\n * PDO操作类\n * @param\n */\nclass PDOTool{\n\n    private $type;//数据库的类型\n    private $host;//IP地址\n    private $port;//端口号\n    private $charset;//字符集\n    private $dbname;//默认选择的数据库\n    private $acc;//帐号\n    private $pwd;//密码\n\n    private $pdo;\n\n    public function __construct($type='mysql', $host='localhost', $port=3306, $charset='utf8', $dbname='test', $acc='root', $pwd='123abc'){ \n        \n        //初始化参数\n        $this->type = $type;\n        $this->host = $host;\n        $this->port = $port;\n        $this->charset = $charset;\n        $this->dbname = $dbname;\n        $this->acc = $acc;\n        $this->pwd = $pwd;\n\n        //连库基本操作\n        $this->connect();\n\n        //设置错误处理模式属性\n        $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n    }\n\n    #连库基本操作\n    private function connect(){ \n        \n        $dsn = \"{$this->type}:host={$this->host};port={$this->port};charset={$this->charset};dbname={$this->dbname}\";\n        $this->pdo = new PDO($dsn, $this->acc, $this->pwd);\n    }\n\n    #设置操作\n    public function setData($sql){ \n        \n        try{\n            $this->pdo->exec($sql);//监听执行增删改的操作\n        }catch(PDOException $err){\n            //输出错误信息\n            echo '错误的代号：' . $err->getCode() . '<br/>'; \n            echo '错误的信息：' . $err->getMessage() . '<br/>'; \n            echo '错误的行号：' . $err->getLine() . '<br/>'; \n            echo '错误的文件：' . $err->getFile(); \n            return false;\n        }\n        return true;\n    }\n\n    #查一条数据\n    public function getRow($sql){ \n        \n        try{\n            $pdostatement = $this->pdo->query($sql);//监听执行增删改的操作\n        }catch(PDOException $err){\n            //输出错误信息\n            echo '错误的代号：' . $err->getCode() . '<br/>'; \n            echo '错误的信息：' . $err->getMessage() . '<br/>'; \n            echo '错误的行号：' . $err->getLine() . '<br/>'; \n            echo '错误的文件：' . $err->getFile(); \n            return false;\n        }\n        return $pdostatement->fetch(PDO::FETCH_ASSOC);//返回解析得到的一条关联数组数据\n    }\n\n    #查询多条数据\n    public function getRows($sql){ \n        \n        try{\n            $pdostatement = $this->pdo->query($sql);//监听执行增删改的操作\n        }catch(PDOException $err){\n            //输出错误信息\n            echo '错误的代号：' . $err->getCode() . '<br/>'; \n            echo '错误的信息：' . $err->getMessage() . '<br/>'; \n            echo '错误的行号：' . $err->getLine() . '<br/>'; \n            echo '错误的文件：' . $err->getFile(); \n            return false;\n        }\n        return $pdostatement->fetchAll();//返回解析得到的一条关联数组数据\n    }\n}\n```\n\n\n\n\n","categories":["PDO"]},{"title":"http协议与文件编程案例","url":"%2Fposts%2F2991748426%2F","content":"\n\n\n## 案例：文件下载\n\n**==操作需求==**：实现文件下载功能，要求：\n\n1. 通过下载页面可以下载code/dw目录中的txt文件和zip文件；\n2. 下载txt文件指定默认的新名字为a.txt；zip文件指定默认的新名字为b.zip；\n\n**==步骤==**：\n\n第一步，构建名为code13.php的程序页面，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>文件下载</title>\n</head>\n<body>\n    \n    <a href=\"http://www.home.com/class/day3/code/code14.php?type=1\">下载txt文件</a>\n    <a href=\"http://www.home.com/class/day3/code/code14.php?type=2\">下载zip文件</a>\n\n</body>\n</HTML>\n```\n\n第二步，构建名为code14的程序处理页面，代码如下：\n\n```php\n<?php\n\n$type = $_GET['type'];//接收type值\n\nif( $type==1 ){//表示下载的是txt文件\n\n    $newFileName = 'a.txt';//下载后默认的新名字\n    $oriFile = './dw/article.txt';//需要下载的txt文件的路径\n\n}elseif( $type==2 ){//表示下载zip文件\n\n    $newFileName = 'b.zip';//下载后默认的新名字\n    $oriFile = './dw/fscp.zip';//需要下载的zip文件的路径\n}\n\n//  表示 服务器告诉浏览器  服务器接下来响应的数据的内容类型是文件流类型的\nheader('Content-type:application/octet-stream');\n//  表示  服务器告诉浏览器  服务器接下来返回的内容你浏览器应该当成附件的形式来处理，这个附件新名字叫filename所指定的名字\nheader('Content-disposition:attachment; filename='.$newFileName);\n//  将读取的文件内容响应给浏览器\necho file_get_contents($oriFile); \n```\n\n第三步，测试使用效果：\n\n访问code13.php，点击下载txt文件，\n\n![1529919943723](23.png)\n\n点击之后，弹出上图所示下载框，新名字为a.txt，\n\n然后选择下载路径，直接下载，\n\n![1529920013880](24.png)\n\n\n\n\n\n","categories":["http协议与文件编程"]},{"title":"PHP流程控制","url":"%2Fposts%2F1870348519%2F","content":"\n\n# 流程控制\n\n顺序结构、分支结构、循环结构\n\n\n\n## 选择(分支)结构\n\n选择结构用于判断给定的条件，根据判断的结果来控制程序的流程\n\nif语句、switch语句\n\n\n\n### if语句\n\n**单分支 **\n\n**结构：**\n\n```\nif(条件语句){\n\n执行代码块\n\n}\n```\n\n结构说明：\n\n条件语句它得到的是布尔值：true \\| false\n\n如果条件表达式成立的话 就执行代码块！\n\n![](1536798148_image2.png)\n\n\n\n**双分支**\n\n**结构：**\n\n```\nif(条件表达式){\n\n执行代码块1\n\n}else{\n\n执行代码块2\n\n}\n```\n\n说明：\n\n如果条件表达式成立， 就执行代码块1， 否则就执行代码块2。\n\n![](1536798148_image3.png)\n\n\n\n**多分支 多条件判断 **\n\n**结构：**\n\n```\nif(条件表达式1){\n\n执行代码块1\n\n}elseif(条件表达式2){\n\n执行代码块2\n\n}elseif(条件表达式n){\n\n执行代码块n\n\n}else{\n\n默认执行的代码块\n\n}\n```\n说明：\n\n先会判断条件表达式1是否成立 ，如果成立就执行代码块1 ，然后就结束if语句。\n\n如果不成立，会判断条件表达式2是否成立， 如果成立就执行代码块2 ，然后就结束if语句； 如果不成立 ，会判断条件表达式n是否成立 ，如果成立就执行代码块n， 如果不成立 就会继续往下判断， 如果上面所有的条件表达式都没有成立， 并且写了else语句 ，就会执行else语句里面的代码块。\n\n![](1536798148_image6.png)\n\n### switch语句\n\n**格式：**\n\n```\nswitch(变量名){\n\ncase 值1:\n\n执行代码块1;\n\nbreak;\n\ncase 值2:\n\n执行代码块2;\n\nbreak;\n\ncase 值3:\n\n执行代码块3;\n\nbreak;\n\ncase 值n:\n\n执行代码块n;\n\nbreak;\n\ndefault:\n\n默认执行的代码块;\n\n}\n```\n\n说明：\n\n得到变量的值与case后面值进行比较 如果返回的是true 就会执行对应的代码块 然后会判断是否有break关键字 如果有的话 switch马上结束 如果没有的话 就会将下一个代码块输出 然后再来判断是否有break关键字。直到找到break关键字为止 ！\n\n```php\n<?php\n//输出今天星期几\n//需要获取服务器的时间\n\n//string date ( string $format [, int $timestamp ] )\n//我们需要设置时区  php.ini配置文件去修改\n// date_default_timezone_set\n//echo date_default_timezone_get(); //获取时区\ndate_default_timezone_set(\"Asia/Chongqing\");\n/*echo date('Y-m-d H:i:s');*/\n$week = date(\"N\"); //获取一周中的第几天 用数字表示  1~7\n$str = \"今天星期\";\nswitch ($week){\n    case 1:\n        $str .= \"一\";\n    break;\n    case 2:\n        $str .= \"二\";\n        break;\n    case 3:\n        $str .= \"三\";\n        break;\n    case 4:\n        $str .= \"四\";\n        break;\n    case 5:\n        $str .= \"五\";\n        break;\n    case 6:\n        $str .= \"六\";\n        break;\n    default:\n        $str .= \"天\";\n}\n\necho $str;\n```\n\n\n\n![](1536798148_image7.png)\n\n\n\n**if语句与switch语句常用的地方：**\n\nif语句一般用于判断范围的\n\nswitch语句一般用于固定值\n\n\n\n##  循环结构\n\n循环是程序设计语言中反复执行某些代码的一种计算机处理过程，常见的有**按照次数循环**和**按照条件循环**。\n\n\n\n\n### while循环\n\n**结构**\n\n```\nwhile(条件表达式){\n\n循环体\n\n}\n```\n\n![](1536798148_image8.png)\n\n![](1536798148_image9.png)\n\n\n\n**流程图：**\n\n![1536750426978](1536798148_1536750426978.png)\n\n\n\n### do....while 循环\n\n**结构**\n\n```\ndo{\n\n循环体\n\n}while(条件表达式);\n```\n\n结构说明：\n\n先会执行一次循环体，然后再来判断条件表达式是否成立！不管条件表达式是否成立 都会先执行一次循环体！\n\n![](1536798148_image11.png)\n\n\n\n### for循环\n\n**格式：**\n\n```\nfor(定义变量;条件语句;变量更新){\n\n循环体\n\n}\n```\n\n结构说明：\n\n第一步：对变量进行初始化 定义变量并赋值 只会执行一次\n\n第二步：判断条件表达式是否成立 当条件表达式不成立 循环体就不会执行了 ！\n\n第三步：在条件表达式成立的情况下 执行循环体\n\n第四步：变量进行更新\n\n![](1536798148_image13.png)\n\n\n\n## 流程控制的替代语法 \n\nPHP 提供了一些流程控制的替代语法，包括 *if*，*while*，*for*，***foreach*** 和 *switch*。替代语法的基本形式是把左花括号（{）换成冒号（:），把右花括号（}）分别换成 *endif;*，*endwhile;*，*endfor;*，*endforeach;* 以及 *endswitch;*\n\n```\nif():\n\nendif;\n\nfor():\n\nendfor;\n\nwhile():\n\nendwhile;\n\nforeach():\n\nendforeach;\n\nswitch():\n\nendswitch;\n```\n\n**注意：**\n\ndo...while是没有替代语法！\n\n![](1536798148_image14.png) \n\n![](1536798148_image15.png)\n\n\n\n# 循环中断关键字\n\n正常情况下循环什么情况才会中断：当条件表达式不满足\n\n**意外中断：**break，continue 一般是在循环语句里面使用， 使用的时候 一般会配合 if语句。\n\n\n\n## break\n\n在循环里面当遇到 break关键字会将整个循环结束 ！\n\n## continue\n\n在循环体里面当遇到 continue关键字中断本次循环 然后继续执行下一次循环！\n\n![](1536798148_image16.png)\n\n\n\n## 中断的层次 \n\n一旦涉及到循环嵌套的时候 就有可以要考虑中断的层数的问题！\n\nbreak关键字 ，它默认是中断一层循环。\n\nbreak n; 它表示可以中断n层循环。\n\n问：\n\n现在我要打印99乘法表！\n\n不输出当遇到乘积大于30\n\n![](1536798148_image17.png)\n\n只要遇到了乘积大于30的数 下面都不要执行！\n\n![](1536798148_image18.png)\n\n\n\n\n","categories":["基础知识"]},{"title":"PHP基本语法","url":"%2Fposts%2F3316045294%2F","content":"\n\n# PHP基本语法\n\n----\n\n\n\n## PHP标签\n\n**为什么要有PHP标签？**   \nPHP是可以嵌入到HTML代码中的！ \n\n![img](php_basic_syntax_01.png)\n\n**注意：**  \n* 如果当PHP与HTML代码进行混编时，当前的这个文件的扩展名一定要**.php**文件 而不是HTML文件。\n* PHP引擎在解析PHP代码时，它只会选择解析属于PHP标签的这一部分代码\n\n----\n\n\n\n## PHP支持2种标签\n\n### <?php   ?> \n\n最常见的标签 \n\n![img](php_basic_syntax_02.png)\n\n\n\n### <?   ?>\n\n短标签 ，但是PHP默认不支持！需要在``php.ini``配置中开启   \n\n第一步：需要在``php.ini``这个配置文件中 开启支持短标签的配置  \n\n![img](php_basic_syntax_03.png)\n\n第二步：需要重启apache服务器  `` httpd.exe -k restart ``  \n\n\n第三步：在02-PHP/code目录下 创建了一个叫demo03.php文件\n\n![](php_basic_syntax_04.png)\n\n----\n\n\n\n## PHP的语句结束符号\n\n要求每一条PHP语句的后面都要加上一个英文状态下面的分号 ， 如果不加会出现语法错误！\n\n![img](php_basic_syntax_05.png)\n\n \n\n在一个PHP文件中有一种情况不需要加分号   \n在整个PHP文件中的最后一条语句 不需要分号，因为在PHP的结束标签中它会默认有一个分号，但是建议大家每条语句都要加分号\n\n----\n\n\n\n## PHP的注释\n\n注释分为两种：**行注释**和**块注释**\n\n### 行注释\n\n```php\n// 注释的内容 \n#  注释的内容 \n```\n\n\n\n### 块注释\n\n```php\n/*\n\n要注释的内容\n\n*/\n```\n\n \n\n块注释一般多用于函数中或者方法！  其实块注释也是有格式！这个格式它可以是PHPDocument这个工具提取到！因为当一个程序员看到当前的函数的注释的时候，就不用去看代码，已经可以明白这个函数是用来做什么的！\n\n![](php_basic_syntax_06.png)\n\n----\n\n\n\n## 几个常用的输出的方法\n\n### print\n\n可以输出变量或者常量的值或者表达式的值！\n\n![](php_basic_syntax_07.png) \n\n\n\n### echo\n\n可以输出变量，常量 ，表达式的值！它可以一次输出多个 每一个之间使用逗号来分隔！\n\n![](php_basic_syntax_08.png) \n\n\n\n### var_dump\n\n它是我们以后在工作中**使用的最多**的 它可以输出变量、常量 、表达式的值 还可以输出其类型以及其它额外信息  并且还可以打印数组！它也可以一次输出多个每一个之间使用逗号来分隔！\n\n![](php_basic_syntax_09.png) \n\n\n\n**注意**   \n* 布尔类型一定要使用var_dump来打印 \n* 数组不能使用print和echo 语句来打印 \n\n\n\n### printf\n\n它比较擅长输出文本与变量的组合产物    \n\n\nprintf这个输出语句通常是由两部分组成！    \n前半部分是由引号括起来的字符串，后半部分是变量  如果前半部分有变量 需要使用一个变量的占位符来表示  变量的占位符通常是用%来表示的。它要与后面的变量一一对应！    \n\n \n\n**常见的变量占位符**      \n\n* **%c**：将后面的变量认为是一个整数，并显示为该整数对应的ASCII码字符    \n\n* **%d**：将后面的变量认为是一个整数，并显示为有符号的十进制数\n* **%u**：将后面的变量认为是一个整数，并显示为无符号的十进制数\n* **%o**：将后面的变量认为是一个整数，并显示为无符号的八进制数\n* **%x**：将后面的变量认为是一个整数，并显示为无符号的十六进制数\n* **%f**：将后面的变量认为是一个浮点数，并显示为浮点数\n* **%s**：将后面的变量认为是一个字符串，并显示为字符串\n\n \n\n有符号：表示有正负之分      \n无符号：只能表示正数       \n\n![](php_basic_syntax_10.png) \n\n \n\n### print_r\n\n一般是用来打印数组，与var_dump的区别是，print_r只打印数组的元素的下标和元素的值，不输出其他的额外信息！  \n\n常见的：**echo**、**var_dump**   \n\n\n**数组只能使用var_dump与print_r来输出。**\n\n\n![](php_basic_syntax_11.png) \n\n\n\n","categories":["基础知识"]},{"title":"PHP错误处理","url":"%2Fposts%2F2553195674%2F","content":"\n\n# 三十三、错误处理\n\n## 错误的分类\n\n### 初始化错误\n\n* 警告错误\n* 致命错误\n\n\n\n### 编译时错误\n\n程序运行之前都要先编译。如果语法有错误，就会立即报错，且不会去执行程序。\n\n* 语法错误\n\n* 警告错误\n\n* 致命错误\n\n  \n\n### 运行时错误\n\n就是在程序语法检查通过后，，开始运行程序并在此过程中遇到的错误。\n\n* 通知错误\n* 警告错误\n* 致命错误\n\n\n\n### 用户自定义的错误\n\n* 通知信息\n* 警告信息\n* 错误信息\n\n\n\n## 错误的分级\n\nphp语言中，将各种错误进行了不同级别的分类归纳，并形成大约有10几个级别的错误，这就是技术层面的错误分级。\n\n每一级别的错误，都有一个\"代号\"，这个代号其实也就是一个系统内部的\"常量而已\"。比如：\n\n![](1536809939_image48.png)\n\n**系统常见错误：**\n\n* E\\_ERROR： 致命错误\n* E\\_WARNING: 警告性错误\n* E\\_NOTICE: 提示性错误\n\n**用户可自定义的错误：**\n\n* E\\_USER\\_ERROR： 自定义致命错误\n\n* E\\_USER\\_WARNING: 自定义警告性错误\n\n* E\\_USER\\_NOTICE: 自定义提示性错误\n\n\n**其他：**\n\n* E\\_STRICT: 严谨性语法检查错误\n\n* E\\_ALL 代表\"所有错误\"。\n\n\n\n\n## 错误的触发\n\n错误的触发，就是让错误\"发生\"。\n\n有两种方式会触发错误：\n\n### 系统触发\n\n程序运行到某行代码，确实出现了某种错误，此时系统就会报错------这就是触发了系统错误。\n\n\n\n系统触发的典型错误有这3种：\n\n**E\\_NOTICE: 提示性错误**，会输出错误提示，并继续执行后续代码；\n\n比如使用不存在的变量或常量：\n\n![](1536809939_image49.png)\n\n**E\\_WARNING: 警告性错误**，会输出错误提示，并继续执行后续代码（也可能看具体情况，比如require)\n\n比如include载入一个不存在的文件：\n\n![](1536809939_image50.png)\n\n**E\\_ERROR： 致命错误 **  ，导致程序无法执行后续语句；\n\n比如调用一个不存在的函数！\n\n![](1536809939_image51.png)\n\n\n\n### 自定义触发\n\n当我们处理某些数据的时候，本来数据本身是没有错误的，但根据具体应用（业务）的需要，会要求数据满足某种条件，而该数据并不满足的时候，我们就可以在程序中\"主动\"去触发（创建）一个错误，以表明该数据的\"非法性\"。\n\n语法形式：\n\n```php\ntrigger_error(\"错误提示信息内容\", 3中用户错误代号之一);\n```\n\n其中触发了用户的致命错误(E\\_USER\\_ERROR）,也会终止程序的后续执行。\n\n![](1536809939_image52.png)\n\n\n\n## 错误报告的显示\n\n所谓错误报告，就是显示在网页上的错误提示内容！\n\n\n\n#### 是否显示错误报告(display\\_errors)\n\n**==有2种做法可以来设定是否显示：==**\n\n**方法1：**\n\n> 在php.ini文件中，设定display\\_errors的值，为on（显示），或为off（不显示）\n\n**方法2：**\n\n> 直接在php的脚本文件中设使用函数ini\\_set()来对其进行设置：\n\n![](1536809939_image53.png)\n\n#### 显示哪些级别的错误报告(error\\_reporting)\n\n显然，前提是\"display\\_errors\"要设置为On(或1），表示可以显示。\n\n**==显示哪些级别的错误报告，也有2个做法：==**\n\n**做法1：**\n\n> 在php.ini文件中配置\n\n**做法2：**\n\n> 在当前的脚本代码中配置\n\n\n\n**在当前脚本使用ini\\_set()函数来设置 **\n\n![](1536809939_image54.png)\n\n\n\n#### 是否记录(log\\_errors)\n\n**php.ini中：**\n\n> log\\_errors = On 或 Off\n\n**脚本中：**\n\n> ini\\_set(\"log\\_erros\", 1); 或 0\n\n补充一句：\n\n1：ini\\_set(\"php配置项\"， 值)； //用于脚本中设置php.ini中是某项的值。\n\n2：\\$v1 = ini\\_get(\"php配置项\")； //用于获取php.ini中是某项的值\n\n\n\n#### 记录到哪里(error\\_log)\n\n直接使用一个文件名，此时系统会自动在每个文件夹下都建立该文件名，并用其记录该文件夹下的所有网页文件发生的错误信息。\n\n![](1536809939_image55.png)  \n","categories":["基础知识"]},{"title":"GD图像处理技术","url":"%2Fposts%2F81311927%2F","content":"\n\n# GD图像处理技术\n\n## 1. GD图像处理技术相关概念\n\n### 为什么使用GD图像处理技术\n\n在WEB项目中，GD图像处理技术应用非常广泛，比如制作验证码图片，给图片打水印等。\n\n\n\n### 什么是GD图像处理技术\n\nGD图像处理技术 即 PHP通过使用==GD扩展==来操作图像的一种技术。\n\n\n\n## 2. 开启GD扩展\n\n扩展，意味着GD并不是PHP默认就是配置开启的，而是需要额外进行配置的。\n\n\n\n**==开启步骤==**：\n\n第一步，打开php的配置文件php.ini，确认extension_dir配置项已经正确配置，\n\n![1530150179361](8.png)\n\n第二步，去掉下图所示配置前的分号，开启配置项，\n\n![1530150268938](9.png)\n\n第三步，确认php_gd2.dll在extension_dir指定的目录下是否存在，\n\n![1530150324161](10.png)\n\n第四步，重启apache，确认是否开启成功，\n\n重启apache\n\n![1530150375912](11.png)\n\n确认扩展是否开启成功\n\n![1530150443200](12.png)\n\nphpinfo输出如上图所示，说明开启成功。\n\n\n\n## 3. ==GD扩展相关操作==\n\n#### 操作分析\n\n在程序中使用GD扩展操作图像，其实就相当于我们在电脑中使用各种绘图软件来绘制图像，比如PS软件。\n\n\n\n我们以PS软件绘制图像的方式为切入点，来分析绘图过程中所需要的一些操作有哪些：\n\n1. 打开PS软件（开启GD扩展操作）\n2. 创建画布操作；\n3. 在画布上做各种各样的绘图操作（画点，画线，画椭圆，选择颜色，填充颜色）\n4. 将成品图保存成文件；\n5. 关闭画布；\n6. 关闭软件；\n\n\n\n#### 创建画布相关操作\n\n涉及的函数：\n\n> **imagecreate**(宽,  高)   创建画布，单位像素\n>\n> **imagecreatetruecolor**(宽,  高)    创建一个真彩色画布\n>\n> **imagecreatefromjpeg**(jpeg图片路径)    根据一张已有的jpeg图片创建画布\n>\n> **imagecreatefromgif**(gif图片路径)    根据一张已有的gif图片创建画布\n>\n> **imagecreatefrompng**(png图片路径)    根据一张已有的png图片创建画布\n\n\n\n**==需求==**：根据以下要求完成操作，\n\n1. 根据imagecreate和imagecreatetruecolor两个函数分别创建一个400*200的画布，打印返回值；\n2. 根据一张已有的jpeg图片创建画布，打印返回值；\n\n**==解答==**：创建名为code2.php的程序文件，代码如下：\n\n```php\n<?php\n\n#imagecreate创建画布\n$img1 = imagecreate(400, 200);\nvar_dump( $img1 ); echo '<hr/>';\n\n#imagecreatetruecolor创建画布\n$img2 = imagecreatetruecolor(400, 200);\nvar_dump( $img2 ); echo '<hr/>';\n\n#imagecreatefromjpeg创建画布\n$img3 = imagecreatefromjpeg('./1.jpg');\nvar_dump( $img3 ); \n```\n\n访问codex1.php，输出的内容如下：\n\n```mysql\nresource(2) of type (gd)  #imagecreate创建的画布资源\nresource(3) of type (gd)  #imagecreatetruecolor创建的画布资源\nresource(5) of type (gd)  #imagecreatefromjpeg创建的画布资源\n```\n\n\n\n**==小结==**：\n\n1. imagecreate和imagecreatetruecolor创建画布是指定的是画布的宽度和高度，单位像素；\n2. imagecreatefrom系列的创建画布是指定固定格式的图片路径，比如imagecreatefromjpeg，就需要指定jpeg格式的图片路径；\n\n\n\n#### 关闭画布操作\n\n涉及的函数：\n\n> **imagedestroy**(画布资源)    销毁画布资源\n\n\n\n**==需求==**：根据以下要求完成操作，\n\n1. 根据imagecreate创建一个400*200的画布，打印返回值；\n2. 使用imagedestroy关闭打开的画布，再次打印\"1\"中创建的画布资源返回值；\n\n**==解答==**：创建名为code3.php的程序文件，代码如下：\n\n```php\n<?php\n\n#imagecreate创建画布\n$img1 = imagecreate(400, 200);\nvar_dump( $img1 ); echo '<hr/>';\n\n#imagedestroy关闭画布资源\nimagedestroy($img1);\nvar_dump( $img1 ); \n\n```\n\n访问code3.php，输出的内容如下：\n\n```mysql\nresource(2) of type (gd)  #imagecreate创建的画布资源\nresource(2) of type (Unknown)   #imagedestroy销毁后的$img1的输出\n```\n\n\n\n#### 图像输出相关操作\n\n涉及的函数：\n\n> **imagejpeg**(画布资源[,  保存文件的全路径])    以jpeg的格式输出图片到浏览器或保存成文件\n>\n> **imagepng**(画布资源[,  保存文件的全路径])    以png的格式输出图片到浏览器或保存成文件\n>\n> **imagegif**(画布资源[,  保存文件的全路径])    以gif的格式输出图片到浏览器或保存成文件\n\n\n\n**==需求==**：创建code4.php程序文件，\n\n1. 使用imagecreate创建一个400*200的画布；\n2. 同时实现根据GET方式传递的type值判定，如果type值为1，则直接将\"1\"中创建的画布以jpeg图片的格式输出到浏览器；如果type值为2，则将\"1\"中创建的画布以jpeg格式保存成图片文件；\n\n**==解答==**：创建名为code4.php的程序文件，代码如下：\n\n```php\n<?php\n\n#imagecreate创建画布\n$img1 = imagecreate(400, 200);\n\nif( $_GET['type']==1 ){//将画布以jpeg格式的图片输出到浏览器\n    header('Content-type:image/jpeg');//输出图像到浏览器之前必须先设置返回给浏览器的内容类型\n    imagejpeg($img1);\n}elseif( $_GET['type']==2 ){//将画布以jpeg格式的图片保存成文件文件\n    imagejpeg($img1, './a.jpg');\n}\n\n```\n\n访问code4.php：\n\n当GET方式传递的type值等于1时，效果为：\n\n![1530154054462](13.png)\n\n当GET方式传递的type值等于2时，效果为：\n\n![1530154082332](14.png)\n\n\n\n**==小结==**：\n\n1. 如果要将图片输出到浏览器，则必须在输出前指定header内容类型；\n2. 如果要将图片保存成文件，则需要给函数指定第二个参数，为文件保存的全路径；\n\n\n\n#### 画布内容相关操作\n\n涉及的函数：\n\n> **imagecolorallocate**(画布资源,  R色值,  G色值,  B色值)    分配一个颜色\n>\n> **imagefill**(画布资源,  基点x坐标,  基点y坐标,  颜色)    向画布填充颜色\n>\n> **imageline**(画布资源,  起点x坐标,  起点y坐标,  终点x坐标,  终点y坐标,  颜色)    画线段操作\n>\n> **imagerectangle**(画布资源,  对角线起点x坐标,  对角线起点y坐标,  对角线终点x坐标,  对角线终点y坐标,  颜色)    画矩形\n>\n> **imagearc**(画布资源,  圆心x坐标,  圆心y坐标,  椭圆宽,  椭圆高,  起点角度,  终点角度,  颜色)    画圆弧线段\n>\n> **imagestring**(画布资源,  字体大小,  文字左上角x坐标,  文字左上角y坐标,  内容,  颜色)    根据系统字体写字\n>\n> **imagettftext**(画布资源,  字体大小,  角度,  文字左下角x坐标,  文字左下角y坐标,  颜色,  字体路径,  内容)    根据ttf格式的字体写字\n\n\n\n**==TIPS==**：在程序中，画布的坐标都是以左上角为（0, 0）坐标点：\n\n![1530156686053](17.png)\n\n\n\n**==需求1==**：创建code5.php程序文件，\n\n1. 使用imagecreate创建一个400*200的画布；\n2. 将画布的背景色填充为RGB(255, 233, 85)；\n3. 将画布以jpeg格式的图片直接输出到浏览器；\n\n**==解答1==**：创建名为code5.php的程序文件，代码如下：\n\n```php\n<?php\n\n#imagecreate创建画布\n$img1 = imagecreate(400, 200);\n\n#填充背景色\n//分配一个颜色\n$color = imagecolorallocate($img1, 255, 233, 85);\n//填充背景色\nimagefill($img1, 0, 0, $color);\n\n#将图像输出到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($img1);\n```\n\n访问code5.php，效果为：\n\n![1530155963554](15.png)\n\n**==需求1小结==**：\n\n函数：\n\n![1530092346153](1.png)\n\n原理：\n\n![1530156344637](16.png)\n\n\n\n\n\n**==需求2==**：创建code6.php程序文件，\n\n1. 使用imagecreate创建一个400*200的画布；\n\n2. 将画布的背景色填充为RGB(255, 233, 85)；\n\n3. 在画布上画一条线段；\n\n4. 将画布以jpeg格式的图片直接输出到浏览器；\n\n5. 效果图为：\n\n   ![1530156855540](18.png)\n\n**==解答2==**：创建名为code6.php的程序文件，代码如下：\n\n```php\n<?php\n#imagecreate创建画布\n$img1 = imagecreate(400, 200);\n\n#填充背景色\n//分配一个颜色\n$color = imagecolorallocate($img1, 255, 233, 85);\n//填充背景色\nimagefill($img1, 0, 0, $color);\n\n#画线段\n//重新选一个原色\n$color1 = imagecolorallocate($img1, 30, 122, 76);\n//画线段\nimageline($img1, 100, 100, 256, 80, $color1);\n\n\n#将图像输出到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($img1);\n```\n\n访问code6.php，效果为：\n\n![1530156952716](19.png)\n\n**==需求2小结==**：\n\n函数：\n\n![1530092426134](2.png)\n\n原理：\n\n两点之间确定一条线段，所以画线段需要指定起点的（x,y）坐标和终点的(x, y)坐标；\n\n\n\n\n\n**==需求3==**：创建code7.php程序文件，\n\n1. 使用imagecreate创建一个400*200的画布；\n\n2. 将画布的背景色填充为RGB(255, 233, 85)；\n\n3. 在画布上画一个矩形；\n\n4. 将画布以jpeg格式的图片直接输出到浏览器；\n\n5. 需要的效果图：\n\n   ![1530157331680](20.png)\n\n**==解答3==**：创建名为code7.php的程序文件，代码如下：\n\n```php\n<?php\n\n#imagecreate创建画布\n$img1 = imagecreate(400, 200);\n\n#填充背景色\n//分配一个颜色\n$color = imagecolorallocate($img1, 255, 233, 85);\n//填充背景色\nimagefill($img1, 0, 0, $color);\n\n#画线段\n//重新选一个原色\n$color1 = imagecolorallocate($img1, 30, 122, 76);\n//画线段\nimagerectangle($img1, 150, 150, 210, 75, $color1);\n\n\n#将图像输出到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($img1);\n```\n\n访问code7.php，效果为：\n\n![1530157405081](21.png)\n\n**==需求3小结==**：\n\n函数：\n\n![1530092458592](3.png)\n\n原理：\n\n通过确定对角线的两个点的坐标，实现最终的矩形。\n\n\n\n\n\n**==需求4==**：创建code8.php程序文件，\n\n1. 使用imagecreate创建一个400*200的画布；\n2. 将画布的背景色填充为RGB(255, 233, 85)；\n3. 在画布上画一个椭圆；\n4. 将画布以jpeg格式的图片直接输出到浏览器；\n\n**==解答4==**：创建名为code8.php的程序文件，代码如下：\n\n```php\n<?php\n\n#imagecreate创建画布\n$img1 = imagecreate(400, 200);\n\n#填充背景色\n//分配一个颜色\n$color = imagecolorallocate($img1, 255, 233, 85);\n//填充背景色\nimagefill($img1, 0, 0, $color);\n\n#画线段\n//重新选一个原色\n$color1 = imagecolorallocate($img1, 30, 122, 76);\n//画弧线段\nimagearc($img1, 200, 100, 200, 100, 30, 120, $color1);\n\n\n#将图像输出到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($img1);\n```\n\n访问code8.php，效果为：\n\n![1530158608731](22.png)\n\n**==需求4小结==**：\n\n函数：\n\n**imagearc**(画布资源,  圆心x坐标,  圆心y坐标,  椭圆宽,  椭圆高,  起点角度,  终点角度,  颜色) \n\n![1530092483368](4.png)\n\n原理：\n\n![1530158359357](23.png)\n\n![1530171224824](26.png)\n\n\n\n\n\n**==需求5==**：创建code11.php程序文件，\n\n1. 使用imagecreate创建一个400*200的画布；\n2. 将画布的背景色填充为RGB(255, 233, 85)；\n3. 在画布上使用imagestring写一句话：\"今天天气好晴朗\"；\n4. 将画布以jpeg格式的图片直接输出到浏览器；\n\n**==解答5==**：创建名为code11.php的程序文件，代码如下：\n\n```php\n<?php\n\n#创建画布\n$img = imagecreate(400, 200);\n\n#填充背景色\n//分配一个颜色\n$color = imagecolorallocate($img, 255, 233, 85);\n//填充背景色\nimagefill($img, 0, 0, $color);\n\n#写字\n//分配写字的颜色\n$color = imagecolorallocate($img, 122, 36, 79);\n//$content = '今天天气好晴朗';//写的内容， 中文变成乱码了\n$content = 'abcdefg';//写的内容\nimagestring($img, 5, 100, 80, $content, $color);\n\n#输出图像到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($img);\n```\n\n访问code11.php，效果为：\n\n![1530169002039](24.png)\n\n**==需求5小结==**：\n\n函数：\n\n![1530092508671](5.png)\n\n原理：\n\n1. 字体的局限性大；\n2. 内容如果输出中文的话，则默认是乱码，因为要开启额外的扩展支持；\n\n\n\n\n\n**==需求6==**：创建code13.php程序文件，\n\n1. 使用imagecreate创建一个400*200的画布；\n2. 将画布的背景色填充为RGB(255, 233, 85)；\n3. 在画布上使用imagettftext写一句话：\"今天天气好晴朗\"；\n4. 将画布以jpeg格式的图片直接输出到浏览器；\n\n**==解答6==**：创建名为code13.php的程序文件，代码如下：\n\n```php\n<?php\n\n#创建画布\n$img = imagecreate(400, 200);\n\n#填充背景色\n$color = imagecolorallocate($img, 255, 233, 85);\nimagefill($img, 0, 0, $color);\n\n#写字\n$color = imagecolorallocate($img, 16, 233, 27);\n$content = '今天天气好晴朗';\nimagettftext($img, 30, 0, 100, 120, $color, 'F:/home/class/day5/code/source/font1.ttf', $content);\n\n#输出图像到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($img);\n\n```\n\n访问code13.php，效果为：\n\n![1530171015331](25.png)\n\n**==需求6小结==**：\n\n函数：\n\n![1530092532916](6.png)\n\n原理：\n\n![1530171382656](27.png)\n\n1. 使用这个函数，需要指定自定义的ttf格式的字体来实现；\n\n\n\n\n\n#### 辅助相关操作\n\n涉及的函数：\n\n> **imagesx**(画布资源)    获得图片的宽度\n>\n> **imagesy**(画布资源)    获得图片的高度\n>\n> **getimagesize**(图片路径)    获得图片的宽度和高度等信息\n\n\n\n**==需求==**：创建code12.php程序文件，\n\n1. 使用imagecreatefromjpeg创建一个画布；\n2. 获取这个画布的宽度；\n3. 获取这个画布的高度；\n4. 获取这个画布的宽度、高度、位度等信息；\n\n**==解答==**：创建名为code12.php的程序文件，代码如下：\n\n```php\n<?php\n\n#创建画布\n$img = imagecreatefromjpeg('./1.jpg');\n\n#获取图片宽度和高度\n$w = imagesx($img);\n$h = imagesy($img);\n\necho '宽度为：'.$w.'px；高度为' . $h . 'px<br/>'; \n\n//获得图片的宽高等信息，指定的参数不能是资源，而应该是文件的路径\n$info = getimagesize('./1.jpg');\necho '<pre>';\nvar_dump( $info ); \n```\n\n访问code12.php，效果为：\n\n```mysql\n宽度为：500px；高度为300px  #imagesx和imagesy获得的宽度和高度信息\n\n#getimagesize函数获得的宽度，高度，位度等信息\narray(7) {\n  [0]=>\n  int(500)\n  [1]=>\n  int(300)\n  [2]=>\n  int(2)\n  [3]=>\n  string(24) \"width=\"500\" height=\"300\"\"\n  [\"bits\"]=>\n  int(8)\n  [\"channels\"]=>\n  int(3)\n  [\"mime\"]=>\n  string(10) \"image/jpeg\"\n}\n```\n\n**==需求小结==**：\n\n1. imagesx和imagesy需要指定画布资源参数；\n2. getimagesize需要指定文件路径参数；\n\n\n\n## 4. 全天总结\n\n1. 创建画布相关函数\n\n   以下两个函数是根据指定的宽高来创建画布\n\n   imagecreate函数\n\n   imagecreatetruecolor函数\n\n   以下三个函数是根据一张已有的图片来创建画布\n\n   imagecreatefromjpeg函数\n\n   imagecreatefrompng函数\n\n   imagecreatefromgif函数\n\n2. 关闭画布资源操作函数\n\n   imagedestroy函数   销毁画布资源\n\n3. 输出图像操作函数\n\n   以下三个函数即可以将图片直接输出到浏览器（==在输出之前必须指定header('Content-type:image/xxxx')项==），又可以将图片保存成指定格式的图片文件，\n\n   imagejpeg函数\n\n   imagepng函数\n   imagegif函数\n\n4. 画布操作相关函数\n\n   imagecolorallocate函数   分配颜色函数\n\n   imagefill函数    填充背景色\n\n   imageline函数   画线段（画点）\n\n   imagerectangle函数   画矩形\n\n   imagearc函数   画弧线段（椭圆，正圆）\n\n   imagestring函数    根据系统字体写字\n\n   imagettftext函数   根据ttf格式的字体写字\n\n5. 打水印操作\n\n   imagecopymerge函数   实现打水印操作\n\n6. 制作缩略图\n\n   imagecopyresampled函数    实现缩略图功能函数\n\n","categories":["GD"]},{"title":"GD图像处理技术案例","url":"%2Fposts%2F2032372126%2F","content":"\n\n# GD图像处理技术\n\n\n\n## 4. 案例：制作水印图\n\n### 功能分析\n\n1. 根据一张需要打上水印的图片(目标图)创建一个画布；\n2. 将logo图也打开成一个画布；\n3. 在目标图上选择一个坐标基点；\n4. 在logo图上也选择一个坐标基点（左上角0，0点）；\n5. 将logo图拖拽到目标图片画布中，将logo图的基点对齐目标图的基点；\n6. 调整logo图的透明度（20%）;\n7. 将成品图保存成图片文件；\n8. 关闭目标图片画布；\n9. 关闭logo图片画布；\n\n\n\n### 代码实现\n\n构建程序文件名为code14.php，代码如下：\n\n```php\n<?php\n\n#1. 根据一张需要打上水印的图片(目标图)创建一个画布\n$dst = imagecreatefromjpeg('./source/fenghuang.jpg');\n$dst_w = imagesx($dst);//[可选]目标图的宽度，用于后续计算\n$dst_h = imagesy($dst);//[可选]目标图的高度，用于后续计算\n\n#2. 将logo图也打开成一个画布\n$src = imagecreatefrompng('./source/logo.png');\n$src_w = imagesx($src);//logo图的宽度，用于参数\n$src_h = imagesy($src);//logo图的高度，用于参数\n\n/*\n#第3～6步\n3. 在目标图上选择一个坐标基点；\n4. 在logo图上也选择一个坐标基点（左上角0，0点）；\n5. 将logo图拖拽到目标图片画布中，将logo图的基点对齐目标图的基点；\n6. 调整logo图的透明度（20%）;\n*/\n//imagecopymerge 拷贝并合并图像的一部分\n//(目标图像,logo图像,目标x位置,目标y位置,logo起始位置x,logo起始位置y,logo宽,logo高,透明度)\n//imagecopymerge($dst, $src, $dst_w/4, $dst_h/6, 0, 0, $src_w, $src_h, 20);\nimagecopymerge($dst, $src, 50, 50, 0, 0, $src_w, $src_h, 20);\n\n#7. 将成品图保存成图片文件；或者输出到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($dst);\n\n#8.关闭目标图片画布\nimagedestroy($dst);\n#9关闭logo图片画布\nimagedestroy($src);\n```\n\n访问code14.php，效果如下：\n\n![1530173036884](28.png)\n\n\n\n## 5. 案例：制作缩略图\n\n### 固定宽高缩略图\n\n#### 功能分析\n\n1. 根据目标缩略图的尺寸创建一个空白画布（dst）（200×300）；\n2. 将需要缩小的那张图片（src）打开成一个画布；\n3. 在dst画布上选择左上角(0,0)点作为dst图的坐标基点；\n4. 在src画布上选择左上角(0,0)点作为src图的坐标基点；\n5. 将src图拖拽到dst画布中，然后将src的坐标基点对齐dst图的坐标基点；\n6. 调整src图的宽度到与dst相同的宽度；并且调整src图的高度到与dst相同的高度；\n7. 将成品图保存成文件；\n8. 关闭dst画布资源；\n9. 关闭src画布资源；\n\n#### 代码实现\n\n创建名为code15.php的程序文件，代码如下：\n\n```php\n<?php\n\n#1. 根据目标缩略图的尺寸创建一个空白画布（dst）（200×300）；\n//$dst = imagecreate(200, 300);  //色彩失真太大了\n$dst = imagecreatetruecolor(200, 300);\n\n#2. 将需要缩小的那张图片（src）打开成一个画布；\n$src = imagecreatefromjpeg('./source/m3.jpg');\n$src_w = imagesx($src);//源图宽，用于后续参数\n$src_h = imagesy($src);//源图高，用于后续参数\n\n/*\n#第3～6步\n3. 在dst画布上选择左上角(0,0)点作为dst图的坐标基点；\n4. 在src画布上选择左上角(0,0)点作为src图的坐标基点；\n5. 将src图拖拽到dst画布中，然后将src的坐标基点对齐dst图的坐标基点；\n6. 调整src图的宽度到与dst相同的宽度；并且调整src图的高度到与dst相同的高度；\n*/\n//imagecopyresampled — 重采样拷贝部分图像并调整大小\n//如果源和目标的宽度和高度不同，则会进行相应的图像收缩和拉伸。\n//(目标图，源图，目标X坐标，目标Y坐标，源图X坐标，源图Y坐标，目标宽，目标高，源图宽，源图高)\nimagecopyresampled($dst, $src, 0, 0, 0, 0, 200, 300, $src_w, $src_h);\n\n#7. 将成品图保存成文件；或输出到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($dst);\n\n#8.关闭dst画布资源\nimagedestroy($dst);\n\n#9.关闭src画布资源\nimagedestroy($src);\n```\n\n访问code15.php的效果：\n\n![1530174118370](29.png)\n\n固定宽高的缩略图，可能导致缩小后图片变形的效果，所以我们还需要改进。\n\n### 等比缩略图\n\n1. 根据源图的宽高比创建目标缩略图的空白画布（dst）；\n2. 将需要缩小的那张图片（src）打开成一个画布；\n3. 在dst画布上选择左上角(0,0)点作为dst图的坐标基点；\n4. 在src画布上选择左上角(0,0)点作为src图的坐标基点；\n5. 将src图拖拽到dst画布中，然后将src的坐标基点对齐dst图的坐标基点；\n6. 调整src图的宽度到与dst相同的宽度；并且调整src图的高度到与dst相同的高度；\n7. 将成品图保存成文件；\n8. 关闭dst画布资源；\n9. 关闭src画布资源；\n\n\n\n创建名为code16.php的程序文件，代码如下：\n\n```php\n<?php\n\n#2. 将需要缩小的那张图片（src）打开成一个画布；\n$src = imagecreatefromjpeg('./source/m3.jpg');\n$src_w = imagesx($src);//src图的宽度\n$src_h = imagesy($src);//src图的高度\n\n\n#计算最终缩略图的宽度和高度\n$max_w = 200;//定义限定区域的最大宽度\n$max_h = 300;//定义限定区域的最大高度\n\n//先缩小原图的高度到和限定区域的高度一样，然后按照原图的宽高比例来缩小宽度\n$dst_h = $max_h;//缩小原图的高度到和限定区域的高度\n/*\n$src_w/$src_h = $dst_w/$dst_h;\n$dst_w = ($src_w/$src_h)*$dst_h;\n*/\n$dst_w = ($src_w/$src_h)*$dst_h;//按照原图的宽高比例来缩小宽度\n\nif( $dst_w>$max_w ){//如果经过第一轮缩小后，缩略图的宽度比限定区域的宽度还要大，说明不满足要求，需要重新再缩小计算一次\n\n    //先缩小原图的宽度到和限定区域的宽度一样，然后按照原图的宽高比例来缩小高度\n    $dst_w = $max_w;//缩小原图的宽度到和限定区域的宽度一样\n    /*\n    $src_w/$src_h = $dst_w/$dst_h;\n    $dst_h = $dst_w/($src_w/$src_h)\n    */\n    $dst_h = $dst_w/($src_w/$src_h);//按照原图的宽高比例来缩小高度\n}\n\n\n#1. 根据源图的宽高比创建目标缩略图的空白画布（dst）；\n//$dst = imagecreate(200, 300);\n$dst = imagecreatetruecolor($dst_w, $dst_h);\n\n\n\n/*\n#第3～6步\n3. 在dst画布上选择左上角(0,0)点作为dst图的坐标基点；\n4. 在src画布上选择左上角(0,0)点作为src图的坐标基点；\n5. 将src图拖拽到dst画布中，然后将src的坐标基点对齐dst图的坐标基点；\n6. 调整src图的宽度到与dst相同的宽度；并且调整src图的高度到与dst相同的高度；\n*/\nimagecopyresampled($dst, $src, 0, 0, 0, 0, $dst_w, $dst_h, $src_w, $src_h);\n\n#7. 将成品图保存成文件；或输出到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($dst);\n\n#8.关闭dst画布资源\nimagedestroy($dst);\n\n#9.关闭src画布资源\nimagedestroy($src);\n```\n\n访问code16.php，效果为：\n\n![1530176230852](30.png)\n\n\n\n## 6. 案例：制作验证码\n\n###   功能分析\n\n1. 创建画布，填充背景色；\n2. 在画布上随机字；\n3. 在画布上构建干扰元素（干扰点，干扰线，干扰弧线）；\n\n\n\n###   代码实现\n\n创建名为code17.php的程序文件，代码如下：\n\n```php\n<?php\n\n#1. 创建画布，填充背景色\n$w = 300;\n$h = 140;\n$img = imagecreate($w, $h);\n\n//填充颜色\n$color = imagecolorallocate($img, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));//分配一个随机色\nimagefill($img, 0, 0, $color);\n\n#写字\n//构建随机字\n$arr = array_merge(range('a', 'z'), range('A', 'Z'), range(0, 9));\n$str = '';//最终随机字存储的变量\nfor($i=0; $i<4; $i++ ){ \n    $key = mt_rand(0, count($arr)-1);\n    $str .= $arr[$key];\n}\n//写字\n$color = imagecolorallocate($img, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));//分配一个随机色\nimagettftext($img, 40, 0, $w/4, $h*3/5, $color, 'F:/home/class/day5/code/source/font1.ttf', $str);\n\n#构建干扰元素\n//干扰点\nfor($i=0; $i<100; $i++ ){ \n    $bx = mt_rand(0, $w);//起点x坐标\n    $by = mt_rand(0, $h);//起点y坐标\n\n    $ex = mt_rand($bx-2, $bx+2);//终点x坐标\n    $ey = mt_rand($by-2, $by+2);//终点y坐标\n\n    $color = imagecolorallocate($img, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));//分配一个随机色\n    imageline($img, $bx, $by, $ex, $ey, $color);\n}\n\n//画干扰线\nfor($i=0; $i<10; $i++ ){ \n    $bx = mt_rand(0, $w/2);//起点x坐标\n    $by = mt_rand(0, $h);//起点y坐标\n\n    $ex = mt_rand($w/2, $w);//终点x坐标\n    $ey = mt_rand(0, $h);//终点y坐标\n\n    $color = imagecolorallocate($img, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));//分配一个随机色\n    imageline($img, $bx, $by, $ex, $ey, $color);\n}\n\n\n#输出到浏览器\nheader('Content-type:image/jpeg');\nimagejpeg($img);\n```\n\n访问code17.php，效果为：\n\n![1530178153757](31.png)\n\n\n\n","categories":["GD"]},{"title":"MYSQLI扩展案例","url":"%2Fposts%2F2685337793%2F","content":"\n\n\n# MYSQLI扩展\n\n\n\n## 案例：MYSQLI实现后台新闻管理系统\n\n### 预览效果\n\n> ==列表页==：\n>\n> ![1529708158948](6.png)\n>\n> ==添加新闻页==：\n>\n> ![1529708158948](7.png)\n>\n> ==编辑新闻页==：\n>\n> ![1529708158948](8.png)\n\n\n\n### 功能分析\n\n1. 新闻列表页；\n2. 新闻添加页和添加功能；\n3. 新闻编辑页和编辑功能；\n4. 删除功能；\n5. 分页功能；\n\n\n\n### 建表\n\n创建一个新闻表，表字段的要求如下：\n\n```mysql\n##建表字段要求：\n##要求数据库为test数据库\n新闻表\nnews\nid,标题,简介,内容,添加时间\nid,title,intro,content,post_date\n\n##建表语句：\ncreate table news(\nid int unsigned primary key auto_increment,\ntitle varchar(50) not null default '' comment '新闻标题',\nintro varchar(255) not null default '' comment '新闻简介',\ncontent text comment '新闻内容',\npost_date int unsigned not null default 0 comment '添加时间'\n)engine=MyISAM charset=utf8;\n\ninsert into news values\n(null, '新闻1', '简介1', '内容1', 12345678),\n(null, '新闻2', '简介22', '内容2', 12345678),\n(null, '新闻3', '简介3', '内容3', 12345678);\n```\n\n\n\n### 实现列表页\n\n**==步骤==**：\n\n第一步，构建一个名为common.php的文件，\n\n```php\n<?php \n\n#连库基本操作\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\nmysqli_set_charset($link, 'utf8');\n```\n\n第二步，构建一个名为list.php文件，代码如下\n\n```php+HTML\n<?php \n\n//引入公共操作文件\ninclude './common.php';\n\n#执行查询语句查询数据表的数据\n$sql = \"select id, title, intro, post_date from news where 1 order by post_date desc\";\n$result = mysqli_query($link, $sql);\n\n//解析出所有的数据\n$rows = mysqli_fetch_all($result, MYSQLI_ASSOC);\n\n?>\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>后台新闻列表页</title>\n</head>\n<body>\n\n    <p>\n        <a href=\"http://www.home.com/class/day2/code/ad.php\">添加新闻</a>\n    </p>\n\n    <table border=\"1px\">\n        <thead>\n            <tr>\n                <td>序号</td>\n                <td>ID</td>\n                <td>新闻标题</td>\n                <td>新闻简介</td>\n                <td>添加时间</td>\n                <td>操作</td>\n            </tr>\n        </thead>\n        <tbody>\n            <?php foreach( $rows as $rows_key=>$row ){ ?>\n            <tr>\n                <td><?php echo $rows_key+1; ?></td>\n                <td><?php echo $row['id']; ?></td>\n                <td><?php echo $row['title']; ?></td>\n                <td><?php echo $row['intro']; ?></td>\n                <td><?php echo date('Y-m-d H:i:s', $row['post_date']); ?></td>\n                <td>\n                    <a href=\"http://www.home.com/class/day2/code/upd.php?id=<?php echo $row['id']; ?>\">编辑新闻</a> \n                    <a href=\"http://www.home.com/class/day2/code/del.php?id=<?php echo $row['id']; ?>\">删除新闻</a>\n                </td>\n            </tr>\n            <?php } ?>\n        </tbody>\n    </table>\n\n    <p>\n        <a href=\"\">上一页</a>\n        ...\n        <a href=\"\">1</a>\n        <a href=\"\">2</a>\n        <a href=\"\" style=\"color:red;\">3</a>\n        <a href=\"\">4</a>\n        <a href=\"\">5</a>\n        ...\n        <a href=\"\">下一页</a>\n    </p>\n\n</body>\n</HTML>\n```\n\n第三步，访问list.php页面，效果如下\n\n![1529740801125](14.png)\n\n### 实现添加页面和功能\n\n**==步骤==**：\n\n第一步，构建名为ad.php的文件，代码如下，\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>新闻添加页</title>\n</head>\n<body>\n    <form method=\"post\" action=\"http://www.home.com/class/day2/code/adh.php\">\n        <p>\n            <span>新闻标题：</span>\n            <input type=\"text\" name=\"title\" />\n        </p>\n        <p>\n            <span>新闻简介：</span>\n            <input type=\"text\" name=\"intro\" />\n        </p>\n        <p>\n            <span>新闻内容：</span>\n            <textarea name=\"content\" cols=40 rows=7></textarea>\n        </p>\n        <p>\n            <input type=\"submit\" value=\"添加新闻\" />\n        </p>\n    </form>\n\n    <p>\n        <a href=\"http://www.home.com/class/day2/code/list.php\">返回新闻列表页</a>\n    </p>\n</body>\n</HTML>\n```\n\n第二步，构建名为adh.php的程序页面，代码如下\n\n```php\n<?php\n\n#接收数据\n$title = $_POST['title'];//接收新闻标题\n$intro = $_POST['intro'];//接收新闻简介\n$content = $_POST['content'];//接收新闻内容\n$post_date = time();//直接获取当前时间的时间戳\n\n#引入公共操作文件\ninclude './common.php';\n\n#构建新增语句，新增数据\n$sql = \"insert into news values (null, '{$title}', '{$intro}', '{$content}', {$post_date})\";\n$re = mysqli_query($link, $sql);\n\nif( $re ){//表示执行成功\n    echo '恭喜添加新闻成功！'; \n}else{//表示执行失败\n    echo '添加新闻失败，请联系管理员！'; \n}\n\n//    2表示在本页面停留2秒       url是表示2秒后需要跳转到的页面链接地址\nheader('Refresh:2; url=http://www.home.com/class/day2/code/list.php');\n```\n\n\n\n### 实现修改页面和功能\n\n**==步骤==**：\n\n第一步，构建名为upd.php的程序页面，代码如下：\n\n```php+HTML\n<?php \n#接收GET传递的新闻id值\n$id = $_GET['id'];\n\n#引入公共文件\ninclude './common.php';\n\n#查询需要回显的本条数据\n$sql = \"select title, intro, content from news where id={$id}\";\n$result = mysqli_query($link, $sql);\n\n//解析数据结果\n$row = mysqli_fetch_assoc($result);\n\n?>\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>新闻添加页</title>\n</head>\n<body>\n    <form method=\"post\" action=\"http://www.home.com/class/day2/code/updh.php?id=<?php echo $id; ?>\">\n        <p>\n            <span>新闻标题：</span>\n            <input type=\"text\" name=\"title\" value=\"<?php echo $row['title']; ?>\" />\n        </p>\n        <p>\n            <span>新闻简介：</span>\n            <input type=\"text\" name=\"intro\" value=\"<?php echo $row['intro']; ?>\" />\n        </p>\n        <p>\n            <span>新闻内容：</span>\n            <textarea name=\"content\" cols=40 rows=7><?php echo $row['content']; ?></textarea>\n        </p>\n        <p>\n            <input type=\"submit\" value=\"立即修改\" />\n        </p>\n    </form>\n\n    <p>\n        <a href=\"http://www.home.com/class/day2/code/list.php\">返回新闻列表页</a>\n    </p>\n</body>\n</HTML>\n```\n\n第二步，构建名为updh.php的程序页面，\n\n```php\n<?php\n\n#接收数据\n$id = $_GET['id'];//接收GET方式传递过来的新闻id值\n$title = $_POST['title'];//接收新闻标题\n$intro = $_POST['intro'];//接收新闻简介\n$content = $_POST['content'];//接收新闻内容\n\n#引入公共操作文件\ninclude './common.php';\n\n#构建更新语句，更新数据\n$sql = \"update news set title='{$title}', intro='{$intro}', content='{$content}' where id={$id}\";\n$re = mysqli_query($link, $sql);\n\nif( $re ){//执行更新成功\n    echo '修改数据成功！'; \n}else{//执行更新失败\n    echo '修改数据失败！'; \n}\n//2秒后跳转回本条数据的编辑页面\nheader('Refresh:2; url=http://www.home.com/class/day2/code/upd.php?id='.$id);\n```\n\n\n\n### 实现删除功能\n\n**==步骤==**：\n\n第一步，构建名为del.php的程序页面，代码如下：\n\n```php\n<?php\n\n#接收数据\n$id = $_GET['id'];//接收GET方式传递过来的新闻id值\n\n#引入公共操作文件\ninclude './common.php';\n\n#构建删除SQL语句，并且执行\n$sql = \"delete from news where id={$id}\";\n$re = mysqli_query($link, $sql);\n\nif( $re ){//删除成功\n    echo '执行删除操作成功！'; \n}else{//删除失败\n    echo '执行删除失败，请联系管理员！';     \n}\n//2秒后跳回列表页\nheader('Refresh:2; url=http://www.home.com/class/day2/code/list.php');\n```\n\n\n\n### 实现分页功能\n\n思路分析\n\n左半边\n\n1. 当前页就是左边界\n\n   ![1529744476766](15.png)\n\n2. 当前页的上一页为左边界\n\n   ![1529744538579](16.png)\n\n3. 当前页的上两页为左边界\n\n   ![1529744587362](17.png)\n\n4. 其他情况\n\n   ![1529744631145](18.png)\n\n   \n\n   \n\n右半边\n\n1. 当前页就是右边界\n\n   ![1529744697444](19.png)\n\n2. 当前页的下一页为右边界\n\n   ![1529744738405](20.png)\n\n3. 当前页的下两页为右边界\n\n   ![1529744767589](21.png)\n\n4. 其他情况\n\n   ![1529744791282](22.png)\n\n\n\n**==步骤==**：\n\n第一步，构建一个名为pageHtml.php的文件，代码如下：\n\n```php\n/**\n * 功能：获得分页html代码部分\n * @param  $nowPage   int   表示当前页的页码\n * @param  $totalPage   int   表示分页的总页数\n * @param  $url   string   表示分页跳转的链接地址\n */\nfunction pageHtml($nowPage, $totalPage, $url){ \n    \n    #左半边\n    $preOnePage = $nowPage-1;//当前页的上一页\n    $preTwoPage = $nowPage-2;//当前页的上二页\n\n    $leftHtml = '';\n\n    if( $nowPage==1 ){//当前页就是左边界\n        \n        $leftHtml .= \" \";\n\n    }elseif( $preOnePage==1 ){//当前页的上一页为左边界\n        // http://www.home.com/class/day2/code/pageHtml.php?page=12\n        $leftHtml .= \"<a href='{$url}={$preOnePage}'>上一页</a> \";\n        $leftHtml .= \"<a href='{$url}={$preOnePage}'>{$preOnePage}</a> \";\n    \n    }elseif( $preTwoPage==1 ){//当前页的上两页为左边界\n    \n        $leftHtml .= \"<a href='{$url}={$preOnePage}'>上一页</a> \";\n        $leftHtml .= \"<a href='{$url}={$preTwoPage}'>{$preTwoPage}</a> \";\n        $leftHtml .= \"<a href='{$url}={$preOnePage}'>{$preOnePage}</a> \";\n\n    }else{//其他情况\n        \n         $leftHtml .= \"<a href='{$url}={$preOnePage}'>上一页</a> \";\n         $leftHtml .= \"... \";\n        $leftHtml .= \"<a href='{$url}={$preTwoPage}'>{$preTwoPage}</a> \";\n        $leftHtml .= \"<a href='{$url}={$preOnePage}'>{$preOnePage}</a> \";\n    }\n\n    #构建当前页\n    $middleHtml = \"<a style='color:red;'>{$nowPage}</a> \";\n\n    #右半边\n    $nextOnePage = $nowPage+1;//当前页的下一页\n    $nextTwoPage = $nowPage+2;//当前页的下二页\n\n    $rightHtml = '';\n\n    if( $nowPage==$totalPage ){//当前页就是右边界\n    \n        $rightHtml .= \" \";\n\n    }elseif( $nextOnePage==$totalPage ){//当前页的下一页为右边界\n\n        $rightHtml .= \"<a href='{$url}={$nextOnePage}'>{$nextOnePage}</a> \";\n        $rightHtml .= \"<a href='{$url}={$nextOnePage}'>下一页</a> \";\n    \n    }elseif( $nextTwoPage==$totalPage ){//当前页的下两页为右边界\n    \n        $rightHtml .= \"<a href='{$url}={$nextOnePage}'>{$nextOnePage}</a> \";\n        $rightHtml .= \"<a href='{$url}={$nextTwoPage}'>{$nextTwoPage}</a> \";\n        $rightHtml .= \"<a href='{$url}={$nextOnePage}'>下一页</a> \";\n\n    }else{//其他情况\n        $rightHtml .= \"<a href='{$url}={$nextOnePage}'>{$nextOnePage}</a> \";\n        $rightHtml .= \"<a href='{$url}={$nextTwoPage}'>{$nextTwoPage}</a> \";\n        $rightHtml .= \"... \";\n        $rightHtml .= \"<a href='{$url}={$nextOnePage}'>下一页</a> \";\n    }\n\n    return $leftHtml . $middleHtml . $rightHtml;\n}\n```\n\n第二步，在list.php中构建分页参数，\n\n```php\n<?php \n\n//引入公共操作文件\ninclude './common.php';\n\n\n\n#==============================================================调整的代码\n//引入分页函数文件\ninclude './pageHtml.php';\n\n#计算分页所需参数\n$numPerPage = 10;//每页显示10条数据\n$nowPage = isset($_GET['page']) ? $_GET['page'] : 1;//如果有当前页的页面，则使用传递的页码，如果没有则默认显示第一页数据\n//计算总页数\n$sql = \"select count(*) as num from news where 1\";\n$result = mysqli_query($link, $sql);\n$pageRow = mysqli_fetch_assoc($result);//查询得到数据表中总的记录条数\n$totalPage = intval(ceil($pageRow['num']/$numPerPage));//求得总页数\n/*\n总的记录条数256\n每页显示10条\n\n总页数 = 总记录条数/每页显示记录数\n\n总页数 = 256/10 = ceil(25.6)=26 \n*/\n$url = \"http://www.home.com/class/day2/code/list.php?page\";\n\n\n#执行查询语句查询数据表的数据\n/*\n第一页     limit 0, 10\n第二页     limit 10, 10\n第三页     limit 20, 10\n第$nowPage页      limit ($nowPage-1)*$numPerPage, 10 \n*/\n$x = ($nowPage-1)*$numPerPage;//计算limit的偏移量\n$sql = \"select id, title, intro, post_date from news where 1 order by id desc limit {$x}, {$numPerPage}\";\n#==============================================================调整的代码\n\n\n\n$result = mysqli_query($link, $sql);\n\n//解析出所有的数据\n$rows = mysqli_fetch_all($result, MYSQLI_ASSOC);\n\n?>\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>后台新闻列表页</title>\n</head>\n<body>\n\n    <p>\n        <a href=\"http://www.home.com/class/day2/code/ad.php\">添加新闻</a>\n    </p>\n\n    <table border=\"1px\">\n        <thead>\n            <tr>\n                <td>序号</td>\n                <td>ID</td>\n                <td>新闻标题</td>\n                <td>新闻简介</td>\n                <td>添加时间</td>\n                <td>操作</td>\n            </tr>\n        </thead>\n        <tbody>\n            <?php foreach( $rows as $rows_key=>$row ){ ?>\n            <tr>\n                <td><?php echo $rows_key+1; ?></td>\n                <td><?php echo $row['id']; ?></td>\n                <td><?php echo $row['title']; ?></td>\n                <td><?php echo $row['intro']; ?></td>\n                <td><?php echo date('Y-m-d H:i:s', $row['post_date']); ?></td>\n                <td>\n                    <a href=\"http://www.home.com/class/day2/code/upd.php?id=<?php echo $row['id']; ?>\">编辑新闻</a> \n                    <a href=\"http://www.home.com/class/day2/code/del.php?id=<?php echo $row['id']; ?>\">删除新闻</a>\n                </td>\n            </tr>\n            <?php } ?>\n        </tbody>\n    </table>\n\n    <p>\n<!-- =======================================================调整的代码 -->     \n        <!-- <a href=\"\">上一页</a> -->\n        <!-- ... -->\n        <!-- <a href=\"\">1</a> -->\n        <!-- <a href=\"\">2</a> -->\n        <!-- <a href=\"\" style=\"color:red;\">3</a> -->\n        <!-- <a href=\"\">4</a> -->\n        <!-- <a href=\"\">5</a> -->\n        <!-- ... -->\n        <!-- <a href=\"\">下一页</a> -->\n        <?php echo pageHtml($nowPage, $totalPage, $url); ?>\n<!-- =======================================================调整的代码 -->   \n    </p>\n\n</body>\n</HTML>\n\n\n```\n\n\n\n## 4. 全天总结\n\n1. 连库基本操作函数\n\n   mysqli_connect函数     连库和选择默认数据库的\n\n   mysqli_set_charset函数    设置字符集的\n\n   mysqli_select_db函数    切换选择新的数据库的\n\n2. 执行增删改操作的函数\n\n   mysqli_query函数    执行增删改SQL语句的，成功返回true,失败返回false\n\n3. 执行查询操作的函数\n\n   mysqli_query函数   执行查询SQL语句的，返回的是一个对象的结果集\n\n   mysqli_fetch_assoc函数   解析结果集得到一条数据记录的，获得的数据是一个关联类型的数组\n\n   mysqli_fetch_row函数   解析结果集得到一条数据记录的，获得的数据是一个索引类型的数组\n\n   mysqli_fetch_all函数   解析结果集得到所有数据记录的，可以指定第二个参数，第二个参数可以是\n\n   MYSQLI_NUM  返回索引数据数组  （默认的）\n\n   MYSQLI_ASSOC  返回关联数据数组\n\n   MYSQLI_BOTH  返回的数据即包含关联类型的数据，也包含索引类型的数据\n\n\n\n\n\n\n\n","categories":["MYSQLI"]},{"title":"PhalApi框架","url":"%2Fposts%2F745665408%2F","content":"\n\n# π框架简介\n\n在我们做小程序应用或者是一些前后端完全分离的项目里面（或者做一个单页应用、SPA ：signal page application），一般我们后端PHP程序员都需要编写好相关的接口，同时还要写好相应的接口文档，以供前端的开发人员或者其他的项目团队进行使用。\n\n 前端程序员在做前后端分离的项目的时候，如果后端没有提供好相关 的即可，则前端可以使用一个 mock.js 脚本生成很多的测试数据。http://mockjs.com\n\n\n\n**一般的开发流程：**\n\n1. 写接口，一个url地址就是一个接口（框架实现），一把来说我们接口都是返回json格式数据。\n\n  现在很多企业的一些项目不再使用api接口（基于REST规范，落地产品为 RESTful，应用到实际项目为 RESTFul api），而是使用RPC，如谷歌的gRPC，远程过程调用的方式去获取相关数据 http://doc.oschina.net/grpc?t=60136\n\n  * 单一从后端获取数据，一般这类接口都不需要做啥认证，请求方式一般都是get。\n  * 需要将客户端的数据提交到后端进行入库保存，或者有部分的数据是需要做一定的认证操作后才可以查看，这一类的接口一般都要事先做好接口的认证工作，证明有权限去访问该接口，请求的方式一般都是POST。\n\n  \t​\t\n\n2. 接口一般都需要做一些认证，对于一些特殊的接口，例如对后端数据库会造成更改，都必须要做出一定的验证，事先写好一个认证接口，同时在服务器端需要保存一定的认证信息，然后将认证的信息返回给客户端，客户端在每次请求其他类型的接口的时候，必须先携带该凭证。\n\n\n\n3. 写接口的调用文档，一把来说我们写好了接口，都需要出示一份文档（接口说明书），给予前端人员使用。\n\n   * url地址\n\n   * 请求方式\n   * 参数传递\n   * 是否需要认证\n   * 返回数据类型\n   * 成功请求后的效果，示例代码，解释好每个字段的含义\n   * 如果失败或者出错的时候，返回的信息，示例代码，一般都要有错误状态码，消息提示\n\n   \n\n一般我们可以使用一些网站提供的在线工具进行接口的编写；（https://www.showdoc.cc）\n\n或者自己使用markdown的编辑器自己使用markdown语法进行编写。熟悉一下markdown语法。\n\n\n\n本次打算使用**π框架**来编写小程序的接口，接口的验证。\n\n**官网**：<https://www.phalapi.net/>\n\n![img](wps328D.tmp.jpg) \n\n \n\n\n\n## 版本介绍\n\n![img](wps329E.tmp.jpg) \n\n \n\n## 在线体验\n\n![img](wps329F.tmp.jpg) \n\n \n\n## 亮点\n\n![img](wps32B0.tmp.jpg) \n\n \n\n## 第三方集成\n\n![img](wps32B1.tmp.jpg) \n\n \n\n## SDK\n\n![img](wps32C1.tmp.jpg) \n\n \n\n \n\n## 查看\n\n![img](wps32C2.tmp.jpg) \n\n \n\n## 下载\n\n<https://www.phalapi.net/download.html>\n\n \n\n## π框架安装\n\n文档 ： [下载与安装](http://docs.phalapi.net/#/v2.0/download-and-setup)\n\n1. 使用composer进行下载\n\n```\n> composer create-project phalapi/phalapi local.papi.com\n```\n\n \n\n2. 安装后的目录结构，`public` 为站点根目录\n\n![img](wps32D4.tmp.jpg) \n\n \n\n3. 配置一个虚拟主机\n\n![img](wps32E4.tmp.jpg) \n\n \n\n4. 配置hosts文件\n\n![img](wps32F5.tmp.jpg) \n\n \n\n5. 浏览器访问效果\n\n![img](wps32F6.tmp.jpg) \n\n \n\n# 文件目录结构\n\n文档： [项目目录结构的差异](http://docs.phalapi.net/#/v2.0/how-to-upgrade-2x?id=%e9%a1%b9%e7%9b%ae%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84%e7%9a%84%e5%b7%ae%e5%bc%82)\n\n## public目录\n\n![img](wps3307.tmp.jpg) \n\n## config目录\n\n![img](wps3308.tmp.jpg) \n\n \n\n## APP目录\n\n![img](wps3318.tmp.jpg) \n\n## 源码\n\n![img](wps3319.tmp.jpg) \n\n \n\n# 访问接口\n\n文档： [运行Hello World >> 访问一个接口](http://docs.phalapi.net/#/v2.0/hello-world?id=%e8%ae%bf%e9%97%ae%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3)\n\n![img](wps331A.tmp.jpg) \n\n \n\n1. 在地址栏进行url访问\n\n![img](wps332B.tmp.jpg) \n\n​\t访问规则：`域名?s=App.控制器名称.方法名称&key=value&key2=value2....`\n\n \n\n2. 对应的控制器和方法\n\n   ![1538487671539](1538487671539.png)\n\n\n\n3. 效果\n\n![img](wps333D.tmp.jpg) \n\n# 访问参数验证\n\n文档位置 ：  [Api接口服务层 >> 接口参数规则配置](http://docs.phalapi.net/#/v2.0/api?id=%e6%8e%a5%e5%8f%a3%e5%8f%82%e6%95%b0%e8%a7%84%e5%88%99%e9%85%8d%e7%bd%ae)\n\n注意：在每个控制器里面都会存在一个getRules方法，该方法里面的用于对应的接口传递的参数行为约束。\n\n```php\n/**\n * 这个方法是做参数验证的\n * @return [type] [description]\n */\n/* 使用示例\npublic function getRules() {\n    return array(\n        '接口类方法名' => array(\n            '接口类属性' => array('name' => '接口参数名称', ... ... ),\n        ),\n    );\n}\n*/\npublic function getRules() {\n\t\n    return array(\n    \t// 一维下标是接口类的方法名，对应接口服务的Action；\n    \t# '方法名' => array\n        'index' => array(\n        \t// \t二维下标是类属性名称，对应在服务端获取通过验证和转换化的最终客户端参数；\n        \t// \tarray()中是对该属性的一个修饰 ，属性的值从get传参过来\n        \t// \t'name' : 指定接口参数名称，对应外部客户端请求时需要提供的参数名称。$_GET['username'] \n        \t// \t'desc'： 描述，生成接口文档的时候使用\n        \t//\n        \t// \t$this->username = isset( $_GET['username'] ) ? $_GET['username'] : 'PhalApi'\n\n        \t# '属性名称' => array()\n            'username' \t=> array('name' => 'username', 'default' => 'PhalApi', 'desc' => '用户名'),\n        ),\n    );\n}\n```\n\n![1538487002273](1538487002273.png)\n\n\n\n TODO\n\n# 文档生成\n\n## 注释参考\n\n\n\n[注释与在线文档](http://docs.phalapi.net/#/v2.0/api?id=%e6%b3%a8%e9%87%8a%e4%b8%8e%e5%9c%a8%e7%ba%bf%e6%96%87%e6%a1%a3)\n\n* [接口服务名称](http://docs.phalapi.net/#/v2.0/api?id=%e6%8e%a5%e5%8f%a3%e6%9c%8d%e5%8a%a1%e5%90%8d%e7%a7%b0)\n\n* [接口说明](http://docs.phalapi.net/#/v2.0/api?id=%e6%8e%a5%e5%8f%a3%e8%af%b4%e6%98%8e)\n\n* [接口参数说明](http://docs.phalapi.net/#/v2.0/api?id=%e6%8e%a5%e5%8f%a3%e5%8f%82%e6%95%b0-1)\n\n* [返回结果](http://docs.phalapi.net/#/v2.0/api?id=%e8%bf%94%e5%9b%9e%e7%bb%93%e6%9e%9c)\n\n* [异常情况](http://docs.phalapi.net/#/v2.0/api?id=%e5%bc%82%e5%b8%b8%e6%83%85%e5%86%b5)\n\n* [公共注释](http://docs.phalapi.net/#/v2.0/api?id=%e5%85%ac%e5%85%b1%e6%b3%a8%e9%87%8a)\n\n\n\n## 在线文档\n\n文档： [在线接口文档](http://docs.phalapi.net/#/v2.0/how-to-request?id=%e5%9c%a8%e7%ba%bf%e6%8e%a5%e5%8f%a3%e6%96%87%e6%a1%a3)\n\nπ框架给我们提供了强大的文档生成方式，我们只需要在方法前面按照指定的格式编写注释，即可生成文档。\n\n1. 在方法前面编写注释\n\n   ![1538490748083](1538490748083.png)\n\n    \n\n2. 通过 域名/docs.php 方式访问在线文档\n\n![img](wps334F.tmp.jpg) \n\n \n\n3. 点击展开\n\n![img](wps3360.tmp.jpg) \n\n \n\n4. 详情查看\n\n![img](wps3370.tmp.jpg) \n\n \n\n \n\n## 离线文档\n\n文档： [生成离线文档](http://docs.phalapi.net/#/v2.0/how-to-request?id=%e5%a6%82%e4%bd%95%e7%94%9f%e6%88%90%e7%a6%bb%e7%ba%bf%e6%96%87%e6%a1%a3%ef%bc%9f)\n\nπ框架提供了离线文档，供开发者使用。\n\n**使用方式：** \n\n```bash\nphalapi$  php ./public/docs.php \n\nUsage:\n生成展开版：  php ./public/docs.php expand\n生成折叠版：  php ./public/docs.php fold\n\n脚本执行完毕！离线文档保存路径为：/path/to/phalapi/public/docs\n```\n\n注意： 根据实际补全路径信息，如  `./public/docs.php  `\n\n\n\n1. 执行如下的命令\n\n![img](wps3371.tmp.jpg) \n\n2. 目录查看\n\n![img](wps3382.tmp.jpg) \n\n \n\n3. 访问 `域名/docs/`\n\n![img](wps3383.tmp.jpg) \n\n \n\n \n\n# π框架的模型\n\n文档： [Model数据模型层与数据库操作](http://docs.phalapi.net/#/v2.0/model?id=model%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e5%b1%82%e4%b8%8e%e6%95%b0%e6%8d%ae%e5%ba%93%e6%93%8d%e4%bd%9c)\n\n==注意==：π框架是没有视图、学习完成控制器之后，我们就可以学习模型，并且π框架里面的模型也不是自己写的，是使用别人开发的一个ORM框架（NotORM）。\n\n\n\n## 数据库配置\n\n![1538491512850](1538491512850.png)\n\n \n\n## 模型的定义\n\n文档参考： \n\n* [NotORM简介](http://docs.phalapi.net/#/v2.0/model?id=notorm%e7%ae%80%e4%bb%8b)    \n\n* [如何获取NotORM实例？](http://docs.phalapi.net/#/v2.0/model?id=%e5%a6%82%e4%bd%95%e8%8e%b7%e5%8f%96notorm%e5%ae%9e%e4%be%8b%ef%bc%9f)\n\n* [Model子类与表名](http://docs.phalapi.net/#/v2.0/model?id=model%e5%ad%90%e7%b1%bb%e4%b8%8e%e8%a1%a8%e5%90%8d)\n\n* **[在Model内的CURD基本操作](http://docs.phalapi.net/#/v2.0/model?id=%e5%9c%a8model%e5%86%85%e7%9a%84curd%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c)**\n\n\n\n**NotORM**是一个优秀的开源PHP类库，可用于操作数据库。PhalApi的数据库操作，主要是依赖此NotORM来完成。 \n\n>  NotORM官网：[www.notorm.com](http://www.notorm.com/) \n\n\n\n在src\\app\\Model目录下创建一个Movie.php文件\n\n![1538031807649](1538031807649.png)\n\n\n\n在src\\app\\Api\\Site.php控制器文件实例化模型，获取数据\n\n![1538033770581](1538033770581.png)\n\n\n\n# 案例： 小程序轮播图\n\n\n\n## 需求\n\n**需求：**\n\n需要为小程序提供一个轮播图的接口\n\n![img](wps3396.tmp.jpg) \n\n\n\n## 分析 \n\n在传统网站开发里面，很多网站的首页里面也是会存在一个轮播图信息，那么如果我们要在传统网页里面实现一个轮播图，则我们可以使用一些插件快速的完成。\n\nhttps://www.swiper.com.cn/\n\n快速入门的案例：\n\nhttps://www.swiper.com.cn/usage/index.html\n\n\n\n我们的需求是在小程序里面实现一个轮播图功能，小程序内部存在一个组件可以实现轮播图效果，只需要给轮播提供素材即可。\n\n\n\n效果：\n\n![1538033370889](1538033370889.png)\n\n \n\n**分析：**\n\n1. 请求方式：GET\n\n2. 是否认证：不需要（接口的认证）\n\n3. 返回数据类型 json\n\n4. 参数：\n  *  `number `代表需要几张轮播图\n  *  设置一个默认值\n  *  `position` 轮播位（轮播图分类）\n     *  首页有轮播图，详情页也有轮播图，所以需要对齐进行分类，才方便读取。\n     *  上传轮播图的时候，需要给这些轮播图一个分类\n\n5. 轮播图点击之后跳转对应的业务\n\n   * 后台我们上传轮播图的时候，需要为轮播图做一些相关业务的关联，一般的关联都是某件商品的展示。\n\n     \n\n\n\n\n## 建表\n\n**设计表**\n\n轮播图表\n\n| id   | url      | gid        | is_on                                       | create_time | update_time | xxxx |\n| ---- | -------- | ---------- | ------------------------------------------- | ----------- | ----------- | ---- |\n|      | 图片地址 | 关联商品id | 表示轮播图是否上线 1代表上线，0代表没有上线 |             |             |      |\n\n  ![1538033551042](1538033551042.png)\n\n\n商品表\n\n| id   | name | price | number | .... | ...  | ..   |\n| ---- | ---- | ----- | ------ | ---- | ---- | ---- |\n|      |      |       |        |      |      |      |\n\n ![1538034695579](1538034695579.png)\n\n \n\n\n\n\n\n## 接口编写示例\n\n1. 定义控制器，创建一个getRules方法\n\n![img](wps33C9.tmp.jpg) \n\n \n\n2. 创建一个lst方法\n\n![img](wps33CA.tmp.jpg) \n\n \n\n3. 创建一个transfer方法，用于数据的格式化\n\n![img](wps33CB.tmp.jpg) \n\n \n\n4. 效果\n\n![img](wps33DB.tmp.jpg) \n\n \n\n## 轮播图接口\n\n1. 在src/Api/Banner.php控制器文件，创建一个getRules方法\n\n![1538037911505](1538037911505.png)\n\n\n2. 在src/Model/Banner.php模型文件，获取轮播图信息\n\n![1538038013908](1538038013908.png)\n\n\n3. 在src/Api/Banner.php控制器文件，创建一个lst方法\n\n![1538037932482](1538037932482.png)\n\n\n4. 在src/Api/Banner.php控制器文件，创建一个transfer方法，用于数据的格式化\n\n![1538037945803](1538037945803.png)\n\n\n5. 效果\n\n![1538038037612](1538038037612.png)\n\n\n\n## 商品详情接口\n\n在src\\app\\Api\\Goods.php文件编写商品详情接口\n\n![1538038776351](1538038776351.png)\n\n### 详情查看\n\n   当我们点击轮播图之后，则需要打开一个页面显示商品的详情信息\n\n\n\n1. 在pages/swiper/swiper.wxml文件为每个轮播项绑定点击事件\n\n   ![1538038628665](1538038628665.png)\n\n2. 在pages/swiper/swiper.js文件定义回调函数打开一个详情页\n\n   ![1538038647842](1538038647842.png)\n\n3. 在pages/detail/detail.js文件获取商品主键id，向商品详情接口发送网络请求获取数据\n\n   ![1538038674478](1538038674478.png)\n\n4. 在pages/detail/detail.wxml页面完成商品展示\n\n   ![1538038716978](1538038716978.png)\n\n5. 效果\n\n   ![1538038688372](1538038688372.png)\n\n## 集成微信小程序\n\n1. 在config/config.js文件定义好url地址常量\n\n   ![1538038334591](1538038334591.png)\n\n2. 在pages/swiper/swiper.js文件，调用接口获取轮播图信息\n\n   ![1538038397690](1538038397690.png)\n\n3. 在pages/swiper/swiper.wxml文件完成布局\n\n   ![1538038458458](1538038458458.png)\n\n4. 效果\n\n   ![1538038482324](1538038482324.png)\n\n\n\n\n\n# 其它\n\n## **语言包**\n\n1. 查看系统使用的默认语言包\n\n![img](wps33EC.tmp.jpg) \n\n \n\n2. 配置自己的语言项\n\n![img](wps33ED.tmp.jpg) \n\n \n\n3. 查看语言包函数\n\n![img](wps33FD.tmp.jpg) \n\n \n\n \n\n## **自定义异常类**\n\n1. 自定义异常类\n\n![img](wps33FE.tmp.jpg) \n\n \n\n2. 在轮播图信息为空的时候抛出异常\n\n![img](wps340F.tmp.jpg) \n\n \n\n3. 效果\n\n![img](wps3410.tmp.jpg) \n\n\n\n## 小程序如何和PHP交互的？\n\n![1538039794609](1538039794609.png)","categories":["PhalApi框架"]},{"title":"TP3框架","url":"%2Fposts%2F551416508%2F","content":"\n\n# tp3简介\n\n在国内的thinkPHP是一个非常不错的框架，很多的PHP程序员入门的第一个框架就是thinkPHP，俗称**tp**框架。并且这个框架也是最好掌握MVC开发思想的框架，学习起来的成本也是很低的。\n\n**目前这个框架存在两个大的版本：**\n\n* tp3\n* tp5\n\n注意：tp5是不兼容tp3，也就是说之前使用的tp3开发的项目是没有直接升级到tp5。并且tp5是完全参照laravel框架进行了编写的。\n\n\n\n一般来说如果去企业上班新的项目肯定都是tp5，但是一些老的项目还是tp3，并且目前情况说tp3还会存活很长一段时间。\n\n\n\n# 下载\n\n[ThinkPHP3.2.3核心版](http://www.thinkphp.cn/down/611.html) \n\n[ThinkPHP3.2.3完整版](http://www.thinkphp.cn/down/610.html) \n\n![1538010465082](1538010465082.png)\n\n\n\n下载后\n\n![1538010508360](1538010508360.png)\n\n\n\n# 部署\n\n注意：tp3不能在PHP7下运行。\n\n创建虚拟主机\n\n![1538010556138](1538010556138.png)\n\n\n\n![1538010650440](1538010650440.png)\n\n\n\n浏览器访问\n\n![1538010679084](1538010679084.png)\n\n\n\n# 目录结构\n\n## 整体规划\n\n![1538010829654](1538010829654.png)\n\n## 入口文件\n\n![1538010987946](1538010987946.png)\n\n\n\n## 应用目录\n\n![1538011138270](1538011138270.png)\n\n\n\n## 公共文件\n\n![1538011266130](1538011266130.png)\n\n\n\n## 模块\n\n![1538011360788](1538011360788.png)\n\n后期我们写代码的时候，基本上都只在模块里面进行书写，如果出于业务考虑，可以在增加一些模块。\n\n\n\n# 控制器学习\n\n我们学习的是一个MVC的产品，那么在学习的时候，学习的顺序是有讲究：\n\n**用户能够直接访问的是MVC里面的哪一个呢？**\n\n答：只能接触到的C，控制器。V是由控制器里面的业务代码决定是否载入。\n\n\n\n开始从控制器学习，学习之后还要做一件事，如何调用控制器里面的方法？\n\n\n\n## 如何调用控制器里面的方法？\n\n为什么可以看到tp3的笑脸？\n\n![1538011637459](1538011637459.png)\n\n原理就是这样对上了。需要对访问规则做一个抽象。\n\n\n\n在tp3里面的对于控制器下的方法访问有很==四种url模式== :  **普通模式、PATHINFO、REWRITE和兼容模式**\n\n1. **PATHINFO模式**是系统的默认URL模式，提供了最好的SEO支持，系统内部已经做了环境的兼容处理，所以能够支持大多数的主机环境。\n\n   ```\n   域名/入口文件/模块的名称/控制器名称/方法名称?get传参\n   ```\n\n   这种模式其实对于搜索引擎来说是最喜欢。\n\n   \n\n2. **普通模式**， 一种使用的比较多的模式，也就是传统的GET传参方式来指定当前访问的模块和操作\n\n   ```\n   域名/index.php?m=Home&c=Index&a=index\n   ```\n\n   `m`代表的是模块，传递一个模块的名称\n\n   `c`代表的是控制器，传递一个控制器的名称\n\n   `a`代表的动词(action)，传递一个控制器里面的方法的名称\n\n   ![1538011845165](1538011845165.png)\n\n3. **REWRITE模式**是在PATHINFO模式的基础上添加了重写规则的支持，可以去掉URL地址里面的入口文件index.php，但是需要额外配置WEB服务器的重写规则。\n\n   如果是Apache则需要在入口文件的同级添加.htaccess文件，内容如下：\n\n   ```\n   <IfModule mod_rewrite.c> \n       RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-d \n       RewriteCond %{REQUEST_FILENAME} !-f \n       RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]\n   </IfModule>\n   ```\n\n   接下来，就可以用下面的URL地址访问了： `http://localhost/home/user/login/var/value`\n\n\n\n4. **兼容模式**是用于不支持PATHINFO的特殊环境，URL地址是：  \n\n   `http://localhost/?s=/home/user/login/var/value`\n\n   可以更改兼容模式变量的名称定义，例如：\n\n   ```\n   'VAR_PATHINFO'  =>  'pathinfo'\n   ```\n\n   PATHINFO参数分隔符对兼容模式依然有效，例如：\n\n   ```\n   // 更改PATHINFO参数分隔符\n   'URL_PATHINFO_DEPR'=>'-', \n   ```\n\n   使用以上配置的话，URL访问地址可以变成：  `http://localhost/?s=/home-user-login-var-value`\n\n\n\n### 方法调用的演示\n\n快速入门测试，我们在Home模块的IndexController控制器文件增加一个test方法，然后在浏览器进行访问调用。\n\n![1538012029890](1538012029890.png)\n\n效果\n\n![1538011955347](1538011955347.png)\n\n## 控制器规范\n\n思考：\n\n1. 控制器写在哪里？\n2. 控制器的文件如何命名？\n3. 控制器里面的代码如何书写？\n4. 控制器的如何被调用？\n\n\n\n实操：\n\n1. 控制器写在哪里？\n\n   ![1538012154947](1538012154947.png)\n\n2. 控制器的文件如何命名？\n\n   **规则**\n\n   `控制器名`  ： 首字母大写\n\n   `Controller` ： 控制器后缀\n\n   ```\n   控制器名 + Controller.class.php\n   ```\n\n   ![1538012286641](1538012286641.png)\n\n3. 控制器里面的代码如何书写？\n\n   ![1538012615686](1538012615686.png)\n\n   \n\n4. 控制器的如何被调用？\n\n   1.  域名/index.php?m=Home&c=User&a=index\n\n   2. 域名/index.php/Home/User/index\n\n      ![1538012683145](1538012683145.png)\n\n思考：我们现在是在Home这个模块写的控制器，如果处于业务需要，现在需要增加一个Admin模块，需要做一个后台首页的功能。则需要一个后台模块，一个后台的首页控制器。\n\n1. 建立一个Admin后台模块\n\n   ![1538012817867](1538012817867.png)\n\n2. 建立一个IndexController.class.php文件\n\n   ![1538012851547](1538012851547.png)\n\n   注意：这里的内容我们需要修改\n\n   ![1538012971866](1538012971866.png)\n\n3. 在该控制器里面增加一个index方法，然后浏览器访问\n\n   ![1538012949236](1538012949236.png)\n\n\n\n# 视图学习\n\n### 视图规范\n\n思考：\n\n1. 视图写在哪里？\n2. 视图文件如何命名？\n3. 视图里面的该写什么？\n4. 视图如何被载入？\n\n\n\n实操：\n\n1. 视图写在哪里？\n\n   ![1538014240033](1538014240033.png)\n\n2. 视图文件如何命名？\n\n   ![1538014301739](1538014301739.png)\n\n3. 视图里面的该写什么？\n\n   1. html标签\n\n   2. 可以PHP代码\n\n   3. 也可以使用PHP的内置的标签\n\n      ![1538014387548](1538014387548.png)\n\n      \n\n4. 视图如何被载入？\n\n   ![1538014441046](1538014441046.png)\n\n   效果\n\n   ![1538014458341](1538014458341.png)\n\n\n\n### 分配变量到视图\n\n思考：如何在视图中控制器方法里面的变量？\n\n![1538014908212](1538014908212.png)\n\n视图代码：\n\n![1538014927897](1538014927897.png)\n\n效果：\n\n![1538014935189](1538014935189.png)\n\n\n\n\n\n# 模型学习\n\n## 数据库配置\n\n思考：\n\n**模型是和数据库打交道的，那么模型和哪个数据库打交道？**\n\n答：我们先在框架完成数据库的配置。\n\n![1538015132314](1538015132314.png)\n\n我们希望TP3和上面的数据库打交道。\n\n![1538015322910](1538015322910.png)\n\n\n\n## 模型规范\n\n当我们配置完成之后，在考虑模型的事？\n\n1. 模型写在哪里？\n2. 模型文件如何命名？\n3. 模型里面的内容如何编写？\n4. 模型如何被实例化？\n\n\n\n1. 模型写在哪里？\n\n   ![1538015376299](1538015376299.png)\n\n2. 模型文件如何命名？\n\n   ![1538015446287](1538015446287.png)\n\n3. 模型里面的内容如何编写？\n\n   ![1538015634239](1538015634239.png)\n\n4. 模型如何被实例化，调用模型的方法，获取数据\n\n   ![1538015958799](1538015958799.png)\n\n5. 效果\n\n   ![1538015982388](1538015982388.png)\n\n\n\n## 模型常见方法\n\n1. select方法：该方法是用于获取所有的记录信息\n2. field方法：获取指定的字段信息\n3. find方法：获取单条记录信息\n\n建议看一下手册：\n\n![1538018425283](1538018425283.png)\n\n\n\n\n\n## 模型简洁调用\n\n### D方法\n\n用于数据模型的实例化操作\n\n![1538018674611](1538018674611.png)\n\n\n\n### M方法\n\n用于数据模型的实例化操作，由于不需要加载具体的模型类，所以性能会更高。\n\n![1538018878618](1538018878618.png)\n\n\n\n**注意：**\n\n1. 这里的M函数得到实例对象其实是系统Model.class.php类的实例。\n\n2. 在我们实例D或者M的时候，其实没有严格的要求，一般M实例化系统的Model，D实例化的我们自定义的模型。但是需要注意的是，D也可以实例化系统模型。\n\n   ![1538019116624](1538019116624.png)\n\n\n\n\n\n\n\n# 总结\n\n通过上面的学习，我们学会了Tp3里面的MVC这种开发思想。\n\n\n\n\n","categories":["TP3框架"]},{"title":"博客项目1","url":"%2Fposts%2F4006364827%2F","content":"\n\n# 一、昨日回顾\n\n## 1. 知识回顾\n\n1. mvc的三大组件是什么？\n\n   M：model     模型\n\n   V：view          视图\n\n   C：Controller     控制器\n\n2. mvc的三大组件分别代表什么意思？\n\n   M：专门用来操作数据表的\n\n   V：专门用来展示视图模板的\n\n   C：专门用来处理业务逻辑，比如说什么时候该调用模型操作数据，什么时候该调用视图展示模板，都是由控制器里来处理。\n\n\n\n构建实例化函数\n\n## 2. 昨日反馈\n\n![1531270551320](114)\n\n# 二、知识路径\n\n- web项目开发流程介绍\n\n- 需求分析\n\n  ​\t功能分析\n\n  ​\tER图设计\n\n- 表设计\n\n- 项目部署\n\n- 项目实现\n\n  ​\t实现后台用户管理系统\n\n  ​\t封装验证码工具类\n\n==目标：能够设计项目所需的表、能够部署自主框架、能够实现后台用户管理系统==\n\n# 三、今日课程内容：博客项目\n\n## 1. web项目开发流程介绍\n\n1)制定计划：博客项目(blog31)  开发周期：4天\n\n2)需求分析：功能分析  ER图设计\n\n3)软件设计：项目环境  表设计\n\n4)程序编写\n\n5)软件测试\n\n6)运行维护\n\n\n\n## 2. 需求分析\n\n### 功能分析\n\n1. 后台用户管理系统；\n2. 后台分类管理系统；\n3. 后台博文管理系统；\n4. 评论管理系统；\n5. 后台登陆和七天免登录；\n6. 前台首页；\n7. 前台注册和登陆功能；\n8. 前台博客文章详情页；\n\n\n\n### ER图设计\n\nE-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。它是描述现实世界概念结构模型的有效方法。是表示概念模型的一种方式，用矩形表示实体型，矩形框内写明实体名；用椭圆表示实体的属性，并用无向边将其与相应的实体型连接起来；用菱形表示实体型之间的联系，在菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1,1:n或m:n）。\n\n \n\n专业的ER图工具：Viso和Power Designer\n\n \n\n==实体== ==》表：矩形表示\n\n==属性== ==》表字段：椭圆\n\n==关系== ==》表与表的关系：菱形（1:1表示1对1关系；1:n表示1对多关系；m:n表示多对多关系）\n\n\n\n博客项目的ER关系图如下： \n\n![1531279764230](1)\n\n\n\n## 3. 表设计\n\n```mysql\ndrop database blog31;\ncreate database blog31;\n\n#############用户表：\nCREATE TABLE `bg_user` (\n  `id` int unsigned auto_increment,\n  `acc` varchar(50) not null default '' COMMENT '帐号',\n  `nickname` varchar(30) not null default '' COMMENT '昵称',\n  `pwd` char(32) not null default '' COMMENT '密码',\n  `cell` varchar(15) not null default '' COMMENT '手机号',\n  `regtime` int unsigned default 0 COMMENT '注册时间',\n  `type` tinyint unsigned not null default 0 COMMENT '用户类型 0:普通用户 1:管理员',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n#############博客文章表：\nCREATE TABLE `bg_article` (\n  `id` int(11) unsigned AUTO_INCREMENT,\n  `title` varchar(100) not null default '' COMMENT '文章标题',\n  `intro` varchar(255) not null default '' COMMENT '文章简介',\n  `content` text not null,\n  `post_date` int unsigned not null default 0 COMMENT '发布时间',\n  `user_id` int unsigned not null default 0 COMMENT '发布管理员id',\n  `user_nickname` varchar(30) not null default '' COMMENT '发布管理员昵称',\n  `comment_num` smallint unsigned not null default 0 COMMENT '评论数量',\n  `cat_id` int unsigned not null default 0 COMMENT '所属分类id',\n  `cat_name` varchar(30) not null default '' COMMENT '所属分类名称',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n#############博客文章分类表：\nCREATE TABLE `bg_category` (\n  `id` int unsigned AUTO_INCREMENT,\n  `name` varchar(30) not null COMMENT '分类名称',\n  `parent_id` int unsigned not null default '0' COMMENT '上级分类ID，0表示顶级分类',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n\n#############评论表：\nCREATE TABLE `bg_comment` (\n  `id` int unsigned AUTO_INCREMENT,\n  `content` text not null,\n  `post_date` int unsigned not null default 0 COMMENT '评论时间',\n  `article_id` int unsigned not null default 0 COMMENT '所属文章ID',\n  `article_title` varchar(50)  not null default '' COMMENT '所属文章标题',\n  `user_id` int unsigned not null default 0 COMMENT '用户ID',\n  `user_nickname` varchar(30)  not null default '' COMMENT '用户昵称',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n```\n\n\n\n## 4. 项目部署\n\n1. 将code/mvc目录改名为blog31，\n\n   下图这个mvc目录：\n\n   ![1531291206947](2)\n\n   改名为blog31:\n\n   ![1531291235746](3)\n\n2. 配置一个基于域名虚拟主机，域名为www.blog31.com\n\n   在httpd-vhosts.conf文件中增加如下图所示的虚拟主机配置项：\n\n   ![1531291311545](4)\n\n   修改hosts文件，\n\n   ![1531291371313](5)\n\n3. 重启apache，测试访问效果：\n\n   ![1531291456736](6)\n\n   访问效果为：\n\n   ![1531291515331](7)\n\n   能够看到上图，则说明部署成功。\n\n\n\n## 5. 项目实现\n\n### 实现后台用户管理系统\n\n#### 实现列表页\n\n1. 将code/templates/admin目录中如下图所示的目录复制一份，\n\n   ![1531291763786](8)\n\n   转移拷贝到code/blog31/app/admin/view目录中，\n\n   ![1531291818821](9)\n\n2. 在blog31/app/admin/controller目录中创建一个名为UserController.class.php的文件，\n\n   ![1531291945355](10)\n\n3. 在blog31/app/admin/controller/UserController.class.php中构建如下代码，展示三个页面，\n\n   ![1531292339989](11)\n\n4. 测试访问后台用户管理系统列表页\n\n   ![1531292433660](12)\n\n5. 进一步做调整，将后台模板使用到的资源文件全部转移进项目中，\n\n   在blog31/public目录中创建一个名为admin的目录，专门保存后台的资源文件，\n\n   ![1531292599939](13)\n\n   复制code/templates/admin/libs目录下的所有文件，如下图所示，\n\n   ![1531292644972](14)\n\n   转移拷贝到blog31/public/admin目录中，\n\n   ![1531292690333](15)\n\n6. 调整blog31/app/admin/view/User/userIndex.html中引入资源文件的路径，\n\n   在blog31/conf/conf.php中增加本网站域名配置项，\n\n   ![1531293146377](16)\n\n   然后在blog31/app/admin/view/User/userIndex.html使用配置项URL的值来引入配置文件，\n\n   ![1531293430682](17)\n\n   ![1531293486446](18)\n\n   上图中替换的是所有图片文件引入路径，截取不全，实际替换的内容以blog31/app/admin/view/User/userIndex.html中的为准。\n\n7. 再次测试访问后台新闻管理系统列表页，\n\n   ![1531293567621](19)\n\n8. 在blog31/app/model目录中创建UserModel.class.php文件，\n\n   ![1531293712684](20)\n\n   内容如下：\n\n   ![1531293731152](21)\n\n   调整blog31/conf/conf.php中PDO配置项的默认选择的数据库名，\n\n   ![1531294133397](22)\n\n9. 在blog31/app/admin/controller/UserController.class.php中showIndex方法里渲染模板之前调用模型查询数据，\n\n   ![1531294688749](23)\n\n   然后在blog31/app/admin/view/User/userIndex.html中回显查询得到的用户数据，\n\n   ![1531294782348](24)\n\n   测试访问后台用户管理系统列表页：\n\n   ![1531294828901](25)\n\n#### 实现添加页\n\n1. 访问后台用户管理系统添加页，\n\n   ![1531295330114](26)\n\n2. 调整blog31/app/admin/view/User/userAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531295483768](27)\n\n3. 调整blog31/app/admin/view/User/userAdd.html中的form表单域各项的值，\n\n   ![1531295777460](28)\n\n4. 在blog31/app/admin/controller/UserController.class.php中创建一个处理添加用户的方法，adh方法，\n\n   ![1531296464355](29)\n\n5. 测试添加用户使用效果：\n\n   在添加表单页面构建数据，点击提交，\n\n   ![1531296568559](30)\n   提交后的效果：\n\n   ![1531296591547](31)\n\n   效果为添加成功，说明功能实现OK。\n\n#### 实现编辑页\n\n1. 访问后台新闻管理系统编辑页：\n\n   ![1531296743041](32)\n\n2. 修改blog31/app/admin/view/User/userIndex.html中编辑按钮的链接：\n\n   ![1531296871382](33)\n\n3. 调整blog31/app/admin/view/User/userEdit.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531296956168](34)\n\n4. 调整blog31/app/admin/view/User/userEdit.html中form表单里的代码，\n\n   ![1531297468408](35)\n\n5. 在blog31/app/admin/controller/UserController.class.php中创建updh方法，代码如下：\n\n   ![1531301022079](36)\n\n6. 测试使用效果：\n\n   点击进入编辑也，如下图所示：\n\n   ![1531301120317](37)\n\n   修改数据，\n\n   ![1531301172674](38)\n\n   点击更新，\n\n   ![1531301192522](39)\n\n   跳回到更新页面：\n\n   ![1531301213845](40)\n\n   密码也是被改变了的，如下图所示：\n\n   ![1531301252698](41)\n\n   说明编辑功能实现OK。\n\n\n\n## 6. 全天总结\n\n1. 项目中的建表部分：\n\n   如果某字段是需要保存时间，一般在PHP的项目中给int数据类型；\n\n   如果某字段需要保存状态类型的值，使用tinyint会更加好；\n\n   如果某字段保存的数据，我们可以预期的很准确，比如说手机号码，通常就是11位，但是我们在项目中一般会采取宁大不小的原则，给11位以上的值，比如给varchar(15)；\n\n   在构建字段的时候，我们一般都会给字段设置default默认值，如果不设置默认值，则今后这个字段无论是否需要添加数据，都必须指定上值。\n\n2. 项目开发部分：\n\n   我们使用框架进行开发，一般程序开发人员从模板入手，先尝试展示出模板页面的效果，然后再考虑是否需要调用模型操作数据库的问题，所以我们通常在MVC框架中，1）首先会将模板页面转移进项目目录；2）然后会创建控制器类，构建方法调用视图展示模板页面；3）调试模板页面展示的效果；4）以上都成功之后，如果没有模型则需要创建模型，如果有模型则直接去考虑调用模型操作数据；\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["博客项目"]},{"title":"PHP数组基础","url":"%2Fposts%2F2612395477%2F","content":"\n\n# 一、数组基础\n\n数组是一种复合类型的数据。它主要是用来存储多个数据！在PHP中的数组元素的数据类型可以是任意数据类型！\n\n### 数组的组成\n\n数组它是由一个一个的元素（element）来组成！\n\n每一个数组元素它又分为两个部分来组成！元素是由下标和值组成\n\n元素的下标称之**key**(键) 键名\n\n元素的值称之为**value**(值)\n\n所以我们一般将其称这为\"key/value 键值对\"\n\n\n\n### 数组的分类\n\n在PHP中数组分为\"索引数组和关联数组\"\n\n如何去区分索引数组和关联数组是通过数组的下标来进行区分。\n\n**索引数组的下标是数值**\n\n![](1536847127_image1.png)\n\n**关联数组的下标是字符串 **\n\n因为下标与值之间是有关系的，这一种就称之为关联数组！\n\n![](1536847127_image2.png)\n\n![](1536847127_image3.png)\n\n\n\n### 创建数组\n\n**显式的创建**\n\n使用array()这个函数来创建\n\n![](1536847127_image4.png)\n\n**隐式的创建**\n\n使用`[ ]`来创建\n\n1.  在创建的时候指定对应的下标值\n\n![](1536847127_image5.png)\n\n2.  在创建的时候不指定对应的下标\n\n![](1536847127_image6.png)\n\n**使用数组的方式来实现斐波那契数列**\n\n![](1536847127_image7.png)\n\n\n\n### 多维数组\n\nPHP本身是没有多维数组的概念 ，因为数组元素的数据类型是任意的 ，如果一个数组元素的类型它还是一个数组 那么这种数组我们就称之为多维数组。\n\n![](1536847127_image8.png)\n\n\n\n### 访问数组元素\n\n**使用下标来进行访问！**\n\n格式：\n\n```php\n数组变量名[下标]\n```\n\n举例：\n\n-   索引数组：数组变量名\\[索引下标\\]\n\n-   关联数组：数组变量名\\['字符下标'\\]\n\n![](1536847127_image9.png)\n\n**使用二维数组来打印杨辉三角**\n\n**//每一层的个数与当前层数相同 **\n\n**//每一层的第一个数与最后一个数都为1 **\n\n**//当前层数的第n列的数它等于当前层数-1的n-1列与当前层数-1的n列**\n\n![](1536847127_image10.png)\n\n\n\n# 二、数组的遍历\n\n## 使用foreach遍历数组\n\n遍历：依次访问数组的每一个元素！\n\n第一种格式：\n\n![](1536847127_image11.png)\n\n**键名与值是两个变量 这个变量可以随意定义 它就表示当前数组的key与value**\n\n![](1536847127_image12.png)\n\n有些时候key对于我们来没有太大的用处 我们就将其省略不写！\n\n第二种方式：\n\n![](1536847127_image13.png)\n\n![](1536847127_image14.png)\n\n## 使用for循环来遍历索引数组\n\n![](1536847127_image15.png)\n\n\n\n# 三、数组的指针\n\n每一个数组元素上面都对应一个指针。如果我们第一次使用指针的方式来访问数组。那么数组的指针会指向当前元素。\n\n## key\n\n获取到当前数组指针指向的元素的键名(下标)\n\n![](1536847127_image16.png)\n\n## current\n\n获取到当前数组指针指向的元素的值\n\n![](1536847127_image17.png)\n\n## next\n\n将数组的指针向下移一位\n\n返回数组内部指针指向的下一个单元的值，或返回 false。 当数组的指针已经移出去了就会返回false!\n\n## reset\n\n将数组中的指针进行重置\n\n## prev\n\n将数组的指针向上移一位\n\n## end\n\n将数组的指针移动到最后一位\n\n![](1536847127_image18.png)\n\n**思考一下：**我们能不能使用数组的指针加上for循环对关联数组进行遍历！\n\n![](1536847127_image19.png)\n\n# 四、使用while\\--list\\-\\-each来遍历数组 \n\n## each\n\neach函数它集合了key，current，next这三个函数的功能！这个each它返回的是一个数组！\n\n这个数组里面的元素共4个。有两个元素分别是索引下标，有两个元素分别是字符下标！\n\n**其中索引下标：**下标为0的表示原数组的中的key值，下标为1的表示原数组中value值\n\n**其中字符下标：**下标为key的表示原数组的中的key值，下标为value的表示原数组中value值\n\n![](1536847127_image20.png)\n\n如果我们要访问each这个函数的访问数组中的数组元素：\n\n访问到原数组的key值：\\$each\\[0\\]或者\\$each\\['key'\\]\n\n访问到原数组的value值：\\$each\\[1\\]或者\\$each\\['value'\\]\n\n![](1536847127_image21.png)\n\n**接下来我们要使用while+each来遍历数组 **\n\n![](1536847127_image22.png)\n\n## list\n\n**作用**：将一个索引数组下标为0的元素赋值给list这个函数中第一个参数，下标为1的赋值给list函数中的第二个参数.......依次类推！\n\n使用while+list+each来遍历数组！\n\n![](1536847127_image23.png)\n\n\n\n# 五、数组相关函数\n\n## count\n\n获取数组的长度 数组中元素的总个数\n\n```php\nint count (mixed $var [, int $mode = COUNT_NORMAL ] )\n```\n\nmixed \\$var：数组变量名\n\n第二个参数：如果这个参数的值为true ，表示支持递归统计。\n\n![](1536847127_image24.png)\n\n## range\n\n建立一个包含指定范围单元的数组\n\n```php\narray range ( mixed $start , mixed $limit [, number $step = 1 ] )\n```\n\n第一个参数：开始的位置\n\n第二个参数：结束的位置\n\n第三个参数：表示步长值\n\n![](1536847127_image25.png)\n\n## array\\_merge\n\n```php\narray array_merge ( array $array1 [, array $... ] )\n```\n\n将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。\n\n**合并数组时：**\n\n-   如果是索引下标的数组：如果下标重复 重新给其进行定义下标\n\n![](1536847127_image26.png)\n\n-   如果是字符下标的数组：如果下标重复 后面的数组会将前面的数组覆盖\n\n![](1536847127_image27.png)\n\n## array\\_rand\n\n从数组中取出一个或多个随机的数组元素的key 返回一个新的索引数组\n\n```php\nmixed array_rand ( array $input [, int $num_req = 1 ] )\n```\n\n第一个参数：数组名\n\n第二个参数：缺省值为1 表示从原数组中取出多少个元素\n\n![](1536847127_image28.png)\n\n## shuffle\n\n将原数组打乱\n\n```php\nbool shuffle ( array &$array )\n```\n\n![](1536847127_image29.png)\n\n## array\\_flip\n\n将数组中的键与值交换\n\n![](1536847127_image30.png)\n\n**验证码**：\n\n![](1536847127_image31.png)\n\n## in\\_array\n\n```php\nbool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )\n```\n\n第一个参数 mixed \\$needle ：要查找的元素\n\n第二个参数：在那一个数组中查找\n\n返回bool\n\n判断数组中是否存在指定的元素！如果有返回true，如果没有返回false\n\n![](1536847127_image32.png)\n\n## array\\_keys\n\n将这个数组中的键名获取到 返回一个新的索引数组\n\n```php\narray array_keys ( array $array [, mixed $search_value [, bool $strict = false ]] )\n```\n\n![](1536847127_image33.png)\n\n## array\\_values\n\n```php\narray array_values ( array $input )\n```\n\n返回原数组中所有的值并给其建立索引数组。\n\n![](1536847127_image34.png)\n\n## array\\_key\\_exists\n\n判断数组中是否存在指定的键名 如果有就返回true 如果没有就返回false\n\n```php\nbool array_key_exists ( mixed $key , array $search )\n```\n\nmixed \\$key：查找的键名\n\narray \\$search：要在哪个数组中进行查找\n\n![](1536847127_image35.png)\n\n## implode\n\n它有一个别名函数：join()\n\n将一个数组的中元素连接为一个字符串\n\n```php\nstring implode ( string $glue , array $pieces )\n```\n\nstring \\$glue：这个参数表示是指定的连接符号\n\narray \\$pieces：将指定的数组进行连接\n\n## explode\n\n将一个字符串分割为一个数组\n\n```php\narray explode ( string $delimiter , string $string [, int $limit ] )\n```\n\n参数说明：\n\nstring \\$delimiter：指定的分隔符\n\nstring \\$string：指定的字符串\n\n![](1536847127_image36.png)\n\n## max\n\n```php\nmixed max ( array $values )\n```\n\n返回当前数组中的最大值\n\n## min\n\n```php\nmixed min ( array $values )\n```\n\n返回当前数组中的最小值\n\n![](1536847127_image37.png)\n\n\n\n\n\n# 七、数组的排序函数\n\n## sort\n\n对数组元素进行升序 重新生成了一个新的数组！这个数组的键名与值是重新进行排列！\n\n![](1536847127_image39.png)\n\n## asort\n\n也是对数组元素进行升序排序 但是保留了原数组的下标与值之间的关系！\n\n![](1536847127_image40.png)\n\n## rsort\n\n对数组进行降序排序\n\n重新生成了一个新的数组！这个数组的键名与值是重新进行排列！\n\n![](1536847127_image41.png)\n\n## arsort\n\n也是对数组元素进行降序排序 但是保留了原数组的下标与值之间的关系！\n\n![](1536847127_image42.png)\n\n\n\n","categories":["基础知识"]},{"title":"PHP函数","url":"%2Fposts%2F2375644162%2F","content":"\n\n# 函数\n\n## 什么是函数？\n\n为了使用其个功能的代码段！\n\n## 函数的主要目的\n\n-   代码重用\n\n-   模块化编程\n\n## 函数的定义\n\n```PHP\nfunction 函数名([形参列表]){\n\n函数体;\n\nreturn;\n\n}\n```\n\n结构说明：\n\n**function** 是定义函数的关键字\n\n函数名的命名规则、不区分大小写， 它的命名规则与变量一样。\n\n## 函数的调用\n\n`函数名();`\n\n![](1536798148_image23.png)\n\n\n\n## 函数的参数 \n\n### 形式参数 Parameter\n\n在定义函数的时候写的参数 我们称之为形式参数 简称\"形参\"。\n\n\n\n### 实际参数 argument\n\n在调用函数的时候传递的参数 我们称之为实际参数 简称\"实参\"。\n\n![](1536798148_image24.png)\n\n\n\n\n\n### 函数参数的传递方式\n\n#### 按值传递\n\n![](1536798148_image25.png)\n\n#### 引用传递\n\n记得在形参的前面加一个&求地址运算符\n\n![](1536798148_image26.png)\n\n![](1536798148_image27.png)\n\n问：如果使用引用传递的时候 ，是否能够将实参使用具体的值而不是使用变量来传递\n\n答：不行，只能变量才可以使用引用传递。\n\n![](1536798148_image28.png)\n\n![](1536798148_image29.png)\n\n\n\n## 可变函数\n\n一个函数的名恰好是一个变量的值\n\n语法：\n\n`变量名(); //就可以调用函数`\n\n![](1536798148_image30.png)\n\n进制转换的作业 就可以使用到可变函数来实现\n\n![](1536798148_image31.png)\n\n\n\n## 函数形参的类型限定\n\n在PHP7.0以后,支持了标量类型数据限定。\n\n-   标量有四种：字符串（string）、布尔值（bool）、整型（int）和浮点型（float）\n\n语法：\n\n```php\nfunction function_name(类型限定 $val){\n\n}\n```\n\n![](1536798148_image32.png)\n\n上图所示的代码：需要的是整型数据， 但是传递不是整型数据 ，函数的内部进行了类型的自动转换功能。\n\n\n\n## 函数形参数类型严格模式\n\n开启类型严格模式语句：`declare(strict_types=1);`\n\n![](1536798148_image33.png)\n\n\n\n## 函数形参的默认值 \n\n**参数为什么需要有默认值？**\n\n假设一个函数它是用来实现的功能比较固定！\n\n![](1536798148_image34.png)\n\n![](1536798148_image35.png)\n\n\n\n## 函数的参数的个数不定 \n\n**指的形参与实参个数之间的关系！**\n\n**实参：**在函数在运行中所传递的数据！\n\n**形参：**函数在运行中所依赖的数据！\n\n### 形参个数大于实参个数\n\n会报错 \"Fatal error\"\n\n### 形参个数等于实参个数\n\n没有错\n\n### 形参个数小于实参个数\n\n没有错\n\n\n\nfunc\\_get\\_args() ：获取函数实参的个数 返回是一个数组\n\n![](1536798148_image36.png)\n\ncount(\\$arr) 用于获取数组的长度\n\n\n\n## 函数的返回值\n\n**return 关键字 **\n\n1、当函数体里面遇到return关键字会将当前的函数停止运行\n\n![](1536798148_image37.png)\n\n2、向函数的调用者返回数据！\n\n![](1536798148_image38.png)\n\n问题：如果调用一个没有返回值的函数 会得到?\n\n![](1536798148_image39.png)\n\n\n\n## 函数返回值的类型\n\n类型严格模式对于返回值的类型限定同样起作用，使用类型严格模式的时候要注意，必须保证声明语句在最开始位置，否则报错！\n\n格式：\n\n```php\nfunction 函数名():返回值的类型{\n\nreturn 指定的类型\n\n}\n```\n\n![](1536798148_image40.png)\n\n\n\n----\n\n# 二十五、匿名函数\n\n一个函数没有名称 ，需要将这个函数赋值给一个变量！\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image1.png)\n\n\n\n# 三十、字符串函数\n\n## Strlen\n\n```php\nint strlen ( string $string )\n```\n\n返回的是指定字符串的字节的长度！\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image17.png)\n\n## Substr\n\n```php\nstring substr ( string $string , int $start [, int $length ] )\n```\n\n作用：截取字符串\n\nstring \\$string：字符串变量\n\nint \\$start：开始下标\n\nint \\$length：可缺省的参数 表示截取的长度 如果不写表示截取到字符串的末尾 如果有些 表示截取到指定的长度\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image18.png)\n\n## Strtolower\n\n```php\nstring strtolower ( string $string )\n```\n\n将大写字母转换为小写\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image19.png)\n\n## Strtoupper\n\n```php\nstring strtoupper ( string $string )\n```\n\n将小写字母转换为大写\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image20.png)\n\n## mb\\_strlen\n\n```php\nmixed mb_strlen ( string $str [, string $encoding = mb_internal_encoding() ] )\n```\n\n作用：获取字符的个数！\n\n如果要使用这个函数需要 在PHP.INI中开启下面的扩展 **php\\_mbstring** 这个扩展\n\n开启扩展\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image21.png)\n\n告诉PHP去哪个目录下面找扩展文件\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image22.png)\n\n重启Apache` httpd.exe -k restart`\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image23.png)\n\n## Ucfirst\n\n```php\nstring ucfirst ( string $str )\n```\n\n将字符串的首字母转换为大写\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image24.png)\n\n## Strpos\n\n```php\nmixed strpos ( string $haystack , mixed $needle [, int $offset = 0 ] )\n```\n\n查找子字符在原字符串首次出来的位置， 如果找的到就返回其下标，如果找不到返回false\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image25.png)\n\n## strrpos\n\n```php\nmixed strrpos ( string $haystack , string $needle [, int $offset = 0 ] )\n```\n\n查找子字符在原字符串最后次出来的位置， 如果找的到就返回其下标，如果找不到返回false\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image26.png)\n\n## strrev\n\n```php\nstring strrev ( string $string )\n```\n\n将字符串进行翻转\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image27.png)\n\n## trim\n\n```php\nstring trim ( string $str [, string $character_mask = \" \\t\\n\\r\\0\\x0B\" ] )\n```\n\n用于去除字符串的首尾的空白字符\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image28.png)\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image29.png)\n\n## explode\n\n```php\narray explode ( string $delimiter , string $string [, int $limit ] )\n```\n\n使用指定的分隔符将一个字符串分隔为数组\n\n参数说明：\n\nstring \\$delimiter：分隔符\n\nstring \\$string：要分割字符串\n\n\n\n**implode** \n\n```php\nstring implode ( string $glue , array $pieces )\n```\n\n参数说明：\n\nstring \\$glue：拼接符号\n\narray \\$pieces：要拼接的数组\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image30.png)\n\n\n\n# 三十一、时间日期函数\n\n## date\\_default\\_timezone\\_set\n\n设置时区三种方法\n\n* date\\_default\\_timezone\\_set() 函数\n* 修改 php.ini 配置文件\n* 使用ini\\_set() 这个函数\n\n第一种方法： date\\_default\\_timezone\\_set()\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image31.png)\n\n第二种方法：修改php.ini配置文件\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image32.png)\n\n第三种方法：使用ini\\_set()函数， 修改php的配置文件配置\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image33.png)\n\n\n\n## date\\_default\\_timezone\\_get\n\n获取到设置的时区\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image34.png)\n\n\n\n## time\n\n获取一个UNIX时间戳 是1970年1月1日0时0分0秒时间的秒数\n\n`int time ( void )`\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image35.png)\n\n\n\n## date\n\n```php\nstring date ( string $format [, int $timestamp ] )\n```\n\n将一个时间戳格式化为一个本地的时间\n\n第二个参数如果不写表示当前的时间戳\n\n------\n\n  **格式**   **说明**\n  Y          4 位数字完整表示的年份\n  m          数字表示的月份，有前导零 取值01\\~12\n  d          月份中的第几天，有前导零的 返回值：01\\~31\n  H          小时，24 小时格式，有前导零 返回值：01\\~23\n  i          有前导零的分钟数 00\\~59\n  s          秒数，有前导零 00\\~59\n  w          星期中的第几天，数字表示 *0*（表示星期天）到 *6*（表示星期六）\n  N          星期中的第几天 数字表示 *1*（表示星期一）到 *7*（表示星期天）\n  a          小写的上午和下午值 *am* 或 *pm*\n  A          大写的上午和下午值 *AM* 或 *PM*\n\n------\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image36.png)\n\n\n\n## strtotime\n\n将任何英文文本的日期时间描述解析为 Unix 时间戳\n\n```php\nint strtotime ( string $time [, int $now = time() ] )\n```\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image37.png)\n\n\n\n## microtime\n\n返回当前 Unix 时间戳和微秒数\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image38.png)\n\n这个函数有一个缺省的参数 ，这个参数是一个布尔型\n\n如果将这个值设置为**true**返回是一个浮点数！时间戳和微秒数合起来的数\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image39.png)\n\n如果没有指定参数 那么返回是两部分：时间戳和微秒。 这是一个字符串 ，将这个字符串以空格分割为数组\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image40.png)\n\n# 三十二、数学函数\n\n## abs\n\n返回一个数的绝对值\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image41.png)\n\n## sqrt\n\n返回一个数的平方根\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image42.png)\n\n## pow\n\npow(x,y) 返回一个x的y次幂\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image43.png)\n\n## ceil\n\n向上取整 得到一个比当前数要大的最小的整数\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image44.png)\n\n## floor\n\n向下取整 得到一个比当前数要大的最大的整数\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image45.png)\n\n## round\n\n对一个数进行四舍五入\n\n第一个参数：表示一个数\n\n第二个参数：可选的 如果没有写表示 不保留小数位 如果有写就表示保留几位小数\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image46.png)\n\n## rand和mt\\_rand\n\n返回一个闭合区间的随机整数\n\nrand和mt\\_rand它们有两个参数\n\n第一个参数：表示最小的整数\n\n第二个参数：表示最大的整数\n\n这两个函数之间的区别在于：mt\\_rand的速度比rand的速度快4倍！\n\n![](1536809939_image47.png)\n\n\n\n----\n\n# 二十七、变量的作用域\n\n**变量的作用域：**表示变量在什么区域里面有效！\n\n**变量的作用域分为两种：**==全局作用域==、==局部作用域==\n\n凡是变量的作用域都是跟**函数**有关系！\n\n在函数外面定义的变量称之**全局变量** 它的作用域是全局的\n\n在函数里面定义的变量称之**局部变量** 它的作用域是局部的，也就是在当前的函数内起作用！\n\n**注意：**\n\nPHP中的变量的作用域是不叠加的！全局不能访问局部的，局部的也不能访问全局的！全局变量只能在全局访问内访问，局部量只能在函数内访问！，在函数内是不能访问函数外定义的变量的！\n\n**在函数里面是无法访问函数外面定义的变量**\n\n**在函数外面无法访问函数里面定义的变量**\n\n**问：**在函数里面访问函数外面定义的变量！\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image5.png)\n\n使用`$_GET`这个超全局变量 可以使用在函数内部访问函数外面定义的变量，但是`$_GET`它本身是用来获取get方式提交的数据！\n\n在PHP中还有一种变量 称之**超全局变量** ，但是超全局变量不能人为的进行定义！只能使用PHP系统内置的！这里的超全局变量的作用域可以理解为与JS中的全局作用域一样！\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image6.png)\n\n虽然说`$_GET`可以使用实现在函数里面也能够被访问， 但是它不是专业做这个的！\n\n**注意：**\n\n**只有超全局变量才可以在函数外面和函数里面能够访问！**\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image7.png)\n\n [\\$GLOBALS](mk:@MSITStore:F:\\手册\\php_manual_zh.chm::/res/reserved.variables.globals.html)\n\n`$GLOBALS`它就是专门实现将一个数据进行超全局化！超全局化以后在全局作用域与局部作用域都可以使用。\n\n**注意：**\n\n1)  \\$GLOBALS这个超全局数组变量中的数组元素它是与全局变量一一对应！只要我们创建了一个全局变量 就是相当于往这个超全局数组变量中添加一个对应的数组元素！变量名就是数组元素的下标 ，变量的值就是这个数组元素的值！\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image8.png)\n\n2)  反过来说， 只是我们往\\$GLOBALS这个超全局数组中添加一个数组元素， 就相当于会创建一个同名的全局变量！\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image9.png)\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536809939_image10.png)\n\n**注意：**\n\n全局变量与`$GLOBALS`这个超全局数组的对应的数组元素它们之间的关系是同生同死！\n\n# 二十八、变量的生命周期\n\n**变量生命周期：**指的当前这个变量什么时候诞生、什么时候消失！\n\n\n\n变量什么时候诞生？\n\n一个变量被定义的时候\n\n变量什么时候消失：\n\n1. 当变量被unset掉以后\n2. 当当前的脚本程序运行结束！\n\n\n\n我们这里讨论是**局部变量的生命周期！**\n\n\n\n什么是局部变量？\n\n是指在函数里面定义的变量\n\n\n\n**问：**如何让局部变量的生命活的久一点！\n\n使用静态变量可以让其活的久一点， 只要当前的PHP程序在运行 ，当前的静态局部变量那么就一直活着！\n\n**如何定义一个静态变量：**\n\n在PHP中有一个**static**关键字 ，可以用来定义一个静态的局部变量！\n\n**用法：**\n\n将**static**放置在局部变量的前面， 那么这个局部变量就会被定义为静态局部变量！\n\n无限级分类 \\-\\-\\--static关键字\n\n![](1536809939_image11.png)","categories":["基础知识"]},{"title":"php","url":"%2Fposts%2F1452351953%2F","content":"\n\n# PHP\n\n\n\n## 计算机网络知识\n\n### IP地址\n\nIP地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。   \n\nIP是英文[Internet Protocol](http://baike.baidu.com/view/696501.htm)的缩写，意思是“[网络之间互连的协议](http://baike.baidu.com/view/565688.htm)”，也就是为[计算机网络](http://baike.baidu.com/view/25482.htm)相互连接进行通信而设计的协议。在[因特网](http://baike.baidu.com/view/1706.htm)中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的[计算机系统](http://baike.baidu.com/view/1130583.htm)，只要遵守IP协议就可以与[因特网](http://baike.baidu.com/view/1706.htm)互连互通。正是因为有了IP协议，[因特网](http://baike.baidu.com/view/1706.htm)才得以迅速发展成为世界上最大的、开放的计算机[通信网络](http://baike.baidu.com/view/71985.htm)。因此，IP协议也可以叫做“[因特网](http://baike.baidu.com/view/1706.htm)协议”。   \n\nIP地址是一个32位的二进制数，通常被分割为4个“8位[二进制](http://baike.baidu.com/view/18536.htm)数”（也就是4个字节）。IP地址通常用“[点分十进制](http://baike.baidu.com/view/828066.htm)” ，例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）。\n\n \n\n### 域名\n\n为什么会出现域名：为了方便记忆！    \n\n`` www.baidu.com  ``   \n从右往左层级越来越高！             \n\n**.com**  商业    \n**.cn**   中国   \n**.hk**   香港   \n**.us**   美国   \n**.gov**  政府   \n**.edu**  教育   \n**.net**  网络    \n\n \n\nIP地址是Internet主机的作为路由寻址用的数字型标识，人不容易记忆。因而产生了域名（domain name）这一种字符型标识。\n\n域名的构成：以一个常见的域名为例说明，baidu网址是由二部分组成，标号“baidu”是这个域名的主域名主体，而最后的标号“com”则是该域名的后缀，代表的这是一个com国际域名，是[顶级域名](http://baike.baidu.com/view/119298.htm)。而前面的www.是网络名。www有特殊的含义：world wide web也就是万维网的意思\n\n \n\n### DNS\n\n域名解析系统  用来将域名解析为对应的IP地址  DNS服务器它会安装在三大运营商的机房里面！     \n\nDNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS使用端口号53。   \n\n\n\n### 端口号\n\n在网络技术中，端口（Port）包括逻辑端口和物理端口两种类型。物理端口指的是物理存在的端口，如ADSL Modem、集线器、交换机、路由器上用 于连接其他网络设备的接口，如RJ-45端口、SC端口等等。逻辑端口是指逻辑意义上用于区分服务的端口，如TCP/IP协议中的服务端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等。由于物理端口和逻辑端口数量较多，为了对端口进行区分，将每个端口进行了编号，这就是端口号。   \n\n端口有什么用呢？我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区 分不同的服务的。   \n\n邮件地址：中粮商务公园+门牌号   \n网页：IP地址+端口号   \n\nhttp协议它是走80端口！   \nwin+R  ---->  cmd--->netstat –an   查看端口号\n\n----\n\n\n\n## PHP简介\n\n### PHP是什么\n\nPHP原始：**personal home page**  个人主页     \n\nPHP于1994年由Rasmus Lerdorf创建，刚刚开始是Rasmus Lerdorf为了要维护个人网页而制作的一个简单的用Perl语言编写的程序。这些工具程序用来显示 Rasmus Lerdorf 的个人履历，以及统计网页流量。后来又用C语言重新编写，包括可以访问数据库。他将这些程序和一些表单直译器整合起来，称为 PHP/FI。PHP/FI 可以和数据库连接，产生简单的动态网页程序   \n\nHypertext Preprocessor，中文名：“超文本预处理器”是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页。用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快。   \n\n**注意：**   \n\n​       PHP代码它是可以嵌入在HTML网页里面！\n\n \n\n----\n\n\n\n### PHP的特点\n\nPHP主要用来做web服务器端开发，用于实现用户的各种web请求；也能做软件开发（不常用）   \n\nPHP是开源自由软件，能够在所有的操作系统平台上稳定的运行   \n\nPHP入门比较简单，容易上手，语法类似于C语言，能够实现面向过程和面向对象并用   \n\nPHP支持多种主流的数据库，比如：mssql、mysql、Oracle、sybase等，只不过和Mysql是“黄金搭档”----**LAMP**  ( Linux   Apache  Mysql   PHP)     \n\n---\n\n\n\n### B/S结构\n\n**Browser/Server**  浏览器与服务器结构，这种结构是web界应用用的最多的！    \nB/S它只需要用户安装浏览器就可以使用！  一对多的关系    \n\n**C/S**   客户端/服务器   一对一关系     \n\n**服务器：**   就是安装了相关服务软件的电脑。   \n\n\n   \n\n为什么在浏览器上输入对应的域名就可以访问对应的网站？    \n电脑与电脑之间的相互访问必须是要使用IP地址来进行访问。    \n\n\n第一步：用户在浏览器中输入对应的域名后，本机电脑会去系统盘中一个叫hosts文件(``C:\\Windows\\System32\\drivers\\etc\\hosts``)中去查找这个域名与IP地址的对应关系，如果有就会将这个IP地址给到浏览器    \n\n\n第二步：如果没有，系统就会去互联网上面去查找这个域名对应的IP地址，DNS服务器 如果找的到就将对应的IP地址给到浏览器，如果找不到就直接显示该网页无法显示。\n\n![](php_01.jpg) \n\n\n\n**一个重要观念：**     \nweb软件的运行模式中，总是先在客户端（浏览器端），发起一个“请求”，然后，服务器端才产生反馈动作（就是“运行”程序），并因此而返回给该浏览器一定的信息——就是所谓的应答（响应）；\n\n----\n\n\n\n## 安装和配置PHP\n\n\n\n### 安装PHP\n\n**首先，要搞清楚PHP与Apache之间的关系！**     \n\nApache负责接收浏览器的请求，此时，如果浏览器请求的是静态资源（以html结尾），Apache就直接作出响应，但是如果浏览器请求的是PHP资源（以php结尾），那么apache就应该将请求交由PHP模块来处理！   \n\n\n所以，二者的关系是Apache调用PHP！   \n典型的，Apache与PHP之间的关系，是将PHP配置成Apache的一个功能模块！   \n\n \n\n**什么叫Apache的功能模块？**   \n\nApache本身并不是很强大，但是它可以加载很多模块来扩展功能，也可以说，Apache就是一个由很多个模块组成的软件，Apache的某一个模块，就专门负责Apache的某一项功能！   \n\n\n可以通过查看Apache的配置文件：``apache/conf/httpd.conf``   \n众多的模块都是利用配置指令LoadModule加载到Apache的内部的，每个模块，其实是一个编译好了的库文件！   \n\n我们也可以通过Apache的命令行``httpd.exe  –M``来查看当前apache已经加载了哪些模块。  \n\n \n\n### 配置PHP\n\n#### 第一步：将PHP配置成Apache的一个功能模块\n\nApache它是由很多很多的模块组成的！   \nApache需要使用``LoadModule``这个指令将PHP模块加载过来     \n\n\n\n\n**加载指令：**    \n``LoadModule   模块名（不能随意改）    模块的动态链接库所在的位置（路径）``      \n\n \n\n其中：PHP的模块的名字是**php7_module**(php程序代码已经规定好了不能更改！)\n\n![](php_02.jpg)\n\n\n\n可以使用cmd窗口中的``httpd.exe  –M ``查找Apache中加载的模块      \n\n但是，此时，还无法解析PHP文件！     \n因为，此时Apache只是加载了PHP模块，还没有给PHP“分配任务”！     \n因为Apache并不是将所有的请求都交给PHP来处理，而且根据请求资源的文件类型来决定！     \n\n \n\n#### 第二步：在apache中将PHP文件交给php模块处理\n\n将以**.php**为扩展名的文件交给PHP引擎进行处理     \n\n``` ini\n;指令：\nAddType  application/x-httpd-php.php\n;或者，告诉Apache去php安装目录找php的配置文件\n<FilesMatch  '\\.php$'>\n   setHandler  application/x-httpd-php\n</FilesMatch>\n```\n\n\n\n#### 第三步：确定并加载PHP的配置文件\n\nPHP所使用的配置文件名php.ini是可以出现在任何的目录中的，而当前应该使用哪一个呢？此时应该先告知**apache**去哪里去找 **php.ini**     \n\n为了便于管理，将PHP的配置文件放到PHP的安装目录下：     \n在 Apache 配置中，配置如下：\n```ini\nPHPIniDir  'php.ini 配置文件所在的的目录'\n```\n\n ![](php_03.jpg) \n\n![](php_04.png)\n\n\n\n**注意：**       \n不管是修改了Apache的配置文件还是PHP的配置文件，都需要重启Apache。     \n\n \n\n","categories":["基础知识"]},{"title":"PHP运算符","url":"%2Fposts%2F2259325832%2F","content":"\n\n# 运算符\n\n----\n\n**什么叫运算符？**  \n可以进行运算的符号 \n\n\n\n**运算符的优先级！**  \n* 有括号先算括号里面的，然后再乘除再加减！\n* 需要提升某一个运算符的优先级是，加括号。\n\n\n\n\n**结合性**  \n什么是结合性，当一个表达式中运算符的优先级相同时 就要考虑结合性。结合性分为左结合和右结合！左结合 运算的规则就从左往右进行运算  右结合 从右往左进行运算！\n\n \n\n**关于运算符的分类**   \n* **一元运算符：**当前的运算符它操作数只能一个  \n* **二元运算符：**当前的运算符它操作的数有两个  \n* **三元运算符：**当前的运算符它操作的数有三个\n\n![](php_operational_character_01.png)\n\n----\n\n\n\n## 算术运算符\n\n| **运算符** | **名称** | **例子**        | **结果**        |\n| ---------- | -------- | --------------- | --------------- |\n| +          | 加法     | $x + $y         | $x 与 $y 求和   |\n| -          | 减法     | $x - $y         | $x 与 $y 的差数 |\n| *          | 乘法     | $x * $y         | $x 与 $y 的乘积 |\n| /          | 除法     | $x / $y         | $x 与 $y 的商数 |\n| %          | 模数     | $x % $y         | $x 除 $y 的余数 |\n| ++         | 加加     | $x++ 或者 ++$x  |                 |\n| --         | 减减     | $x--  或者 --$x |                 |\n\n``++``  运算符  \n它不管前置加加还是后置加加反正它最终都是自加1 \n它分为前置++和后置++   \n\n* **前置++**：先加1，再赋值    ++在前变量在后 \n* **后置++**：先赋值后再自加1\n\n\n\n``--``  运算符   \n它不管前置减减还是后置减减反正它最终都是自减1  \n它分为前置--和后置--   \n\n* **前置--**：先自减1，再赋值 \n* **后置--**：先赋值后再自减1\n\n----\n\n\n\n## 赋值运算符\n\n| **赋值** | **等同于**   | **描述**                       |\n| -------- | ------------ | ------------------------------ |\n| $x = $y  | $x = $y      | 右侧表达式为左侧运算数设置值。 |\n| $x += $y | $x = $x + $y | 相加                           |\n| $x -= $y | $x = $x - $y | 相减                           |\n| $x *= $y | $x = $x * $y | 相乘                           |\n| $x /= $y | $x = $x / $y | 相除                           |\n| $x %= $y | $x = $x % $y | 相取余（模）                   |\n\n----\n\n\n\n## 字符串连接运算符\n\n| 运算符 | 名称     | 例子                                       | 结果 |\n| ------ | -------- | ------------------------------------------ | ---- |\n| .      | 串接     | $txt1 = \"Hello\"  $txt2 = $txt1 . \" world!\" | 现在 $txt2 包含 \"Hello world!\" |\n| .=     | 串接赋值 | $txt1 = \"Hello\"  $txt1 .= \" world!\"        | 现在 $txt1 包含 \"Hello world!\" |\n\n----\n\n\n\n## 比较运算符\n\n**注意：比较运算符它返回布尔类型的数据  true** **和false** \n\n\n| 运算符 | 名称               | 例子      | 结果                                               |\n| ------ | ------------------ | --------- | -------------------------------------------------- |\n| ==     | 等于               | $x == $y  | 如果 $x 等于 $y，则返回 true。                     |\n| ===    | 全等（完全相同）   | $x === $y | 如果 $x 等于 $y，且它们类型相同，则返回 true。     |\n| !=     | 不等于             | $x != $y  | 如果 $x 不等于 $y，则返回 true。                   |\n| <>     | 不等于             | $x <> $y  | 如果 $x 不等于 $y，则返回 true。                   |\n| !==    | 不全等（完全不同） | $x !== $y | 如果 $x 不等于 $y，或它们类型不相同，则返回 true。 |\n| >      | 大于               | $x > $y   | 如果 $x 大于 $y，则返回 true。                     |\n| <      | 大于               | $x < $y   | 如果 $x 小于 $y，则返回 true。                     |\n| >=     | 大于或等于         | $x >= $y  | 如果 $x 大于或者等于 $y，则返回 true.              |\n| <=     | 小于或等于         | $x <= $y  | 如果 $x 小于或者等于 $y，则返回 true。             |\n\n\n\n----\n\n\n\n## 三目运算符\n\n**语法：** \n\n```php\n条件语句 ? 代码1 :代码2;\n```\n\n**说明：**\n问号前面的位置是判断的条件，判断结果为boolean型，为true时执行代码1，为false时执行代码2。 \n如果为真执行第一个，否则执行第二个。”\n\n----\n\n\n\n## 合并运算符\n\n运算符号：``??``\n\n合并运算符就是三目运算符和isset语句的简写。\n\n```php\n<?php\n//如果 ?? 前面的变量未定义，则使用后面的，否则使用??前面的    \n$v1=20;\necho $v1 ?? 10;  //20\n```\n\n----\n\n\n\n## 逻辑运算符\n\n| 运算符     | 名称 | 例子                   | 结果                                                 |\n| ---------- | ---- | ---------------------- |------------------------- |\n| and 或 &&  | 与   | $x and $y或 $x && $y   | 如果 $x 和 $y 都为 true，则返回 true                 |\n| or 或 \\|\\| | 或   | $x or $y 或 $x \\|\\| $y | 如果 $x 和 $y 只要有一个为 true，则返回 true         |\n| xor        | 异或 | $x xor $y              | 如果 $x 和 $y 有且仅有一个为 true，则返回 true       |\n| !          | 非   | !$x                    | 如果 $x 为 true，则返回 false，$x为false，则返回true |\n\n**短路运算**  \n我们一般使用逻辑与来实现短路运算！\n\n```php\ntrue && $v1++;\necho $v1; //11\n```\n\n\n\n----\n\n\n\n## 位运算  bit \n\n| 运算符         | 名称 | 描述 |\n| ------------------ | -------- | -------------------- |\n| $a  & $b | 按位与   | 把 *$a* 和 *$b* 中都为 1 的位设为 1，其余位置设为0          |\n| $a \\| $b | 按位或   | 把 *$a* 和 *$b* 中都为 0 的位设为0，其余位置设为1           |\n| $a  ^  $b | 按位异或 | 把 *$a* 和 *$b* 中一个为 1 另一个为 0 的位设为 1，其余设为0 |\n| ~  $a      | 按位取反 | *$a* 中为 0 的位设为 1，为1的位设为0                        |\n| $a  <<  $b | 左移     | *$a* 中的位向左移动 *$b* 次                                 |\n| $a  >>  $b | 右移     | *$a* 中的位向右移动 *$b* 次                                 |\n\n使用二进制来参与运算！将一个数转换比特位然后再来参与运算！  \n\n**位运算一般是针对于整型数据来进行操作！**\n\n\n\n| 符号 | 说明                                           |\n| ---- | ---------------------------------------------- |\n| ~    | 按位取反  如果是0的话就变成1  如果1的话就变成0 |\n\n![](php_operational_character_02.png)\n\n\n\n**原码、反码、补码**    \n将一个整型数据转换二进制， 在我们计算机叫(补码计算机)  \n在计算机中二进制其实是以补码的形式存在的！  \n但是在展示给用户看的时候是原码。 \n\n\n\n**正数的原码、反码、补码都一样**  \n将一个数转换为二进制以后：最高位用于表示符号位  \n\n* 0表示正数 \n* 1表示负数 \n\n\n\n### 原码\n\n![](php_operational_character_03.png)\n\n \n\n![](php_operational_character_04.png)\n\n### 反码\n\n**正数的原码反码补码都一样**\n\n![](php_operational_character_05.png)\n\n \n\n \n\n负数的反码， 除了最高位不变 ， 其它的位 取反！将0变成1  将1变成0\n\n \n\n![](php_operational_character_06.png)\n\n \n\n \n\n### 补码\n\n正数的原码反码补码都一样  \\\\\\\n\n负数的补码是其反码的基础上进行加1 \n\n \n\n![](php_operational_character_07.png)\n\n \n\n### 按位与  &  \n\n它的运算规则与逻辑与是一样  只不过它是拿每一个位进行与操作 同时为1才为1 其它的情况都为0 \n\n \n\n![](php_operational_character_12.png)\n\n \n\n \n\n### 按位或   |\n\n \n\n它的运算规则与逻辑或是一样  只不过它是拿每一个位进行或操作 只要有一个位为1 就为1 \n\n \n\n![](php_operational_character_11.png)\n\n \n\n \n\n### 按位异或   ^\n\n \n\n它的运算规则与逻辑异或是一样  只不过它是拿每一个位进行异或操作 只有一个为0一个为1的情况才为1 \n\n![](php_operational_character_10.png)\n\n \n\n### 按位右移 >>\n\n![](php_operational_character_09.png)\n\n \n\n### 按拉左移 << \n\n![](php_operational_character_08.png)\n\n \n\n\n\n----\n\n\n\n## 飞船运算符\n\nphp7之后新增的运算符，也是用于比较运算。  \n运算符号：``<=>``    它是用于比较两个表达式。当第一个表达式比第二个表达式，分别小于，等于或大于时它返回-1，0或1。\n\n----\n\n\n\n## 错误抑制符\n\n**@**  用于抑制错误！ 只能抑制错误级别低：notice   warning \n\n主要是用于数据库连接的时候    \n\n\n使用一个没有定义的变量，也可以使用错误抑制符。\n\n\n\n\n\n","categories":["基础知识"]},{"title":"PHP其它","url":"%2Fposts%2F2709295124%2F","content":"\n\n# 一、终止脚本执行\n\n`die`或者`exit `常用来调试代码 ，用于将当前的脚本终止执行！\n\n这两个它们互为别名！\n\n![](1536809939_image2.png)\n\n`sleep()`：让其代码睡觉 ，参数是秒数！\n\n当前网页执行的最大时间为30秒！这里是通过PHP中的配置文件设置！ `max_execution_time=30`\n\n![](1536809939_image3.png)\n\n如果说有一个脚本它执行的时候需要超过30s ，就不能通过网页的方式来访问这个脚本程序 ，需要通过黑窗口来访问！\n\n![](1536809939_image4.png)\n\n\n\n\n# 二、递归\n\n**递归只是算法一种表现形式而已！**\n\n**什么是递归：**在一个函数里面 再调用当前的这个函数\n\n![](1536809939_image12.png)\n\n![](1536809939_image13.png)\n\n![](1536809939_image14.png)\n\n**为什么要有递归调用呢？**\n\n因为我们在生活中，经常如遇到如下的问题：当我们遇到一个大问题的问题 会把这个大问题拆分很多小问题来解决，但是会发生解决大问题的方法同样适用于小问题！\n\n使用递归的思路在来解决一个问题：\n\n[斐波那契数列](https://www.baidu.com/link?url=VRFOYhAvfNI6UqTBDF1MERCsDcfppwufPPfLtppPNU5I7fhmt036TDUTCnfnkpD1Yim2boM4UzBZc5ZJklXxNPNqo-5YirY-sAkBOdf1WUmu6LCcAuWdqbYM9I0Xj1j43N0B7Z9Wx3aPix1AlFa_ca&wd=&eqid=e787dd7d00012d79000000035866074b)**：前两项已知 后一项的数为前两项之和**\n\n-------- -------- -------- -------- -------- ------- ------- ------- ------- --------\n  第一项   第二项   第三项   第四项   第五项   第6项   第7项   第8项   第9项   第10项\n  1        1        2        3        5        8       13      21      34      55\n-------- -------- -------- -------- -------- ------- ------- ------- ------- --------\n\n==在实现递归的时候一定要明确两点：==\n\n1、**递归点** 什么时候开始递归\n\n2、**递归出口** 什么时候不需要递归\n\n**递归点 当n=3的时候开始递归 **\n\n[斐波那契数列](https://www.baidu.com/link?url=VRFOYhAvfNI6UqTBDF1MERCsDcfppwufPPfLtppPNU5I7fhmt036TDUTCnfnkpD1Yim2boM4UzBZc5ZJklXxNPNqo-5YirY-sAkBOdf1WUmu6LCcAuWdqbYM9I0Xj1j43N0B7Z9Wx3aPix1AlFa_ca&wd=&eqid=e787dd7d00012d79000000035866074b)\n\n**递归出口 当n=1或者n=2的时候不需要递归**\n\n![](1536809939_image15.png)\n\n![](1536809939_image16.png)\n\n\n\n----\n\n\n\n# 三、模拟数据结构\n\n**入栈和队列**\n\n### 入栈的特点\n\n先进后出\n\n后进先出\n\n入栈：**array\\_push** --- 将一个或多个单元压入数组的末尾（入栈）\n\n出栈：**array\\_pop** 将数组最后一个单元弹出（出栈）\n\n\n\n### 队列\n\n先进先出\n\n后进后出\n\n入队：**array\\_push()**\n\n出队：**array\\_shift()** ：从数组的开头删除一个元素\n\n------\n\n  **函数名**         **功能**\n ` array_unshift()`   向数组开头添加一个或者是多个数组元素\n  `array_shift()  `   将数组的第一个元素删除并将其返回\n  `array_push()   `   向数组的末尾添加一个或者是多个数组元素\n  `array_pop()   `    将数组的最后一个元素删除并将其返回\n\n------\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536847127_image38.png)\n\n\n\n\n\n# 四、算法\n\n## 冒泡排序\n\n拿数组中相邻的元素进行比较 如果前一个数组元素的值要大于后一个元素的值那么就将两个元素的位置进行互换！\n\n\\$row = array(10,3,8,7,6,2);\n\n------\n\n  原数组   10   3   8   7   6   2\n  第一次   3    8   7   6   2   10\n  第二次   3    7   6   2   8   10\n  第三次   3    6   2   7   8   10\n  第四次   3    2   6   7   8   10\n  第五次   2    3   6   7   8   10\n\n------\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536847127_image43.png)\n\n## 选择排序\n\n假设当前第一个元素已经排序好，然后记住该元素的下标，拿着这个元素与后面的其他元素进行比较，如果比较之后发现后面的元素比当前元素还要小，记住当前的最小值为后面元素的下标。每一次遍历完数组都会发现一个最小元素的下标，最后进行一次交换。\n\n\\$row = array(10, 8,3 ,1,6,2);\n\n------\n\n  原数组   10   8   3   1    6    2\n  第一次   1    8   3   10   6    2\n  第二次   1    2   3   10   6    8\n  第三次   1    2   3   10   6    8\n  第四次   1    2   3   6    10   8\n  第五次   1    2   3   6    8    10\n\n------\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536847127_image44.png)\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536847127_image45.png) \n\n## 二分查找算法\n\n二分查找算法它要求当前的数组是已经排好序的。\n\n二分查找算法又称之为折半查找。\n\n```php\n<?php\n\n$arr = array(10, 22, 34, 55, 60, 68, 74, 100, 105, 170, 200);\n\n//折半查找 要求是有序\n\n/**\n\n*折半查找\n\n*\\@param1 array $data 被查找的数组\n\n*\\@param1 int $num 要查找的数\n\n*return mixed index|String\n\n*/\n\nfunction binarySearch($data,$num){\n\n$startIndex = 0; //开始下标\n\n$endIndex = count($data)-1; //结束下标\n\nwhile($startIndex <= $endIndex){\n\n$middleIndex = floor(($startIndex + $endIndex)/2);//中间下标\n\n//要查找的元素比中间的元素要大 向右找\n\nif($num > $data[$middleIndex]){\n\n$startIndex = $middleIndex+1;\n\n}\n\n//要查找的元素比中间的元素要小 向左找\n\nif($num < $data[$middleIndex]){\n\n$endIndex = $middleIndex-1;\n\n}\n\n//要查找的元素与中间的元素相等\n\nif($num == $data[$middleIndex]){\n\nreturn $middleIndex;\n\n}\n\n}\n\nreturn \"找不到\";\n\n}\n\necho binarySearch($arr,70);\n```\n\n----\n\n\n\n# 五、文件包含\n\n**文件包含的主要目的：用于解决代码的重复使用！**\n\n一个网站它的头部、页脚部分的结构代码是一样的！我们可以想一个办法将这两部分抽离出现！然后需要用到这两部分的 我们就将这两个部分载入进去！\n\n**include**、**include\\_once**、**require**、**require\\_once**\n\n这四个文件包含的功能就是一样 ：将一个文件里面的内容全部复制到当前文件中！这个文件包含它只在意文件里面的内容 而不去管这个文件到底是什么文件 ！\n\n\n\n当把目标文件加载到当前文件中的时候， 先将目标文件中的代码退到PHP模式\n\n\\#PHP模式 在PHP标签里面的代码 称之PHP模式\n\n\\#HTML模式 在PHP标签外面的代码 称之HTML模式\n\n在将一个文件包含到PHP中文件中的时候 它先会退出PHP模式\n\n\n\n## 文件的地址\n\n用于描述，一个文件在磁盘上的位置，文件载入，在磁盘上查找文件！\n\n`D:\\itcast\\php31\\04-PHP\\code\\demo10.php `文件的绝对路径\n\n[[www.php31.com/04-PHP/code/demo10.php]](http://www.php31.com/04-PHP/code/demo10.php) 服务器上文件的地址\n\n文件包含后所使用的是 磁盘上的文件位置！ 相对路径与绝对路径\n\n分成，==相对路径==与==绝对路径==\n\n\n\n### 相对路径\n\n相对于当前位置的某个文件的位置。\n\n当前目录的表示方式总共会有两种：\n\n`./`  当前文件所在的地址\n\n\n\n**==注意==**：当前位置的确定，不是由代码写在哪个文件中确定的，而是有当前代码在哪里执行确定！ 浏览器请求谁（哪个脚本），当前地址就是哪里！\n\n因为以后我们在做项目的时候 目录结构非常复杂 可能需要将其它的目标文件包含到某一个文件里面的执行 使用相对路径就会出面问题。\n\n**因此建议，使用包含文件 项目中（目录结构复杂），最好使用绝对路径！**\n\n\n\n### 绝对路径\n\n文件在磁盘上的真实位置！\n\n在windows上，决定路径就是带盘符的路径！\n\n缺点，比较长，典型的，将某部分，定义成常量！\n\n`include 绝对路径`\n\n通常我们会定义一些目录常量 ，通过字符串拼接的方式得到我们想要载入的文件的路径。\n\n`__DIR__ `这个魔术常量会使用的非常多。\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536798148_image19.png)\n\n* 文件包含后面的文件的路径一定是绝对路径，不要写在相对路径。\n\n\n\n## 各种文件包含的区别\n\n**include**、**include\\_once**、**require**、**require\\_once**\n\ninclude与require之间有的区别， 同时适用于include\\_once与require\\_once\n\ninclude ：包含\n\nrequire：必须\n\n**语法：**\n\n`include '载入文件的地址'`\n\n`require '载入文件的地址'`\n\n只是在于报错的上面的显示的区别\n\n当使用include载入文件的时候 如果目标文件不存在， 会报一个**警告**错误！ 但是不会影响到当前文件继续往下执行！\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536798148_image20.png)\n\n当使用require 载入文件的时候 如果目标文件不存在 会报一个**致命**错误！ 但是会影响到当前文件继续往下执行！\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536798148_image21.png)\n\n在工作中一般建议使用require\n\ninclude与include\\_once之间有的区别， 同时适用于require与require\\_once\n\ninclude\\_once 在载入之间会进行一次判断 ，判断当前的文件是否已经被载入了，如果已经被载入过了 就不会再载入！\n\ninclude 不会去判断当前文件是否已经载入\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/1536798148_image22.png)\n\n----\n\n\n\n# 六、进制转换\n\n------\n\n**什么是进制?**  \n\n* **一种可以进位的机制！**\n\n\n\n**生活中有哪些进制？**    \n\n十进制：   \n\n* 24：一天24小时\n* 60：60分钟一个小时\n* 12：12月为一年\n* 365：365天为一年\n* 7:7天为一周\n* 360:360°为一周\n* 16：古代的一市斤=16两\n\n\n\n在计算机中有**二进制、八进制、十进制、十六进制** \n\n* 二进制 ：0 1\n* 八进制：01234567\n* 十进制：0123456789\n* 十六进制：0123456789ABCDEF   \n* 位权：每一个位上面都有一个权重来表示 \n* 基数：二进制的基数就是2   八进制的8，依次类推 \n\n------\n\n\n\n## 其他进制转十进制\n\n每一位数*基数位权\n\n按权展开：\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/php_jinzhi_transform_03.png)\n\n------\n\n\n\n## 十进制转二进制\n\n\n\n**13.75**\n\n\n\n### 整数部分\n\n除二取余：\n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/php_jinzhi_transform_01.png)\n\n**填充法（填“1”法）**  \n\n要使用填1法，要知道 1个字节的每一个位的数是什么。\n\n\n\n### 小数部分\n\n**乘2取整法**   \n\n将一个小数转换为二进制的时候 需要做到保留几位小数。   \n将小数转换为二进制会存在一个问题：丢失精度。  \n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/php_jinzhi_transform_04.png)\n\n小数是不能用于比较大小的，因为它的精度不准确。\n\n------\n\n\n\n## 十进制转八进制\n\n**整数部分**：除8取余\n\n**小数部分**：乘8取整\n\n------\n\n\n\n## 十进制转十六进制\n\n**整数部分**：除16取余\n\n**小数部分**：乘16取整\n\n------\n\n\n\n## 二进制与八进制之间的互转\n\n一个八进制数等于3位2进制数    **421法**\n\n| **数数** | **八进制** | **二进制** |\n| -------- | ---------- | ---------- |\n| **0**    | **0**      | **000**    |\n| **1**    | **1**      | **001**    |\n| **2**    | **2**      | **010**    |\n| **3**    | **3**      | **011**    |\n| **4**    | **4**      | **100**    |\n| **5**    | **5**      | **101**    |\n| **6**    | **6**      | **110**    |\n| **7**    | **7**      | **111**    |\n\n \n\n`八转二：一拆三`   : 将一个八进制数拆分三个二进制数   \n\n``二转八：三并一  ``   :  将三位二进制数合并为一位八进制数    \n\n------\n\n\n\n## 二进制与十六进制互转\n\n二进制与十六进制之间的互转需要用到 **8421法**\n\n| **数数** | **十六进制** | **二进制** |\n| -------- | ------------ | ---------- |\n| **0**    | **0**        | **0000**   |\n| **1**    | **1**        | **0001**   |\n| **2**    | **2**        | **0010**   |\n| **3**    | **3**        | **0011**   |\n| **4**    | **4**        | **0100**   |\n| **5**    | **5**        | **0101**   |\n| **6**    | **6**        | **0110**   |\n| **7**    | **7**        | **0111**   |\n| **8**    | **8**        | **1000**   |\n| **9**    | **9**        | **1001**   |\n| **10**   | **A**        | **1010**   |\n| **11**   | **B**        | **1011**   |\n| **12**   | **C**        | **1100**   |\n| **13**   | **D**        | **1101**   |\n| **14**   | **E**        | **1110**   |\n| **15**   | **F**        | **1111**   |\n| **16**   |              |            |\n\n``十六转二：一拆四`` ： 将一个十六进制拆分四位二进制数   \n\n``二转十六：四并一`` ：  将四位二进制合成一位十六进制数   \n\n------\n\n\n\n## 八进制与十六进制的互转\n\n``八进制转十六：先一拆三，再四合一`` ：  先将一个八进制数拆分三个二进制数， 然后将四个二进制数合并为一个十六进制数。   \n\n``十六转八：先一拆四，再三并一``  ： 先将一位十六进制数拆分为四位二进制数  然后将三位二进制数合并成一位 \n\n![](../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/note/php_jinzhi_transform_02.png)\n\n------\n\n\n\n# 进制转换的函数\n\n进制的英文表示方式：\n\n* **二进制：bin**\n* **八进制：oct**\n* **十进制：dec**\n* **十六进制：hex**\n\n \n\n**注意：**   \n在PHP中，进制转换函数只能是十进制转换为其它进制、或者其它进制转换为十进制！  \n\n\n\n* 十进制转换二进制：decbin(int $val)\n* 十进制转换八进制：decoct(int $val)\n* 十进制转换十六进制：dechex(int $val)\n* 二进制转换十进制：bindec(string $val)\n* 八进制转换十进制：octdec(string $val)\n* 十六进制转换十进制：hexdec(string $val)\n\n\n\n----\n\n\n\n","categories":["基础知识"]},{"title":"MVC","url":"%2Fposts%2F2218208633%2F","content":"\n\n\n# 1. MVC基本概念\n\n### 为什么使用MVC\n\nMVC是目前应用最广的一种编程方式，本质上，MVC是将代码进行分离，将显示数据的部分、处理业务的部分 和 操作数据的部分 都独立出来。\n\n \n\n打个比方，没有使用MVC方式进行开发的项目就好像是一个管理混乱的餐馆，客户点菜（需求），餐厅的经理、服务员、清洁员一起上，然后你一嘴我一嘴的告诉厨师要做什么菜，最后菜出来了，又不管各自的职能都去端菜给客户，极其混乱：\n\n![1530972930761](2.png)\n\n而使用了MVC方式开发的项目就好比是一个管理有序的餐馆，每个人员都知道自己该做什么，调理清晰，执行业务顺畅：\n\n![1530972965070](3.png)\n\n\n\n我们以第二天开发的新闻管理系统为例：\n\n以前的实现方式：\n\n![1531014431630](4.png)\n\n使用MVC的实现方式：\n\n![1531014444989](5.png)\n\n\n\n使用MVC的好处实在是太多，最主要的方面体现在：\n\n1，  可以实现单入口，增强一个项目中对页面地址的控制能力；\n\n2，  功能和数据分层明确，便于后台人员维护和管理；\n\n3，  极其有利于多人协同开发（前端与后台，后台与后台），各成员之间互不影响；\n\n4，  拥有比较完善的基本结构，多人协同开发也不至于产生混乱。\n\n\n\n### 什么是MVC\n\nMVC不是某种语法，而是前辈们经过无数的实践总结而得出来的一种便捷，智慧的设计思想。\n\n \n\nMVC是三个英文单词的首字母，分别代表三个组件：\n\n**M** --》Model\n\n**V** --》View\n\n**C** --》Controller\n\n \n\nMVC思想大体上将我们开发的程序分成三个部分（三大组件），并且规定这三个部分：\n\n**Model表示模型层**，负责数据业务规则的处理，凡是跟数据操作有关的内容都属于数据逻辑，只要与SQL指令有关，那么都属于模型（数据逻辑）；\n\n \n\n**View表示视图层**，负责展示数据，其实就是我们看到的页面，也就是模板template（模板），用来承载数据的容器，通常是HTML文件（显示[HTML]，美化[CSS]和效果[JavaScript]）；\n\n \n\n**Controller表示控制器**，也叫作模块（Module），负责接受用户请求，并调用相应的模型和视图处理和展示业务，是用来与用户直接接触的脚本代码（浏览器直接提交给PHP的脚本对象），判断用户操作的逻辑性，在需要的时候，他可以调用模型操作数据，也可以调用视图展示页面。\n\n\n\n**名次释义**\n\n``model``  ： 模型。\n\n``module``   ：  模块，组件。\n\n\n\n# 2. 案例：使用MVC实现新闻管理系统\n\n### 1. MVC实现过程\n\n#### 第一步，搭建MVC基本结构，配置专用虚拟主机域名\n\n1. 在code目录中创建了名为mvc的目录，\n\n   ![1531016988428](7.png)\n\n   mvc目录结构如下图：\n\n![1531016948626](6.png)\n\n2. 配置www.mvc.com域名指向code/mvc根目录\n\n   在apache的虚拟主机配置文件httpd-vhosts.conf中增加虚拟主机配置项，\n\n   ![1531017169937](8.png)\n\n   在hosts文件中增加配置项，\n\n   ![1531017212138](9.png)\n\n   重启apache,\n\n   ![1531017246599](10.png)\n\n   测试虚拟主机域名是否配置成功，\n\n   在入口文件index.php中构建如下代码：\n\n   ![1531017356840](12.png)\n\n   访问index.php效果如下：\n\n   ![1531017323491](11.png)\n\n\n\n#### 第二步，将HTML模板页面转移进项目目录\n\n1. 复制后台所需的三个模板页面，拷贝到mvc/app/admin/view目录中，\n\n   在view目录中创建名为news的目录，\n\n   ![1531017685001](13.png)\n\n   拷贝三个文件到news目录中，\n\n   ![1531017770854](14.png)\n\n2. 复制前台所需的模板页面，拷贝到mvc/app/home/view目录中，\n\n   复制如下图所示文件，\n\n   ![1531017890669](15.png)\n\n   拷贝到view目录中，\n\n   ![1531017931576](16.png)\n\n\n\n#### 第三步，构建控制器展示视图模板文件\n\n**建议：每张有实际意义的表，建立一个对应的控制器类**\n\n1. 在mvc/app/admin/controller目录中创建名为NewsController.class.php，\n\n   ![1531018163097](17.png)\n\n   在NewsController.class.php中创建相应的类，并且构建方法展示出不同的后台模板页面，\n\n   ![1531018518445](18.png)\n\n2. 测试访问不同的页面，\n\n   访问后台新闻列表页：在NewsController.class.php类中构建测试代码，如下\n\n   ![1531018618650](19.png)\n\n   访问NewsController.class.php文件，\n\n   ![1531018665311](20.png)\n\n   如果要切换访问添加页，只要将调用的方法切换为访问showAd方法即可，\n\n   ![1531018712369](21.png)\n\n   再次访问NewsController.class.php，页面就成功的切换到了后台新闻添加页，\n\n   ![1531018751317](22.png)\n\n   \n\n   **==问题==**：当前我们访问后台页面都是通过访问NewsController.class.php文件实现的，但是MVC的流程要求访问任何页面都应该通过访问入口文件（index.php）实现，所以，我们需要做进一步的改进。\n\n   \n\n#### 第四步，实现通过入口文件访问不同的页面\n\n1. 剪切NewsController.class.php中访问不同页面的测试代码，如下图所示，\n\n   ![1531019891138](23.png)\n   拷贝到入口文件mvc/index.php中，如下图所示，\n\n   ![1531019963689](24.png)\n\n   同时还需在index.php中实例化NewsController类之前引入该类的类文件，\n\n   ![1531020115555](25.png)\n\n2. 调整入口文件Index.php中的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531021013436](26.png)\n\n   调整mvc/app/admin/controller/NewsController.class.php中的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531021107795](27.png)\n\n3. 测试访问入口文件index.php的效果，\n\n   ![1531021161444](28.png)\n\n4. 现在我们虽然能够实现从index.php单入口访问不同的页面了，但是每次我们切换访问页面，就需要跑到index.php中手动微调代码，非常的不方便也不智能。所以我们进一步作出改进，在index.php中定义三个变量参数，分别$action动作参数，$module模块参数，$plat平台参数。\n\n   **名词释义**\n\n   ``action`` ： 动作  \n\n   ``module`` ： 模块  \n\n   ``platform`` ： 平台\n\n   \n\n   **动态拼接**我们所需的东西，比用**if**判断的更实际。实际代码如下图所示蓝框中的代码改为红框中的代码：\n\n   ![1531033549826](29.png)\n\n   测试进一步调整之后的效果：\n\n   我们访问后台新闻管理系统列表页，\n\n   ![1531033755367](30.png)\n\n   不需要再手动在index.php中修改代码了，实现的功能OK了。\n\n\n**==问题==**：当前我们已经能够通过入口文件index.php实现智能的切换访问不同的页面，但是，我们发现每个页面中展示的数据都是写死的，并不是从数据表中查得的数据，所以，我们需要再一次进行调整。\n\n\n\n**视图 ``view``  OK 了，接下来要实现模型``Model`` ，即，要实现活的数据**\n\n\n\n#### 第五步，构建模型类，实现在控制器中调用模型操作数据表中的数据 \n\n**建议：每张有实际意义的表，建立一个对应的模型类**\n\n\n\n1. 在mvc/app/model目录下创建一个名为NewsModel.class.php的文件，\n\n   ![1531034615784](31.png)\n\n   模型类代码如下图所示：\n\n   ![1531035545533](32.png)\n\n2. 在入口文件中定义model目录的常量，然后引入模型类文件，\n\n   ![1531035619381](33.png)\n\n3. 在mvc/app/admin/controller/NewsController.class.php中的showList方法里调用模型**查询**数据，\n\n   ![1531035711459](34.png)\n\n4. **回显**查询得到的数据到视图模板文件中去，mvc/app/admin/view/news/newslist.html\n\n   ![1531035824378](35.png)\n\n  测试访问效果后台新闻管理系统列表页效果：\n\n![1531035852016](36.png)\n\n**数据展示正常！**\n\n\n\n#### 第六步，实现父模型(类)\n\n**更正**： 父类模型  -> 父模型类\n\n\n\n**因为很多地方都需要用到数据连接查询等基本操作，所以，需要把这些放置到一个类中。**\n\n**子类继承，就不用到处都需要new了**\n\n\n\n1. 在mvc/core目录下创建名为Model.class.php的文件：\n\n   ![1531037697777](37.png)\n\n   Model.class.php中的代码如下：\n\n   ![1531037763156](38.png)\n\n2. 调整父模型类文件mvc/core/Model.class.php中PDO类和PDOException类所使用的命名空间，改动部分如一下所有图中的行号内容，\n\n   ![1531037844488](39.png)\n\n   ![1531037876410](40.png)\n\n   ![1531037905831](41.png)\n\n   ![1531037926684](42.png)\n\n   \n\n3. 在入口文件index.php中引入父模型类文件，\n\n   ![1531037985285](43.png)\n\n4. 在模型类文件mvc/app/model/NewsModel.class.php继承父类模型，如下图所示将蓝框中的代码改为红框中的代码，\n\n   ![1531038115357](44.png)\n\n5. 测试使用，访问后台新闻管理系统列表页，\n\n   ![1531038164908](45.png)\n\n   **效果正常，说明父类模型构建成功。**\n\n   \n\n#### 第七步，引入SMARTY模板引擎\n\n1. 复制SMARTY的核心类库目录libs，\n\n   ![1531038491032](46.png)\n\n   拷贝到mvc/plugins目录中，\n\n   ![1531038546566](47.png)\n\n   将libs改名为smarty\n\n   ![1531038577438](48.png)\n\n2. 在入口文件index.php中引入SMARTY核心类文件，\n\n   ![1531039420006](49.png)\n\n3. 在mvc/app/admin/controller/NewsController.class.php中showList方法中使用SMARTY，如下图将蓝框所示的代码改为红框所示的代码，\n\n   ![1531039766358](50.png)\n\n4. 调整模板文件(mvc/app/admin/view/news/newslist.html)回显内容：\n\n   ![1531039849016](51.png)\n\n5. 测试访问效果：\n\n   ![1531039866731](52.png)\n\n   效果正常。\n\n   \n\n#### 第八步，实现父控制器类\n\n**更正** ：  父类控制器  -> 父控制器类\n\n\n\n**为了简化Smarty的代码，需要构建一个 父控制器类 （继承 Smarty）。**\n\n**子控制器类 集成 父控制器类，这样就可直接使用 Smarty，而无需实例化它。**\n\n\n\n1. 在mvc/core目录下创建Controller.class.php的文件，\n\n   ![1531042301195](53.png)\n\n   在Controller.class.php中实现继承Smarty类，\n\n   ![1531042388086](54.png)\n\n2. 在入口文件中引入父类控制器类文件，\n\n   ![1531042434373](55.png)\n\n3. 调整mvc/app/admin/controller/NewsController.class.php中showList方法内使用SMARTY代码，如下图将蓝框所示的代码改变成红框所示的代码：\n\n   ![1531042734977](56.png)\n\n4. 测试使用效果：\n\n   ![1531042781158](57.png)\n\n   效果正常。\n\n\n\n\n\n#### 第九步，实现配置文件\n\n1. 在mvc根目录中创建名为conf的目录，\n\n   ![1531189176903](60.png)\n\n2. 在mvc/conf目录下创建名为conf.php的文件，\n\n   ![1531189444605](61.png)\n\n3. 在入口文件index.php中引入mvc/conf/conf.php配置文件，\n\n   ![1531190344187](62.png)\n\n4. 在父类模型mvc/core/Model.class.php中使用配置值，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531190425050](63.png)\n\n5. 测试使用效果：访问后台新闻管理系统列表页\n\n   ![1531190509292](64.png)\n\n6. 在mvc/core目录下创建了一个Func.php的文件，封装一个名为C的读取配置项值的函数，\n\n   ![1531195125586](65.png)\n\n   ![1531195172492](66.png)\n\n7. 在index.php中引入公共函数，\n\n   ![1531195232253](67.png)\n\n8. 调整父类模型中读取配置的方式，\n\n   ![1531195279966](68.png)\n\n测试访问后台新闻管理系统列表页，\n\n![1531195319459](69.png)\n\n\n\n继续完善配置文件的配置项，\n\n在mvc/conf/conf.php增加如下配置项，\n\n![1531204942908](70.png)\n\n在入口文件中修改三个参数$plat、$module、$action的默认值使用方式，如下图将蓝框的代码改为红框的代码：\n\n![1531205009160](71.png)\n\n再次测试访问后台新闻管理系统列表页，\n\n![1531205094498](72.png)\n\n\n\n#### 第十步，实现初始化文件\n\n1. 在mvc/conf目录下创建一个名为init.php的文件，\n\n   ![1531205430421](73.png)\n\n2. 将入口文件中的定义常量的操作和引入文件的操作全部剪切转移到mvc/conf/init.php中，\n\n   剪切index.php中如下图所示代码：\n\n   ![1531205507075](74.png)\n\n   ![1531205536680](75.png)\n\n   将上面剪切的代码转移粘贴到mvc/conf/init.php中，\n\n   ![1531205614696](76.png)\n\n   ![1531205649768](77.png)\n\n3. 将mvc/conf/init.php中定义根目录的常量进行调整，\n\n   ![1531206215541](78.png)\n\n4. 再次测试访问后台新闻管理系统列表页，\n\n   ![1531206257537](79.png)\n\n\n\n再对mvc/conf/init.php中的初始化操作做进一步调整，\n\n在mvc/conf目录下创建define.php文件，\n\n![1531206361222](80.png)\n\n将mvc/conf/init.php中所有define操作的代码进行剪切，\n\n![1531206409723](81.png)\n\n将上面剪切的代码转移粘贴到mvc/conf/define.php中，\n\n![1531206448284](82.png)\n\n在mvc/conf/init.php中引入mvc/conf/define.php文件，\n\n![1531206806237](83.png)\n再次测试访问新闻列表页：\n\n![1531206840140](84.png)\n\n\n\n### 2. 全天总结\n\nMVC全天总结流程图在doc/MVC1.vsd\n\n\n\n![1531044680403](58.png)\n\n\n\n# \n\n# 1. 实现后台新闻新增页和功能\n\n1. 调整mvc/app/admin/controller/NewsController.class.php中的showAd方法的程序，如下图将蓝框的代码改为红框的代码：\n\n   ![1531208255075](85.png)\n\n2. 调整mvc/app/admin/view/news/newsad.html中form表单的action，\n\n   ![1531208390925](86.png)\n\n3. 在mvc/app/admin/controller/NewsController.class.php中创建adh方法，\n\n   ![1531208496983](87.png)\n\n4. 测试使用效果：\n\n   访问添加页：\n\n   ![1531208605725](89.png)\n\n   点击提交：\n\n   ![1531208626016](90.png)\n\n\n\n# 2. 实现前台展示新闻首页\n\n1. 在mvc/conf/define.php中定义几个路径常量，\n\n   ![1531210329600](91.png)\n\n2. 再在mvc/conf/init.php中引入mvc/app/home/controller/IndexController.class.php，\n\n   ![1531210385141](92.png.png)\n\n3. 调整mvc/app/home/controller/IndexController.class.php中的代码，如下图将蓝框的代码改为红框的代码：\n\n   ![1531210444985](93.png)\n\n4. 调整mvc/core/Controller.class.php中设置存放模板文件目录的代码，如下图将蓝框的代码改为红框的代码：\n\n   ![1531210531679](94.png)\n\n5. 再次测试访问后台新闻列表页和前台新闻首页\n\n   后台新闻列表页：\n\n   ![1531210603165](95.png)\n\n   前台新闻首页：\n\n   ![1531210629327](96.png)\n\n   \n\n   **虽然现在能够访问到前台新闻首页，但是前台新闻首页没有展示出从数据表中读取的数据**\n\n   \n\n6. 在mvc/app/home/controller/IndexController.class.php中showIndex方法里渲染模板之前先将数据查询出来，\n\n   ![1531211263979](97.png)\n\n   调整模板mvc/app/home/view/newsIndex.html中回显数据的部分，\n\n   ![1531211323875](98.png)\n\n7. 再次测试访问前台新闻首页：\n\n   ![1531211360389](99.png)\n\n   说明功能制作OK。\n\n\n\n# 3. 创建核心框架类实现自动加载\n\n文件引入定义中，有些文件，其文件名等，可能是长期不变的，相反，有些可能会变动频繁或不止当前的数量，\n\n未来可能有更多的文件需要引入，每次都手动引入很繁琐。\n\n**所以，可以根据命名的规律，来定义一个自动加载的方法。**\n\n\n\n1. 在mvc/core目录下创建App.class.php文件，\n\n   ![1531212246554](100.png)\n\n2. 在mvc/core/App.class.php中构建autoload方法，内容如下：\n\n   ![1531214521156](101.png)\n\n3. 在mvc/conf/init.php中注册自动加载方法，\n\n   ![1531214608626](102.png)\n\n4. 再次测试：\n\n   测试访问后台新闻管理系统列表页：\n\n   ![1531214698370](103.png)\n\n   测试访问前台新闻首页：\n\n   ![1531214731773](104.png)\n\n\n\n# 4. 实现程序启动方法\n\n\n\n**继续优化入口文件（``index.php``） ，将接收参数，输出等 归纳到一个（静态）方法中，然后入口文件调用即可。**\n\n\n\n1. 在mvc/core/App.class.php中构建一个名为run的静态方法，\n\n   ![1531214904885](105.png)\n\n2. 将入口文件mvc/index.php中如下图所示的代码剪切转移到mvc/core/App.class.php中的run方法里，\n\n   剪切下图所示代码：\n\n   ![1531214994723](106.png)\n\n   转移到mvc/core/App.class.php中的run方法里：\n\n   ![1531215053641](107.png)\n\n3. 将mvc/core/App.class.php中的run方法$action、$module、$plat三个局部变量提升为全局变量，如下图将蓝框的代码改为红框的代码：\n\n   ![1531215368334](108.png)\n\n4. 在入口文件index.php中调用启动方法，\n\n   ![1531215450815](109.png)\n\n5. 测试访问效果：\n\n   访问后台新闻列表页：\n\n   ![1531215508203](110.png)\n\n\n\n# 5. 实现单例工厂模式\n\n1. 在mvc/core/App.class.php中构建single方法和$_obj静态属性，如下图所示，\n\n   ![1531217621021](111.png)\n\n2. 调整mvc/core/App.class.php中run方法中实例化控制器类的对象，如下图将蓝框的代码改为红框的代码：\n\n   ![1531217723272](112.png)\n\n3. 再次测试访问后台新闻管理系统列表页，\n\n   ![1531217809504](113.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["MVC"]},{"title":"面向对象3","url":"%2Fposts%2F4277359260%2F","content":"\n\n# 面向对象3\n\n## 1. ==PHP中的接口==\n\nPHP中的接口指的不是我们平常听到的支付接口，物流API接口等，指的是纯粹的PHP中的语法；\n\n\n\n==实现语法==：\n\n```php\n#使用关键字interface来定义接口\ninterface  接口名{\n\t接口成员\n}\n```\n\n\n\n### 接口中的成员\n\n接口中的成员包含两个部分：\n\n- [x] 接口常量\n- [x] 接口抽象方法\n\n\n\n定义方式：\n\n```php\n<?php\n\n#使用关键字interface声明一个接口\ninterface InterfaceDemo{\n\n    //接口常量\n    const URL='www.home.com';\n\n    //接口抽象方法，注意，定义接口抽象方法不能指定abstract关键字\n    public function f1($v1, $v2=100);\n}\n```\n\n\n\n### 接口的特点\n\n1. 接口需要使用implements关键字来实现；\n\n   演示代码：\n\n   ```php\n   <?php\n   \n   interface inter1{\n   \n   }\n   \n   //使用implements关键字来实现接口\n   class A implements inter1{\n   \n   }\n   ```\n\n   \n\n2. 接口可以被多实现；\n\n   演示代码：\n\n   ```php\n   <?php\n   \n   interface inter1{\n   \n   }\n   interface inter2{\n   \n   }\n   interface inter3{\n   \n   }\n   \n   //使用implements关键字可以实现多个接口\n   class A implements inter1, inter2, inter3{\n   \n   }\n   ```\n\n   \n\n3. 接口如果被普通类所实现，那么，接口中的所有接口抽象方法都要被全部实现；\n\n   演示代码：\n\n   ```php\n   <?php\n   \n   interface inter1{\n       public function f1($name);\n       public function f2($age);\n   }\n   \n   //使用implements关键字可以实现多个接口\n   class A implements inter1{\n       public function f1($name){ \n           echo $name; \n       }\n   }\n   ```\n\n   访问演示代码，输出效果：\n\n   ![1530498245014](2_3.png)\n\n4. 接口还可以被抽象类所实现，如果被抽象类实现，那么接口中的接口抽象方法可以不被实现；\n\n   演示代码：\n\n   ```php\n   <?php\n   \n   interface inter1{\n       public function f1($name);\n       public function f2($age);\n   }\n   \n   #使用了一个抽象类A去实现了接口inter1，接口被抽象类所实现后，接口中的抽象方法可以不被实现\n   abstract class A implements inter1{\n   \n       abstract public function f3();\n   \n       public function f1($name){ \n           \n       }\n   }\n   ```\n\n   \n\n5. 接口中的接口抽象方法只能是public类型；\n\n   演示代码：\n\n   ```php\n   <?php\n   \n   interface inter1{\n       public function f1($name);\n       private function f2($age);//接口中的抽象方法只能是公有的\n   }\n   ```\n\n   访问演示代码，输出效果：\n\n   ![1530498698510](3_3.png) \n\n\n\n## 2. 静态延时绑定\n\n**引言**：静态延时绑定是PHP5.3之后才出现的特性。\n\n\n\n静态延时绑定需要用到的关键字是：**==static==**\n\nstatic关键字的意思：**==表示哪个类调用，就代表那个类==**。\n\n\n\n**==需求==**：使用code/prepare目录下的StaticDemo.php文件中的代码，\n\n1. 在StaticDemo类的f1方法中打印出子类Demo中的$var2属性的值；\n2. 在Demo类的f2方法中打印父类$var1的值 和 本类中$var2的值；\n\n**==解答==**：\n\n```php\n<?php\n\n\nclass StaticDemo{\n\n    public static $var1='var1';\n\n    public static function f1(){ \n        var_dump( Demo::$var2 ); //访问Demo类中的$var2静态属性\n        echo '<br/>';\n        var_dump( static::$var2 ); \n    }\n}\n\nclass Demo extends StaticDemo{\n    \n    public static $var2='var2';\n\n    public function f2(){ \n        var_dump( parent::$var1 ); echo '<br/>';\n        var_dump( self::$var2 ); echo '<br/>';\n        echo 'static：<br/>'; \n        var_dump( static::$var1 ); echo '<br/>';\n        var_dump( static::$var2 ); \n    }\n}\n\n//调用f1方法\n//StaticDemo::f1(); echo '<hr/>';//这次访问f1方法中输出的static::$var2将会报错，因为static表示哪个类调用就代表那个类，所以现在是StaticDemo类在调用f1方法，所以f1方法中的static就代表StaticDemo类，而StaticDemo中没有$var2静态属性，所以报错\n//Demo::f1();//这次访问f1方法中输出的static::$var2可以正常输出，因为现在f1方法中的static代表Demo类，所以能够访问Demo自己类中的$var2静态属性；\n\n//echo '<hr/>';echo '<hr/>';\n\n//调用f2方法\n$obj = new Demo;\n$obj->f2();//这次访问f2方法中的static::$var1和static::$var2都能正常输出，因为此时$obj对象在调用f2方法，而$obj对象是由Demo类实例化出来的对象，所以f2方法里的static关键字就代表Demo类，所以能够正常访问到父类的$var1和自己内部的$var2属性；\n\n```\n\n\n\n**==小结==**：\n\n1. static关键字就表示：哪个类调用就代表那个类；\n\n\n\n## 3. ==PHP中的重载==(overload)\n\n概念：PHP中的重载，指的是当访问一个**==不可访问==**的成员时，如何来进行处理，这个**==处理过程==**就是PHP中的重载。 \n\n\n\n重载在PHP中分成两个部分：\n\n- [x] 默认的重载              当访问一个**不可访问**的成员时，PHP默认的处理过程\n- [x] 自定义重载              当访问一个**不可访问**的成员时，开发者自定义的处理过程\n\n\n\n通过观察相关概念，不难发现，在重载这个部分，最关键是要弄明白什么情况属于访问到一个**==不可访问==**的成员。\n\n\n\n在重载中，所谓的访问到一个不可访问的成员，指的是：\n\n1. 访问到一个不存在的成员（方法  和  非静态属性）\n2. 访问到一个存在却不能访问的成员（方法  和  非静态属性）\n\n\n\n### PHP中默认的重载\n\n**==需求==**：使用code/prepare目录下的OverloadDemo.class.php文件中的代码，在类的外部创建一个基于OverloadDemo类的对象$obj，\n\n1. 使用对象$obj增加一个非静态属性$name=zhangsan，然后打印对象$obj，查看效果；\n2. 使用对象$obj获取$var1属性的值，并尝试打印，查看效果；\n3. 使用unset尝试删除对象$obj中的$var1属性，查看效果；\n4. 使用isset判断$obj中的$var1是否存在，查看效果；\n5. 在类的外部尝试调用f1和f2方法，查看效果；\n\n**==解答==**：\n\n```php\n<?php\n\nclass OverloadDemo{\n\n    protected $var1='var1';\n\n    protected function f1($v1){ //protected类型  的  非静态方法\n        echo $v1; \n    }\n\n    private static function f2($v1){ //private类型  的  静态方法\n        echo $v1; \n    }\n}\n\n\n$obj = new OverloadDemo;\nvar_dump( $obj ); echo '<br/>';\n\n#当访问到一个 不存在的 非静态属性时，PHP默认往对象中添加一个新的非静态属性\n$obj->name = 'zhangsan';\nvar_dump( $obj ); echo '<hr/>';\n\n#当访问(获取)到一个  存在但是不能访问的  非静态属性时，PHP默认的处理方式是拒绝访问直接报错\n//var_dump( $obj->var1 ); echo '<hr/>';\n\n#当使用unset访问(删除)到一个  存在但是不能访问的  非静态属性时，PHP默认的处理方式是拒绝访问直接报错\n//unset($obj->var1); \n\n#当使用isset访问(判断是否存在)到一个  存在但是不能访问的  非静态属性时，PHP直接返回false\nvar_dump( isset($obj->var1) ); \necho '<hr/>';echo '<hr/>';\n\n#\n//$obj->f1(100);//当访问到一个  存在但是不能访问的  非静态方法时，PHP默认的处理方式是拒绝访问直接报错\nOverloadDemo::f2(200);//当访问到一个  存在但是不能访问的  静态方法时，PHP默认的处理方式是拒绝访问直接报错\n```\n\n\n\n**==小结==**：\n\n1. 当访问一个不存在的非静态成员属性时，PHP默认的处理方式是直接添加一个新的属性；\n2. 当访问到一个存在但不能访问的成员时，除了isset操作是返回false之外，其他的都是拒绝访问直接报错；\n\n\n\n### PHP中自定义重载\n\nPHP中自定义重载又被划分为两个类别，分别是：\n\n- [x] （非静态）属性的重载\n- [x] 方法的重载\n\n\n\n#### 属性的重载\n\n（非静态）属性的重载，涉及的魔术方法：\n\n> **__get**(属性名)                          当==获取==一个不可访问的（非静态）成员属性值时，进行自定义的处理\n>\n> **__set**(属性名， 属性值)          当==设置==一个不可访问的（非静态）成员属性值时，进行自定义的处理\n>\n> **__unset**(属性名)                     当==删除==一个不可访问的（非静态）成员属性时，进行自定义的处理\n>\n> **__isset**(属性名)                       当==判断==一个不可访问的（非静态）==成员属性是否存在==时，进行自定义的处理\n\n\n\n##### __get魔术方法\n\n**==需求==**：使用code/prepare目录下的\\_\\_getDemo.php文件中的代码，在类的外部创建一个基于\\_\\_getDemo类的对象$obj，\n\n1. 构建\\_\\_get魔术方法，在方法中实现判断，当属性名为name时返回该属性的实际值；当属性名为var1时返回提示信息'就不给你看！'；\n\n**==解答==**：构建名为code10.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass __getDemo{\n\n    protected $name='郭嘉';\n\n    #魔术方法__get\n    public function __get($varName){ \n\n        if( $varName=='name' ){\n            //        $this->name\n            return $this->$varName;//直接将name属性的值返回出去\n        }elseif( $varName=='var1' ){\n            return '就不给你看！';\n        }\n    }\n}\n\n$obj = new __getDemo;\n//                $obj->name=$obj->__get('name');\nvar_dump( $obj->name ); //获取一个不可访问的非静态属性值时，\n//                $obj->var1=$obj->__get('var1');\nvar_dump( $obj->var1 ); //获取一个不可访问的非静态属性值时，\n//               $obj->var100=$obj->__get('var100');\nvar_dump( $obj->var100 ); \n```\n\n访问code10.php，效果为：\n\n![1530504072822](4_3.png)\n\n\n\n**==小结==**：\n\n1. \\_\\_get魔术方法PHP不负责定义，只负责调用；\n2. 当获取一个不可访问的非静态属性值时，则会触发PHP自动调用执行\\_\\_get魔术方法，并且会将这个不可访问的非静态属性的名字传递给\\_\\_get魔术方法；\n\n\n\n##### __set魔术方法\n\n**==需求==**：使用code/prepare目录下的\\_\\_setDemo.php文件中的代码，在类的外部创建一个基于\\_\\_setDemo类的对象$obj，\n\n1. 构建\\_\\_set魔术方法，在方法中实现判断，当属性名为name时则允许进行设置；当属性名为age时则固定设置为100；其他情况则输出提示信息'不允许添加额外的属性哦！'；\n\n**==解答==**：构建code12.php程序，代码如下：\n\n```php\n<?php\n\nclass __setDemo{\n\n    protected $name='王翦';\n    private $age=18;\n\n    #创建一个名为__set的魔术方法，需要两个参数，第一个参数不可访问的非静态属性名；第二个参数为不可访问的非静态属性新值；\n    public function __set($varName, $varValue){ \n\n        if( $varName=='name' ){\n            //$this->name = $varValue;\n            $this->$varName = $varValue;\n        }elseif( $varName=='age' ){\n            $this->age = 100;\n        }else{\n            echo '不允许添加额外的属性哦！'; \n        }\n    }\n}\n\n$obj = new __setDemo;\n$obj->height = 1.78;\necho '<br/>';\nvar_dump( $obj ); \necho '<hr/>';\n$obj->name = '大战神';\nvar_dump( $obj ); \necho '<hr/>';\n$obj->age = 2000;\nvar_dump( $obj ); \n```\n\n访问code12.php，效果如下：\n\n![1530515476054](5_3.png)\n\n\n\n**==小结==**：\n\n1. PHP不负责定义\\_\\_set魔术方法，只负责调用这个魔术方法；\n2. 调用这个魔术方法的时机是：当设置了一个不可访问的非静态属性的值时，则会触发PHP自动调用执行\\_\\_set魔术方法，这个魔术方法是需要两个参数的，具体参数的说明请参看上面的代码注释\n\n\n\n##### __unset魔术方法\n\n**==需求==**：使用code/prepare目录下的\\_\\_unsetDemo.php文件中的代码，在类的外部创建一个基于\\_\\_unsetDemo类的对象$obj，\n\n1. 构建\\_\\_unset魔术方法，在方法中实现判断，当属性名为age时则允许删除，返回true；其他情况则输出提示信息'再删！给你小拳拳哦！'，返回false；\n\n**==解答==**：构建code13.php，代码如下：\n\n```php\n<?php\n\nclass __unsetDemo{\n\n    protected $name='梦奇';\n    private $age=19;\n\n    #构建__unset魔术方法，需要一个必填参数，这个参数表示删除的不可访问的非静态属性的属性名\n    public function __unset($varName){ \n\n        if( $varName=='age' ){\n            unset($this->age);\n            return true;//给返回值无效，所以不用去指定返回值\n        }else{\n            echo '再删！给你小拳拳哦！'; \n            return false;//给返回值无效，所以不用去指定返回值\n        }\n    }\n}\n\n$obj = new __unsetDemo;\nvar_dump( $obj ); echo '<br/>';\nunset($obj->age);echo '<hr/>';\nvar_dump( $obj ); echo '<br/>';\nunset($obj->name);echo '<hr/>';\nvar_dump( $obj ); \n```\n\n访问code13.php，效果为：\n\n![1530516511557](6_3.png)\n\n**==小结==**：\n\n1. PHP不负责构建这个魔术方法，只负责调用这个魔术方法；\n2. 调用该魔术方法的时机是：当删除一个不可访问的非静态成员属性时，则会触发PHP自动调用\\_\\_unset魔术方法自动执行，这个魔术方法有一个必填参数，参数说明请参看上面案例中的代码注释。\n\n\n\n##### __isset魔术方法\n\n**==需求==**：使用code/prepare目录下的\\_\\_issetDemo.php文件中的代码，在类的外部创建一个基于\\_\\_issetDemo类的对象$obj，\n\n1. 构建\\_\\_isset魔术方法，在方法中实现判断，当属性名为name时则返回true；其他情况则返回false；\n\n**==解答==**：构建code15.php，代码如下：\n\n```php\n<?php\n\nclass __unsetDemo{\n\n    protected $name='二师兄';\n    private $age=19;\n\n    #构建__isset魔术方法，需要指定一个必填参，参数表示判断的不可访问的非静态属性的属性名\n    public function __isset($varName){ \n        if( $varName=='name' ){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n\n$obj = new __unsetDemo;\nvar_dump( isset($obj->name) ); echo '<hr/>';\nvar_dump( isset($obj->age) ); \n```\n\n访问code15.php，效果为：\n\n![1530517042589](7_3.png)\n\n\n\n**==小结==**：\n\n1. PHP不负责定义该魔术方法，只负责调用该魔术方法；\n2. 调用\\_\\_isset魔术方法的时机是：当判断一个不可访问的非静态属性是否存在时，则会触发PHP自动调用\\_\\_isset魔术方法执行一次，需要传递一个必填参数，参数说明请参看上面代码的注释。\n\n\n\n#### 方法的重载\n\n涉及的魔术方法：\n\n> **__call**(方法名， 传递给方法的参数)                当访问一个不可访问的（非静态）成员方法时，进行自定义处理\n>\n> **__callstatic**(方法名， 传递给方法的参数)       当访问一个不可访问的（静态）成员方法时，进行自定义处理\n\n\n\n##### __call魔术方法\n\n**==需求==**：使用code/prepare目录下的\\_\\_callDemo.php文件中的代码，在类的外部创建一个基于\\_\\_callDemo类的对象$obj，\n\n1. 构建\\_\\_call非静态魔术方法，在方法中实现判断，当方法名为f1时则允许访问；其他情况则提示\"没有这个方法！\"，返回false；\n\n**==解答==**：构建code16.php，代码如下：\n\n```php\n<?php\n\nclass __callDemo{\n\n    private function f1($v1, $v2){ \n        echo '$v1：' . $v1 . '；$v2：' . $v2; \n    }\n\n    #构建一个__call的魔术方法，需要两个必填参，第一个参数指定的是方法名，第二个参数指定的是传递给方法的所有参数形成的数组集合\n    public function __call($methodName, $methodParams){ \n        //echo '方法名：'; \n        //var_dump( $methodName ); echo '<br/>';\n        //echo '参数数据：'; \n        //var_dump( $methodParams ); \n\n        if( $methodName=='f1' ){\n            //$this->f1($methodParams[0], $methodParams[1]);\n            $this->$methodName($methodParams[0], $methodParams[1]);\n        }else{\n            echo '没有这个方法！'; \n            return false;\n        }\n    }\n}\n\n$obj = new __callDemo;\n$obj->f1(100, 200);  echo '<hr/>';\n\n$re = $obj->f2(100);\nvar_dump( $re ); \n```\n\n访问code16.php，效果为：\n\n![1530518364734](8_3.png)\n\n**==小结==**：\n\n1. PHP不负责定义\\_\\_call魔术方法，只负责调用这个魔术方法；\n2. 调用该魔术方法的时机是：当访问到一个不可访问的非静态方法时，将会触发PHP自动调用该魔术方法，这个魔术方法本身也是一个非静态方法，参数请参看上面代码中的注释；\n\n\n\n##### __callstatic魔术方法\n\n**==需求==**：使用code/prepare目录下的\\_\\_callstaticDemo.php文件中的代码，在类的外部创建一个基于\\_\\_callstaticDemo类的对象$obj，\n\n1. 构建\\_\\_callstatic静态魔术方法，在方法中实现判断，当方法名为f1时则允许访问；其他情况则提示\"没有这个方法！\"，返回false；\n\n**==解答==**：构建code17.php，代码如下：\n\n```php\n<?php\n\nclass __callstaticDemo{\n\n    private static function f1($v1){ \n        echo $v1; \n    }\n\n    private static function f2(){ \n        echo 'f2'; \n    }\n    #构建（静态）魔术方法__callstatic，需要两个必填参，第一个参数指定的是方法名，第二个参数指定的是传递给方法的所有参数形成的数组集合\n    public static function __callstatic($methodName, $methodParams){ \n\n        if( $methodName=='f1' ){\n            self::f1($methodParams[0]);\n        }else{\n            echo '没有这个方法！'; \n            return false;\n        }\n    }\n}\n\n__callstaticDemo::f1(100);echo '<hr/>';\n$re = __callstaticDemo::f2();\nvar_dump( $re ); \n```\n\n访问code17.php，效果如下：\n\n![1530518988382](9_3.png)\n\n**==小结==**：\n\n1. PHP不负责定义\\_\\_callstatic只负责调用这个魔术方法；\n2. 调用的时机：当访问到一个不可访问的静态方法时，将会触发PHP自动调用该魔术方法，这个魔术方法本身也是一个静态方法，参数请参看上面代码中的注释；\n\n\n\n## 4. 面向对象的三大特性\n\n1）  ==封装==的特性， 将特定的功能打包成一个类；\n\n2）  ==继承==的特性， 指的就是extends语法特性；\n\n3）  ==多态==的特性， 指的就是重写的特性，一种方法可以有多种实现方式；\n\n\n\n## 5. ==两种常见的设计思想==(模式)\n\n**引言**：在PHP中，存在两种常见的设计模式，一个是单例模式，另一个是工厂模式，这两种设计模式，并不是固定的PHP语法，而是==广大的开发工作者在长期的开发工作中总结出来的开发经验==。\n\n\n\n### 单例模式\n\n**引言**：在程序中，我们可以通过使用new关键字来达到实例化对象的目的，并且只要new一次，都将会得到一个全新的对象（空间）；而实际上，在项目中，如果我们需要使用对象来调用类中的成员进行操作的话，基于这个类创建一个对象就足以满足所有的调用操作需求，没有必要额外再创建更多的对象。因为，创建更多的对象，也就意味着额外会有更多的损耗。\n\n\n\n广大的开发工作者也注意到这个问题，为了能够减少损耗，提升程序运行的效率，通过逐步总结开发经验，得出了单例这种设计思想模式。\n\n\n\n单例模式实现的**目标**效果是： 无论我们实例化多少次，都只能得到唯一的一个对象（空间）。\n\n\n\n**==TIPS==**：单例模式也被称为：**三私一公**\n\n\n\n#### 实现步骤\n\n1. 第一步目标，先实现禁止创建对象，让我们在程序中无法通过new来得到对象\n\n   ![1530521448563](10_3.png)\n\n2. 第二步，想办法，开放一个对象，创建一个私有的静态属性$_obj，再创建一个名为single的静态方法，方法中的代码内容如下：\n\n   ```php\n   <?php\n   \n   class A{\n       \n       private static $_obj;//保存本类唯一对象的静态属性\n   \n       private function __construct(){ //将构造方法私有化，使得基于类A在类的外部没有办法通过new的方式创建对象\n   \n       }\n   \n       public static function single(){ \n   \n           if( !is_object(self::$_obj) ){//如果不是一个对象\n               //创建一个全新的对象\n               self::$_obj = new self;//创建一个基于本类的对象\n           }\n           //返回新创建的对象\n           return self::$_obj;\n       }\n   }\n   \n   $a1 = A::single();\n   var_dump( $a1 ); echo '<hr/>';\n   $a2 = A::single();\n   var_dump( $a2 ); echo '<hr/>';\n   $a3 = A::single();\n   var_dump( $a3 ); echo '<hr/>';\n   ```\n\n   访问该程序的效果为：\n\n   ![1530522407724](11_3.png)\n\n3. 我们还需要将clone魔术方法禁掉，代码如下：\n\n   ```php\n   <?php\n   \n   class A{\n       \n       private static $_obj;//保存本类唯一对象的静态属性\n   \n       private function __construct(){ //将构造方法私有化，使得基于类A在类的外部没有办法通过new的方式创建对象\n   \n       }\n   \n       public static function single(){ \n   \n           if( !is_object(self::$_obj) ){//如果不是一个对象\n               //创建一个全新的对象\n               self::$_obj = new self;//创建一个基于本类的对象\n           }\n           //返回新创建的对象\n           return self::$_obj;\n       }\n   \n       private function __clone(){ //禁掉clone魔术方法，使得在类的外部无法通过clone来得到全新的对象\n           \n       }\n   }\n   \n   $a1 = A::single();\n   var_dump( $a1 ); echo '<hr/>';\n   $a2 = A::single();\n   var_dump( $a2 ); echo '<hr/>';\n   $a3 = A::single();\n   var_dump( $a3 ); echo '<hr/>';\n   $a4 = clone $a3;\n   var_dump( $a4 ); \n   ```\n\n   访问程序代码，效果为：\n\n   ![1530522614001](12_3.png)\n\n\n\n\n\n### 工厂模式\n\n**引言**：在程序中，如果使用面向对象的开发方式进行开发，那么，基于类创建对象这种操作一定是非常频繁的。\n\n\n\n广大的开发工作者为了在程序中能够对创建对象这种频繁的操作能够有集中的管理，故而从大量的开发实践中总结出工厂模式设计思想。\n\n\n\n工厂模式实现的目标效果：构建一个类，专门用于生产对象。 \n\n\n\n#### 实现步骤\n\n构建的程序代码为：\n\n```php\n<?php\n\n//构建一个工厂类\nclass Factory{\n\n    //构建一个专门生产对象的静态方法，需要一个必填参，这个必填参是以后要实例化类的类名\n    public static function produce($className){ \n        \n        if( $className=='A' ){//如果是A类\n            include './A.class.php';//则引入A类所在的类文件\n            $obj = new A;//实例化一个A类的对象\n        }\n\n        return $obj;//将对象返回\n    }\n}\n\n\n$a1 = Factory::produce('A');\nvar_dump( $a1 ); \n```\n\n\n\n**==小结==**：\n\n1. 工厂模式指的就是构建一个专门生产对象的类；\n\n\n\n## 7. 全天总结\n\n1. 什么是重载？\n\n   重载指的就是当访问到一个不可访问的成员（非静态属性和方法）时，如何去处理，这个处理过程就是重载；\n\n2. \\_\\_set、\\_\\_get、\\_\\_unset和\\_\\_call魔术方法的操作\n\n   \\_\\_set魔术方法是当设置一个不可访问的非静态属性的值时，PHP将会自动调用\\_\\_set魔术方法执行一次；\n\n   \\_\\_get魔术方法是当获取一个不可访问的非静态属性的值时，PHP将会自动调用\\_\\_get魔术方法执行一次；\n\n   \\_\\_unset魔术方法是当删除一个不可访问的非静态属性时，PHP将会自动调用\\_\\_unset魔术方法执行一次；\n\n   \\_\\_call魔术方法是当调用一个不可访问的非静态方法时，PHP将会自动调用\\_\\_call魔术方法执行一次；\n\n3. 面向对象的三大特性：\n\n   封装         就是将功能打包成一个类\n\n   继承         指的就是extends的特性\n\n   多态         指的就是重写，同一种方法有多种实现方式\n\n4. 能够实现单例模式\n\n   单例模式的目标：无论在类的外部实例化多少次，只能得到唯一的一个对象。\n\n   实现单例模式的方式叫：三私一公\n\n   我们的实现方式：1）禁掉所有在类的外部创建的对象；2）在类的内部开放一个；3）禁掉clone魔术方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["PHP面向对象编程"]},{"title":"TP5框架案例","url":"%2Fposts%2F2849568870%2F","content":"\n\n# ==TP5第一天==\n\n# 一、案例：搭建后台首页\n\n## 步骤1：创建控制器和方法\n\n在后台**admin**创建一个**IndexController**控制器的**index**方法，输出模板\n\n![](media1/image69.png)\n\n\n\n## 步骤2：定义路由\n\n```php\nRoute::get(\"admin/index/index\",\"admin/index/index\");\n```\n\n\n\n## 步骤3：创建或配置模版\n\n在`admin/view/index/`创建一个`index.html`模板，此模板可以复制后台模板的index.html，同时更改静态资源文件路径\n\n![](media1/image70.png)\n\n\n\n## 步骤4：模版公共部分处理\n\n提取模版的公共部分，独立文件，并定义三个方法top、left、main\n\n此模版已处理。\n\n![](media1/image71.png)\n\n定义路由：\n\n```php\nRoute::get(\"admin/index/top\",\"admin/index/top\");\nRoute::get(\"admin/index/left\",\"admin/index/left\");\nRoute::get(\"admin/index/main\",\"admin/index/main\");\n```\n\n复制对应的模板到`/admin/view/index`目录下面\n\n![](media1/image72.png)\n\n修改`index.html`的iframe的src路径为对应的路由：\n\n![](media1/image73.png)\n\n\n\n## 步骤5：模版修改\n\n修改top.html、left.html、main.html模板的**静态资源文件**\n\n**a**.  复制资源到`/public/static`中\n\n![](media1/image74.png)\n    \n**b**.      `top.html`、`left.html`、`main.html`模板中进行替换路径(快捷键ctrl+h)\n    \n![](media1/image75.png)\n    \n建议静态资源路径直接配置在文件`config.php`中，方便后期维护：\n    \n![](media1/image76.png)\n    \n替换好如下所示，以top.html文件为例。\n    \n![](media1/image77.png)\n    \n最终访问效果：\n    \n![](media1/image78.png)\n\n----\n\n\n\n# 二、案例：搭建登录页\n\n## 步骤1：创建控制器和方法\n\n在后台admin中创建一个PublicController控制器的login方法，输出登录的内容\n\n![](media1/image79.png)\n\n\n\n## 步骤2：定义路由\n\n```php\nRoute::any('admin/public/login','admin/public/login');\n```\n\n\n\n## 步骤3：配置和修改模版\n\n把后台模板`login.html`复制到`admin/view/public/`下面，并替换静态资源文件路径\n\n![](media1/image80.png)\n\n效果：\n\n![](media1/image81.png)\n\n----\n\n\n\n# ==TP5第二天==\n\n# 一、案例：完成后台登录功能\n\n## 1、代码实现\n\n一般系统第一个用户都是手工添加的，在`application/config.php`中添加一个密码的加密串（盐）\n\n![](media2/image40.png)\n\n把密码和盐md5加密的结果复制到password字段中\n\n![](media2/image41.png)\n\n## 2、完成登录的实现 \n\n**步骤1**：在login登录的表单中设置input的name属性和表的字段==保持一致==，同时设置提交方式为post提交\n\n![](media2/image42.png)\n\n**步骤2**：在`login`方法中，判断是否是**post**请求，完成用户的登录逻辑\n\n![](media2/image43.png)\n\n**步骤3**：在User模型中定义一个`checkuser`方法，判断用户名和密码是否匹配成功，成功把用户信息写入**session**中\n\n![](media2/image44.png)\n\n在后台首页，回显session的用户名，修改`top.htm`页面\n\n![](media2/image45.png)\n\n效果：\n\n![](media2/image46.png)\n\n## 3、补充 \n\n### 3.1、跳转\n\n在应用开发中，经常会遇到一些带有提示信息的跳转页面，例如操作成功或者操作错误页面，并且自动跳转到另外一个目标页面。系统的`\\think\\Controller`类内置了两个跳转方法`success()`和`error()`\n\n**成功跳转**：`$this->success($msg,$url,$data,$time)`\n\n**失败跳转**：`$this->error($msg,$url,$data,$time)`\n\n参数说明：\n\n-   `msg`：跳转的提示信息\n\n-   `url` ：跳转的地址。 可以直接使用助手函数`url()`生成地址。失败默认跳回上一页（`history.go(-1)`）。一般不需要指定\n\n-   `data `：返回的数据，一般不写，留空即可\n\n-   `time`  ：默认成功和失败等待时间都是3秒\n\n\n\n### 3.2、重定向\n\n**语法**:\n\n```php\n$this-> redirect($url,[$params]); \n```\n\n**参数说明**：\n\n-   `$url`：跳转的地址, 格式为 `模块/控制器/方法`\n\n    \\$this-\\> redirect('index')，未指定模块和控制器，默认会重定向到**当前模块**的**当前控制器**的index方法。\n\n    在路由的强制模式前提下，则url必须是路由中定义的规则\n\n-   `$params`：跳转携带的参数，数组形式如：传参数id为3，`[id=>3]`\n\n    \n\n    **==问：什么时候使用跳转和重定向？==**\n\n    答：\n\n    **1、需要给用户操作的提示信息，则用跳转。**\n\n    一般是删除或编辑失败的时候，这需要给用户提示错误信息，操作失败则用跳转error，成功用success。\n\n    **2、不需要给任何提示信息，则用重定向。**\n\n    如用户登录成功不需要给提示信息则直接redirect重定向到首页，登录失败就用error给用户提示错误信息。\n\n\n\n### 3.3、session\n\n**tp5中session会话默认是开启的**\n\n\n\n-   设置sesion信息\n\n    ```php\n    session('键','值');\n    ```\n\n    \n\n-   获取session信息\n\n    ```php\n    session('键');\n    ```\n\n    \n\n-   清除session信息\n\n    ```php\n    session('键',null); //清除一个\n    session(null); //清除当前会话所有的session\n    ```\n\n----\n\n\n\n\n# 二、案例：完成后台退出功能\n\n思路：**清除用户登录成功所设置的session信息**\n\n**步骤1**：在后台`admin`的`publicController`控制器中建立一个`logout`的方法完成退出的实现\n\n![](media2/image47.png)\n\n**步骤2**：设置退出链接的链接地址，并设置好路由\n\n![](media2/image48.png)\n\n**步骤3**：定义退出路由\n\n```php\nRoute::group('admin',function(){\n\tRoute::get('/user/logout','admin/user/logout');\n});\n```\n\n---\n\n\n\n# 三、案例：完成登录防翻墙\n\n**核心思想**： 建立一个公共的控制器如：`CommonController`，在此控制器中做权限验证，判断是否有没有session,其他需要验证用户登录session信息的控制器就需要继承此控制器即可。\n\n把验证session的写在`CommonController`控制器的初始化方法`_initialize`中,\n\n![](media2/image49.png)\n\n需要验证session的控制器，继承Common即可\n\n![](media2/image50.png)\n\n注：Public控制器不可以继承，因为此时还没有登录进来，未有session信息。\n\n----\n\n\n\n# 四、验证器实现登录验证（新增）\n\n## 1、验证器概述\n\nThinkPHP5.0使用独立的`\\think\\Validate`验证器类进行验证。\n\n手册位置：验证==>验证器。\n\n![](media2/image51.png)\n\n## 2、基本使用\n\n**步骤1**. 先在控制器中先引入验证器类\n\n```php\nuse \\think\\Validate;\n```\n\n\n\n**步骤2**. 定义验证规则和提示信息：\n\n```php\n$rule = [\n'表单name值'\t=> '规则'   // （多个规则竖线‘|‘隔开）\t\n      ......\n];\n//定义验证不通过的提示信息\n$msg = [\n\t'表单name值.规则名'\t=> '规则的不通过时的提示信息'\n  ......\t\n]\n```\n\n\n\n**步骤3**. 进行数据验证\n\n**单个验证：**\n\n```php\n$validate = new Validate($rule,$msg);\n$result = $validate->check($data);\n```\n\n**参数**：$data是要验证的数据，要求是==一维数组==，其**键名**和规则**rule中的键名**需一致。\n**返回值**：验证成功返回**true**,失败返回对应规则的错误提示信息，通过`$validate->getError());`可获取到错误信\n\n\n\n**批量验证:**\n\n当需要同时验证多个规则的时候使用`batch()`方法即可\n\n```php\n$result = $validate->batch()->check($data);\n```\n\n**返回值**：验证成功返回**true**，批量验证不通过，返回的是一个错误信息的数组[err1,err2]\n\n\n\n## 3、代码如下\n\n**步骤1**：引入验证器类\n\n![](media2/image52.png)\n\n**步骤2**：在`login`方法中定义验证器进行数据的验证\n\n![](media2/image53.png)\n\n----\n\n\n\n# ==TP5第三天==\n\n\n\n# 一、案例：完成登录的验证码功能\n\n手册位置：杂项\\--\\>验证码\n\n**步骤1**：找到`login.html`模板，设置**img**的**src**为`{:captcha_src()} `\n\n![](media3/image13.png)\n\n**步骤2**：设置验证码的配置\n\n![](media3/image14.png)\n\n**步骤3**：设置随机数，单击验证码时，可重新请求验证码\n\n![](media3/image15.png)\n\n**步骤4**：单击登录按钮，在`login`方法中判断验证码是否输入正确\n\n![](media3/image16.png)\n\n**步骤5**：页面输入错误，返回来时候。让验证码自执行单击事件，即刷新验证码：\n\n![](media3/image17.png)\n\n效果：\n\n![](media3/image18.png)\n\n----\n\n\n\n# 二、案例：完成文章分类的添加\n\n## 1、输出添加分类的模板展示\n\n**步骤1**：在后台`admin`的`CategoryController`控制器中添加一个`add`方法，输出模板\n\n![](media3/image19.png)\n\n**步骤2**：定义访问的路由（`application/route.php`）\n\n```php\nRoute::group('admin',function(){\n\tRoute::get('/category/add','admin/category/add');\n});\n```\n\n**步骤3**：设置后台的菜单链接\n\n![](media3/image20.png)\n\n**步骤4**：把后台模板`add.html`模板文件复制到以下目录，并替换静态资源文件路径\n\n![](media3/image21.png)\n\n如替换css路径：\n\n![](media3/image22.png)\n\n并修改模板的内容：\n\n![](media3/image23.png)\n\n效果如下：\n\n![](media3/image24.png)\n\n**步骤5**：==获取无限极分类数据显示在select框中==\n\na.  在`Category`模型中定义一个无限极分类的方法\n\n![](media3/image25.png)\n\nb.  控制器调用上面的方法，并把数据分类到模板中\n\n![](media3/image26.png)\n\nc.  模板中进行遍历\n\n![](media3/image27.png)\n    \n效果：\n    \n![](media3/image28.png)\n\n\n\n\n## 2、完成添加分类数据的入库\n\n**步骤1**：把**get**路由换成**any**形式\n\n```php\nRoute::group('admin',function(){\n\tRoute::any('/category/add','admin/category/add');\n});\n```\n\n**步骤2**：在`add`方法判断是否是**post**请求，完成数据的入库操作\n\n![](media3/image29.png)\n\n----\n\n\n\n# 三、案例：完成文章分类的列表展示\n\n**步骤1**：修改`left.html`文件的链接地址\n\n![](media3/image30.png)\n\n**步骤2**：设置路由\n\n```php\nRoute::group('admin',function(){\n\tRoute::any('/category/index','admin/category/index');\n});\n```\n\n**步骤3**：建立一个`index`的方法，取出分类的数据并分配在模板中，输出模板内容\n\n![](media3/image31.png)\n\n**步骤4**：把后台模板`showlist.html`复制到对应目录，并修改静态资源文件路径\n\n![](media3/image32.png)\n\n效果：\n\n![](media3/image33.png)\n\n注：其中`create_time`和`update_time`在数据库中是时间戳**int**的格式，可以在配置文件`application/database.php`中修改以下配置项，在模板中显示时就会自动转化为日期格式：\n\n![](media3/image34.png)\n\n如果不想转化，可以在对应的模型类中进行取消。\n\n![](media3/image35.png)\n\n----\n\n\n\n# 四、案例：完成文章分类的编辑 \n\n## 1、实现编辑分类数据回显到模板中\n\n**步骤1**：修改`index.html`模板的编辑的链接地址，并设置好路由\n\n![](media3/image36.png)\n\n```php\nRoute::group('admin',function(){\n\tRoute::any('/category/upd,'admin/category/upd);\n});\n```\n\n**步骤2**：建立一个`upd`的方法，根据`cat_id`的参数，取出当前分类的数据，分配到模板中\n\n![](media3/image37.png)\n\n**步骤3**：在`upd.html`模板中进行回显数据。模板可复制当前的`add.html`\n\n![](media3/image38.png)\n\n==小技巧：==\n\n```\n$(\"select\").val(3); //把option的value=3的默认选中\n$(\"select\").val(当前分类的父分类cat_id);\n```\n\n![](media3/image39.png)\n\n\n\n## 2、实现分类编辑的数据入库\n\n在`upd`方法中判断**post**请求，完成编辑的数据入库\n\n![](media3/image40.png)\n\n----\n\n\n\n# 五、把验证器独立出来使用 \n\n如果把验证的逻辑都写在控制器的方法中，那么方法就会变的很臃肿且难以维护，且还会写出和其他功能相同的规则，造成代码冗余，我们可以把这些验证规则单独写一个验证器类中。方便后期维护，让控制器方法逻辑更加直观。\n\n**步骤1**：在模块中创建一个`validate`目录，存储验证器类。 验证类名建议和模型类名保持一致\n\n![](media3/image41.png)\n\n验证场景解读\n\n```php\n$scene=[\n    //后面未写规则，则验证 【规则名】 下所有规则，多个规则用竖线 | 隔开\n    //'场景名'=>['规则名'=>'规则|规则','规则名'],\n    'upd'=>['cat_name'=>'require|unique','pid'],\n];\n```\n\n\n\n**步骤2**：使用上面的验证器进行验证\n\n如，在分类的`add`方法中使用：\n\n![](media3/image42.png)\n\n**注：使用外部的单独验证器类进行验证，不需要引入。调用validae方法时候框架会自动加载**\n\n**validate**方法的源码位置：`thinkphp\\library\\Controller.php`\n\n![](media3/image43.png)\n\n**参数1**：验证的数据，要求是一个一维数组，键名是表的字段名。\n\n**参数2**：`验证器名.场景名`\n\n​\t\t如果只写验证器名，则验证所有的元素规则。若只验证add场景下的元素，则这么写：验证器名.add\n\n**参数3**：提示信息，默认写\\[\\]即可。\n\n**参数4**：true为批量验证，false验证单个验证。\n\n**返回值**：\n\n验证成功，返回**true**\n\n验证失败，批量验证返回**错误**数组，单个验证返回一个错误的字符串。\n\n----\n\n\n\n# 六、案例：使用Ajax完成文章分类的无刷新删除 \n\njqueyr发送ajax请求：\n\n-   `$.ajax({})` 发送get也可以post，可以控制同步或异步。\n\n-   `$.get(url,data,callback,dataType)` 只能发送get请求，默认是异步,只有成功的回调函数。\n\n-   `$.post(url,data,callback,dataType) `只能发送post请求，默认是异步，只有成功的回调函。\n\n\n\n**==删除分类的注意事项：==**\n\n-   当前分类下不能存在子分类\n\n-   当前分类下面不能存在文章\n\n    \n\n满足上面两个条件之一都不能删除。\n\n\n\n**步骤1**：给`index.html`模板页面的删除链接阻止默认行为、设置自定义属性`cat_id`记录当前要删除的分类，设置类名为`delCat`。\n\n![](media3/image44.png)\n\n**步骤2**：给`class='delCat'`，绑定单击事件，获取`cat_id`的属性值，发送ajax请求\n\n![](media3/image45.png)\n\n查看get和post所传递的参数，查看抓包的**header**选项：\n\n![](media3/image46.png)\n\n![](media3/image47.png)\n\n**步骤3**：在CategoryController控制器建立一个`ajaxDelCat`的方法，完成分类的删除\n\na.  定义路由\n\n```php\nRoute::group('admin',function(){\n\tRoute::get('/category/ajaxdelcat','admin/category/ajaxdelcat');\n});\n```\n\n![](media3/image48.png)\n\n![](media3/image49.png)\n\n**步骤4**：判断状态码等于200，即删除成功，移除当前**tr**行\n\n![](media3/image50.png)\n\n----\n\n\n\n# 七、案例：完成文章的添加\n\n## 1、输出添加文章模板的展示\n\n**步骤1**：在后台`admin`创建一个`ArticleController`，并建立一个`add`方法输出模板内容。\n\n![](media3/image51.png)\n\n**步骤2**：设置`add.html`模板的**name**名称\n\n![](media3/image52.png)\n\n## 2、集成富文本编辑器到文章的内容添加页中\n\n**步骤1**：把**ueditor**编辑器复制到`/public/plugins/`目录下面\n\n![](media3/image53.png)\n\n**步骤2**：引入富文本编辑器的三个js文件（可参考上面的index.html文件）\n\n![](media3/image54.png)\n\n给文本域textarea设置一个id，给此id进行初始化。\n\n![](media3/image55.png)\n\n效果如下：\n\n![](media3/image56.png)\n\n## 3、实现文章数据的入库\n\n在`add`方法中判断是否是**post**请求，完成数据入库\n\n![](media3/image57.png)\n\n定义验证器的**add**验证场景：\n\n![](media3/image58.png)\n\n设置模型的时间戳自动维护：\n![](media3/image59.png)\n\n\n\n----\n\n\n\n# ==TP5第四天==\n\n# 一、案例：完成文章的图片上传和缩略图生成\n\n## 1、实现文章的图片上传\n\n**上传文件的要求：**\n\n-   **post**请求\n\n-   设置**form**标签的`enctype='multipart/form-data'`\n\n    \n\n    **步骤1**：设置表单上传文件的要求\n\n    ![](media4/image1.png)\n\n    **步骤2**：设置文件上传域`type=file`\n\n    ![](media4/image2.png)\n\n    **步骤3**：在`add`的方法中，接收文件信息，进行文件上传\n\n    手册位置：杂项-\\>上传\n\n    ![](media4/image3.png)\n\n    在当前控制器中，封装一个上传文件的方法，成功返回图片的路径\n\n    ![](media4/image4.png)\n\n    上传成功如下：\n\n    ![](media4/image5.png)\n\n    数据库存储的路径：\n\n    ![](media4/image6.png)\n\n    **步骤4**：限制上传图片的一些要求：如图片的后缀，图片的大小\n\n    ![](media4/image7.png)\n\n\n\n## 2、实现文章图片缩略图生成\n\n手册位置：杂项-\\>图像处理\n\n安装`topthink/think-image`包通过执行以下指令：\n\n```php\ncomposer require topthink/think-image=1.0.7\n```\n\n![](media4/image8.png)\n\n下载好如下所示：\n\n![](media4/image9.png)\n\n使用缩略图进行缩放处理：\n\n![](media4/image10.png)\n\n表中存储的字段内容如下：\n\n![](media4/image11.png)\n\n原图是路径默认反斜杠`\\`分隔，缩略图路径默认是正斜杠，需要注意。\n\n效果如下：\n\n![](media4/image12.png)\n\n----\n\n\n\n# 二、案例：完成文章列表的展示\n\n## 1、实现文章列表在模板中展示\n\n**步骤1**：设置`left.html`的链接地址\n\n![](media4/image13.png)\n\n**步骤2**：设置路由\n\n```php\nRoute::group('admin',function(){\n\tRoute::any('/article/index','admin/article/index');\n});\n```\n\n**步骤3**：在`ArticleController`建立一个`index`的方法，获取文章数据，分配到模板中\n\n![](media4/image14.png)\n\n**步骤4**：模板中遍历数据\n\n![](media4/image15.png)\n\n效果：\n\n![](media4/image16.png)\n\n\n\n## 2、实现文章列表的分页功能\n\n手册位置：杂项-\\>分页\n\n在`index`方法中，把模型的select方法改为**paginate**(每页显示的条数)\n\n![](media4/image17.png)\n\n在模板中调用`render()`方法进行渲染出分页的页码结构：\n\n![](media4/image18.png)\n\n注意：默认tp5分页页码是没有样式，我们自己需自定义样式，可以引入`page.css`文件。\n\n![](media4/image19.png)\n\n效果：\n\n![](media4/image20.png)\n\n----\n\n\n\n# 三、案例：文章的编辑\n\n## 1、实现编辑数据回显到模板中\n\n**步骤1**：给`index.html`的编辑设置链接地址\n\n![](media4/image21.png)\n\n**步骤2**：设置路由\n\n```php\nRoute::group('admin',function(){\n\tRoute::any('/article/upd,'admin/article/upd');\n});\n```\n\n**步骤3**：建立一个`upd`方法，取出当前分类的数据，回显到模板中\n\n![](media4/image22.png)\n\n**步骤4**：模板中进行回显\n\n![](media4/image23.png)\n\n![](media4/image24.png)\n\n效果：\n\n![](media4/image25.png)\n\n\n\n## 2、实现编辑数据入库\n\n在`upd`方法中，判断是否是**post**请求\n\n![](media4/image26.png)\n\n编辑还需要完成图片上传，有图片，则在上传时需要把原图给移除\n\n![](media4/image27.png)\n\n----\n\n\n\n# 四、案例：文章的删除\n\n**步骤1**：给删除的链接地址设置一个**url**\n\n![](media4/image28.png)\n\n**步骤2**：设置删除的路由\n\n```php\nRoute::group('admin',function(){\n\tRoute::any('/article/del,'admin/article/del');\n});\n```\n\n**步骤3**：在`articleController`中建立一个`del`的方法，完成删除，并删除文章的图片\n\n![](media4/image29.png)\n\n删除文件`unlink`方法：\n\n![](media4/image30.png)\n\n----\n\n\n\n# 五、案例：ajax+layer弹出层获取文章内容\n\n**步骤1**：设置查看文章内容的标签\n\n![](media4/image39.png)\n\n**步骤2**：给`class=showContent`绑定单击事件\n\n![](media4/image40.png)\n\n**步骤3**：设置一个路由\n\n```php\nRoute::group('admin',function(){\n\tRoute::any('/article/showcontent','admin/article/showcontent');\n});\n```\n\n**步骤4**：在`ArticleController`建立一个`showContent`方法，获取文章的详情，返回**json**格式数据\n\n![](media4/image41.png)\n\n**步骤5**：把响应的内容在==layer==弹出层进行显示\n\na.  把下载下来的插件的压缩包中的layer文件夹复制`/public/plugins/`目录下\n\n![](media4/image42.png)\n\nb.  引入上面插件的核心js文件layer.js\n\n![](media4/image43.png)\n\nc.  页面层中显示内容\n\n![](media4/image44.png)\n    \n效果：\n![](media4/image45.png)\n\n----\n\n\n\n# 六、案例：实现上传图片的预览\n\n参考文件：\n\n![](media4/image46.png)\n\n**步骤1**：在`add.html`文件中引入核心js文件\n\n![](media4/image47.png)\n\n**步骤2**：给上传文件域设置**onchange**事件，以及设置图片预览的区域\n\n![](media4/image48.png)\n\n效果：\n\n![](media4/image49.png)\n\n\n\n----\n\n\n\n\n\n","categories":["ThinkPHP5框架"]},{"title":"会话技术","url":"%2Fposts%2F790821465%2F","content":"\n\n\n# 会话技术\n\n## 1. 会话技术相关概念\n\n### 为什么使用会话技术\n\n1)我们访问网站走的是HTTP协议，协议具有无连接无状态的特性，对事物的处理不具有记忆能力；\n\n2)我们在web项目中，很多时候需要将会话数据记忆存储，以便后续的程序能够随时调用和使用；\n\n \n\n在web项目中我们可以通过会话技术解决以上问题。\n\n\n\n### 什么是会话技术\n\n通俗的讲：会话技术就是浏览器和服务器“唠嗑”。\n\n\n\n**==概念==**：在web页面访问过程中，使访问过程中产生的数据==持久化存储==的一种技术。\n\n\n\n## 2. 会话技术的分类\n\n会话技术按==照数据存储的位置==划分，分为两类：\n\n- [x] COOKIE技术；\n- [x] SESSION技术；\n\n\n\n## 3. ==COOKIE技术==\n\n==**概念**==：将数据持久化存储在==浏览器端==，并且能够==使数据标识服务器==的一种技术。\n\n\n\n### 基本操作\n\n#### 设置操作（增删改）\n\n涉及的函数：\n\n> **setcookie**(名,  值)       设置COOKIE数据\n\n\n\n**==需求==**：分别实现增、删、改COOKIE数据的操作，要求\n\n1. 访问code1.php文件，实现新增一条COOKIE数据，名为：name，值为：zhangsan；\n2. 访问code2.php文件，实现修改\"1\"中新增的COOKIE数据，新值为：lisi；\n3. 访问code3.php文件，实现删除COOKIE数据name；\n\n**==解答==**：构建名为code1.php的程序文件，代码如下：\n\n```php\n<?php\n\n#新增COOKIE数据\nsetcookie('name', 'zhangsan');\n```\n\n访问code1.php后新增COOKIE数据的效果为：\n\n![1529978044769](2.png)\n\n构建名为code2.php的程序文件，代码如下：\n\n```php\n<?php\n\n#修改COOKIE数据，名不变，值改变\nsetcookie('name', 'lisi');\n```\n\n访问code2.php后修改COOKIE数据的效果为：原来为zhangsan，现在为lisi\n\n![1529978156853](3.png)\n\n构建名为code3.php的程序文件，代码如下：\n\n```php\n<?php\n\n#删除COOKIE数据，名不变，值变为空字符串\nsetcookie('name', '');\n```\n\n访问code3.php后删除COOKIE数据的效果为：原来有name=lisi数据，现在被删除了\n\n![1529978258153](4.png)\n\n\n\n**==小结==**：\n\n1. setcookie函数可以实现增，删，改COOKIE数据的操作。\n\n\n\n#### 查看操作\n\n**==需求==**：分别查看COOKIE数据的操作，要求\n\n1. 访问code4.php文件，实现新增两条COOKIE数据，第一条名为：name，值为：wangwu，第二条名为：age，值为：16；\n2. 访问code5.php文件，实现新增一条COOKIE数据名为：height，值为：1.78，同时查看并打印所有的COOKIE数据；\n3. 访问code6.php文件，查看并打印出所有的COOKIE数据；\n\n**==解答==**：构建名为code4.php的程序文件，代码如下：\n\n```php\n<?php\n\n#新增两条COOKIE数据\nsetcookie('name', 'wangwu');\nsetcookie('age', '16');\n```\n\n访问code4.php后新增COOKIE数据的效果为：\n\n![1529979097450](5.png)\n\n构建名为code5.php的程序文件，代码如下：\n\n```php\n<?php\n\n//再新增一条COOKIE数据\nsetcookie('height', 1.78);\n\n#打印目前所有的COOKIE数据\nvar_dump( $_COOKIE ); \n```\n\n访问code5.php后打印效果为：\n\n![1529979341453](6.png)\n\n构建名为code6.php的程序文件，代码如下：\n\n```php\n<?php\n\n#打印目前所有的COOKIE数据\nvar_dump( $_COOKIE ); \n```\n\n访问code6.php后打印效果为：\n\n![1529979415024](7.png)\n\n\n\n**==小结==**：\n\n1. 查询操作只需要使用$_COOKIE超全局预定义数组变量就可以办到。\n\n\n\n**==提问==**：在访问code4.php时首先生成了两条COOKIE数据，然后再访问code5.php时在程序中又新增了一条COOKIE数据，按道理来说一共现在有3条COOKIE数据，但是访问code5.php时只打印出了code4.php中生成的2条，然而，再访问新的文件code6.php时却能够打印三条，为什么呢？\n\n\n\n### COOKIE技术的基本原理\n\n**==原理图==**：\n\n![1529980095166](8.png)\n\n\n\n**==小结==**：\n\n1. COOKIE数据时存储在浏览器端的；\n2. 每当请求服务器时，只要存在该服务器的COOKIE数据，则会随着本次请求将**==所有==**的COOKIE数据全部携带上，一起去到服务器；\n\n\n\n### setcookie与$_COOKIE变量之间的关系\n\n**==关系图==**：\n\n![1529980979714](9.png)\n\n\n\n**==小结==**：\n\n1. setcookie函数只负责一件事情，在接下来响应浏览器的时候，告诉浏览其应该去设置一条什么样的COOKIE；\n2. $_COOKIE只有在程序编译阶段才被PHP执行初始化操作，执行setcookie函数不会直接操作到$\\_COOKIE;\n\n\n\n### COOKIE数据的属性设置\n\nsetcookie除了前两个参数表示名和值之外，还有五个属性相关的参数，分别是： \n\n> **setcookie**(名, 值, ==有效期==，==有效路径==，==有效域==，==是否安全传输==，==httponly==);\n\n\n\n#### 有效期\n\n通过setcookie函数的第三个参数来进行设置的；\n\n==不设置==或==设置为0==表示==默认==情况，为一个会话周期；\n\n默认情况一个会话周期为从新增该条COOKIE到浏览器关闭为止。\n\n\n\n**==需求==**：新增一条COOKIE数据，名为：name1，值为：zhaoliu；同时设置这条COOKIE数据的有效期为当前时间过3秒失效。\n\n**==解答==**：构建名为code7.php的程序文件，代码如下：\n\n```php\n<?php\n\n//        设置有效期为当前时间3秒后失效\nsetcookie('name1', 'zhaoliu', time()+3);\n```\n\n访问code7.php，观察监控面板效果：\n\n访问时，生成的COOKIE数据\n\n![1529981567302](10.png)\n\n3秒后，刷新监控面板，发现被浏览器自动清除了，说明有效期生效\n\n![1529981595490](11.png)\n\n**==小结==**：\n\n1. 有效期能够控制COOKIE数据存活的生命周期；\n2. 我们时常利用COOKIE数据的有效期来设置一个过期的时间，以达到删除某条COOKIE数据的效果；\n\n\n\n#### 有效路径\n\n通过setcookie函数的第四个参数来进行设置的；\n\n==不设置==或==设置为空字符串==表示默认情况；\n\n默认情况表示当前程序所在目录及其子目录有效。\n\n\n\n**==需求==**：在code目录中创建名为code9.php的程序文件，新增2条COOKIE数据，\n\n1. 第一条名为：name2，值为：zhaoliu2，不设置其他属性；第二条名为：name3，值为：zhaoliu3，要求这条COOKIE数据的有效路径为\"/\"；\n2. 在当前目录中新建一个新目录demo1，在新目录中创建一个新的程序文件code_demo.php，打印出所有能够获得的COOKIE数据；\n3. 在code目录的上级目录中创建一个新的程序文件code_up.php，打印出所有能够获得的COOKIE数据；\n\n**==解答==**：在code目录下构建名为code9.php的程序文件，代码如下：\n\n```php\n<?php\n//设置了一条普通的COOKIE数据\nsetcookie('name2', 'zhaoliu2');\n//下面这条COOKIE数据的有效路径被设置成了“/”,表示网站的根目录及其子孙目录全有效\nsetcookie('name3', 'zhaoliu3', 0, '/');\n```\n\n访问code9.php，观察监控面板效果：\n\n![1529983381869](12.png)\n\n在code新建一个新目录demo1，并且在新目录中创建一个新的程序文件code_demo.php，代码如下：\n\n```php\n<?php\necho '<pre>';\nvar_dump( $_COOKIE ); \n```\n\n访问code_demo.php文件，观察打印效果：\n\n![1529983466465](13.png)\n\n在code目录的上级目录创建一个新的程序文件code_up.php，代码如下：\n\n```php\n<?php\n\necho '<pre>';\nvar_dump( $_COOKIE ); \n```\n\n访问code_up.php文件，观察打印效果：\n\n![1529983592804](14.png)\n\n\n\n**==小结==**：\n\n1. 我们可以通过setcookie第四个参数设置COOKIE数据的有效路径；\n2. 所能设置的最大有效路径，只能到网站的根目录，网站根目录用\"/\"表示；\n\n\n\n#### 有效域\n\n通过setcookie函数的第五个参数来进行设置的；\n\n==不设置==或==设置为空字符串==表示默认情况；\n\n默认情况表示当前域名及其子域名有效。\n\n\n\n**==需求==**：完成以下要求：\n\n1. 配置一个新的域名\"test.home.com\"和已有的www.home.com域名指向相同的目录；\n2. 构建名为code10.php的程序文件，使用www.home.com域名访问，实现新增两条COOKIE数据，第一条名为：name4，值为：zhaoliu4，不设置其他属性；第二条名为：name5，值为：zhaoliu5，要求这条COOKIE数据的有效域为\"home.com\"；\n3. 构建code11.php文件，在文件中实现打印所有COOKIE数据操作，观察使用www.home.com访问时的效果和test.home.com访问时的效果；\n\n**==解答==**：\n\n首先打开apache的虚拟主机配置文件，新增test.home.com虚拟主机域名配置项，参照www.home.com的配置，如下图所示，\n\n![1529984401422](15.png)\n\n构建名为code10.php的程序文件，代码如下：\n\n```php\n<?php\n//设置了一条普通的COOKIE数据\nsetcookie('name4', 'zhaoliu4');\n//设置第五个参数为顶级域名home.com\nsetcookie('name5', 'zhaoliu5', 0, '', 'home.com');\n```\n\n访问code10.php，观察监控面板效果：\n\n![1529984763148](16.png)\n\n构建名为code11.php的程序文件，代码如下：\n\n```php\n<?php\necho '<pre>';\nvar_dump( $_COOKIE ); \n```\n\n使用www.home.com访问，效果为：\n\n![1529985065407](17.png)\n\n使用test.home.com访问，效果为：\n\n![1529985121137](18.png)\n\n\n\n**==小结==**：\n\n1. 默认情况下，普通的COOKIE数据在当前域名及其子域名有效；\n2. 可以通过第五个参数进行修改，但是最大的域名只能设置成顶级域名；\n\n\n\n#### 是否安全传输\n\n通过setcookie函数的第六个参数来进行设置的；\n\n==不设置==或==设置为false==表示默认情况；\n\n默认情况表示http或https下都有效，如果将值设置为true,则表示只有在https下才有效（包括增删改查）。\n\n\n\n**==需求==**：完成以下要求：\n\n1. 在day4/code/code13.php新增1条COOKIE数据，名为：name6，值为：zhaoliu6，将是否安全传输出行设置为true，使用http://www.home.com域名访问，查看执行效果；\n2. 在day3/code/code_day4.php新增1条COOKIE数据，名为：name6，值为：zhaoliu6，将是否安全传输出行设置为true，使用https://www.t1.com域名访问，查看执行效果；\n\n**==解答==**：在day4/code构建名为code13.php的程序文件，代码如下：\n\n```php\n<?php\n//将第六个是否安全传输参数设置为true\nsetcookie('name6', 'zhaoliu6', 0, '', '', true);\n```\n\n使用http://www.home.com域名访问code13.php，观察监控面板效果：\n\n![1529985676277](19.png)\n\n在day3/code构建名为code_day4.php的程序文件，代码如下：\n\n```php\n<?php\n//将第六个是否安全传输参数设置为true\nsetcookie('name6', 'zhaoliu6', 0, '', '', true);\n```\n\n使用https://www.t1.com域名访问code_day4.php，观察监控面板效果：\n\n![1529985721393](20.png)\n\n\n\n**==小结==**：\n\n1. 如果要想在https下专门设置COOKIE数据成功，则必须指定第六个参数为true;\n\n\n\n#### httponly\n\n通过setcookie函数的第七个参数来进行设置的；\n\n==不设置==或==设置为false==表示默认情况；\n\n默认情况表示除了能够使用原程序脚本代码访问以外，还能够通过其他脚本语言访问到COOKIE数据。如果设置为true，则表示==只==允许原程序脚本代码进行操作。\n\n\n\n**==需求==**：实现如下操作，要求：\n\n1. 构建code14.php程序文件，新增三条COOKIE数据，第一条数据名为：name，值为：zhangsan；第二条数据名为：age，值为：16；第三条数据名为：name1，值为：zhaoliu1，要求第三条数据设置httponly属性为true；\n2. 构建code15.php程序文件，使用PHP打印出所有的COOKIE数据；同时使用javascript代码也打印能够获取的COOKIE数据；\n\n**==解答==**：构建code14.php，代码如下：\n\n```php+HTML\n<?php\n\nsetcookie('name', 'zhangsan');\nsetcookie('age', 16);\n//设置第七个参数为true，表示httponly属性开启\nsetcookie('name1', 'zhaoliu1', 0, '', '', false, true);\n```\n\n访问code14.php，监控面板观察新增的COOKIE数据如下：\n\n![1529998614350](25.png)\n\n构建code15.php，代码如下：\t\n\n```php+HTML\n<?php\n\nvar_dump( $_COOKIE ); \n\n?>\n<script type=\"text/javascript\">\nalert(document.cookie);\n</script>\n```\n\n访问code15.php，观察效果：\n\njavascript输出内容为：\n\n![1529998707791](26.png)\n\nphp输出内容为：\n\n![1529998736539](27.png)\n\n\n\n**==小结==**：\n\n1. httponly属性如果设置为true，则表示只允许源程序脚本语言进行操作；\n\n\n\n### COOKIE技术的局限\n\n1)COOKIE数据保存在浏览器端（用户机器上），不可控因素高，安全性相对比较低。\n\n2)每次请求都会携带所有的COOKIE数据，如果数据量大，将会占用大量的带宽，降低网站加载效率。\n\n \n\n正因为以上局限性，SESSION技术应运而生！\n\n\n\n## 4. ==SESSION技术==\n\n**==概念==**：将数据==持久化存储==在==服务器端==，并且还要==使数据能够区分不同的浏览器==的一种技术。 \n\n\n\n### 基本操作\n\n对SESSION数据的基本操作包括：设置操作（==增删改==）和查询操作。\n\n\n\n**==需求==**：分别实现增、删、改、查SESSION数据的操作，要求\n\n1. 访问code16.php文件，实现新增一条SESSION数据，名为：name，值为：zhangsan；\n2. 访问code17.php文件，实现修改\"1\"中新增的SESSION数据，新值为：lisi；\n3. 访问code18.php文件，实现删除SESSION数据name；\n4. 以上操作实现完成后，都通过访问code19.php文件来进行查看操作；\n\n**==解答==**：构建名为code19.php的程序文件，本文件中实现只输出SESSION数据操作，代码如下：\n\n```php\n<?php\n\n//1. 开启SESSION机制\nsession_start();\n\n//2. 打印出所有的SESSION数据\nvar_dump( $_SESSION ); \n```\n\n构建名为code16.php程序文件，代码如下：\n\n```php\n<?php\n\n//1. 开启SESSION机制\nsession_start();\n\n//2. 新增一条SESSION数据，直接往$_SESSION数组中添加一个元素\n$_SESSION['name'] = 'zhangsan';\n```\n\n先访问code16.php，然后再访问code19.php，输出内容效果如下：\n\n![1529997065186](21.png)\n\n构建名为code17.php的程序文件，代码如下：\n\n```php\n<?php\n\n//1. 开启SESSION机制\nsession_start();\n\n//2. 修改名为name的SESSION数据\n$_SESSION['name'] = 'lisi';\n```\n\n先访问code17.php，然后再访问code19.php，输出内容效果如下：\n\n![1529997190732](22.png)\n\n构建名为code18.php的程序文件，代码如下：\n\n```php\n<?php\n\n//1. 开启SESSION机制\nsession_start();\n\n//2. 删除指定的SESSION数据\nunset($_SESSION['name']);\n```\n\n先访问code18.php，然后再访问code19.php，输出内容效果如下：\n\n![1529997377687](23.png)\n\n\n\n**==小结==**：\n\n1. 在操作SESSION数据之前，必须先开启SESSION机制，方法是：session_start()函数；\n2. SESSION数据的增删改查操作其实就是对$_SESSION这个数组进行元素的增删改查操作；\n\n\n\n### SESSION技术的基本原理\n\n**==原理图==**：\n\n![1529998140298](24.png)\n\n\n\n**==小结==**：\n\n1. SESSION数据是存储在服务器端；\n2. 实现SESSION技术的本质其实是依赖于COOKIE技术，因为能够标识出存储SESSION数据空间的标识就是以COOKIE数据的形态来存在的；\n\n\n\n### $_SESSION与SESSION会话数据区的关系\n\n**==关系图==**：\n\n![1530000015767](28.png)\n\n\n\n**==小结==**：\n\n1. session_start时，如果之前没有开辟过SESSION会话数据区，则重新开辟一个，然后将$_SESSION赋值为空数组；如果已经存在SESSION会话数据区，则直接找到这个数据区，然后将数据区中所有的数据赋值给$\\_SESSION作为$\\_SESSION的数组元素；\n2. 在程序执行的过程中，对$_SESSION变量的任何操作都不会直接操作到SESSION会话数据区；\n3. 整个程序执行的过程中只有两个时机会操作到SESSION会话数据区，一个是session_start时，一个是程序执行结束时，程序执行结束时，将会把$_SESSION数组变量中的所有数据全部覆盖存储进SESSION会话数据区；\n\n\n\n### 销毁SESSION数据（区）\n\n涉及的函数：\n\n> session_destroy()    销毁SESSION会话数据（区）\n\n\n\n**==需求==**：分别实现如下操作\n\n1. 访问code22.php文件，实现新增2条SESSION数据，第一条名为：name，值为：zhangsan；第二条名为：age，值为12；\n2. 访问code23.php文件，先打印出所有的SESSION数据，然后再执行销毁SESSION数据区的操作，接着再次打印所有的SESSION数据；\n3. 访问code24.php文件，打印出所有的SESSION数据；\n\n**==解答==**：构建名为code22.php的程序文件，代码如下：\n\n```php\n<?php\n\n//1. 开启SESSION机制\nsession_start();\n\nvar_dump( $_SESSION ); echo '<hr/>';\n//新增两条SESSION数据\n$_SESSION['name'] = 'zhangsan';\n$_SESSION['age'] = 12;\n\nvar_dump( $_SESSION ); \n\n```\n\n访问code22.php，然后再构建名为code23.php的程序文件，代码如下：\n\n```PHP\n<?php\n\n//1. 开启SESSION机制\nsession_start();\n\nvar_dump( $_SESSION ); echo '<hr/>';//第一次输出\n\n//销毁SESSION数据（区）\nsession_destroy();\n\nvar_dump( $_SESSION ); //第二次输出\n\n```\n\n访问code23.php后，输出的内容为：\n\n```mysql\narray(2) { [\"name\"]=> string(8) \"zhangsan\" [\"age\"]=> int(12) }//第一次输出\narray(2) { [\"name\"]=> string(8) \"zhangsan\" [\"age\"]=> int(12) }//第二次输出\n```\n\n构建code24.php的程序文件，代码如下：\n\n```php\n<?php\n\n//1. 开启SESSION机制\nsession_start();\n\nvar_dump( $_SESSION );\n```\n\n访问code24.php，输出的内容如下：\n\n![1530001165966](29.png)\n\n\n\n**==小结==**：\n\nsession_destroy函数只负责销毁SESSION会话数据区，其他任何事情都不负责处理。\n\n\n\n### SESSION的属性控制\n\nSESSION技术的实现，本质上是依赖于COOKIE技术的，在做SESSION操作的时候，PHP会自动生成一个名为PHPSESSID的COOKIE数据。\n\n既然PHPSESSID是一条COOKIE数据，那么，COOKIE数据所具有的属性PHPSESSID也同样拥有。但是，因为PHPSESSID不是我们通过setcookie函数来新增的，而是PHP帮我们增加的，所以，如果我们要控制PHPSESSID这条特殊的COOKIE数据的属性的话，就必须通过配置php.ini相应的配置项来控制。\n\n#### 有效期\n\n和普通的COOKIE数据==相同==。\n\n默认情况下也是一个会话周期。\n\n一个会话周期表示生成这个COOKIE数据开始到浏览器关闭为止。\n\n#### 有效路径\n\n和普通COOKIE数据==不同==。\n\n默认情况下是网站的==根目录及其子孙目录==下都有效。\n\n#### 有效域\n\n和普通的COOKIE数据==相同==。\n\n都是当前域名及其子域名下有效。\n\n#### 是否安全传输\n\n和普通的COOKIE数据==相同==。\n\n默认情况为http和https都能使用。\n\n#### httponly\n\n这个属性对于SESSION无意义。\n\n#### 在php.ini中的对应配置项\n\n![1530001822134](30.png)\n\n![1530001847896](31.png)\n\n#### SESSION的属性设置\n\n涉及的函数：\n\n> **session_set_cookie_params**(有效期[,  有效路径[,  有效域[,  是否安全传输[,  httponly]]]])\n\n**==案例==**：通过session_set_cookie_params设定有效期，观察效果。\n\n**==实现==**：构建名为code25.php的程序文件，代码如下：\n\n```php\n<?php\n\n//在开启SESSION机制之前设置接下来要生成的PHPSESSID的属性\nsession_set_cookie_params(10, '/', 'home.com');\n\n//1. 开启SESSION机制\nsession_start();\n\n$_SESSION['name'] = 'zhangsan';\nvar_dump( $_SESSION );\n```\n\n访问code25.php观察有效期效果：\n\n![1530003062729](32.png)\n\n有效期10秒后，再刷新监控面板，\n\n![1530003115266](33.png)\n\n\n\n**==小结==**：\n\n1. 虽然SESSION的属性（PHPSESSID的属性）可以通过php.ini来控制，但是我们在项目中并不会采取这种方式，原因是服务器中环境是唯一的，但是项目可能有多个，如果改变环境的配置，则会影响所有的项目，包括不是你的项目；所以我们的使用策略是，什么时候需要，就什么是有设置；\n2. 所以我们可以在程序session_start开启SESSION机制之前使用session_set_cookie_params来进行设置；\n\n\n\n### SESSION的垃圾回收机制\n\nPHP中存在一种针对SESSION会话数据区的垃圾回收机制，如果PHP发现，在==一定的时间内==，==某个SESSION会话数据区没有被使用==，则在下一次访问时，将会==自动==以==一定的概率清除==这个被认为是无效的垃圾SESSION会话数据区。 \n\n\n\n涉及到php.ini中的几个配置项：\n\n![1530003933106](34.png)\n\nPHP对于SESSION数据区是否是一个垃圾数据区的判定方法是：如果发现在session.gc_maxlifetime秒数内，如果还没有任何程序访问这个数据区，则会认为这数据区==可能==是一个垃圾数据区；接着会以session.gc_probability除以session.gc_divisor得到的概率来进行清除；\n\n\n\n**==小结==**：\n\n1. 如果在一定的时间内，PHP发现SESSION数据区没有被任何程序访问，则会认为这个数据区==可能==是一个垃圾会话数据区，则会以php.ini中配置参数形成的概率进行删除这个会话数据区。\n\n\n\n## 8. 全天总结\n\n1. COOKIE技术 指的是  将数据持久化存储在浏览器端，并且使数据能够区分服务器的一门技术；\n\n2. SEESION技术  指的是 将数据持久化存储在服务器端，并且使数据能够区分浏览器的一门技术；\n\n3. COOKIE数据的设置（增删改）操作：使用setcookie函数进行操作；查询操作：使用$_COOKIE变量进行操作；\n\n4. SESSION数据的增删改查操作：1)必须session_start开启SESSION机制；2）然后使用$_SESSION进行增删改查操作，操作的方法就像操作普通数组一样操作；\n\n5. COOKIE技术实现的基本原理：\n\n   1）COOKIE数据存储在浏览器端的；\n\n   2）如果浏览器存在某个服务器的COOKIE数据，则当访问服务器时将会把所有有关该服务器的COOKIE数据全部携带上；\n\n6. setcookie函数与$_COOKIE变量之间的关系：\n\n   1）setcookie函数只是负责在服务器响应浏览器时，告诉浏览器接下来需要去设置一条什么样的COOKIE数据；\n\n   2）$_COOKIE是只负责接收请求时传递过来的COOKIE数据的，setcookie函数执行时并不会直接操作到$\\_COOKIE变量；\n\n7. SESSION技术实现的基本原理：\n\n   1）SESSION数据存储在服务器端的；\n\n   2）SESSION技术本质是依赖于COOKIE技术的，因为如果开辟SESSION会话数据区，将会产生与之对应的PHPSESSID，PHPSESSID是以COOKIE数据的形态存在的；\n\n8. $_SESSION与SESSION会话数据区的关系\n\n   1）session_start时，如果之前没有SESSION数据区，则会开辟一个新的SESSION数据区，同时会将$_SESSION初始化成空数组；如果之前有SESSION数据区，则会直接找到该数据区，并且将数据区中所有的数据初始化给$\\_SESSION变量；\n\n   2）只有当程序执行结束时，$_SESSION中的数据才会一次性覆盖存储进SESSION会话数据区；\n\n   3）在程序执行的过程中，操作$_SESSION变量不会直接立即影响到SESSION数据区中的任何数据；\n\n\n","categories":["会话技术"]},{"title":"PHP变量与常量","url":"%2Fposts%2F327881324%2F","content":"\n\n# PHP变量与常量\n\n----\n\n\n\n## 变量\n\n\n### 变量名的命名规则\n\n* 变量名可以使用**大小写英文字母**、**下划线**、**数字**组成\n\n* 变量名**不可以以数字开头**\n* **变量名不能使用$this 来命名，因为$this它是一个关键字  在面向对象使用**\n* 在定义变量名的时候要做到见名知意\n* 变量名**区分大小写** \n* 如果变量名是由多个单词组成的最好可以使用**下划线连接法**和**驼峰法**\n  * 比如：``$get_user_name``  下划线连接\n  * 比如：``$getUserName `` 从第二个单词开始首字母要大写 \n\n![](php_variable_constant_01.png) \n\n\n### 创建或者声明变量(增)\n\n**语法：**   \n``$变量名 = 值;``\n\n \n\n**注意：**    \n这里的$符号它不是属于变量名的一部分，它只是一种语法规则而已！   \nPHP是一种弱类型的语言，在创建变量的时候不需要指明变量的数据类型！   \n虽然PHP在创建变量的时候不需要指明变量的数据类型， 但是它也是有类型的！它的数据类型是由其值决定的！   \n\n不能使用没有定义的变量。\n\n```php\n<?php\n$name;\n$age=18;\n```\n\n\n\n### 修改变量的值(改)\n\n给变量重新赋值一个值！\n\n```php\n<?php\n//修改变量的值\n$v1=10;\necho $v1; // 10\n$v1=20;  //重新赋值\necho $v1; // 20\n```\n\n![](php_variable_constant_02.png) \n\n\n\n### 获取变量的值(查)\n\n使用输出语句将变量的值输出 \n\n```php\n<?php\n$v1=10;\necho $v1;  //获取变量的值(查)\n```\n\n\n\n### 删除(删)\n\n要删除变量就得使用PHP中的一个内置的系统函数！ \n\n``unset(变量名)``   \n\n使用``unset()``这个函数以后会将变量名与引用给去掉。 \n但其值是被PHP的垃圾回收机制给销毁！   \n\n```php\n<?php\n$v1=10;\necho $v1; \n\nunset($v1);  //销毁变量\necho $v1;   //报错  \n```\n\n\n\n### 可变变量\n\n**概念**：一个变量的值刚好是另外变量的名字！\n\n```php\n<?php\n$v1='abc';\n$abc=10;\n//可变变量语法： $$变量名\necho $$v1; // 10\n```\n----\n\n### 超全局变量\n\n超全局变量也称之为**预定义变量** \n\n**预定义变量：**  PHP系统预先定义变量，这几个变量程序员无法创建！只能使用。   \n得到的结果都是数组。 \n\n![](php_variable_constant_04.png)\n\n下面是一些常用的超全局变量：\n\n#### $_SERVER\n\n**作用**：获取到服务器与浏览器的相关信息！ \n\n\n\n**$_SERVER[‘SERVER_NAME’]**\n\n![](php_variable_constant_05.png)\n\n\n\n**$_SERVER[‘SERVER_ADDR’]**  \n\n![](php_variable_constant_06.png)\n\n\n\n**$_SERVER[‘REMOTE_ADDR’]**  \n\n![](php_variable_constant_07.png)\n\n\n\n**$_SERVER[‘DOCUMENT_ROOT’]**  \n\n![](php_variable_constant_08.png)\n\n\n\n**$_SERVER[‘SCRIPT_FILENAME’]**\n\n![](php_variable_constant_09.png)\n\n\n\n#### $_GET\n\n**作用：**获取到表单以get方式提交的数据或者是用户模拟get方式提交的数据！ \n\n![](php_variable_constant_10.png)\n\n**注意：**\n1. 如果我们需要将表单中数据发送给PHP来进行处理，那么就需要给当前的表单控件标签设置name属性值 。\n\n2. 如果我们不需要将表单中的某一个表单控件的数据提交给PHP来进行处理的话 ，就不需要设置name属性。\n\n   \n\n\n模拟get请求\n\n![](php_variable_constant_11.png)\n\n\n\n#### $_POST\n\n**作用：**获取到表单以POST方式提交的数据！ \n\n![](php_variable_constant_12.png)\n\n\n\n#### $_REQUEST\n\n**$_REQUEST = $_POST +$_GET**      \n\n**作用**：它可以获取表单以post方式提交的数据，也可以获取到表单以get方式提交的数据。 \n\n![](php_variable_constant_13.png)\n\n\n\n----\n\n\n\n## 常量\n\n**什么是常量？**   \n常量一旦被定义就不能修改和删除！这个数据是一直是固定的！常量的值是存放全局数据区的常量区中！  \n\n在一个PHP文件中，常量 的值永远是固定的！它不会发生改变！\n\n\n\n### 常量名的命名规则\n\n* 常量名在定义的时候**不能使用$符号**  \n\n* 常量名的命名规则与变量名其实是差不多的 \n* 常量名命名的时候建议使用大写 \n* 常量名命名的可以很松散 \n\n```php\n//常量名命名可以很松散\n<?php\ndefine('^_^','aaa');\necho constant('^_^');  //输出：aaa\n```\n\n\n\n### 定义常量\n\n**语法：**  \n``define(\"常量名\",常量的值);``  \n\n在新版的PHP中， 可以使用const 这个关键字来定义常量，  const这个关键字它本身是用来定义类常量。  \n\n``const 常量名 = 值; ``\n\n```php\n<?php\n//define定义常量\n//常量名一般是大写，常量一旦被定义，其值不能被修改和删除(unset())\ndefine(\"PI\",3.14);\necho PI;   //3.14\n\n//const定义常量\n//PHP7 新增语法\nconst p = 33;\necho p;  //33\n```\n\n\n\n### 数组常量\n\n在php7之后，常量支持以数组的形式来进行定义。\n\n```php\n<?php\n//定义数组常量\ndefine('ARR',array(1,5));\nvar_dump(ARR);\n\n//数组常量输出：\nArray(\n\t[0] => 1,\n    [1] => 5\n)\n```\n\n\n\n### 检测常量是否被定义\n\n要使用一个PHP中的内置函数来测试常量是否定义。   \n\n``bool defined (string $name)``\n\n \n\n``bool ``   ：指的函数的返回值 。 如果该常量已经定义就得到一个**true** ， 如果该常量没有定义就会得到一个**false**。    \n\n``string $name ``  ：字符串 要求是常量名。也就是说在defined这个函数里面写常量名需要加引号。 \n\n```php\n//检测常量PI是否已定义\nvar_dump(defined('PI'));    //bool(true)\n```\n\n\n\n### 常量名的大小写\n\n一般情况下常量名肯定是区分大小写的 ，可以通过第三个参数来开启不区分大小写。 \n\n``bool define (常量名, 常量值 [, bool $case_insensitive = false ] );``  \n\n关于第三个参数： \n\n* 默认为 **false **表示区分大小写，如果不写就表示区分大小写。  \n* 如果将其写为 **true** 则表示不区分大小写。\n\n----\n\n\n\n### 预定义常量\n\n系统预先定义好的常量 ！\n\n* **PHP_OS** ：输出当前服务器所在的操作系统\n\n* **PHP_VERSION** ：输出当前PHP的版本\n* **PHP_INT_MAX** ：输出PHP中最大的整型数据\n* **PHP_INT_SIZE**     ：输出PHP中整型的所占用的字节数\n\n![](php_variable_constant_14.png)\n\n----\n\n\n\n### 魔术常量\n\n使用的语法和常量是一样的，而且也是预定义的，但是其值是由其所在的位置决定的，可能出现很多的值！  \n\n\n**注意：左右两边各有两个下划线**    \n\n一些常用的魔术常量：  \n\n* ``__DIR__``     获取当前文件所在的目录的路径。   \n\n* ``__FILE__``   **获取当前文件所在的路径。** \n* ``__LINE__``    文件中的当前行号。 \n* ``__FUNCTION__``  当前的函数的名字\n* ``__CLASS__``   **当前的类的名字**\n* ``__METHOD__``  **当前方法的名字**\n\n![](php_variable_constant_15.png)\n\n----\n\n\n\n## 按值传递和按引用传递\n\n**传递：变量与变量之间的赋值** \n\n\n\n### 按值传递\n\n将一个变量的值赋值给另外一个变量，然后修改其中一个变量的值，并**不会影响**到另外一个变量 。这两个变量之间是没有联系的！\n\n![](php_variable_constant_16.png)\n\n \n\n \n\n**问：**将变量$v1给unset掉 会不会影响到变量$v2？\n\n**答**：不会影响到$v2这个变量  \n\n![](php_variable_constant_17.png)\n\n![](php_variable_constant_18.png)\n\n \n\n\n\n### 按引用传递\n\n将一个变量的内存地址赋值给另外一个变量，然后修改一个变量的值 ，它**会影响**到另外一个变量的值。这两个变量之间是有联系的！ \n\n\n在PHP中是通过一个&(求地址运算符)得到一个变量的值内存地址。\n\n![](php_variable_constant_19.png)\n\n \n\n1. 先得到$v1的内存地址，然后将这个内存地址赋值给$v2 。\n2. $v1与$v2这两个变量指向是同一个地址空间！如果修改一个变量的值另外一个变量也会跟着改变。\n\n \n\n**思考一下：**如果将其中一个变量给unset掉，那么会不会影响到另外一个变量？\n\n**答**  ：不会影响到另外一个变量。因为unset这个函数它只是将变量名与引用给销毁，变量的值还在。\n\n![](php_variable_constant_20.png)\n\n\n\n----\n\n\n\n## 变量的数据类型\n\n**PHP中有八种数据类型：**  \n\n整型、浮点型、布尔型、字符串型、数组、对象、资源、NULL \n\n\n\n### 标量数据类型(基本数据类型)\n\n特点：只能存储一个值！  \n\n**整型、浮点型、布尔型、字符串型**\n\n\n\n#### 整型 int 或者integer\n\n``PHP_INT_SIZE``：表示整型的字节数   \n``PHP_INT_MAX``：表示整型的最大数   \n\n\n整型在内存中是使用是**二进制**的方式来表示的！  \n4个字节共表示32位！但是最高位表示符号位。如果最高位是0表示正数，如果1表示负数！  \n\n\n在PHP中定义整型数据可以使用四种方式来表示：   \\\\\\\n(十进制、八进制、十六进制、二进制)\n\n* 十进制：1234  -1234\n* 八进制：以0开头\n* 十六进制：以0x开头\n* 二进制：以0b开头\n\n问：如果给``PHP_INT_MAX+1``会不会报错？\n答：不会，会自动将这个数转换为浮点型数据。\n\n\n\n\n\n#### 浮点数 float或者double\n\n其实浮点数是分为单精度与双精度之分 只是PHP没有作这个区分！  \n浮点数使用8个字节来表示   \n\n**单精度**与**双精度**   \n\n浮点数有两种表示的方式：  \n``小数、指数``  \n\n小数：``12.38``    \n指数：7e3 ---> 7*10^3   \n\n\n如果是使用指数来表示：\n* e后面必须要有数\n* e后面必须是整数 \n\n\n浮点数的字长和平台相关，尽管通常最大值是 1.8e308 并具有 14 位十进制数字的精度（64 位 IEEE 格式）。   \n\n```php\n<?php\n//定义浮点数\n$v1=10.23;\nvar_dump($v1);   //float(10.23)\n\n//使用指数定义浮点数\n$v2=7e3;\nvar_dump($v2); //7*10^3\n```\n\n**注意：**最好不要使用浮点数来进行比较！   \n\n因为计算机只能识别二进制数，需要将0.3转换为二进制数， 乘2取整法   \n因此小数在转换为二进制的时候会丢失精度！\n\n\n\n#### 布尔型 bool或boolean\n\n布尔型常用表示**真**与**假**！  \n\n布尔型只有两个值：``true``和``false `` ，并且这两个单词不区分大小写！  \\\\\\\n\n**要打印布尔型的结果，不能使用 echo 输出，必须使用``var_dump``语句来打印。** \n\n布尔类型一般多用于比较\n```php\n<?php\n//定义布尔类型\n$flag=false;\nvar_dump($flag);  //false\n```\n\n\n\n\n\n#### 字符串数据类型 string\n\n在PHP中定义字符串数据类型总共有四种方式：\n* 单引号 \n* 双引号 \n* heredoc 语法结构 \n* nowdoc 语法结构（自 PHP 5.3.0 起） \n\n\n\n##### 单引号\n\n使用单引号定义的字符串的特点如下：\n1. 单引号不可以解析其中的变量！\n2. 当使用单引号定义字符串时，如果字符串里面又有单引号，需要用反斜线来进行转义。\n3. 单引号定义的字符串里面只能解析转义单引号和转换反斜线。其它的字符转义不了。\n\n```php\n<?php\n//单引号 定义字符串\n$name='张三';\n$res='姓名： $name';   //单引号不可以解析其中的变量\necho $res;\n\n//反斜线来进行转义\n$str='姓名：\\'张三\\'';\necho $str; // 姓名：'张三'\n```\n\n\n\n##### 双引号\n\n 使用双号定义的字符串的特点如下：\n\n* 双引号可以解析其中的变量！\n\n* 当使用双引号定义字符串时，如果字符串里面又有双引号，需要用反斜线来进行转义。\n* 双引号定义的字符转义字符都可以被解析！\n* 双引号内如果有变量名，需要确定变量名边界 。\n\n```php\n<?php\n//双引号 定义字符串\n$name='张三';\n$res=\"姓名： $name\";   \necho $res; //姓名： 张三\n\n//反斜线来进行转义\n$str=\"姓名：\\\"张三\\\" \";\necho $str; // 姓名：\"张三\"\n\n//策略一：变量名与后面的字符串之间加上空格\n$res=\"姓名 $name \";   \n//策略二（标准做法）：将变量名用大括号包裹起来，这里的花括号就表示变量名的边界！\n$res=\"姓名{$name}\";   \n```\n\n![](php_variable_constant_21.png)\n\n\n\n##### heredoc \n\n定界符，就是让用户自己定义字符串的边界！  \n\n适用于定义复杂的、多行的字符串，因为字符串的边界是可以由自己随便定义的，所以可以人为的保证边界和字符串的内部不会发生冲突！\n\n**语法形式**：\n\n```PHP\n<?php\n//注：标记名称前后不能有空格，结束时的标记名称必须靠边。\n// heredoc 相当于双引号定义的字符串    \n<<<标记名称\n    字符串\n标记名称;\n\n//示例\n$str=<<<doc\n    dsfdsfdsf\ndoc;    \n```\n\n\n\n##### nowdoc\n\n**语法形式**：\n\n```PHP\n<?php\n//注：标记名称前后不能有空格，结束时的标记名称必须靠边。\n// nowdoc 相当于单引号定义的字符串    \n<<<'标记名称'\n    字符串\n标记名称;\n\n//示例\n$str=<<<'doc'\n    dsfdsfdsf\ndoc;    \n```\n\n**关于heredoc与nowdoc需要注意的地方**：\n\n1. 当我们在PHP中要定义大量的HTML代码或者是JS代码说可以使用这两种定界符。\n2. heredoc定义的字符串它是可以解析变量的 。\n3. nowdoc定义的字符串它不能解析变量。\n4. nowdoc开始定界符处需要加上单引号。\n5. 不管是heredoc与nowdoc在结束定界符处前面不能有空格 一定要顶格写，开始定界符后面也不要有空格！\n\n\n\n\n\n### 复合数据类型\n\n特点：复合数据类型可以存储多个值！  \n\n**数组、对象**\n\n\n\n（详见其它文档）\n\n\n\n\n### 特殊数据类型\n\n**资源、NULL**\n\n\n\n#### 资源 resource\n\n凡是PHP操作的外部数据，得到的都是资源数据类型！   \n\n\n\n**注意**：  \n\n* 资源数据类型是不能进行定义的，只能读取！\n* 将资源转换为布尔型，会转换为true \n\n```php\n<?php\n$fp=fopen('a.txt','r+');\nvar_dump($fp);  // resource(3) of type(stream)\n```\n\n\n\n\n\n#### 空 Null\n\n**如何得到这个空型：**\n\n* 将一个变量赋值为null  \n* 使用一个没有定义的变量\n* 将一个变量unset掉\n* 调用一个没有返回值的函数 \n\n![](php_variable_constant_22.png)\n\n----\n\n\n\n## 变量数据类型的转换 \n\n变量会根据上下文的环境，数据类型可以会做相应转换！   \n\n分为：**自动转换** 、**强制转换**   \n\n\n\n**注意： **   \n\n不管是自动转换还是强制转换，变量数据类型转换的结果都是相同的！\n\n\n\n### 自动转换\n\nPHP会根据上下文的环境，对变量数据类型进行自动转换！\n\n```php\n//自动转换\n$flag=1;\nif($flag){\n    echo true;\n}else{\n    echo false\n}\n\n// true\n```\n\n\n\n### 强制类型转换\n\n使用PHP中的系统内置函数，将一个变量的数据类型强制的转换为另外一个数据类型！  \n\n**语法：**  \n\n```php\n(目标变量的数据类型)变量名  //把变量数据类型强制的转换为目标变量的数据类型\n```\n\n \n\n| **强制类型转换符** | **转换为的类型** |\n| ------------------ | ---------------- |\n| (int)变量名或者(integer)变量名 | 将变量名强制的转换为整型                |\n| (float)变量名                  | 将变量名强制的转换为浮点型              |\n| (bool)变量名                   | 将变量名强制的转换为布尔型  **true**\\|**false** |\n| (string)变量名                 | 将变量名强制的转换为字符型              |\n| (array)变量名                  | 将变量名强制的转换为一个数组            |\n| (object)变量名                 | 将变量名强制的转换为一个对象            |\n\n\n\n#### 将其它数据类型转换为整型 \n\n``(int)变量名或者(integer)变量名``\n\n| **其它数据类型**                          | **整型的结果** |\n| ----------------------------------------- | :------------: |\n| “字符”                                    |       0        |\n| “数字字符”                                |      数字      |\n| “字符数字”                                |       0        |\n| “”与“  ”与 “0”   空字符串与有空格的字符串 |       0        |\n| false                                     |       0        |\n| true                                      |       1        |\n| null                                      |       0        |\n| float                                     |      取整      |\n\n![](php_variable_constant_23.png)\n\n\n\n#### 将其它的数据类型转换为浮点型\n\n``(float)变量名``\n\n![](php_variable_constant_24.png)\n\n\n\n#### 将其它的数据类型转换为布尔型\n\n``(bool)变量名``\n\n![](php_variable_constant_25.png)\n\n\n\n\n#### 将其它的数据类型为数组\n\n``(Array)变量名``   \n\n**注意：** 在工作中这种方法几乎不会使用。\n\n```php\n<?php\n$v1=10;\n$arr= Array($v1);\nvar_dump($arr);\n```\n\n\n\n\n\n----\n\n\n\n## 与类型相关的函数\n\n### gettype\n语法：\n```php\nstring  gettype ( mixed $var );\n```\n获取到变量的数据类型\n\n![](php_variable_constant_26.png)\n\n \n\n\n\n### settype\n语法：\n```php\nbool settype ( mixed &$var , string $type );\n```\n将变量数据类型设置为指定的类型\n* mixed  &$var：要设置的变量\n* string $type：将变量设置为什么类型\n\n![](php_variable_constant_27.png)\n\n\n\n### isset\n语法：\n```php\nbool  isset(mixed $var1[,mixed $var2]);\n```\n**作用**：判断一个变量是否存在，存在就返回**true**，不存在就返回**false**\n\n\n\n变量不存在有三种情况：\n1. 变量未被声明（没有被初始化）\n2. 变量被unset掉了\n3. 变量的值如果为NULL，也认为不存在！\n\n![](php_variable_constant_28.png)\n\n\n\n### is_int\n语法：\n```php\nbool  is_int ( mixed $var );\n```\n**作用**：检测变量是否是整型，如果$val是整型返回 TRUE，否则返回 FALSE。 \n\n \n\n### is_float\n语法：\n```php\nbool is_float ( mixed $var );\n```\n**作用**：检测变量是否是浮点型，如果 $var 是 float 则返回 TRUE，否则返回 FALSE。\n\n \n\n### is_string\n语法：\n```php\nbool is_string ( mixed $var );\n```\n**作用**：检测变量是否是字符串型，如果 $var 是String则返回 TRUE，否则返回 FALSE。\n\n \n\n### is_bool\n语法：\n```php\nbool is_bool ( mixed $var );\n```\n**作用**：检测变量是否是布尔型 ，如果 $var 是 boolean则返回 TRUE，否则返回 FALSE。\n\n \n\n### is_array\n语法：\n```php\nbool is_array ( mixed $var );\n```\n**作用**：检测变量是否是数组，如果 $var 是 Array则返回 TRUE，否则返回 FALSE。\n\n\n\n### is_null\n语法：\n```php\nbool is_null ( mixed $var );\n```\n**作用**：检测变量是否是NULL，如果 $var 是 null则返回 TRUE，否则返回 FALSE。\n\n\n\n### is_numeric\n语法：\n```php\nbool  is_numeric ( mixed $var );\n```\n**作用**：检测变量是否为数字或数字字符串，如果 $var 是数字和数字字符串则返回 TRUE，否则返回 FALSE。\n\n![](php_variable_constant_29.png)\n\n----\n\n\n\n","categories":["基础知识"]},{"title":"MYSQLI扩展","url":"%2Fposts%2F3495660076%2F","content":"\n\n\n# MYSQLI扩展\n\n## 1. MYSQLI的概念\n\n### 为什么使用MYSQLI扩展\n\n```sequence\nnote left of PHP: 通过MYSQLi进行操作\nPHP-->MYSQL数据库（服务器）:建立连接和认证\nMYSQL数据库（服务器）-->PHP:返回连接信息\nnote left of PHP: 通过MYSQLi进行操作\nPHP-->MYSQL数据库（服务器）:执行各种MYSQL操作指令\nMYSQL数据库（服务器）-->PHP:返回执行的结果\n```\n\n**==小结==**：PHP可以通过使用MYSQLI实现对MYSQL数据库进行操作。\n\n\n\n### 什么是MYSQLI扩展\n\n概念：MYSQLI扩展即PHP利用MYSQL提供的语言操作接口，==封装==出来的一系列操作MYSQL数据库的==函数==和操作类。 \n\n\n\n## 2. ==MYSQLI扩展的使用==\n\nMYSQLI是PHP中的一个==扩展==，扩展的意思即不是默认就自带支持的，而是需要通过额外引入才能使用的。\n\n\n\n所以我们在使用之前，需要先将MYSQLI扩展引入进PHP。\n\n### 引入MYSQLI扩展\n\n> ==步骤==：\n> 第一步，打开PHP的配置文件**php.ini**,去掉php_mysqli.dll前面的注释符号\"；\"\n>\n> ![1529720270909](9.png)\n>\n> 第二步，配置php.ini中的extension_dir配置项，\n>\n> ![1529720394115](10.png)\n>\n> 第三步，确认在extension_dir配置的目录中php_mysqli.dll文件是存在的，\n>\n> ![1529720462175](11.png)\n>\n> 第四步，重启apache，测试是否开启成功\n>\n> 重启apache成功\n>\n> ![1529720522702](12.png)\n>\n> 测试mysqli开启是否成功\n>\n> 在code1.php中构建phpinfo()函数，访问code1.php，查看到如下图所示的mysqli配置项，\n>\n> ![1529720610970](13.png)\n>\n> 如果看到上图，则说明mysqli开启配置成功。\n\n\n\n### 回顾黑窗口对MYSQL数据表数据的基本操作\n\n1. 执行连接数据库相关操作（连接数据库，选择数据库，设置字符集）；\n2. 设置操作（包括：增删改操作）\n3. 查询操作\n\n\n\n### 使用MYSQLI实现连库基本操作\n\n使用MYSQLI实现连库基本操作  相当于  打开黑窗口==连接数据库==，==选择默认的数据库==和==设置字符集==操作。\n\n\n\n> 涉及的函数：\n>\n> **mysqli_connect**(数据库ip地址,  帐号,  密码,  默认选择的数据库)  \n>\n> **mysqli_set_charset**(mysqli连接,  字符集编码)\n>\n> **mysqli_select_db**(mysqli连接, 数据库名) \n\n\n\n**==操作需求1==**：使用MYSQLI实现连接数据库，选择默认的数据库为test，设置字符集为utf8操作。\n\n**==解答==**：构建code2.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\nvar_dump( $link ); echo '<hr/>';\n\n#设置字符集操作\n$re = mysqli_set_charset($link, 'utf8');\nvar_dump( $re ); \n```\n\n输出操作的结果：\n\n```mysql\n####输出的操作结果为：\n//下面这个object对象数据时$link的值，如果有这个输出，说明连接数据库和选择默认的数据库成功\nobject(mysqli)#1 (19) { [\"affected_rows\"]=> int(0) [\"client_info\"]=> string(79) \"mysqlnd 5.0.12-dev - 20150407 - $Id: 38fea24f2847fa7519001be390c98ae0acafe387 $\" [\"client_version\"]=> int(50012) [\"connect_errno\"]=> int(0) [\"connect_error\"]=> NULL [\"errno\"]=> int(0) [\"error\"]=> string(0) \"\" [\"error_list\"]=> array(0) { } [\"field_count\"]=> int(0) [\"host_info\"]=> string(20) \"localhost via TCP/IP\" [\"info\"]=> NULL [\"insert_id\"]=> int(0) [\"server_info\"]=> string(6) \"5.5.24\" [\"server_version\"]=> int(50524) [\"stat\"]=> string(131) \"Uptime: 6444 Threads: 2 Questions: 14 Slow queries: 0 Opens: 33 Flush tables: 1 Open tables: 0 Queries per second avg: 0.002\" [\"sqlstate\"]=> string(5) \"00000\" [\"protocol_version\"]=> int(10) [\"thread_id\"]=> int(15) [\"warning_count\"]=> int(0) }\n\n//下面这个是设置字符集操作的结果\nbool(true)//返回true说明设置字符集成功\n```\n\n\n\n**==操作需求2==**：在\"操作需求1\"的基础上，实现切换选择数据库为db1数据库操作。\n\n**==解答==**：构建code3.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\nvar_dump( $link ); echo '<hr/>';\n\n#设置字符集操作\n$re = mysqli_set_charset($link, 'utf8');\nvar_dump( $re ); echo '<hr/>';\n\n#切换选择新的数据库db1\n$re = mysqli_select_db($link, 'db1');\nvar_dump( $re ); \n```\n\n输出操作的结果：\n\n```mysql\n####输出的操作结果为：\nobject(mysqli)#1 (19) { [\"affected_rows\"]=> int(0) [\"client_info\"]=> string(79) \"mysqlnd 5.0.12-dev - 20150407 - $Id: 38fea24f2847fa7519001be390c98ae0acafe387 $\" [\"client_version\"]=> int(50012) [\"connect_errno\"]=> int(0) [\"connect_error\"]=> NULL [\"errno\"]=> int(0) [\"error\"]=> string(0) \"\" [\"error_list\"]=> array(0) { } [\"field_count\"]=> int(0) [\"host_info\"]=> string(20) \"localhost via TCP/IP\" [\"info\"]=> NULL [\"insert_id\"]=> int(0) [\"server_info\"]=> string(6) \"5.5.24\" [\"server_version\"]=> int(50524) [\"stat\"]=> string(131) \"Uptime: 6659 Threads: 2 Questions: 15 Slow queries: 0 Opens: 33 Flush tables: 1 Open tables: 0 Queries per second avg: 0.002\" [\"sqlstate\"]=> string(5) \"00000\" [\"protocol_version\"]=> int(10) [\"thread_id\"]=> int(16) [\"warning_count\"]=> int(0) }\nbool(true)\n//下面这个为切换选择数据库的操作结果\nbool(true)//返回true说明切换数据库操作成功\n```\n\n**==小结==**：\n\n1. mysqli_connect函数可以实现连接数据库和选择默认的数据库操作；\n2. mysqli_set_charset函数可以实现设置字符集操作；\n3. mysqli_select_db函数可以实现切换选择新的数据库操作；\n\n\n\n### 使用MYSQLI实现关闭数据库连接操作\n\n使用MYSQLI实现关闭数据库操作  相当于  在黑窗口==退出数据库==操作。\n\n\n\n> 涉及的函数：\n>\n> **mysqli_close**(mysqli连接) \n\n\n\n**==操作需求==**：使用MYSQLI实现关闭数据库操作。\n\n**==解答==**：构建code4.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\nvar_dump( $link ); echo '<hr/>';\n\n#关闭数据库连接\n$re = mysqli_close($link);\nvar_dump( $re ); echo '<hr/>';\nvar_dump( $link ); \n```\n\n输出操作的结果：\n\n```mysql\n####输出的操作结果为：\n//下面这个object对象数据时$link的值，如果有这个输出，说明连接数据库和选择默认的数据库成功\nobject(mysqli)#1 (19) { [\"affected_rows\"]=> int(0) [\"client_info\"]=> string(79) \"mysqlnd 5.0.12-dev - 20150407 - $Id: 38fea24f2847fa7519001be390c98ae0acafe387 $\" [\"client_version\"]=> int(50012) [\"connect_errno\"]=> int(0) [\"connect_error\"]=> NULL [\"errno\"]=> int(0) [\"error\"]=> string(0) \"\" [\"error_list\"]=> array(0) { } [\"field_count\"]=> int(0) [\"host_info\"]=> string(20) \"localhost via TCP/IP\" [\"info\"]=> NULL [\"insert_id\"]=> int(0) [\"server_info\"]=> string(6) \"5.5.24\" [\"server_version\"]=> int(50524) [\"stat\"]=> string(131) \"Uptime: 6989 Threads: 2 Questions: 18 Slow queries: 0 Opens: 33 Flush tables: 1 Open tables: 0 Queries per second avg: 0.002\" [\"sqlstate\"]=> string(5) \"00000\" [\"protocol_version\"]=> int(10) [\"thread_id\"]=> int(17) [\"warning_count\"]=> int(0) }\n\n//下面这个是关闭数据库操作的返回值\nbool(true)//返回true说明关闭数据库连接成功\n\n//下面这个是关闭之后再次打印$link的结果，虽然object依然存在，但是里面的数据全部被清空为null值，说明确实被关闭了\nCouldn't fetch mysqli in F:\\home\\class\\day2\\code\\code4.php on line 10\nobject(mysqli)#1 (19) { [\"affected_rows\"]=> NULL [\"client_info\"]=> NULL [\"client_version\"]=> int(50012) [\"connect_errno\"]=> int(0) [\"connect_error\"]=> NULL [\"errno\"]=> NULL [\"error\"]=> NULL [\"error_list\"]=> NULL [\"field_count\"]=> NULL [\"host_info\"]=> NULL [\"info\"]=> NULL [\"insert_id\"]=> NULL [\"server_info\"]=> NULL [\"server_version\"]=> NULL [\"stat\"]=> NULL [\"sqlstate\"]=> NULL [\"protocol_version\"]=> NULL [\"thread_id\"]=> NULL [\"warning_count\"]=> NULL }\n```\n\n**==小结==**：\n\nmysqli_close函数的作用就是用来关闭mysqli数据库连接的。\n\n\n\n### 使用MYSQLI实现设置(增删改)操作\n\n使用MYSQLI实现设置操作  相当于  在黑窗口实现对数据表数据==执行增、删、改SQL语句==操作。\n\n\n\n> 涉及的函数：\n>\n> **mysqli_query**(mysqli连接,  sql语句)            对数据库执行一次查询\n\n\n\n**==操作需求1==**：使用MYSQLI操作test数据库中的cz_user表，实现往数据表cz_user中新增一条数据的操作。\n\n**==解答==**：构建code5.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\nvar_dump( $link ); echo '<hr/>';\n\n#设置字符集\nmysqli_set_charset($link, 'utf8');\n\n#新增操作\n//构建新增数据的SQL语句\n$sql = \"insert into cz_user values (null, '李元霸', '112233')\";//字符串里面不要加分号\n//执行新增语句\n$re = mysqli_query($link, $sql);\nvar_dump( $re ); \n```\n\n输出的结果如下\n\n```mysql\nobject(mysqli)#1 (19) { [\"affected_rows\"]=> int(0) [\"client_info\"]=> string(79) \"mysqlnd 5.0.12-dev - 20150407 - $Id: 38fea24f2847fa7519001be390c98ae0acafe387 $\" [\"client_version\"]=> int(50012) [\"connect_errno\"]=> int(0) [\"connect_error\"]=> NULL [\"errno\"]=> int(0) [\"error\"]=> string(0) \"\" [\"error_list\"]=> array(0) { } [\"field_count\"]=> int(0) [\"host_info\"]=> string(20) \"localhost via TCP/IP\" [\"info\"]=> NULL [\"insert_id\"]=> int(0) [\"server_info\"]=> string(6) \"5.5.24\" [\"server_version\"]=> int(50524) [\"stat\"]=> string(131) \"Uptime: 8221 Threads: 2 Questions: 24 Slow queries: 0 Opens: 34 Flush tables: 1 Open tables: 1 Queries per second avg: 0.002\" [\"sqlstate\"]=> string(5) \"00000\" [\"protocol_version\"]=> int(10) [\"thread_id\"]=> int(18) [\"warning_count\"]=> int(0) }\n//下面这个是执行新增语句后的返回结果\nbool(true)//返回true说明执行新增操作成功\n```\n\n\n\n**==操作需求2==**：使用MYSQLI操作test数据库中的cz_user表，实现修改id为4的数据pwd的值为\"1234abcd\"。\n\n**==解答==**：构建code6.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\nvar_dump( $link ); echo '<hr/>';\n\n#设置字符集\nmysqli_set_charset($link, 'utf8');\n\n#新增操作\n//构建修改数据的SQL语句\n$sql = \"update cz_user set pwd='1234abcd' where id=4\";//字符串里面不要加分号\n//执行修改语句\n$re = mysqli_query($link, $sql);\nvar_dump( $re ); \n```\n\n输出的结果如下\n\n```mysql\nobject(mysqli)#1 (19) { [\"affected_rows\"]=> int(0) [\"client_info\"]=> string(79) \"mysqlnd 5.0.12-dev - 20150407 - $Id: 38fea24f2847fa7519001be390c98ae0acafe387 $\" [\"client_version\"]=> int(50012) [\"connect_errno\"]=> int(0) [\"connect_error\"]=> NULL [\"errno\"]=> int(0) [\"error\"]=> string(0) \"\" [\"error_list\"]=> array(0) { } [\"field_count\"]=> int(0) [\"host_info\"]=> string(20) \"localhost via TCP/IP\" [\"info\"]=> NULL [\"insert_id\"]=> int(0) [\"server_info\"]=> string(6) \"5.5.24\" [\"server_version\"]=> int(50524) [\"stat\"]=> string(131) \"Uptime: 8358 Threads: 2 Questions: 28 Slow queries: 0 Opens: 34 Flush tables: 1 Open tables: 1 Queries per second avg: 0.003\" [\"sqlstate\"]=> string(5) \"00000\" [\"protocol_version\"]=> int(10) [\"thread_id\"]=> int(19) [\"warning_count\"]=> int(0) }\n\n//下面这个是执行修改语句后的返回结果\nbool(true)//返回true说明执行修改操作成功\n\n####数据表中的数据变化效果\n更新前的数据：\nmysql> select * from cz_user;\n+----+----------+---------+\n| id | name     | pwd     |\n+----+----------+---------+\n|  1 | zhangsan | 123abc  |\n|  2 | lisi     | abcdefg |\n|  3 | wangwu   | aaabbb  |\n|  4 | zhaoliu  | aabb    |     <--------这条数据\n|  5 | qinqi    | ccdd    |\n|  6 | 李元霸        | 112233  |\n+----+----------+---------+\n6 rows in set (0.00 sec)\n更新后的数据：\nmysql> select * from cz_user;\n+----+----------+----------+\n| id | name     | pwd      |\n+----+----------+----------+\n|  1 | zhangsan | 123abc   |\n|  2 | lisi     | abcdefg  |\n|  3 | wangwu   | aaabbb   |\n|  4 | zhaoliu  | 1234abcd |     <--------这条数据\n|  5 | qinqi    | ccdd     |\n|  6 | 李元霸        | 112233\n+----+----------+----------+\n6 rows in set (0.00 sec)\n```\n\n\n\n**==操作需求3==**：使用MYSQLI操作test数据库中的cz_user表，删除id为5的数据。\n\n**==解答==**：构建code7.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\nvar_dump( $link ); echo '<hr/>';\n\n#设置字符集\nmysqli_set_charset($link, 'utf8');\n\n#新增操作\n//构建删除数据的SQL语句\n$sql = \"delete from cz_user where id=5\";//字符串里面不要加分号\n//执行删除语句\n$re = mysqli_query($link, $sql);\nvar_dump( $re ); \n```\n\n输出的结果如下\n\n```mysql\nobject(mysqli)#1 (19) { [\"affected_rows\"]=> int(0) [\"client_info\"]=> string(79) \"mysqlnd 5.0.12-dev - 20150407 - $Id: 38fea24f2847fa7519001be390c98ae0acafe387 $\" [\"client_version\"]=> int(50012) [\"connect_errno\"]=> int(0) [\"connect_error\"]=> NULL [\"errno\"]=> int(0) [\"error\"]=> string(0) \"\" [\"error_list\"]=> array(0) { } [\"field_count\"]=> int(0) [\"host_info\"]=> string(20) \"localhost via TCP/IP\" [\"info\"]=> NULL [\"insert_id\"]=> int(0) [\"server_info\"]=> string(6) \"5.5.24\" [\"server_version\"]=> int(50524) [\"stat\"]=> string(131) \"Uptime: 8550 Threads: 2 Questions: 32 Slow queries: 0 Opens: 34 Flush tables: 1 Open tables: 1 Queries per second avg: 0.003\" [\"sqlstate\"]=> string(5) \"00000\" [\"protocol_version\"]=> int(10) [\"thread_id\"]=> int(20) [\"warning_count\"]=> int(0) }\n\n//下面这个是执行删除语句后的返回结果\nbool(true)//返回true说明执行删除操作成功\n\n####数据表中的数据变化效果\n删除前的数据：\nmysql> select * from cz_user;\n+----+----------+----------+\n| id | name     | pwd      |\n+----+----------+----------+\n|  1 | zhangsan | 123abc   |\n|  2 | lisi     | abcdefg  |\n|  3 | wangwu   | aaabbb   |\n|  4 | zhaoliu  | 1234abcd |\n|  5 | qinqi    | ccdd     |        <-------这条将会被删了\n|  6 | 李元霸        | 112233   |\n+----+----------+----------+\n6 rows in set (0.00 sec)\n删除后的数据：\nmysql> select * from cz_user;\n+----+----------+----------+\n| id | name     | pwd      |\n+----+----------+----------+\n|  1 | zhangsan | 123abc   |\n|  2 | lisi     | abcdefg  |\n|  3 | wangwu   | aaabbb   |\n|  4 | zhaoliu  | 1234abcd |\n|  6 | 李元霸        | 112233   |\n+----+----------+----------+\n5 rows in set (0.00 sec)\n\n```\n\n\n\n**==小结==**：\n\nmysqli_query函数可以实现增删改操作；\n\n\n\n### 使用MYSQLI实现查询操作\n\n使用MYSQLI实现查询操作  相当于  在黑窗口==执行查询SQL语句==操作。\n\n\n\n> 涉及的函数：\n>\n> **mysqli_query**(mysqli连接,  sql语句)            对数据库执行一次查询\n>\n> **mysqli_fetch_assoc**(结果集)                         获取作为关联数组的结果行\n>\n> **mysqli_fetch_row**(结果集)\t\t\t\t   获取作为索引数组的结果行\t\n>\n> **mysqli_fetch_all**(结果集[, 数组形态])          获取作为关联（索引）数组的**所有**结果行\n>\n> ​\t\t\t\t\t                           数组形态可指定**MYSQLI_ASSOC**、**MYSQLI_NUM**或**MYSQLI_BOTH**\n\n\n\n**==操作需求1==**：使用MYSQLI操作test数据库中的cz_user表，查询id小于4的所有数据，要求得到的每条数据结果是一个关联数组。\n\n**==解答==**：构建code8.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\n\n#设置字符集\nmysqli_set_charset($link, 'utf8');\n\n#查询操作\n//构建并执行查询SQL语句\n$sql = \"select * from cz_user where id<4\";\n$result = mysqli_query($link, $sql);\nvar_dump( $result ); echo '<hr/>';\n\n//解析返回的$result结果集中的数据\n$row = mysqli_fetch_assoc($result);//第一次解析\nvar_dump( $row ); echo '<br/>';\n$row = mysqli_fetch_assoc($result);//第二次解析\nvar_dump( $row ); echo '<br/>';\n$row = mysqli_fetch_assoc($result);//第三次解析\nvar_dump( $row ); echo '<br/>';\n$row = mysqli_fetch_assoc($result);\nvar_dump( $row ); echo '<br/>';\n$row = mysqli_fetch_assoc($result);\nvar_dump( $row ); echo '<br/>';\n```\n\n执行程序后输出的结果\n\n```mysql\n####下面为输出的结果\n//下面这个object是输出的$result的结果\nobject(mysqli_result)#2 (5) { [\"current_field\"]=> int(0) [\"field_count\"]=> int(3) [\"lengths\"]=> NULL [\"num_rows\"]=> int(3) [\"type\"]=> int(0) }\n\n//下面这个是第一次使用mysqli_fetch_assoc函数解析后的结果，得到的是查询的所有数据中第一条数据的结果，是一个关联数组\narray(3) { [\"id\"]=> string(1) \"1\" [\"name\"]=> string(8) \"zhangsan\" [\"pwd\"]=> string(6) \"123abc\" } \n//下面这个是第二次使用mysqli_fetch_assoc函数解析后的结果，得到的是查询的所有数据中第二条数据的结果，是一个关联数组\narray(3) { [\"id\"]=> string(1) \"2\" [\"name\"]=> string(4) \"lisi\" [\"pwd\"]=> string(7) \"abcdefg\" } \n//下面这个是第三次使用mysqli_fetch_assoc函数解析后的结果，得到的是查询的所有数据中第三条数据的结果，是一个关联数组\narray(3) { [\"id\"]=> string(1) \"3\" [\"name\"]=> string(6) \"wangwu\" [\"pwd\"]=> string(6) \"aaabbb\" } \n//下面这两个NULL值是逐条解析完成数据之后，再继续使用mysqli_fetch_assoc解析后的结果，说明已经无法继续获得数据了，因为前三次已经取完了数据\nNULL \nNULL \n\n\n####下面为查询语句在黑窗口中执行后获得的数据\nmysql> select * from cz_user where id<4;\n+----+----------+---------+\n| id | name     | pwd     |\n+----+----------+---------+\n|  1 | zhangsan | 123abc  |\n|  2 | lisi     | abcdefg |\n|  3 | wangwu   | aaabbb  |\n+----+----------+---------+\n3 rows in set (0.00 sec)\n```\n\n\n\n**==操作需求1小结==**：\n\n1. mysqli_query也能执行查询语句，但是返回的是一个对象类型的查询结果集；\n\n2. mysqli_fetch_assoc的特点：\n\n   ​\ta)每次执行只能解析得到一行数据；\n\n   ​\tb)每次得到的数据是一个关联类型的数组，数组元素的下标对应着数据的字段名，值对应着数据值；\n\n   ​\tc)当解析完成后，再次去执行将会只返回NULL值，说明数据已经再之前全部取完了；\n\n\n\n\n\n**==操作需求2==**：使用MYSQLI操作test数据库中的cz_user表，查询id小于4的所有数据，要求得到的每条数据结果是一个索引数组。\n\n**==解答==**：构建code9.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\n\n#设置字符集\nmysqli_set_charset($link, 'utf8');\n\n#查询操作\n//构建并执行查询SQL语句\n$sql = \"select * from cz_user where id<4\";\n$result = mysqli_query($link, $sql);\nvar_dump( $result ); echo '<hr/>';\n\n//解析返回的$result结果集中的数据\n$row = mysqli_fetch_row($result);//第一次解析\nvar_dump( $row ); echo '<br/>';\n$row = mysqli_fetch_row($result);//第二次解析\nvar_dump( $row ); echo '<br/>';\n$row = mysqli_fetch_row($result);//第三次解析\nvar_dump( $row ); echo '<br/>';\n$row = mysqli_fetch_row($result);\nvar_dump( $row ); echo '<br/>';\n$row = mysqli_fetch_row($result);\nvar_dump( $row ); echo '<br/>';\n```\n\n执行程序后输出的结果\n\n```mysql\n####下面为输出的结果\n//下面这个object是输出的$result的结果\nobject(mysqli_result)#2 (5) { [\"current_field\"]=> int(0) [\"field_count\"]=> int(3) [\"lengths\"]=> NULL [\"num_rows\"]=> int(3) [\"type\"]=> int(0) }\n\n//下面这个是第一次使用mysqli_fetch_row函数解析后的结果，得到的是查询的所有数据中第一条数据的结果，是一个索引数组\narray(3) { [0]=> string(1) \"1\" [1]=> string(8) \"zhangsan\" [2]=> string(6) \"123abc\" } \n//下面这个是第二次使用mysqli_fetch_row函数解析后的结果，得到的是查询的所有数据中第二条数据的结果，是一个索引数组\narray(3) { [0]=> string(1) \"2\" [1]=> string(4) \"lisi\" [2]=> string(7) \"abcdefg\" } \n//下面这个是第三次使用mysqli_fetch_row函数解析后的结果，得到的是查询的所有数据中第三条数据的结果，是一个索引数组\narray(3) { [0]=> string(1) \"3\" [1]=> string(6) \"wangwu\" [2]=> string(6) \"aaabbb\" } \n\n//下面这两个NULL值是逐条解析完成数据之后，再继续使用mysqli_fetch_row解析后的结果，说明已经无法继续获得数据了，因为前三次已经取完了数据\nNULL \nNULL \n\n\n####下面为查询语句在黑窗口中执行后获得的数据\nmysql> select * from cz_user where id<4;\n+----+----------+---------+\n| id | name     | pwd     |\n+----+----------+---------+\n|  1 | zhangsan | 123abc  |\n|  2 | lisi     | abcdefg |\n|  3 | wangwu   | aaabbb  |\n+----+----------+---------+\n3 rows in set (0.00 sec)\n```\n\n\n\n**==操作需求2小结==**：\n\nmysqli_fetch_row函数在特性上和mysqli_fetch_assoc函数一模一样，只有一个区别，mysqli_fetch_row解析后返回的数据结果是一个**索引数组**类型的数据。\n\n\n\n**==操作需求3==**：\n\n1. 使用MYSQLI操作test数据库中的cz_user表，查询id小于3的所有数据\n2. 要求一次性得到所有数据的结果；\n3. 数据结果分别要求输出关联数组数据一份，索引数组数据一份，同时包含关联和索引数组元素的数组一份；\n\n**==解答==**：构建code10.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\n\n#设置字符集\nmysqli_set_charset($link, 'utf8');\n\necho '<pre>';\n#查询操作\n//构建并执行查询SQL语句\n$sql = \"select * from cz_user where id<3\";\n$result = mysqli_query($link, $sql);\nvar_dump( $result ); echo '<hr/>';\n\n//解析返回的$result结果集中的数据\n$row = mysqli_fetch_all($result, MYSQLI_NUM);\necho '索引类型的数据：<br/>'; \nvar_dump( $row ); echo '<hr/>';\n//$row = mysqli_fetch_all($result, MYSQLI_ASSOC);\n//echo '关联类型的数据：<br/>'; \n//var_dump( $row ); echo '<hr/>';\n//$row = mysqli_fetch_all($result, MYSQLI_BOTH);\n//echo '即包含关联类型又包含索引类型的数据：<br/>'; \n//var_dump( $row ); echo '<hr/>';\n```\n\n访问程序code10.php后输出的结果：\n\n```mysql\n##下面这个为$reuslt的输出的数据\nobject(mysqli_result)#2 (5) {\n  [\"current_field\"]=>\n  int(0)\n  [\"field_count\"]=>\n  int(3)\n  [\"lengths\"]=>\n  NULL\n  [\"num_rows\"]=>\n  int(2)\n  [\"type\"]=>\n  int(0)\n}\n\n索引类型的数据：\n##下面这个为mysqli_fetch_all指定第二个参数为MYSQLI_NUM之后的结果\narray(2) {\n  [0]=>\n  array(3) {\n    [0]=>\n    string(1) \"1\"\n    [1]=>\n    string(8) \"zhangsan\"\n    [2]=>\n    string(6) \"123abc\"\n  }\n  [1]=>\n  array(3) {\n    [0]=>\n    string(1) \"2\"\n    [1]=>\n    string(4) \"lisi\"\n    [2]=>\n    string(7) \"abcdefg\"\n  }\n}\n\n\n//关联类型的数据：\n##下面这个为mysqli_fetch_all指定第二个参数为MYSQLI_ASSOC之后的结果\n//array(2) {\n//  [0]=>\n//  array(3) {\n//    [\"id\"]=>\n//    string(1) \"1\"\n//    [\"name\"]=>\n//    string(8) \"zhangsan\"\n//    [\"pwd\"]=>\n//    string(6) \"123abc\"\n//  }\n//  [1]=>\n//  array(3) {\n//    [\"id\"]=>\n//    string(1) \"2\"\n//    [\"name\"]=>\n//    string(4) \"lisi\"\n//    [\"pwd\"]=>\n//    string(7) \"abcdefg\"\n//  }\n//}\n\n\n//即包含关联类型又包含索引类型的数据：\n##下面这个为mysqli_fetch_all指定第二个参数为MYSQLI_BOTH之后的结果,即包含索引类型的数据又包含关联类型的数据\n//array(2) {\n//  [0]=>\n//  array(6) {\n//    [0]=>\n//    string(1) \"1\"\n//    [\"id\"]=>\n//    string(1) \"1\"\n//    [1]=>\n//    string(8) \"zhangsan\"\n//    [\"name\"]=>\n//    string(8) \"zhangsan\"\n//    [2]=>\n//    string(6) \"123abc\"\n//    [\"pwd\"]=>\n//    string(6) \"123abc\"\n//  }\n//  [1]=>\n//  array(6) {\n//    [0]=>\n//    string(1) \"2\"\n//    [\"id\"]=>\n//    string(1) \"2\"\n//    [1]=>\n//    string(4) \"lisi\"\n//    [\"name\"]=>\n//    string(4) \"lisi\"\n//    [2]=>\n//    string(7) \"abcdefg\"\n//    [\"pwd\"]=>\n//    string(7) \"abcdefg\"\n//  }\n//}\n```\n\n**==操作需求3小结==**：\n\n1. mysqli_fetch_all函数能够一次性解析出**所有**查询的结果；\n\n2. mysqli_fetch_all函数还可以指定第二个参数，第二个参数可以是\n\n   **MYSQLI_ASSOC**     返回关联类型的数组数据\n\n   **MYSQLI_NUM**       返回索引类型的数组数据\n\n   **MYSQLI_BOTH**      返回即包含关联类型的又包含索引类型的数组数据\n\n   如果不指定第二个参数，==默认就是MYSQLI_NUM==这个值\n\n\n\n### MYSQLI扩展中辅助操作函数\n\n\n\n> 涉及的函数：\n>\n> **mysqli_field_count**(mysqli连接)\t返回最近一次查询语句查询数据中的总列数\n>\n> **mysqli_num_fields**(结果集)\t获得查询的结果集中字段的个数\n>\n> **mysqli_num_rows**(结果集)\t获得查询结果集中记录的总行数\n>\n> **mysqli_errno**(mysqli连接)\t\t获得错误的错误码值\n>\n> **mysqli_error**(mysqli连接)\t\t获得错误的错误码值对应的错误信息\n>\n> **mysqli_insert_id**(mysqli连接) \t\t获得最近一次新增数据的主键id值\n\n\n\n**==操作需求1==**：\n\n1. 使用MYSQLI操作test数据库中的cz_user表，执行两次查询操作；\n2. 第一次查询所有数据，但是限制最终只获得2条数据；\n3. 第二次查询所有数据，但是限制最终只获得3条数据；\n4. 打印出最近一次查询语句查询数据中的总列数；\n5. 打印第一次查询结果中的总列数；\n6. 打印第一次查询结果集中数据的总行数；\n\n**==解答==**：构建code11.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\n\n#设置字符集\nmysqli_set_charset($link, 'utf8');\n\n#查询操作\n//执行第一次查询操作\n$sql = \"select * from cz_user where 1 limit 2\";\n$result = mysqli_query($link, $sql);\n\n//执行第二次查询操作\n$sql = \"select * from cz_user where 1 limit 3\";\n$result1 = mysqli_query($link,$sql);\n\n//返回最近一次查询语句查询数据中的总列数\n$cols = mysqli_field_count($link);\necho '最近一次查得数据的总列数: ';\nvar_dump( $cols ); echo '<hr/>';\n\n//返回指定的第一次查询语句查询数据中的总列数\n$cols1 = mysqli_num_fields($result);\necho '指定的第一次查得数据的总列数: ';\nvar_dump( $cols1 ); echo '<hr/>';\n\n//返回指定的第一次查询语句查询数据中的总行数\n$rows = mysqli_num_rows($result);\necho '指定的第一次查得数据的总行数: ';\nvar_dump( $rows ); \n```\n\n访问code11.php后输出的结果：\n\n```mysql\n##输出的结果为\n最近一次查得数据的总列数: int(3)\n指定的第一次查得数据的总列数: int(3)\n指定的第一次查得数据的总行数: int(2)\n\n##cz_user表中的所有数据\nmysql> select * from cz_user;\n+----+----------+----------+\n| id | name     | pwd      |\n+----+----------+----------+\n|  1 | zhangsan | 123abc   |\n|  2 | lisi     | abcdefg  |\n|  3 | wangwu   | aaabbb   |\n|  4 | zhaoliu  | 1234abcd |\n|  6 | 李元霸        | 112233   |\n+----+----------+----------+\n5 rows in set (0.00 sec)\n```\n\n\n\n**==操作需求1小结==**：\n\nmysqli_field_count函数可以获得最近一次查询结果中的总列数（没得选）；\n\nmysqli_num_fields函数可以获得指定的某次查询结果中的总列数（有得选）；\n\nmysqli_num_rows函数可以获得指定的某次查询结果中的总行数；\n\n\n\n**==操作需求2==**：\n\n1. 使用MYSQLI执行连库操作，要求要连库成功；同时执行设置字符集操作，要求设置的字符集为\"utf8888\"，使得设置字符集操作失败；\n2. 打印出MYSQLI操作失败的错误信息；\n3. 打印出MYSQLI操作失败错误信息对应的错误码值；\n\n**==解答==**：构建code12.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\n\n#设置字符集\n$re = mysqli_set_charset($link, 'utf8888');\necho '设置字符集的返回值结果: '; \nvar_dump( $re ); echo '<hr/>';\n\n//返回出错的错误信息原因\n$errMsg = mysqli_error($link);\necho '错误的原因：'; \nvar_dump( $errMsg ); echo '<hr/>';\n\n//返回出错的信息对应的错误码值\n$errCode = mysqli_errno($link);\necho '错误码值：'; \nvar_dump( $errCode ); \n```\n\n访问code12.php输出的信息为：\n\n```mysql\n设置字符集的返回值结果: bool(false)\n错误的原因：string(51) \"Invalid characterset or character set not supported\"\n错误码值：int(2019)\n```\n\n\n\n**==操作需求2小结==**：\n\n1. mysqli_errno函数可以实现在出现操作错误时返回错误信息对应的错误码值；\n2. mysqli_error函数可以实现在出现操作错误时返回错误信息；\n\n\n\n**==操作需求3==**：\n\n1. 使用MYSQLI操作test数据库中的cz_user表，向数据表中新增一条数据；\n2. 打印出最近一次新增数据时的主键id；\n\n**==解答==**：构建code13.php程序页面，代码如下\n\n```php\n<?php\n#连接数据库和选择默认的数据库\n$link = mysqli_connect('localhost', 'root', '123abc', 'test');\n\n#设置字符集\nmysqli_set_charset($link, 'utf8');\n\n#新增数据操作\n$sql = \"insert into cz_user values (null, '赵子龙', '1122')\";\nmysqli_query($link, $sql);\n\n//返回最近一次新增数据的主键id值\n$priId = mysqli_insert_id($link);\necho '最近一次新增数据的主键id值:'; \nvar_dump( $priId ); \n\n\n```\n\n访问code13.php输出的结果\n\n```mysql\n最近一次新增数据的主键id值:int(7)\n\n##执行之前数据表的数据\nmysql> select * from cz_user;\n+----+----------+----------+\n| id | name     | pwd      |\n+----+----------+----------+\n|  1 | zhangsan | 123abc   |\n|  2 | lisi     | abcdefg  |\n|  3 | wangwu   | aaabbb   |\n|  4 | zhaoliu  | 1234abcd |\n|  6 | 李元霸        | 112233   |\n+----+----------+----------+\n5 rows in set (0.00 sec)\n\n##执行之后数据表的数据\nmysql> select * from cz_user;\n+----+----------+----------+\n| id | name     | pwd      |\n+----+----------+----------+\n|  1 | zhangsan | 123abc   |\n|  2 | lisi     | abcdefg  |\n|  3 | wangwu   | aaabbb   |\n|  4 | zhaoliu  | 1234abcd |\n|  6 | 李元霸        | 112233   |\n|  7 | 赵子龙         | 1122     |    <---------这条数据是新增成功的\n+----+----------+----------+\n6 rows in set (0.00 sec)\n```\n\n\n\n**==操作需求3小结==**：\n\nmysqli_insert_id函数可以实现返回最近一次新增操作后数据的主键id值。\n\n\n\n## 3. 全天总结\n\n1. 连库基本操作函数\n\n   mysqli_connect函数     连库和选择默认数据库的\n\n   mysqli_set_charset函数    设置字符集的\n\n   mysqli_select_db函数    切换选择新的数据库的\n\n2. 执行增删改操作的函数\n\n   mysqli_query函数    执行增删改SQL语句的，成功返回true,失败返回false\n\n3. 执行查询操作的函数\n\n   mysqli_query函数   执行查询SQL语句的，返回的是一个对象的结果集\n\n   mysqli_fetch_assoc函数   解析结果集得到一条数据记录的，获得的数据是一个关联类型的数组\n\n   mysqli_fetch_row函数   解析结果集得到一条数据记录的，获得的数据是一个索引类型的数组\n\n   mysqli_fetch_all函数   解析结果集得到所有数据记录的，可以指定第二个参数，第二个参数可以是\n\n   MYSQLI_NUM  返回索引数据数组  （默认的）\n\n   MYSQLI_ASSOC  返回关联数据数组\n\n   MYSQLI_BOTH  返回的数据即包含关联类型的数据，也包含索引类型的数据\n\n\n\n\n","categories":["MYSQLI"]},{"title":"PDO与异常","url":"%2Fposts%2F1712274088%2F","content":"\n\n\n# PDO与异常\n\n## 1. PDO的基本概念\n\n### 为什么使用PDO\n\n在WEB开发中，能够使用的数据库不仅仅只有MYSQL，还可能使用其他的数据库，比如：ORACLE、FIREBIRD、MSSQL等。\n\n\n\n在PHP程序中，我们执行的是相同的操作，但是所写的操作函数却不一样，以连接数据库操作为例：\n\nMySQLi：mysqli_connect\n\nMSSQL：mssql_connect\n\nORACLE：oci_connect\n\n\n\n所以，当我们要切换数据库时，就必须更换为相应扩展的操作函数\n\n![1530715856586](2.png)\n\n\n\n这无疑将提高程序人员操作的门槛，如果需要在项目中更换数据库或者增加不同的数据库，那么一方面我们需要学习不同的数据库操作函数，非常麻烦；另一方面操作功能多了维护起来也会增加负担。\n\n \n\n然而PDO却给我们提供了一个方便的操作方式，我们不再需要学习市面上各种各样的数据库操作，只需要学会使用PDO，那么就可以通过PDO来达到使用相同的操作方法，改变个别参数值，就能达到操作不同类型数据库的目的。\n\n![1530716189186](3.png)\n\n### 什么是PDO\n\nPDO：PHP Data Object  即 PHP数据==对象==\n\n**概念**：PDO即PHP中专门用来操作数据库的一套==扩展==。\n\n\n\nPDO在手册中的位置：\n\n![1530716434955](4.png)\n\n\n\n## 2. ==PDO的基本操作==\n\n#### 开启PDO扩展\n\n第一步，打开php.ini配置文件，确认extension_dir配置项是否正确，\n\n![1530756520292](8.png)\n\n第二步，开启php_pdo_mysql.dll扩展配置项，\n\n![1530756573703](9.png)\n\n第三步，确认在extension_dir所配置的目录下存在php_pdo_mysql.dll文件，\n\n![1530756626328](10.png)\n\n第四步，重启apache，查看pdo_mysql确实开启成功。\n\n![1530756731411](11.png)\n\n通过phpinfo查看扩展是否开启成功，如下图所示，说明开启成功。\n\n![1530756776669](12.png)\n\n\n\n#### 使用PDO实现连库基本操作\n\n引言：我们可以通过实例化PDO类的对象，来达到实现连库基本操作的目标。\n\n\n\n一旦实例化PDO类的对象，则PDO类中的==构造方法==将会被PHP自动调用执行，所以我们需要先了解一下PDO中的构造方法：\n\n> **__construct**(基本参数， 数据库帐号， 数据库密码)      负责初始化连库基本操作\n\n参数详解：\n\n> 基本参数： 包含==数据库类型==，数据库==IP地址==，==端口号==，==字符集==和==默认的数据库==名\n>\n> 基本参数的格式：'数据库类型：==host\\===IP地址==；port\\===端口号==；charset\\===字符集==；dbname\\===数据库名'\n\n\n\n**==演示案例==**：实例化PDO类的对象实现连库基本操作\n\ncode2.php\n\n```php\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';//连库基本参数\n//                    帐号    密码\n$pdo = new PDO($dsn, 'root', '123abc');\nvar_dump( $pdo ); \n```\n\n访问code2.php，效果为\n\n![1530757386020](13.png)\n\n\n\n**==小结==**：\n\n1. 实例化PDO类的对象，其实一次性完成了连接数据库、选择默认的数据库、设置字符集操作；\n\n\n\n#### 使用PDO实现设置操作（增删改）\n\n涉及的方法：\n\n> **exec**(SQL语句)      执行增删改操作SQL语句\n\n\n\n**==需求==**：完成以下操作\n\n1. 使用PDO，向test数据库中的cz_user表实现新增一条数据；\n2. 使用PDO，向test数据库中的cz_user表实现修改id=8的数据name值为'小红帽'；\n3. 使用PDO，删除test数据库中的cz_user表id为1的数据；\n\n**==解答==**：构建名为codex1.php的文件，代码如下：\n\n```php\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';//连库基本参数\n//                                  帐号    密码\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#向cz_user表新增一条数据\n//$sql = 'insert into cz_user values (null, \"王羲之\", \"112233\")';//构建SQL语句\n//$re = $pdo->exec($sql);//调用exec方法执行新增SQL语句，执行成功返回 1 ，失败返回False\n//var_dump( $re ); \n\n#修改cz_user表中的某条数据\n//$sql = 'update cz_user set name=\"小红帽\" where id=8';//构建SQL语句\n//$re = $pdo->exec($sql);//调用exec方法执行修改SQL语句，执行成功返回 1 ，失败返回False\n//var_dump( $re ); \n\n#删除cz_user表中的某条数据\n$sql = 'delete from cz_user where id=1';//构建SQL语句\n$re = $pdo->exec($sql);//调用exec方法执行删除SQL语句，执行成功返回 1 ，失败返回False\nvar_dump( $re ); \n```\n\n\n\n**==小结==**：\n\n1. 我们可以通过调用exec方法实现增删改操作；\n\n\n\n#### 使用PDO实现查询操作\n\n涉及的方法：\n\n【PDO类中】\n\n> **query**(SQL语句)      执行查询操作SQL语句\n\n【PDOStatement类中】\n\n> **fetch**(解析类型)      一次解析一行数据\n>\n> **fetchAll**()       一次性解析所有数据\n>\n> **rowCount**()        获得查询出来的数据的总行数\n>\n> **columnCount**()         获得查询出来的数据的总列数（字段总个数） \n>\n> **fetchObject**()        一次解析一行数据，数据为对象类型\n\n\n\n**==需求==**：完成以下操作\n\n1. 使用PDO，查询test数据库中的cz_user表id<3的数据；\n2. 使用PDO，查询test数据库中的cz_user表id<7的所有数据；\n3. 使用PDO，查询test数据库中的cz_user表id<7的数据一共有几行；\n4. 使用PDO，查询test数据库中的cz_user表id<7的数据一共有几列；\n5. 使用PDO中的fetchObject方法，查询test数据库中的cz_user表id=6的数据，查看打印效果；\n\n**==解答1==**：构建名为code4.php的文件，代码如下：\n\n```php\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';//连库基本参数\n//                                  帐号    密码\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#查询test数据库中的cz_user表id<3的数据\n$sql = 'select * from cz_user where id<3';\n$pdostatement = $pdo->query($sql);//通过pdo对象调用query方法执行查询SQL语句\nvar_dump( $pdostatement ); echo '<hr/>';\n\n//解析查询得到的对象结果集里面的数据\n$row = $pdostatement->fetch();//第一次调用fetch方法解析数据\necho '<pre>';\nvar_dump( $row ); echo '<hr/>';\n\n$row = $pdostatement->fetch();//第二次调用fetch方法解析数据\necho '<pre>';\nvar_dump( $row ); echo '<hr/>';\n\n$row = $pdostatement->fetch();//第三次调用fetch方法解析数据\necho '<pre>';\nvar_dump( $row ); \n```\n\n访问code4.php的效果：\n\n![1530759404874](14.png)\n\n**==解答1小结==**：\n\n1. 在程序中如果需要查询一条数据，我们首先需要使用pdo对象调用query方法执行查询SQL语句；然后再使用query方法返回的对象调用fetch方法解析出实际查询的一条数据；\n\n2. 上面的效果中，之所以第二次和第三次调用fetch方法返回为false，是因为本身查询语句只查了一条数据，所以第一次解析得到数据后，再去执行fetch，则只能返回false；\n\n3. fetch方法第一个参数详解：\n\n   ​         类常量**PDO::FETCH_ASSOC**      解析关联类型的数组数据\n\n   ​\t 类常量**PDO::FETCH_NUM**      解析索引类型的数组数据\n\n   ​\t 类常量**PDO::FETCH_BOTH**      解析得到的数组数据即包含关联类型元素又包含索引类型元素(默认)\n\n   ​         类常量**PDO::FETCH_OBJ**      解析对象类型的数组数据\n\n   ![1530760743075](15.png)\n\n\n\n**==解答2==**：构建名为code7.php的文件，代码如下：\n\n```php\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';//连库基本参数\n//                      帐号    密码\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#查询test数据库中的cz_user表id<3的数据\n$sql = 'select * from cz_user where id<7';\n$pdostatement = $pdo->query($sql);//使用PDO对象调用query方法执行查询SQL语句\n\nvar_dump( $pdostatement ); \n\n//使用query方法的返回值对象调用fetchAll方法一次性解析所有数据\n$rows = $pdostatement->fetchAll();\necho '<pre>';\nvar_dump( $rows ); \n```\n\n**==解答2小结==**：\n\n![1530761077197](16.png)\n\n\n\n**==解答3==**：构建名为code8.php的文件，代码如下：\n\n```php\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';//连库基本参数\n//                                  帐号    密码\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#查询test数据库中的cz_user表id<3的数据\n$sql = 'select * from cz_user where id<7';\n$pdostatement = $pdo->query($sql);//使用PDO对象调用query方法执行查询SQL语句\n\n//获得查询得到的数据总共有多少行\n$rowCount = $pdostatement->rowCount();\nvar_dump( $rowCount ); \n```\n\n**==解答3小结==**：\n\n![1530761258058](17.png)\n\n\n\n\n\n**==解答4==**：构建名为code9.php的文件，代码如下：\n\n```php\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';//连库基本参数\n//                    帐号    密码\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#查询test数据库中的cz_user表id<3的数据\n$sql = 'select * from cz_user where id<7';\n$pdostatement = $pdo->query($sql);//使用PDO对象调用query方法执行查询SQL语句\n\n//获得查询得到的数据总共有多少列\n$colCount = $pdostatement->columnCount();\nvar_dump( $colCount ); \n```\n\n**==解答4小结==**：\n\n![1530761526517](18.png)\n\n**==解答5==**：构建名为code10.php的文件，代码如下：\n\n```php\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';//连库基本参数\n//                     帐号    密码\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#查询test数据库中的cz_user表id<3的数据\n$sql = 'select * from cz_user where id<7';\n$pdostatement = $pdo->query($sql);//使用PDO对象调用query方法执行查询SQL语句\n\n//解析一行，获得一个对象类型的数据\n$row = $pdostatement->fetchObject();\nvar_dump( $row ); \n```\n\n**==解答5小结==**：\n\n![1530761739365](19.png)\n\n\n\n## 3. ==PDO中的事务==\n\n#### MYSQL客户端中的事务\n\n我们以zhangsan向lisi借钱为例子，如果要想在数据库实现zhangsan向lisi借100元钱，则过程应该是：\n\n首先lisi的money需要减少100，必须要执行成功如下的SQL语句：\n\nupdate user set money=money-100 where name='lisi';\n\n \n\n其次,zhangsan的money需要增加100，必须要执行成功如下SQL语句：\n\nupdate user set money=money+100 where name='zhangsan';\n\n \n\n这个过程，必须是两条SQL语句同时都执行成功，才算是借钱成功，只要中途有任何一个执行不成功，都不能算借钱成功。\n\n\n\n**提前准备**：\n\n```mysql\n#user表\ncreate table user(\nid int unsigned primary key auto_increment,\nname varchar(30) not null default '',\nmoney decimal(10, 2) not null default 0\n)engine=Innodb charset=utf8;\n\n#user表的两条数据\ninsert into user values (null, 'zhangsan', 1000);\ninsert into user values (null, 'lisi', 1000);\n```\n\n\n\n**==需求==**：使用黑窗口实现成功借钱的例子；\n\n**==步骤==**：\n\n1. 开启事务，固定的操作语句：**==start transaction;==**\n\n   ![1530762517800](20.png)\n\n2. 执行如下所示的SQL语句，使lisi减少100块\n\n   ```\n   update user set money=money-100 where name='lisi';\n   ```\n\n   ![1530762723944](21.png)\n\n3. 执行如下所示SQL语句，使zhangsan增加100块\n\n   ```\n   update user set money=money+100 where name='zhangsan';\n   ```\n\n   ![1530762838369](22.png)\n\n4. 将完整的事务整体提交一次，提交事务的语句：**==commit;==**\n   ![1530763027364](23.png)\n\n\n\n\n\n**==需求==**：使用黑窗口实现失败借钱的例子；\n\n**==步骤==**：\n\n1. 开启事务，固定的操作语句：**==start transaction;==**\n\n2. 执行事务当中的子过程\n\n   lisi减少100块\n\n   ```\n   update user set money=money-100 where name='lisi';\n   ```\n\n   zhangsan增加100块\n\n   ```\n   update user set money=money+100 where name='zhangsan';\n   ```\n\n   ![1530763367392](24.png)\n\n3. 假设现在虽然执行成功了两个子过程，但是因为某些特殊的原因，要求撤销这个完整的操作，使操作不生效，所以，我们需要执行回滚操作，回滚操作的语句：**==rollback;==**\n\n   ![1530763547676](25.png)\n\n\n\n\n\n==**小结**==：\n\n1. 事务可以将许多的过程整合成一个完整的过程，只要子过程有一个失败，整个过程都失败，只有当全部的子过程成功，整个过程才认为是成功；\n2. 如果要使用事务，则数据表的引擎必须是Innodb引擎；\n\n\n\n#### 使用PDO实现事务\t\n\n\n\n> beginTransaction();   开启事务\n> commit(); 提交事务\n\n\n\n\n**==需求==**：使用PDO实现借钱的例子；\n\n**==步骤==**：构建code12.php程序文件，代码如下：\n\n```php\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#开启事务\n$pdo->beginTransaction();\n\n//判断标识\n//默认true ，如果某条语句执行失败，则将其设置为false\n//即要全部语句执行成功，才能提交事务。\n$flag = true;\n\n#将lisi的money减少100块\n$sql = 'update user set money=money-100 where name=\"lisi\"';\nif( !$pdo->exec($sql) ){//执行更新语句失败\n    $flag = false;\n}\n\n#将zhangsan的money增加100块\n$sql = 'update user set money=money+100 where name=\"zhangsan\"';\nif( !$pdo->exec($sql) ){//执行更新语句失败\n    $flag = false;\n}\n\n#根据判断标识来执行提交事务或回滚事务操作\nif( $flag ){//表示子过程完全没有问题\n    #提交事务\n    $pdo->commit();\n    echo '借钱成功！'; \n}else{//表示子过程至少有一个出了问题\n    #回滚事务\n    $pdo->rollBack();\n    echo '借钱失败'; \n}\n```\n\n访问code12.php效果为：\n\n![1530775608835](26.png)\n\n![1530775651617](27.png)\n\n\n\n==**小结**==：\n\n1. 我们在程序中，可以通过事务，将零散的过程整合成一个完整的过程，只要完整的过程中任意一个子过程出现问题，则事务将回滚；如果整个事务中的子过程都没有问题，则可以提交事务，使子过程影响的数据立即生效。\n\n\n\n## 4. ==PDO中的预处理技术==\n\n#### 为什么使用预处理技术\n\n在MYSQL中，其标准的执行SQL语句的流程是：\n\n1. 构建SQL语句；\n2. 通过黑窗口客户端发送SQL语句到MYSQL服务器；\n3. MYSQL服务器接收SQL语句；\n4. 解析SQL语句；\n5. 执行SQL语句；\n6. 将执行的结果返回；\n\n\n\n在通常的情况下，无论我们在MYSQL中执行的是不是相同的操作，MYSQL都会每次去重新解析完整的SQL语句，那么，如果当我们的操作，每次执行的都是相同的，只不过数据不同，如下面新增数据的SQL语句：\n\n```mysql\ninsert into cz_user values (null, 'zhangsan', 'aa');\ninsert into cz_user values (null, 'lisi', 'bb');\ninsert into cz_user values (null, 'wangwu', 'cc');\ninsert into cz_user values (null, 'zhaoliu', 'dd');\n```\n\n都是向cz_user表执行新增数据的动作，只不过每次新增的数据不同而已。但是MYSQL依然会每次都完整的去解析这些SQL语句。\n\n \n\n这样就造成每次都重复的解析了相同的操作，浪费了一定的时间。所以，在MYSQL中，提供了一种名为预处理的技术，这个技术就是专门用来优化上述问题的技术。\n\n\n\n#### MYSQL客户端中实现预处理技术\n\n##### 不带参数的预处理\n\n涉及的语句语法：\n\n> 构建预处理语句语法：==**prepare**  预处理语句名  **from**  “SQL语句”;== \n>\n> 执行预处理语句语法：==**execute**  预处理语句名;==\n>\n> 删除预处理语句语法：==**drop  prepare**  预处理语句名;== \n\n\n\n**==需求==**：使用预处理技术执行\"select * from cz_user\"SQL语句；\n\n**==步骤==**：\n\n1. 构建预处理语句，\n\n   ```mysql\n   prepare p1 from \"select * from cz_user\";\n   ```\n\n   ![1530777591251](28.png)\n\n2. 执行预处理语句，\n\n   ```\n   execute p1;\n   ```\n\n   ![1530777790476](29.png)\n\n3. 删除预处理语句\n\n   ```\n   drop prepare p1;\n   ```\n\n   ![1530777850402](30.png)\n\n\n\n\n\n==**小结**==：\n\n1. 实现预处理的步骤有三个：1)准备预处理语句；2）执行预处理语句；3）删除预处理语句；\n\n\n\n##### 携带参数的预处理\n\n涉及的语句语法：\n\n> 构建预处理语句语法：==**prepare**  预处理语句名  **from**  “SQL语句”;== \n>\n> 新增参数数据语句语法：==**set  @**变量名=变量值;==\n>\n> 执行预处理语句语法：==**execute**  预处理语句名  **using**  @变量1, @变量2，….,@变量n;==\n>\n> 删除预处理语句语法：==**drop  prepare**  预处理语句名;== \n\n\n\n**==需求==**：使用预处理技术实现往cz_user表中添加数据；\n\n**==步骤==**：\n\n1. ；准备预处理语句，\n\n   ```mysql\n   #以下的\"?\"问号表示占位符\n   prepare p1 from \"insert into cz_user values (null, ?, ?)\";\n   ```\n\n   ![1530778196962](31.png)\n\n2. 执行预处理语句，\n\n   准备数据操作：\n\n   ```php\n   #定义两个变量保存两个数据值\n   set @aa='zhangsan';\n   set @bb='123456';\n   ```\n\n   ![1530778373108](32.png)\n\n   使用准备的数据执行预处理语句：\n\n   ```mysql\n   execute p1 using @aa, @bb;\n   ```\n\n   ![1530778688372](33.png)\n\n3. 删除预处理语句\n\n   ```mysql\n   drop prepare p1;\n   ```\n\n\n\n==**小结**==：\n\n1. 携带参数的预处理比不携带参数的预处理，多了绑定数据的操作；\n\n\n\n#### PDO中实现预处理技术\n\n涉及的方法：\n\n【PDO类中】\n\n> **prepare**(SQL语句)      生成预处理语句\n\n【PDOStatement类中】\n\n> **bindParam**(参数序号， ==&==参数值)      绑定参数\n>\n> **execute**([参数集合])       执行预处理语句\n\n\n\n**==需求==**：使用PDO实现用预处理技术往cz_user表中添加数据，要求\n\n1. 使用序号绑定参数的方式实现一次；\n2. 使用\"：字段名\"绑定参数的方式实现一次；\n3. 使用数组绑定参数的方式实现一次；\n\n**==解答1==**：构建code13.php程序文件，代码如下：\n\n```php\n# ----------按序号绑定参数---------- #\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#准备预处理语句\n$sql = 'insert into cz_user values (null, ?, ?)';\n$pdostatement = $pdo->prepare($sql);\nvar_dump( $pdostatement ); \n\n#准备绑定的数据\n$aa = '李元芳';\n$bb = '223344';\n\n//注：第二个参数为引用传递，必须是变量\n$pdostatement->bindParam(1, $aa);//为第一个占位符绑定$aa数据\n$pdostatement->bindParam(2, $bb);//为第二个占位符绑定$bb数据\n\n#执行预处理语句\n$pdostatement->execute();\n\necho '执行预处理完毕'; \n# ----------按序号绑定参数---------- #\n```\n\n访问code13.php的效果：\n\n![1530779980684](34.png)\n\n==**小结1**==：\n\n1. bindParam方法的第二个参数是引用传递，所以不能够直接指定数据值，否则将直接报错；\n\n\n\n**==解答2==**：构建code14.php程序文件，代码如下：\n\n```php\n# ----------按 ：字段名 绑定参数---------- #\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#准备预处理语句\n//使用\":\"+字段名  的方式指定占位符，这里的字段名是自定义的，并不一定要和表中一致\n$sql = 'insert into cz_user values (null, :name, :pwd)';\n$pdostatement = $pdo->prepare($sql);\n//var_dump( $pdostatement ); \n\n#准备绑定的数据\n$aa = '狄仁杰';\n$bb = '223344';\n\n//注：第二个参数为引用传递，必须是变量\n//绑定参数也需要指定相应的占位符\n$pdostatement->bindParam(':name', $aa);\n$pdostatement->bindParam(':pwd', $bb);\n\n#执行预处理语句\n$pdostatement->execute();\n\necho '执行预处理完毕'; \n# ----------按 ：字段名 绑定参数---------- #\n```\n\n访问code14.php的效果：\n\n![1530781215060](35.png)\n\n==**小结2**==：\n\n1. 使用  :+字段名  的方式作为占位符，比较好辨认。\n\n\n\n**==解答3==**：构建code15.php程序文件，代码如下：\n\n```php\n# ----------按 数组 绑定参数---------- #\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#准备预处理语句\n$sql = 'insert into cz_user values (null, :name, :pwd)';//使用\":\"+字段名  的方式指定占位符\n$pdostatement = $pdo->prepare($sql);\n//var_dump( $pdostatement ); \n\n#准备绑定的数据\n//下标为占位符，值为占位符指定的数据\n$data = array(\n    ':name' => '包青天',\n    ':pwd' => '展昭'\n);\n\n#执行预处理语句\n//直接为execute指定数组数据\n$pdostatement->execute($data);\n\necho '执行预处理完毕'; \n# ----------按 数组 绑定参数---------- #\n```\n\n访问code15.php的效果：\n\n![1530781475689](36.png)\n\n==**小结3**==：\n\n1. 我们还可以通过数组的方式来实现绑定数据；\n\n\n\n## 5. ==PDO中的异常处理==\n\n\"异常\"两个字的意思，我们可以理解为错误，它可以是执行时出现的错误，也可以是逻辑错误。\n\n\n\n#### PDO中实现异常\n\n在PDO中，封装了一个类用于实现对PDO中的错误进行异常处理方式的处理，这个类名字PDOException，它的本质就是继承了PHP的系统类Exception，所以PHP系统类Exception具有的操作，也都被PDOException所拥有。\n\n![1530745661759](6.png)\n\n\n\n涉及的方法：\n\n【PDO类】\n\n> **setAttribute**(属性名， 属性值)      设置PDO的模式属性\n\n【PDOException类】\n\n> **getMessage**()     获取错误信息\n\n\n\n**==需求==**：使用PDO异常处理方式实现执行查询出错的案例。\n\n**==解答==**：构建code17.php程序文件，代码如下：\n\n```php\n$dsn = 'mysql:host=localhost;port=3306;charset=utf8;dbname=test';\n$pdo = new PDO($dsn, 'root', '123abc');\n\n#设置pdo对错误的处理模式属性\n//PDO::ATTR_ERRMODE：错误处理模式                   \n$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);//异常模式\n\n//$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);//静默模式（默认的模式）  将不会有任何的信息提示\n\n//$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);//警告模式  将会把错误信息以warning警告的方法报错\n\n#构建错误的查询语句\n$sql = 'select * from cz_user whereeeeeee 1';\n\n# 尝试捕获错误\ntry{\n\n    $pdo->query($sql);\n    /*\n    if(!$pdo->query($sql)){//执行失败\n        $obj = new PDOException;\n        throw($obj);  ===>   $a=$obj;\n    }\n    */\n\n}catch(PDOException $a){\n\n    var_dump( $a ); echo '<hr/>';\n    echo $a->getMessage() . '<br/>'; //获得错误的错误信息\n    echo $a->getCode() . '<br/>'; //获得错误的代号\n    echo $a->getFile() . '<br/>'; //获得错误出现的文件\n    echo $a->getLine() . '<br/>'; //获得错误出现的行的行号\n}\n```\n\n![1530782781145](37.png)\n\n所谓的抛出基于PDOException类的对象，实际上就是将PDOException类的对象赋值给$a。\n\n\n\n==**小结**==：\n\n1. 实现异常错误处理步骤：\n\n   第一步，将错误处理模式使用setAttribute方法设置为异常处理模式；\n\n   第二步，使用try结构监听执行SQL语句的代码；\n\n   第三步，使用catch结构获取错误的信息；\n\n\n\n## 6. 全天总结\n\n1. 连库基本操作：实例化PDO类的对象；\n\n2. 能够执行设置操作（增删改）的方法：PDO类中exec方法\n\n3. 能够执行查询操作的方法：\n\n   PDO类中的query方法：执行查询SQL语句\n\n   PDOStatement类中的fetch方法：每次执行只解析一条数据，返回的数据默认是一个混合数组（即包含关联又包含索引数组元素的数组），我们可以通过改变第一个参数的值，来达到返回不同数据格式的数据：\n\n   ​\t\tPDO::FETCH_ASSOC       返回关联数组\n\n   ​\t\tPDO::FETCH_NUM        返回索引数组\n\n   ​\t\tPDO::FETCH_BOTH      返回混合数组\n\n   ​\t\tPDO::FETCH_OBJ         返回对象数据\n\n   PDOStatement类中的fetchAll方法：一次执行返回所有查询得到的数据，数据是一个混合类型的二维数组；\n\n4. PDO中如何实现事务：\n\n   第一步，开启事务      PDO类中的beginTransaction方法\n\n   第二步，完成子过程\n\n   第三步，根据执行子过程的结果标识（是否有子过程执行失败），来判断应该执行提交操作还是回滚操作\n\n5. PDO中如何实现预处理技术：\n\n   第一步，准备预处理语句：PDO类中的prepare方法\n\n   第二步，绑定参数：构建参数数组\n\n   第三步，执行预处理语句：PDOStatement类中的execute方法\n\n6. PDO中如何实现异常处理：\n\n   第一步，设置错误处理模式为异常模式： PDO类中的setAttribute方法\n\n   第二步，使用try结构监听执行SQL语句的代码\n\n   第三步，使用catch结构获取错误相关信息\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["PDO"]},{"title":"面向对象2","url":"%2Fposts%2F2314494474%2F","content":"\n\n# 面向对象2\n\n## 1. ==自动加载==\n\n**引言**：\n\n早期的开发过程中，程序开发人员通常会将所有的可能要使用的类文件通过include的方式，引入到当前的程序脚本中。但是这么做，会使得程序加载效率过低，拖慢程序的整体执行速度。\n\n比如，当前有三个类，A、B、C，分别定义在三个文件中，A类定义在A.class.php中，B类定义在B.class.php中，C类定义在C.class.php中。当构建一个新的项目页面时，为了操作方便，将会事先把三个类文件全部引入进项目页面，如将三个类文件引入进test.php中。\n\n那么，如果test.php中只使用到了一个类，而另外两个类在整个项目里都没用到，则会造成解析test.php程序代码时额外的开销和浪费。\n\n\n\n所以，在PHP中，可以使用\"自动加载\"这种技术方式，来弥补这样的缺陷。\n\n\n\n\"自动加载\"==技术的思路==是：什么时候要用到这个类，就将这个类所在的类文件引入进项目中来。\n\n\n\n**触发**执行自动加载的**==时机==**：当==**使用到**==某个类时，而当前整个程序脚本中又没有这个类的定义，就会触发PHP执行走自动加载，寻找类的定义。 \n\n\n\n### 默认的自动加载\n\n**引言**：PHP中是通过一个==固定名字的函数==来实现默认的自动加载的。\n\n\n\n**==需求==**：使用code/prepare目录中的A、B、C类文件，在code/cod3.php中通过默认的自动加载函数实现加载A类和B类的类文件。\n\n**==解答==**：在code3.php中构建代码如下：\n\n```php\n<?php\n\n#默认的自动加载函数\nfunction __autoload($className){ \n    if( $className=='A' ){\n        include './prepare/A.class.php';\n    }elseif( $className=='B' ){\n        include './prepare/B.class.php';\n    }\n}\n\n\n$a = new A;\nvar_dump( $a ); echo '<hr/>';\n\n$b = new B;\nvar_dump( $b ); \n```\n\n访问code1.php，效果为：\n\n![1530411425985](2_2.png)\n\n**==小结==**：\n\n1. PHP不负责定义默认的自动加载函数，只负责调用这个函数；\n2. 调用默认自动加载函数的时机：当使用到一个类，而这个类的定义又不存在时，则会触发PHP自动调用执行一次这个函数，传递使用的这个类的类名给该函数；\n\n\n\n### 自定义自动加载\n\n**引言**：除了默认的自动加载，PHP还支持使用自定义的自动加载。\n\n\n\n涉及的函数：\n\n> **spl_autoload_register**(混合型参数)    自动加载注册函数\n\n\n\n在PHP中，自定义的自动加载有三种实现方式：\n\n- [x] 自定义函数\n- [x] 自定义非静态方法\n- [x] 自定义静态方法\n\n\n\n**==注意==**：无论使用哪一种方式，都需要用到spl_autoload_register函数。\n\n\n\n#### 自定义函数\n\n**==需求==**：使用code/prepare目录中的A、B、C类文件，在code/code4.php中通过自定义函数实现自动加载A类和B类的类文件。\n\n**==解答==**：在code4.php中构建代码如下：\n\n```php\n<?php\n\n#自定义函数\nfunction f1($className){ \n    if( $className=='A' ){\n        include './prepare/A.class.php';\n    }elseif( $className=='B' ){\n        include './prepare/B.class.php';\n    }\n}\n\n#告诉PHP接下来要使用哪个自定义的函数做自动加载\nspl_autoload_register('f1');//告诉PHP接下来使用名为f1的自定义函数做自动加载\n\n$a = new A;\nvar_dump( $a ); echo '<hr/>';\n\n$b = new B;\nvar_dump( $b ); \n```\n\n访问code4.php，效果为：\n\n![1530412199666](3_2.png)\n\n**==小结==**：\n\n1. 函数名可以任意指定，但是也需要一个必填参，这个参数将会接收PHP传递的某个类的类名；\n2. 要使用自定义函数做自动加载，必须要使用spl_autoload_register注册自动加载函数；\n\n\n\n#### 自定义非静态方法\n\n**==需求==**：使用code/prepare目录中的A、B、C类文件，在code/code5.php中通过自定义非静态方法实现自动加载A类和B类的类文件。\n\n**==解答==**：在code5.php中构建代码如下：\n\n```php\n<?php\n\nclass Demo{\n\n    #非静态方法\n    public function f1($className){ \n        if( $className=='A' ){\n            include './prepare/A.class.php';\n        }elseif( $className=='B' ){\n            include './prepare/B.class.php';\n        }\n    }\n}\n\n$obj1 = new Demo;\n\n#告诉PHP接下来要使用哪个自定义的非静态方法做自动加载\nspl_autoload_register(array($obj1, 'f1'));//告诉PHP接下来使用$obj1对象调用f1非静态方法实现自动加载\n\n$a = new A;\nvar_dump( $a ); echo '<hr/>';\n\n$b = new B;\nvar_dump( $b ); \n```\n\n访问code1.php，效果为：\n\n![1530412778712](4_2.png)\n\n**==小结==**：\n\n1. 如果要使用非静态方法实现自动加载，则必须先创建一个基于该方法所在类的对象；\n2. 然后在spl_autoload_register函数中指定一个数组参数，数组的第一个元素必须是在\"1\"中创建的对象，第二个元素必须是该对象下的方法的方法名；\n\n\n\n#### 自定义静态方法\n\n**==需求==**：使用code/prepare目录中的A、B、C类文件，在code/code6.php中通过自定义静态方法实现自动加载A类和B类的类文件。\n\n**==解答==**：在code6.php中构建代码如下：\n\n```php\n<?php\n\nclass Demo{\n\n    #静态方法\n    public static function f1($className){ \n        if( $className=='A' ){\n            include './prepare/A.class.php';\n        }elseif( $className=='B' ){\n            include './prepare/B.class.php';\n        }\n    }\n}\n\n\n#告诉PHP接下来要使用哪个自定义的静态方法做自动加载\n//spl_autoload_register(array('Demo', 'f1'));//告诉PHP接下来使用Demo类调用其下的f1静态方法实现自动加载\nspl_autoload_register('Demo::f1');//这个写法和上面的效果是一样的\n\n$a = new A;\nvar_dump( $a ); echo '<hr/>';\n\n$b = new B;\nvar_dump( $b ); \n```\n\n访问code6.php，效果为：\n\n![1530413143842](5_2.png)\n\n**==小结==**：\n\n1. 如果要使用静态方法实现自动加载，则无需事先创建对象，只需要在spl_autoload_register中指定这个类的类名及该类中的静态方法名即可；\n\n\n\n### 总结\n\n1. 如果是面向过程的方式开发项目，则默认的自动加载函数用的多；如果使用的是基于面向对象的框架方式开发，则静态方法用的多；\n2. 如果使用了自定义的自动加载，则默认的自动加载函数将会失效，要想将默认的自动加载函数重新恢复效果，则需要再次使用spl_autoload_register函数将默认的自动加载函数重新注册一次；\n3. 自定义自动加载可以注册多个，但是每次使用spl_autoload_register只能注册一个；\n\n\n\n## 2. ==类的继承==\n\n**引言**：程序是模拟现实世界的，现实世界中存在着继承的概念，故程序中也有相应的模拟实现方式。\n\n==**概念**==：属于类A的成员，同时也属于类B，我们就说类B==继承==了类A。\n\n\n\n### 继承的语法\n\n==实现语法==：\n\n```php\n//extends是关键字\nclass 子类类名 extends 父类类名{\n\t子类的类成员；\n}\n```\n\n\n\n**==需求==**：使用code/prepare目录中的Animal.class.php类文件，在code/code8.php中通过构建Birds类实现继承Animal类，要求，\n\n1. 给Birds类构建非静态属性$firther，值为：有羽毛；\n2. 实例化一个基于Birds类的对象保存给$bird，打印该对象；\n3. 测试通过$bird对象调用move方法；\n\n**==解答==**：在code8.php中构建代码如下：\n\n```php\n<?php\n\ninclude './prepare/Animal.class.php';\n\n#通过关键字extends实现Birds类继承了Animal类\nclass Birds extends Animal{\n\n    public $firther='有羽毛';\n}\n\n$bird = new Birds;\nvar_dump( $bird ); echo '<hr/>';\n$bird->move();\n```\n\n访问code8.php，效果为：\n\n![1530415309819](6_2.png)\n\n**==小结==**：\n\n1. 继承是通过关键字extends来实现的；\n2. 实现了继承后，子类中也就拥有了父类的成员；\n\n\n\n### 继承中的三个概念\n\n父类：就是被继承的那个类；\n\n派生：派生是一个==过程==，通过一个已有的类，产生一个新类的过程，就叫派生；\n\n子类：继承别的类的这个类（==子类也叫派生类==）；\n\n\n\n**==提问==**：到目前为止，我们从效果上观察到，通过继承，可以使子类也能拥有父类的成员，那么，实现继承的过程，是否意味着在程序中将父类的成员直接拷贝给了子类呢？\n\n### 继承链\n\n==原理图==：\n\n![1530416132277](7_2.png)\n\n**==小结==**：\n\n1. 通过继承，实际上将会在编译过程和之后实例化对象的过程中形成一种关系，其中在对象空间中形成的如上图所示青绿色部分的空间关系内容，就是继承链部分，相当于在#1大空间下分别开辟小的空间分门别类的保存不同的成员；\n\n### parent关键字\n\n作用：parent关键字就是专门在==子类中==**代替**==父类的类名==的。\n\n\n\n**==需求==**：使用code/prepare目录中的Father.class.php类文件，在code/code9.php中通过构建Son类实现继承Father类，要求，\n\n1. 在Son类中创建一个名为test的非静态方法；\n2. 在test方法中打印父类的$desposit属性；\n3. 在test方法中访问singing方法；\n\n**==解答==**：在code9.php中构建代码如下：\n\n```php\n<?php\n\ninclude './prepare/Father.class.php';\n\n\nclass Son extends Father{\n\n    public function test(){ \n        //访问父类的$desposit静态属性\n        var_dump( Father::$deposit ); echo '<br/>';\n        var_dump( Son::$deposit ); echo '<br/>';\n        var_dump( self::$deposit ); echo '<br/>';\n        var_dump( parent::$deposit ); echo '<hr/>';//通过parent能够调用到父类中的静态属性\n\n        //访问父类的singing静态方法\n        Father::singing('两只老虎');echo '<br/>';\n        parent::singing('嗡嗡嗡');//通过parent也能够调用到父类中的静态方法\n    }\n}\n\n//调用测试方法\n$zhangsan = new Son;\n$zhangsan->test();\n```\n\n访问code9.php，效果为：\n\n![1530417128214](8_2.png)\n\n**==小结==**：\n\n1. paernt关键字，在存在继承关系的子类中，专门用来代替父类的类名的；\n\n\n\n### 访问限定修饰符\n\n**引言**：访问限定修饰符，顾名思义就是一种符号，专门用来限定用户访问的。\n\n\n\n在PHP中，访问限定修饰符共有三个：\n\n- [x] public    表示公有的\n- [x] protected    表示受保护的\n- [x] private    表示私有的\n\n\n\n定义方式：\n\n```php\n<?php\n\nclass Mark{\n    \n    #限定属性\n    //public\n    public $var1='public_var1';\n    public static $var2='public_static_var2';\n\n    //protected\n    protected $var3='protected_var3';\n    protected static $var4='protected_static_var4';\n\n    //private\n    private $var5='private_var5';\n    private static $var6='private_static_var6';\n    \n    #限定方法\n    //public\n    public function f1(){ \n        echo 'public_function_f1'; \n    }\n    public static function f2(){ \n        echo 'public_static_function_f2'; \n    }\n\n    //protected\n    protected function f3(){ \n        echo 'protected_function_f3'; \n    }\n    protected static function f4(){ \n        echo 'protected_static_function_f4'; \n    }\n\n    //private\n    private function f5(){ \n        echo 'private_function_f5'; \n    }\n    private static function f6(){ \n        echo 'private_static_function_f6'; \n    }\n}\n```\n\n\n\n被不同的访问限定修饰符所修饰的成员，将具有不同的特性。\n\n#### 访问限定修饰符的特性\n\n三种访问限定修饰符的特性分别为：\n\n- [ ] public    表示在**类的内部**，**类的外部**和**类的继承链中**都能**==直接==**访问；\n- [ ] protected     表示**在类的内部**和**继承链中**能被**==直接==**访问；\n- [ ] private    表示**只能**在**本类的内部**被**==直接==**访问；\n\n\n\n#### public\n\n**==需求1==**：使用code/prepare目录中的PublicTest.class.php类文件中的类，要求，\n\n1. 测试在PublicTest类的外部访问pubic修饰的四个成员；\n\n**==解答1==**：在code10.php中构建代码如下：\n\n```php\n<?php\n\nclass PublicTest{\n    \n    #public\n    public $var1='public_var1';\n    public static $var2='public_static_var2';\n\n    public function f1(){ \n        echo 'public_function_f1'; \n    }\n    public static function f2(){ \n        echo 'public_static_function_f2'; \n    }\n}\n\n#在类的外部直接访问public修饰的成员\n$obj= new PublicTest;\nvar_dump( $obj->var1 ); //非静态属性\necho '<br/>';\nvar_dump( PublicTest::$var2 ); //静态属性\necho '<br/>';\n$obj->f1();\necho '<br/>';\nPublicTest::f2();\n```\n\n访问code10.php，效果为：\n\n![1530427484390](9_2.png)\n\n\n\n**==需求2==**：使用code/prepare目录中的PublicTest.class.php类文件中的类，要求，\n\n1. 在PublicTest类中创建一个名为test的测试方法，测试在PublicTest类的内部访问pubic修饰的四个成员；\n\n**==解答2==**：在codex11.php中构建代码如下：\n\n```php\n<?php\n\nclass PublicTest{\n    \n    #public\n    public $var1='public_var1';\n    public static $var2='public_static_var2';\n\n    public function f1(){ \n        echo 'public_function_f1'; \n    }\n    public static function f2(){ \n        echo 'public_static_function_f2'; \n    }\n\n    #在类的内部直接访问public修饰的四个成员\n    public function test(){ \n        var_dump( $this->var1 ); echo '<br/>';\n        var_dump( self::$var2 ); echo '<br/>';\n        $this->f1(); echo '<br/>';\n        self::f2();\n    }\n}\n\n$obj = new PublicTest;\n$obj->test();\n```\n\n访问code11.php，效果为：\n\n![1530427658939](10_2.png)\n\n\n\n**==需求3==**：使用code/prepare目录中的PublicTest.class.php类文件中的类，要求，\n\n1. 再创建一个名为PublicTestSon的类继承PublicTest类，在PublicTestSon类中创建son_test方法，测试在继承链中访问PublicTest类中pubic修饰的四个成员；\n\n**==解答3==**：在code12.php中构建代码如下：\n\n```php\n<?php\n\nclass PublicTest{\n    \n    #public\n    public $var1='public_var1';\n    public static $var2='public_static_var2';\n\n    public function f1(){ \n        echo 'public_function_f1'; \n    }\n    public static function f2(){ \n        echo 'public_static_function_f2'; \n    }\n}\n\n//Demo继承PublicTest类\nclass Demo extends PublicTest{\n    #测试在继承链中直接访问继承链中的public所修饰的成员\n    public function test(){ \n        var_dump( $this->var1 ); echo '<br/>';\n        var_dump( parent::$var2 ); echo '<br/>';\n        $this->f1(); echo '<br/>';\n        parent::f2();\n    }\n}\n\n$obj = new Demo;\n$obj->test();\n```\n\n访问code12.php，效果为：\n\n![1530427900850](11_2.png)\n\n\n\n**==小结==**：\n\n1. 被public所修饰的成员，可以在 类的内部、类的外部 和 继承链中 被**==直接==**访问；\n\n\n\n#### protected\n\n**==需求1==**：使用code/prepare目录中的ProtectedTest.class.php类文件中的类，要求，\n\n1. 测试在ProtectedTest类的外部访问protected修饰的四个成员；\n\n**==解答1==**：在code13.php中构建代码如下：\n\n```php\n<?php\n\nclass ProtectedTest{\n    \n    #protected\n    protected $var3='protected_var3';\n    protected static $var4='protected_static_var4';\n\n    protected function f3(){ \n        echo 'protected_function_f3'; \n    }\n    protected static function f4(){ \n        echo 'protected_static_function_f4'; \n    }\n}\n\n//测试在类的外部直接访问protected修饰的成员\n$obj = new ProtectedTest;\n//var_dump( $obj->var3 ); //测试的结果为，报错，说明不能直接访问protected修饰的 非静态属性\n//var_dump( ProtectedTest::$var4 ); //测试的结果为，报错，说明不能直接访问protected修饰的 静态属性\n//$obj->f3();//测试的结果为，报错，说明不能直接访问protected修饰的 非静态方法\nProtectedTest::f4();//测试的结果为，报错，说明不能直接访问protected修饰的 静态方法\n```\n\n访问code13.php，效果为：\n\n![1530428416788](12_2.png)\n\n\n\n**==需求2==**：使用code/prepare目录中的ProtectedTest.class.php类文件中的类，要求，\n\n1. 在ProtectedTest类中创建一个名为test的测试方法，测试在ProtectedTest类的内部访问protected修饰的四个成员；\n\n**==解答2==**：在code14.php中构建代码如下：\n\n```php\n<?php\n\nclass ProtectedTest{\n    \n    #protected\n    protected $var3='protected_var3';\n    protected static $var4='protected_static_var4';\n\n    protected function f3(){ \n        echo 'protected_function_f3'; \n    }\n    protected static function f4(){ \n        echo 'protected_static_function_f4'; \n    }\n\n    #测试在类的内部访问protected修饰的成员\n    public function test(){ \n        var_dump( $this->var3 ); echo '<br/>';\n        var_dump( self::$var4 ); echo '<br/>';\n        $this->f3(); echo '<br/>';\n        self::f4();\n    }\n}\n\n//调用测试方法\n$obj = new ProtectedTest;\n$obj->test();\n```\n\n访问code14.php，效果为：\n\n![1530428595051](13_2.png)\n\n\n\n**==需求3==**：使用code/prepare目录中的ProtectedTest.class.php类文件中的类，要求，\n\n1. 再创建一个名为ProtectedTestSon的类继承ProtectedTest类，在ProtectedTestSon类中创建son_test方法，测试在继承链中访问ProtectedTest类中protected修饰的四个成员；\n\n**==解答3==**：在code15.php中构建代码如下：\n\n```php\n<?php\n\nclass ProtectedTest{\n    \n    #protected\n    protected $var3='protected_var3';\n    protected static $var4='protected_static_var4';\n\n    protected function f3(){ \n        echo 'protected_function_f3'; \n    }\n    protected static function f4(){ \n        echo 'protected_static_function_f4'; \n    }\n}\n\nclass Demo extends ProtectedTest{\n\n    #测试在继承链中访问父类中protected修饰的成员\n    public function test(){ \n        var_dump( $this->var3 ); echo '<br/>';\n        var_dump( parent::$var4 ); echo '<br/>';\n        $this->f3();echo '<br/>';\n        parent::f4();\n    }\n}\n\n//调用测试方法\n$obj = new Demo;\n$obj->test();\n\n```\n\n访问code15.php，效果为：\n\n![1530428798197](14_2.png)\n\n\n\n**==小结==**：\n\n1. 被protected修饰的成员，只能在  类的内部  和  继承链中  被**==直接==**访问；\n\n\n\n#### private\n\n**==需求1==**：使用code/prepare目录中的PrivateTest.class.php类文件中的类，要求，\n\n1. 测试在PrivateTest类的外部访问private修饰的四个成员；\n\n**==解答1==**：在code16.php中构建代码如下：\n\n```php\n<?php\n\nclass PrivateTest{\n    \n    #private\n    private $var5='private_var5';\n    private static $var6='private_static_var6';\n    \n    private function f5(){ \n        echo 'private_function_f5'; \n    }\n    private static function f6(){ \n        echo 'private_static_function_f6'; \n    }\n}\n\n#测试在类的外部直接访问private修饰的类成员\n$obj = new PrivateTest;\n//var_dump( $obj->var5 );//测试的结果为，报错，说明不能直接访问private修饰的 非静态属性\n//var_dump( PrivateTest::$var6 ); //测试的结果为，报错，说明不能直接访问private修饰的 静态属性\n//$obj->f5();//测试的结果为，报错，说明不能直接访问private修饰的 非静态方法\nPrivateTest::f6();//测试的结果为，报错，说明不能直接访问private修饰的 静态方法\n```\n\n访问code16.php，效果为：\n\n![1530429177226](15_2.png)\n\n\n\n**==需求2==**：使用code/prepare目录中的PrivateTest.class.php类文件中的类，要求，\n\n1. 在PrivateTest类中创建一个名为test的测试方法，测试在PrivateTest类的内部访问private修饰的四个成员；\n\n**==解答2==**：在code17.php中构建代码如下：\n\n```php\n<?php\n\nclass PrivateTest{\n    \n    #private\n    private $var5='private_var5';\n    private static $var6='private_static_var6';\n    \n    private function f5(){ \n        echo 'private_function_f5'; \n    }\n    private static function f6(){ \n        echo 'private_static_function_f6'; \n    }\n\n    #测试在本类的内部直接访问private修饰的成员\n    public function test(){ \n        var_dump( $this->var5 ); echo '<br/>';\n        var_dump( self::$var6 ); echo '<br/>';\n        $this->f5();echo '<br/>';\n        self::f6();\n    }\n}\n\n//调用测试方法\n$obj =new PrivateTest;\n$obj->test();\n```\n\n访问code17.php，效果为：\n\n![1530429332125](16_2.png)\n\n\n\n**==需求3==**：使用code/prepare目录中的PrivateTest.class.php类文件中的类，要求，\n\n1. 再创建一个名为PrivateTestSon的类继承PrivateTest类，在PrivateTestSon类中创建son_test方法，测试在继承链中访问PrivateTest类中private修饰的四个成员；\n\n**==解答3==**：在code18.php中构建代码如下：\n\n```php\n<?php\n\nclass PrivateTest{\n    \n    #private\n    private $var5='private_var5';\n    private static $var6='private_static_var6';\n    \n    private function f5(){ \n        echo 'private_function_f5'; \n    }\n    private static function f6(){ \n        echo 'private_static_function_f6'; \n    }\n}\n\nclass Demo extends PrivateTest{\n\n    #测试在继承链中直接访问父类中private修饰的成员\n    public function test(){ \n        //var_dump( $this->var5 );//虽然可以访问，但是实际上是一个NULL值，说明没有被继承下来\n        //var_dump( parent::$var6 ); //不可以直接访问，访问将会报错，说明继承链中不能直接访问受private修饰的  静态属性\n        //$this->f5();//不可以直接访问，访问将会报错，说明继承链中不能直接访问受private修饰的  非静态方法\n        parent::f6();//不可以直接访问，访问将会报错，说明继承链中不能直接访问受private修饰的  静态方法\n\n    }\n}\n\n//调用测试方法\n$obj = new Demo;\n$obj->test();\n```\n\n访问code18.php，效果为：\n\n![1530429804764](17_2.png)\n\n\n\n**==小结==**：\n\n1. 被private修饰的成员，**只能**在**本类**的内部被**==直接==**访问；\n\n\n\n### 继承的特点\n\n1. 类只能单继承，不能多继承，但是能够形成一个长串的继承链；\n\n   演示代码：\n\n   ```php\n   <?php\n   \n   class A{\n       public $var1='A';\n   }\n   \n   class B extends A{//让B继承A\n       public $var2='B';\n   }\n   \n   class C extends B{//让C继承B，则因为B继承了A，所以C也会拥有A中继承过来的成员\n       public $var3='C';\n   }\n   \n   \n   $obj = new C;\n   var_dump( $obj ); \n   \n   ```\n\n   执行演示代码，输出如下所示：\n\n   \n\n   ![1530430983383](18_2.png)\n\n2. 类只能继承父类中的非私有成员（不能使用但是可以看）；\n\n   ![1530431240869](19_2.png)\n\n\n\n## 3. ==重写==（override）\n\n**概念**：所谓的重写，指的就是对父类中**==已有方法的重新定义==**。\n\n**==需求==**：使用code/prepare目录中的Animal.class.php类文件，在code/code21.php中通过构建Birds类和Fish类实现继承Animal类，要求，\n\n1. 给Birds类构建非静态属性$firther，值为：有羽毛；给Fish类构建非静态属性$scale，值为：有鱼鳞；\n2. 在Birds类中重写父类的move方法，并测试使用；\n3. 在Fish类中重写父类的move方法，并测试使用；\n\n**==解答==**：在code21.php中构建代码如下：\n\n```php\n<?php\n\n\n#动物类\nclass Animal{\n    \n    public $name='动物';\n    public $age='生命周期';\n\n    public function move(){ \n        echo '哈哈，我能移动！'; \n    }\n}\n\n\nclass Birds extends Animal{\n    public $firther='有羽毛';\n\n    public function move(){ //对父类中已有的move方法进行重新定义\n        echo '呵呵呵，我可以飞行来移动！'; \n    }\n}\n\nclass Fish extends Animal{\n    public $scale='有鱼鳞';\n\n    public function move(){ //对父类中已有的move方法进行重新定义\n        echo '嘿嘿嘿，我可以游动来移动！'; \n    }\n}\n\n$bird1 = new Birds;\n$bird1->move();\n\necho '<hr/>';\n\n$fish1 = new Fish;\n$fish1->move();\n```\n\n访问code21.php，效果为：\n\n![1530432147116](20_2.png)\n\n**==小结==**：\n\n1. 重写可以保证老的代码的完整性不会被破坏；\n2. 重写就是对父类中已有方法的重新定义；\n\n\n\n### 魔术方法重写问题\n\n**引言**：我们可以通过重写的方式达到即不改动老的代码，又能改进功能的目的，但是在类中，有一种方法一旦被重写，将会导致出现问题，这个方法就是魔术方法。\n\n\n\n**==需求1==**：使用code/prepare目录中的Father1.class.php类文件，在code/code23.php中通过构建Son类实现继承Father1类，要求，\n\n1. Son类中构建两个非静态属性，分别为$son_name、$son_age，不指定初始值；\n2. Son类中构建构造方法为$son_name、$son_age赋值，创建基于Son类的对象，打印该对象查看效果；\n3. 解决Son中的构造方法对父类构造方法的重写问题；\n\n**==解答1==**：在code23.php中构建代码如下：\n\n```php\n<?php\n\nclass Father1{\n    \n    public $father_name;\n    public $father_age;\n\n    public function __construct($name, $age){ \n        \n        $this->father_name = $name;\n        $this->father_age = $age;\n    }\n}\n\nclass Son extends Father1{\n\n    public $son_name;\n    public $son_age;\n\n    public function __construct($v1, $v2, $v3, $v4){ \n\n        #解决父类构造方法被重写的方法\n        parent::__construct($v1, $v2);//在子类构造方法中的第一时间，先将父类构造方法执行一次。\n        $this->son_name = $v3;\n        $this->son_age = $v4;\n    }\n}\n\necho '<pre>';\n$obj1 = new Son('zhangsan_father', 58, 'zhangsan', 18);\nvar_dump( $obj1 ); \n```\n\n访问code23.php，效果为：\n\n![1530433740258](21_2.png)\n\n**==小结1==**：\n\n1. 当前的例子是以构造方法被重写为案例的，其实解决魔术方法被重写的方式和解决构造方法被重写的方式是一样的，解决魔术方法重写的方式如下：\n\n```php\nparent::方法名([形参列表]);\n```\n\n\n\n## 4. ==final关键字==\n\n在php中，final关键字可以用来定义两种东西：\n\n- [x] 类                        使用final关键字定义的类，我们称其为  ==final类==或==最终类==\n- [x] 类中的方法         使用final关键字定义的类中的方法，我们称其为  ==final方法==或==最终方法==\n\n\n\n### 最终类\n\n==实现语法==：\n\n```php\n//使用final关键字申明类\nfinal  class  类名{\n\t类成员\n}\n```\n\n\n\n**==演示案例==**：构建code25.php程序文件，代码如下：\n\n```php\n<?php\n\nclass A{\n    public $var1='A';\n}\n\nfinal class B{//如果带上了final关键字申明，则意味着该类不能被继承了\n    public $var2='B';\n}\n\nclass C extends A{\n\n}\n\nclass D extends B{\n\n}\n\n$c = new C;\nvar_dump( $c ); \n\n```\n\n访问code25.php，效果为：\n\n![1530435022410](22_2.png)\n\n\n\n**==小结==**：\n\n1. 如果是final申明的类，则这个不能被继承；\n\n\n\n### 最终方法\n\n==实现语法==：\n\n```php\n//使用final关键字申明方法\nfinal public/protected [static] function  方法名(){\n\t方法体\n}\n```\n\n\n\n**==演示案例==**：构建code26.php程序文件，代码如下：\n\n```php\n<?php\n\nclass B{\n\n    public function f1(){ \n        echo 'f1'; \n    }\n\n    final public function f2(){ //如果一个方法被final声明了，则这个方法在子孙类中就不能被重写(override)了\n        echo 'f2'; \n    }\n}\n\nclass C extends B{\n\n    public function f2(){ \n        echo 'C-f2'; \n    }\n}\n```\n\n访问code26.php，效果为：\n\n![1530435385397](23_2.png)\n\n\n\n**==小结==**：\n\n1. 被final声明的方法不能被子孙类重写(override)；\n\n\n\n## 5. ==抽象类==\n\n==实现语法==：\n\n```php\n//使用abstract申明一个抽象类\nabstract  class  类名{\n\t抽象类成员\n}\n```\n\n\n\n### 抽象类的成员\n\n抽象类的成员包含两个部分：\n\n- [x] 普通类的所有成员\n- [x] 抽象方法\n\n\n\n定义方式：\n\n```php\n<?php\n\n#使用abstract关键字声明一个抽象类\nabstract class AbstractDemo{\n\n    #普通类的成员\n    public $var1='var1';\n    public static $var2='var2';\n\n    const URL='www.home.com';\n\n    public function f1(){ \n        echo 'f1'; \n    }\n    public static function f2(){ \n        echo 'f2'; \n    }\n\n    #抽象方法\n    abstract public function f3($v1, $v2=100);\n}\n```\n\n\n\n### 抽象类的特点\n\n1. 抽象类==只能被继承==，==不能被==直接==实例化==为对象，但是抽象类中的静态成员和类常量都能够正常使用；\n\n   演示代码：\n\n   ```php\n   <?php\n   \n   abstract class AbstractDemo{\n   \n       #普通类的成员\n       public $var1='var1';\n       public static $var2='var2';\n   \n       const URL='www.home.com';\n   \n       public function f1(){ \n           echo 'f1'; \n       }\n       public static function f2(){ \n           echo 'f2'; \n       }\n   \n       #抽象方法\n       abstract public function f3($v1, $v2=100);\n   }\n   \n   #抽象类不能用来实例化成对象\n   //$obj = new AbstractDemo;\n   \n   var_dump( AbstractDemo::$var2 ); //访问静态属性\n   echo '<br/>';\n   AbstractDemo::f2(); //访问静态方法\n   echo '<br/>';\n   var_dump( AbstractDemo::URL ); //访问类常量\n   ```\n\n   访问测试代码，输出效果为：\n\n   ![1530436054783](24_2.png)\n\n2. 抽象类如果被普通类所继承，那么抽象类中的抽象方法必须==全部==被实现；\n\n   演示代码：\n\n   ```php\n   <?php\n   \n   abstract class A{\n   \n       #抽象方法\n       abstract public function f3($v1, $v2=100);\n       abstract public function f4();\n   }\n   \n   class B extends A{\n       \n       public function f3($v1, $v2=100){ //实现了父类中的抽象方法f3\n           \n       }\n   }\n   ```\n\n   访问测试代码，输出效果为：\n\n   ![1530436516925](25_2.png)\n\n3. 抽象类还可以被抽象类所继承，如果被抽象类所继承，那么被继承的那个抽象类中其抽象方法可以不被实现；\n\n   演示代码：\n\n   ```php\n   <?php\n   \n   abstract class A{\n   \n       #抽象方法\n       abstract public function f2();\n       abstract public function f3($v1, $v2=100);\n   }\n   \n   abstract class B extends A{//抽象类继承抽象类，则父类中的抽象方法可以不被实现\n       \n       abstract public function f4();\n   \n       public function f2(){ \n           \n       }\n   }\n   \n   ```\n\n   \n\n## 7. 全天总结\n\n1. 使用静态方法实现自动加载。\n\n   步骤：\n\n   1)定义一个静态方法，实现自动加载功能；\n\n   2)使用spl_autoload_register将这个静态方法注册成为自动加载方法；\n\n2. 继承的特点，\n\n   1. 继承只能单继承（只能有一个爸爸），不能多继承，但是可以实现长串的继承链（可以有爸爸，也可以有爷爷，曾爷爷。。。）；\n   2. 继承只能继承非私有的成员，私有的成员能看到，但是不能使用；\n\n3. 访问限定修饰符\n\n   1. public                  表示公有的，被public修饰的成员，能够在类的外部，类的内部和类的继承链中被**==直接==**访问；\n   2. protected           表示受保护的，被protected修饰的成员，只能在类的内部和类的继承链中被**==直接==**访问；\n   3. private                表示私有的，被private修饰的成员，只能在本类的内部被**==直接==**访问；\n\n4. 构造方法如果被重写，可以使用固定的一个结果：parent::__construct([实参列表])来避免构造方法被重写；\n\n5. final关键字如果声明的是一个类，则该类不能再被继承；如果声明的是一个方法，则方法不能被重写；\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["PHP面向对象编程"]},{"title":"面向对象4","url":"%2Fposts%2F1620559679%2F","content":"\n\n# 面向对象4\n\n## 1. ==对象的遍历==\n\n对象和数组本质上同属于**复合数据**类型，我们可以在程序中可以对数组进行遍历。\n\n\n\n回顾对数组的遍历：\n\n**==需求==**：对以下指定的数组进行foreach遍历\n\n```php\n$arr = ['name'=>'zhangsan', 'age'=>12, 'height'=>1.78];\n```\n\n**==解答==**：构建名为code1.php的文件，代码如下：\n\n```php\n$arr = ['name'=>'zhangsan', 'age'=>12, 'height'=>1.78];\n\nforeach( $arr as $k=>$v ){ \n    echo 'Key：'; \n    var_dump( $k ); echo '<br/>';\n    echo 'Value：'; \n    var_dump( $v ); echo '<hr/>';\n}\n```\n\n访问code1.php的效果：\n\n![1530668234222](4_4.png)\n\n**==小结==**：\n\n1. 遍历数组其实就是每次都去得到数组的一个元素，将数组元素的下标赋值给$k，将数组元素的值赋值给$v；\n\n\n\n**提问**：我们可以对数组进行遍历，那么，是否也能够对对象进行遍历呢？\n\n### 默认的对象遍历\n\n我们尝试对对象进行一次遍历测试，\n\n\n\n**==需求==**：对$a1对象进行foreach遍历\n\n```php\nclass A{\n    \n    public $name='zhangsan';\n    public $age=12;\n    public $height=1.8;\n}\n\n$a1 = new A;\n```\n\n**==解答==**：构建名为code2.php的文件，代码如下：\n\n```php\nclass A{\n    \n    public $name='zhangsan';\n    public $age=12;\n    public $height=1.8;\n}\n\n$a1 = new A;\nvar_dump( $a1 ); echo '<hr/>';\n\nforeach( $a1 as $k=>$v ){ \n    echo 'Key：'; \n    var_dump( $k ); echo '<br/>';\n    echo 'Value：'; \n    var_dump( $v ); echo '<hr/>';\n}\n```\n\n访问code2.php的效果：\n\n![1530668552715](5_4.png)\n\n**==小结==**：\n\n1. 默认的对象遍历，其实就是逐个 的去获得属性的名和属性的值；\n\n\n\n### 自定义对象遍历\n\nPHP中，还提供了一种自定义遍历对象的方式。\n\n\n\n实现自定义对象遍历的**前提**：需要实现PHP==预定义==接口\"Iterator\"\n\n自定义对象遍历的**概念**：当==遍历==一个==对象时==，PHP自动==按顺序执行==预定义接口Iterator中实现的==五个方法==。 \n\n\n\nPHP预定义接口Iterator：\n\n![1530607474017](1_4.png)\n\n\n\n**==需求1==**：测试Iterator接口中五个抽象方法的执行顺序；\n\n**==解答1==**：构建名为code4.php的文件，代码如下：\n\n```php\n#使用一个普通类实现预定义接口Iterator\nclass A implements Iterator{\n\n    public $num=0;\n\n    public function current(){ \n        echo 'current<br/>'; \n    }\n    public function key(){ \n        echo 'key<br/>'; \n    }\n    public function next(){ \n        echo 'next<br/>'; \n    }\n    public function rewind(){ \n        echo 'rewind<br/>'; \n    }\n    public function valid(){ \n        if( $this->num<1 ){\n            $this->num++;\n            echo 'valid<br/>'; \n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n\n$a1 = new A;\nforeach( $a1 as $k=>$v ){ //遍历$a1对象，触发PHP自动去按顺序执行5个被实现了的抽象方法\n    \n}\n```\n\n访问code4.php的效果：\n\n![1530669826108](6_4.png)\n\n**==小结1==**：\n\n1. 我们从最终的效果中发现，5个抽象方法执行的顺序是：1)rewind方法，2）valid方法，3）current方法，4）key方法，5）next方法；\n\n\n\n5个抽象方法的作用前置说明：\n\n![1530670918450](7_4.png)\n\n\n\n**==需求2==**：使用Iterator预定义接口完成对$arr属性中保存的数组数据的遍历；\n\n1. 需要使用如下所示的类：\n\n   ```php\n   class A{\n       \n       public $arr=['name'=>'zhangsan', 'age'=>12, 'height'=>1.78];\n   }\n   ```\n\n**==解答2==**：构建名为code5.php的文件，代码如下：\n\n```php\n#实现Iterator预定义接口\nclass A implements Iterator{\n    \n    public $var1='var1';\n    public $var2='var2';\n    public $arr=['name'=>'zhangsan', 'age'=>12, 'height'=>1.78];\n\n    #rewind方法将会被首次执行\n    public function rewind(){ \n        reset($this->arr);//重置$arr属性所保存数组指针到第一个元素的位置\n    }\n\n    #当第一轮遍历的时候，valid将会被作为第二个被执行的方法来执行；以后每一轮都将最为第一个被执行的方法来执行\n    public function valid(){ \n        if( key($this->arr)===NULL ){//如果当前元素的指针所在位置上的元素下标的值为NULL，则说明指针已经挪出了数组了\n            return false;//返回false，停止继续往下循环执行\n        }else{//否则则说明指针还在数组里面\n            return true;//返回true,继续往下执行\n        }\n    }\n    #当第一轮遍历的时候，current方法将会作为第三个被执行的方法来执行；以后每一轮都将作为第二个被执行的方法来执行\n    public function current(){ \n        return current($this->arr);//将当前指针位置上的元素值返回给foreach结构的$v\n    }\n    #当第一轮遍历的时候，key方法将会作为第四个被执行的方法来执行；以后每一轮都将作为第三个被执行的方法来执行\n    public function key(){ \n        return key($this->arr);//将当前指针位置上的元素键返回给foreach结构的$k\n    }\n    #next方法是每一轮的最后一次将被执行的方法\n    public function next(){ \n        next($this->arr);//将$arr属性保存的数组元素的指针向下移动一位\n    }\n}\n\n$a1 = new A;\nforeach( $a1 as $k=>$v ){ \n    echo 'key：'; \n    var_dump( $k ); echo '<br/>';\n    echo 'value：'; \n    var_dump( $v ); echo '<hr/>';\n}\n```\n\n访问code5.php的效果：\n\n![1530673346357](8_4.png)\n\n**==小结2==**：\n\n1. 当实现了一个预定义接口Iterator及其5个抽象方法后，再使用遍历的方式去遍历对象的话，则会触发PHP自动按顺序去执行5个实现了的抽象方法；\n\n\n\n## 2. ==对象的序列化与反序列化==\n\n在PHP中，如果我们直接将（PHP八种数据类型）数据写入文件中，那么，除了字符串数据外，其他的数据都将会失真。\n\n\n\n**==需求==**：按要求完成以下操作；\n\n1. 在code目录中创建code9.php的程序，代码如下，访问该程序页面将八种数据类型数据写入文件中：\n\n   ```php\n   #标量数据类型\n   $string = 'string';//字符串\n   $int = 100;//整型\n   $float = 3.14;//浮点\n   $bool = true;//布尔\n   \n   file_put_contents('./txt/string.txt', $string);\n   file_put_contents('./txt/int.txt', $int);\n   file_put_contents('./txt/float.txt', $float);\n   file_put_contents('./txt/bool.txt', $bool);\n   \n   #复合数据类型\n   $array = ['zhangsan', 16];//数组\n   $object = new stdClass;//对象\n   \n   file_put_contents('./txt/array.txt', $array);\n   file_put_contents('./txt/object.txt', $object);\n   \n   #特殊数据类型\n   $resource = opendir('./dir');//资源\n   $null = null;//null\n   \n   file_put_contents('./txt/resource.txt', $resource);\n   file_put_contents('./txt/null.txt', $null);\n   ```\n\n2. 再在code目录下创建code10.php程序，代码如下，访问该程序页面，分别读取八个文件中保存的八种数据，查看最终打印效果，\n\n   ```php\n   #标量数据类型\n   $string = file_get_contents('./txt/string.txt');\n   echo 'string.txt文件的内容：<br/>'; \n   var_dump( $string ); \n   echo '<hr/>';\n   \n   $int = file_get_contents('./txt/int.txt');\n   echo 'int.txt文件的内容：<br/>'; \n   var_dump( $int ); \n   echo '<hr/>';\n   \n   $float = file_get_contents('./txt/float.txt');\n   echo 'float.txt文件的内容：<br/>'; \n   var_dump( $float ); \n   echo '<hr/>';\n   \n   $bool = file_get_contents('./txt/bool.txt');\n   echo 'bool.txt文件的内容：<br/>'; \n   var_dump( $bool ); \n   echo '<hr/>';\n   \n   \n   #复合数据类型\n   $array = file_get_contents('./txt/array.txt');\n   echo 'array.txt文件的内容：<br/>'; \n   var_dump( $array ); \n   echo '<hr/>';\n   \n   $object = file_get_contents('./txt/object.txt');\n   echo 'object.txt文件的内容：<br/>'; \n   var_dump( $object ); \n   echo '<hr/>';\n   \n   \n   #特殊数据类型\n   $resource = file_get_contents('./txt/resource.txt');\n   echo 'resource.txt文件的内容：<br/>'; \n   var_dump( $resource ); \n   echo '<hr/>';\n   \n   $null = file_get_contents('./txt/null.txt');\n   echo 'null.txt文件的内容：<br/>'; \n   var_dump( $null ); \n   echo '<hr/>';\n   ```\n\n**==解答==**：最终读取txt文件的内容效果为：\n\n![1530674681298](9_4.png)\n\n**==小结==**：\n\n1. 除了字符串类型在保存前和读取后数据值和数据类型都维持了一致，其余7中数据类型全部都失真了。\n\n\n\n在PHP中，将对象进行序列化与反序列化操作就是为了让对象数据类型数据，存储进文件后，再从文件中读取出来也不失真。\n\n\n\n### 对象的序列化\n\n**概念**：对象的序列化就是通过==serialize函数==将某个==对象转换==成一个具有固定信息格式的==字符串==。\n\n涉及的函数：\n\n> **serialize**(对象)      将对象进行序列化\n\n\n\n**==需求==**：将如下所示的对象$d进行序列化，并且将序列化后的结果输出；\n\n```php\nclass DirTool{\n    public $path;\n    public $resource;\n    \n    public function __construct(){\n        $this->path = './dir';\n        $this->resource = opendir($this->path);\n    }\n}\n\n$d = new DirTool;\n```\n\n**==解答==**：构建名为code11.php的文件，代码如下：\n\n```php\nclass DirTool{\n    public $path;\n    public $resource;\n    \n    public function __construct(){\n        $this->path = './dir';\n        $this->resource = opendir($this->path);\n    }\n}\n\n$d = new DirTool;\nvar_dump( $d ); //直接打印对象\necho '<hr/>';\n$str = serialize($d);//将$d对象进行序列化操作\nvar_dump( $str ); \n\n```\n\n访问code11.php的效果：\n\n![1530675554615](10_4.png)\n\n**==小结==**：\n\n1. 使用serialize函数能够直接将对象进行序列化；\n2. 将对象序列化之后，其实就变成了一个具有固定格式的字符串；\n\n\n\n#### __sleep魔术方法\n\n当对象被序列化时，如果类中定义了__sleep魔术方法，则该魔术方法将会被PHP自动调用执行。\n\n\n\n**==需求==**：在如下所示的类中构建__sleep魔术方法；\n\n```php\nclass DirTool{\n    public $path;\n    public $resource;\n    \n    public function __construct(){\n        $this->path = './dir';\n        $this->resource = opendir($this->path);\n    }\n}\n\n$d = new DirTool;\n```\n\n1. 在魔术方法中输出\"100\"，观察访问页面效果；\n\n2. 在魔术方法中构建如下代码，观察访问页面效果；\n\n   ```php\n   return array('path');\n   ```\n\n**==解答==**：构建名为code12.php的文件，代码如下：\n\n```php\nclass DirTool{\n    public $path;\n    public $resource;\n    \n    public function __construct(){\n        $this->path = './dir';\n        $this->resource = opendir($this->path);\n    }\n\n    //定义一个__sleep魔术方法\n    public function __sleep(){ \n        //echo 100; \n        return array('path');//return语句中的数组元素，负责控制将会把哪些属性进行序列化\n    }\n}\n\n$d = new DirTool;\n\n$str = serialize($d);//将$d对象进行序列化\nvar_dump( $str ); \n```\n\n访问code12.php的效果：\n\n![1530676203069](11_4.png)\n\n**==小结==**：\n\n1. PHP不负责定义__sleep魔术方法，只负责调用这个魔术方法；\n2. 调用这个魔术方法的时机是，当使用serialize对一个对象进行序列化时，将会触发PHP自动调用执行这个魔术方法；\n3. 如果在魔术方法中构建return语句返回数组，则数组可以控制哪些属性将会被序列化，不在数组当中的属性将不会被序列化；\n\n\n\n### 对象的反序列化\n\n**概念**：对象的反序列化就是通过unserialize函数将==某个对象序列化后的字符串==**还原回**原来的==对象==。\n\n涉及的函数：\n\n> **unserialize**(序列化后的字符串)      将对象进行反序列化\n\n\n\n**==需求1==**：按要求完成以下操作：\n\n1. 构建程序文件code13.php，内容如下，将$str进行反序列化，打印反序列化后的结果，观察效果；\n\n   ```php\n   $str = 'O:7:\"DirTool\":2:{s:4:\"path\";s:5:\"./dir\";s:8:\"resource\";i:0;}';\n   ```\n\n**==解答1==**：构建名为code13.php的文件，代码如下：\n\n```php\n\n$str = 'O:7:\"DirTool\":2:{s:4:\"path\";s:5:\"./dir\";s:8:\"resource\";i:0;}';//这个是某个对象序列化后的字符串结果\n\n#执行反序列化操作\n$obj = unserialize($str);\n\nvar_dump( $obj ); \n```\n\n访问code13.php的效果：\n\n![1530676639879](12_4.png)\n\n**==小结1==**：\n\n1. 在反序列化对象时，如果没有原始类的定义，则反序列化后，PHP将会自动把该对象划归为PHP中的一个预定义系统类__PHP\\_Incomplete\\_Class中；\n\n\n\n**==需求2==**：按要求完成以下操作：\n\n1. 构建程序文件codex1.php，内容如下，将$str进行反序列化，打印反序列化后的结果，观察效果；\n\n   ```php\n   class DirTool{\n       public $path;\n       public $resource;\n       \n       public function __construct(){\n           $this->path = './dir';\n           $this->resource = opendir($this->path);\n       }\n   }\n   \n   $str = 'O:7:\"DirTool\":2:{s:4:\"path\";s:5:\"./dir\";s:8:\"resource\";i:0;}';\n   ```\n\n**==解答2==**：构建名为code16.php的文件，代码如下：\n\n```php\nclass DirTool{      //原始类的定义\n    public $path;\n    public $resource;\n    \n    public function __construct(){\n        $this->path = './dir';\n        $this->resource = opendir($this->path);\n    }\n}\n\n$str = 'O:7:\"DirTool\":2:{s:4:\"path\";s:5:\"./dir\";s:8:\"resource\";i:0;}';//对象序列化后的字符串结果\n\n$obj = unserialize($str);//反序列化回一个对象\nvar_dump( $obj ); \n```\n\n访问code16.php的效果：\n\n![1530687768539](13_4.png)\n\n**==小结2==**：\n\n1. 反序列化需要使用unserialize函数来实现；\n2. 反序列化时必须要有原始类的定义才能够正确的还原对象；\n\n\n\n#### __wakeup魔术方法\n\n当对象序列化的字符串结果被反序列化时，如果类中定义了__wakeup魔术方法，则该魔术方法将会被PHP自动调用执行。\n\n\n\n**==需求==**：在如下所示的类中构建__wakeup魔术方法；\n\n```php\nclass DirTool{\n    public $path;\n    public $resource;\n    \n    public function __construct(){\n        $this->path = './dir';\n        $this->resource = opendir($this->path);\n    }\n}\n\n$str = 'O:7:\"DirTool\":2:{s:4:\"path\";s:5:\"./dir\";s:8:\"resource\";i:0;}';\nvar_dump(unserialize($str));\n```\n\n1. 在魔术方法中输出\"100\"，观察访问页面效果；\n2. 在魔术方法中再次把$resource属性的资源值重新还原回来，观察访问页面效果；\n\n**==解答==**：构建名为code17.php的文件，代码如下：\n\n```php\nclass DirTool{      //原始类的定义\n    public $path;\n    public $resource;\n    \n    public function __construct(){\n        $this->path = './dir';\n        $this->resource = opendir($this->path);\n    }\n\n    #构建一个__wakeup魔术方法\n    public function __wakeup(){ \n        $this->resource = opendir($this->path);\n    }\n}\n\n$str = 'O:7:\"DirTool\":2:{s:4:\"path\";s:5:\"./dir\";s:8:\"resource\";i:0;}';//对象序列化后的字符串结果\n\n$obj = unserialize($str);//反序列化回一个对象\nvar_dump( $obj ); \n```\n\n访问code17.php的效果：\n\n![1530688892385](14_4.png)\n\n**==小结==**：\n\n1. PHP不负责定义__wakeup魔术方法，只负责调用该方法；\n2. 调用该魔术方法的时机：当反序列化一个对象序列化字符串结果时，将会被PHP自动调用执行一次；\n\n\n\n## 3. ==反射机制==\n\n函数拓展：\n\n> **get_declared_classes**()   获得当前程序脚本中所定义出的所有类的类名\n>\n> **get_class_methods**(类名)    获得类中定义的方法信息\n\n \n\n我们可以在程序中通过以上两个函数和其他的一些函数获得类中相关的一些简单信息。但是有时候我们需要获得更加详细的类中的信息，通过这些简单函数就没有办法获得了。那怎么呢？\n\n \n\n在PHP中，我们可以通过反射机制来获得更详细的类中的信息！反射机制可以形象的比喻为： X光机 或 照妖镜\n\n\n\n在PHP中，我们是通过PHP==预定义==好的类来实现反射机制的，\n\n![1530612867044](2_4.png)\n\n\n\n反射机制可以分为：1）类的反射；2）类常量的反射；3）类属性的反射；4）类方法的反射；5）类方法参数的反射；\n\n\n\n### 类的反射\n\n涉及的方法：\n\n> ReflectionClass::export    反射指定的类的信息\n>\n> getFileName    反射类所在的文件名\n>\n> implementsInterface    判断某个类是否实现了某个接口\n\n\n\n**==需求1==**：引入code/prepare/CatpchaTool.class.php文件，使用ReflectionClass::export反射CaptchaTool类的信息；\n\n**==解答1==**：构建名为code20.php的文件，代码如下：\n\n```php\ninclude './prepare/CaptchaTool.class.php';//引入类文件\n\necho '<pre>';\n//ReflectionClass::export('CaptchaTool');//第一个参数可以是  类名\n\n//$obj = new CaptchaTool;\n//ReflectionClass::export($obj);//第一个参数也可以是基于某个类创建的对象\n\n$info = ReflectionClass::export('CaptchaTool', true);//第二个参数如果不指定，则信息将会直接输出到浏览器，如果指定为true，则信息将会以返回值的信息返回\necho '<pre>';\nvar_dump( $info ); \n\n```\n\n访问code20.php的效果：\n\n![1530692397154](15_4.png)\n\n**==小结1==**：\n\n1. ReflectionClass::export可以实现获得类中的详细类信息；\n\n\n\n**==需求2==**：引入code/prepare/CatpchaTool.class.php文件，使用getFileName方法反射CaptchaTool类所在的文件名；\n\n**==解答2==**：构建名为code21.php的文件，代码如下：\n\n```php\ninclude './prepare/CaptchaTool.class.php';//引入类文件\n\n$obj = new ReflectionClass('CaptchaTool');//创建ReflectionClass类的对象，反射CaptchaTool类中的信息\nvar_dump( $obj ); echo '<hr/>';\n$fileName = $obj->getFileName();//获得CaptchaTool类所在的文件\nvar_dump( $fileName ); \n```\n\n访问code21.php的效果：\n\n![1530692843172](16_4.png)\n\n**==小结2==**：\n\n1. getFileName能够获取某个类所在的文件全路径。\n\n\n\n**==需求3==**：使用如下代码，按要求完成操作：\n\n```php\ninterface inter1{}\ninterface inter2{}\n\nclass A implements inter2{}\n```\n\n1. 使用implementsInterface方法反射A类是否实现了inter1和inter2接口；\n\n**==解答3==**：构建名为code22.php的文件，代码如下：\n\n```php\ninterface inter1{}\ninterface inter2{}\n\nclass A implements inter2{}\n\n$obj = new ReflectionClass('A');//实例化ReflectionClass反射类的对象，反射A类的信息\n$re = $obj->implementsInterface('inter1');//判断需要反射的A类是否有实现指定的inter1接口\nvar_dump( $re ); echo '<hr/>';//返回false意味着没有实现inter1接口\n$re = $obj->implementsInterface('inter2');//判断需要反射的A类是否有实现指定的inter2接口\nvar_dump( $re ); //返回true意味着实现了inter2接口\n```\n\n访问code22.php的效果：\n\n![1530693358443](17_4.png)\n\n**==小结3==**：\n\n1. implementsInterface方法可以判断某个类是否实现了某个接口。\n\n\n\n### 类常量的反射\n\n涉及的方法：\n\n> getConstants方法    获得所有相关常量的信息\n\n\n\n**==需求==**：使用如下代码，按要求完成操作：\n\n```php\nclass A{\n    const URL='www.home.com';\n}\n```\n\n1. 使用getConstants方法反射A类中的常量信息；\n\n**==解答==**：构建名为code23.php的文件，代码如下：\n\n```php\nclass A{\n    const URL='www.home.com';\n    const PATH='./source';\n}\n\n$obj = new ReflectionClass('A');//实例化ReflectionClass反射类的对象，反射A类的信息\n$info = $obj->getConstants();//获得类常量的所有信息\nvar_dump( $info ); \n```\n\n访问code23.php的效果：\n\n![1530694151735](18_4.png)\n\n**==小结==**：\n\n1. getConstants方法可以获取所有常量的信息；\n\n\n\n### 类属性的反射\n\n涉及的方法：\n\n> getProperties方法  获得类中所有属性的信息 \n\n\n\n**==需求==**：引入code/prepare/CatpchaTool.class.php文件，使用getProperties方法反射CaptchaTool类中所有属性的信息；\n\n**==解答==**：构建名为code24.php的文件，代码如下：\n\n```php\ninclude './prepare/CaptchaTool.class.php';//引入类文件\n\n$obj = new ReflectionClass('CaptchaTool');//创建ReflectionClass类的对象，反射CaptchaTool类中的信息\n$info = $obj->getProperties();\necho '<pre>';\nvar_dump( $info ); \n```\n\n访问code24.php的效果：\n\n![1530694279997](19_4.png)\n\n**==小结==**：\n\n1. getProperties可以获取类中所有的属性信息；\n\n\n\n### 类方法的反射\n\n涉及的方法：\n\n> getMethods方法  获得类中所有方法的信息\n\n\n\n**==需求==**：引入code/prepare/CatpchaTool.class.php文件，使用getMethods方法反射CaptchaTool类中所有方法的信息；\n\n**==解答==**：构建名为code25.php的文件，代码如下：\n\n```php\ninclude './prepare/CaptchaTool.class.php';//引入类文件\n\n$obj = new ReflectionClass('CaptchaTool');//创建ReflectionClass类的对象，反射CaptchaTool类中的信息\n$info = $obj->getMethods();\necho '<pre>';\nvar_dump( $info ); \n```\n\n访问code25.php的效果：\n\n![1530694387522](20_4.png)\n\n**==小结==**：\n\n1. getMethods可以获取类中所有方法名；\n\n\n\n### 类方法参数的反射\n\n涉及的方法：\n\n> ReflectionMethod::export     反射指定方法的参数信息\n\n\n\n**==需求==**：引入code/prepare/CatpchaTool.class.php文件，使用ReflectionMethod::export方法反射CaptchaTool类中getColor方法所有参数的信息；\n\n**==解答==**：构建名为code26.php的文件，代码如下：\n\n```php\ninclude './prepare/CaptchaTool.class.php';//引入类文件\n\necho '<pre>';\n//ReflectionMethod::export('CaptchaTool', 'getColor');//反射CaptchaTool类中的getColor方法中的所有参数信息，不指定第三个参数，默认是false，表示直接将信息输出到浏览器\n$info = ReflectionMethod::export('CaptchaTool', 'getColor', true);//\nvar_dump( $info ); \n```\n\n访问code26.php的效果：\n\n![1530694732275](21_4.png)\n\n**==小结==**：\n\n1. ReflectionMethod::export可以反射指定类中某个指定方法的所有参数信息；\n\n\n\n## 4. ==命名空间==\n\n**提问**：我们在电脑中，如何创建两个同名的文件？\n\n回答： 在不同的文件夹下创建同名文件即可。\n\n \n\n**提问**：在PHP中，同一个脚本代码程序里，是否能够创建两个相同名的函数？\n\n回答：正常情况下，是不行的。但是，如果使用了命名空间，则允许创建同名函数。\n\n\n\n命名空间的定义语法：\n\n```php\n#关键字为namespace\nnamespace  空间名; \n```\n\n\n\n**==需求==**：在程序中实现定义两个同名函数f1；\n\n**==解答==**：构建名为code27.php的文件，代码如下：\n\n```php\nnamespace first;//定义一个命名空间名字叫first空间\n\nfunction f1(){ \n    echo 'f1'; \n}\n\nnamespace second;//定义一个命名空间，名字叫second空间\n\nfunction f1(){ \n    echo 'new-f1'; \n}\n```\n\n访问code27.php的效果：\n\n![1530695119116](22_4.png)\n\n**==小结==**：\n\n1. 可以使用关键字namespace定义命名空间；\n\n\n\n**==注意事项==**：命名空间==首次定义==之前不能有任何PHP非注释代码；\n\n==演示案例==：\n\n![1530695234154](23_4.png)\n\n\n\n### 空间成员\n\n命名空间所支持控制的成员包括三种：1）函数；2）类；3）老版本的常量；\n\n\n\n### 全局空间和子空间\n\n全局空间示例：程序页面中未指定命名空间的部分就属于全局空间。\n\n![1530695566139](24_4.png)\n\n\n\n==子空间示例==：\n\n![1530695776831](25_4.png)\n\n\n\n### 命名空间的三种访问方式\n\n命名空间的三种访问方式包括：1)非限定名称访问；2）完全限定名称访问；3）限定名称访问；\n\n\n\n#### 非限定名称访问\n\n**概念**：所谓的非限定名称访问，指的就是在访问的成员前面不加上命名空间。 \n\n==演示案例==：\n\n![1530695967585](26_4.png)\n\n\n\n#### 完全限定名称访问(推荐)\n\n**概念**：完全限定名称访问指的就是从全局空间开始指定一直访问到该成员的访问方式。 \n\n==演示案例==：\n\n![1530696149324](27_4.png)\n\n\n\n#### 限定名称访问\n\n**概念**：表示从当前空间开始，直接指定子空间的成员。 \n\n==演示案例==：\n\n![1530696438035](28_4.png)\n\n\n\n#### 总结\n\n1. 完全限定名称访问的方式是从全局空间开始一直指定到需要访问的成员为止；\n\n\n\n### 空间引入\n\n==演示案例==：\n\n构建一个名为code34.php的文件，代码如下：\n\n```php\nnamespace second;\n\nfunction f1(){ \n    echo 'second-f1'; \n}\n```\n\n再构建一个名为code33.php的文件，代码如下：\n\n```php\nnamespace first;\n\nfunction f1(){ \n    echo 'first-f1'; \n}\n\ninclude './code34.php';\n\nf1();\n```\n\n访问code33.php效果为：\n\n![1530696744827](29_4.png)\n\n**==小结==**：\n\n从上面的案例效果来看，我们发现没有输出second-f1，而是输出了first-f1，说明非限定名称访问方式访问到的最近的空间是first，为什么不是引入进来的second空间？\n\n\n\n#### 空间引入的原理\n\n![1530697224171](30_4.png)\n\n\n\n### 空间类的引入\n\n==演示案例==：\n\n![1530697667733](31_4.png)\n\n\n\n**==小结==**：\n\n1. 空间类的引入必须引入到具体的类名上；\n\n\n\n## 5. 全天总结\n\n1. 对象的遍历：1）默认的对象遍历；2）自定义的对象遍历；\n\n   默认的对象遍历：foreach遍历一个对象，就是逐个去获得对象中的属性名和属性值；\n\n   自定义对象的遍历：（如果实现了一个名为Iterator的预定义接口）foreach遍历一个对象时，则会触发PHP自动按顺序调用执行5个被实现了的接口抽象方法；\n\n2. 对象的序列化：使用serialize函数将一个对象进行序列化，如果存在__sleep魔术方法，则序列化一个对象时将会触发PHP自动调用执行一次该魔术方法；\n\n   对象的反序列化（必须要有原始类的定义）：使用unserialize函数将一个对象序列化后的字符串结果还原回原来的对象；如果存在__wakeup魔术方法，则反序列化时将会触发PHP自动调用执行一次该魔术方法；\n\n3. 反射机制的概念：通过PHP内置的预定义系统类，获得某个指定的类中所有的相关成员的信息；\n\n4. 定义命名空间：使用namespace关键字定义命名空间；\n\n   ==完全限定名称==访问调用命名空间成员：从全局空间开始，一直指定到这个成员为止。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["PHP面向对象编程"]},{"title":"http协议与文件编程","url":"%2Fposts%2F3647702629%2F","content":"\n\n\n# ==一、HTTP协议==\n\n## 1. HTTP协议的相关概念\n\n### 为什么学习HTTP协议\n\n浏览器访问网站页面时，走的都是==HTTP协议==，如以下截图红框所示部分，标明的就是HTTP协议。\n\n![1529766534526](1.png)\n\n作为一个将要从事web项目开发工作的开发者，对HTTP协议需要有一个基本的了解。\n\n\n\n### 什么是HTTP协议\n\n**HTTP**：Hyper Text Transfer Protocol  中文翻译为 \"超文本传输协议\"。\n\n \n\nMr ZHANG是英国人，只会说英语；宫本是日本人，只会说日语；两人想要相互沟通交流，如果都各自使用本国语言，那么对方都将听不懂。\n\n为了能够让两个人无障碍相互沟通交流，让Mr ZHANG和宫本都学会中文，那么，两人就都能够使用中文进行交流了。而中文在这里就变成了两人之间沟通的一个协议。这个协议规定了两方向对方说话，按照某种语法来表达一个具体的意思。\n\n```sequence\nMr ZHANG(英国人)-->宫本（日本人）: 使用中文说：\"早上好！\" 问候宫本\nnote right of 宫本（日本人）:宫本按照中文的语法\\n来理解\"早上好！\"的意思\n宫本（日本人）-->Mr ZHANG(英国人): 使用中文说：\"早上好！\" 回复Mr ZHANG\nnote left of Mr ZHANG(英国人):Mr ZHANG按照中文的语法\\n来理解\"早上好！\"的意思\n```\n\n而在web项目中，是浏览器和服务器之间进行交互的一个过程。也就意味着浏览器与服务器两方要通话。\n\n而浏览器和服务器本身并不是同类，双方之间要想互相说话让对方听的明白，可以让双方都支持一个第三方的规定，通过这个规定来进行沟通交流。那么，HTTP协议，就是浏览器和服务器之间沟通的这个规定。\n\n```sequence\n浏览器-->服务器: 使用HTTP协议规定的格式\\n发出请求\nnote right of 服务器:服务器按照HTTP协议规定的格式\\n解析并处理请求内容\n服务器-->浏览器: 使用HTTP协议规定的格式\\n返回响应\nnote left of 浏览器:浏览器按照HTTP协议规定的格式\\n解析并处理响应内容\n```\n\n \n\n**概念**：HTTP协议，就是一种规定，它规定了浏览器请求服务器时，需要用什么样的格式发送请求数据；也规定了服务器响应浏览器时，需要用什么样的格式回应响应数据；这些对**数据格式的规定**就是HTTP协议。\n\n\n\n## 2. HTTP协议的分类\n\nHTTP协议的分类包含两种：\n\n- [ ] HTTP请求\n- [ ] HTTP响应\n\n\n\n### HTTP请求\n\n包含四个组成部分：1）请求行；2）请求头；3）空白行；4）请求数据 \n\n**==图例==**：\n\n![1529893232189](3.png)\n\n\n\n#### 请求行\n\n包含基本的请求信息部分。\n\n**==图例==**：\n\n![1529893388660](4.png)\n\n\n\n#### 请求头\n\n由一个一个的==请求协议项==组成。\n\n**==图例==**：\n\n![1529894139972](5.png)\n\n\n\n**常见的请求头协议项**：\n\n> **host**：当前url中所要请求的服务器的主机名（域名）\n> **accept-encoding**：是浏览器发给服务器,声明浏览器支持的压缩编码类型  比如gzip\n> **accept_charset**：表示，浏览器支持的字符集\n> **==referer==**：表示，此次请求来自哪个网址\n> **accept-language**：可以接收的语言类型，cn，en等\n> **cookie**：如果之前当前请求的服务器在浏览器端设置了数据（cookie），那么当前浏览器再次请求该服务器的时候，就会把对应的数据带过去\n> **user-agent**：用户代理，当前发起请求的浏览器的内核信息\n> **accept**：表示浏览器可以接收的数据类型\n> **content-length**（==post==）：只有post提交的时候才会有的请求头，显示的是当前要提交的数据的长度（字节）\n> **if-modified-since**（==get==）：表示，在客户端向服务器请求某个资源文件时，询问此资源文件是否被修改过\n> ==**content-type**==（==post==）：用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件\n\n\n\n#### 空白行\n\n专门用于分隔请求头和请求数据的结构。\n\n**==图例==**：\n\n![1529894320058](6.png)\n\n\n\n#### 请求数据\n\n只有当post方式提交数据时才会存在。\n\n**==图例==**：\n\n![1529894379399](7.png)\n\n请求数据指的是跟着请求一并携带到指定服务器的数据内容。\n\n\n\n#### 小结\n\n1. HTTP请求包含四个组成部分：1)请求行；2）请求头；3）空白行；4）请求数据；\n\n2. 四个结构的内容：\n\n   请求行包括 请求方式，请求资源文件的路径 和 协议名与协议版本号；\n\n   请求头包括 请求的协议项\n\n   空白行就是分隔请求头和请求数据的\n\n   请求数据只有当post方式才会存在\n\n\n\n### HTTP响应\n\n包含四个组成部分：1）状态行；2）响应头；3）空白行；4）响应数据 \n\n**==图例==**：\n\n![1529894737546](8.png)\n\n\n\n#### 状态行\n\n包含基本的响应信息部分。\n\n**==图例==**：\n\n![1529894855228](9.png)\n\n\n\n##### 响应状态码\n\n1xx：表示请求尚未完成；\n\n2xx：表示请求和响应都没有问题；\n\n3xx：表示重定向；\n\n4xx：表示请求出现问题，响应失败；\n\n5xx：表示服务器出现问题，响应失败；\n\n\n\n==**常见的响应状态码**==：\n\n200  表示完全没有问题\n\n301和302：    301表示永久重定向；302表示临时重定向；\n\n404：找不到请求的文件\n\n500：服务器出现故障\n\n\n\n#### 响应头\n\n由一个一个的响应协议项组成。\n\n**==图例==**：\n\n![1529896532372](10.png)\n\n\n\n**常见的响应头协议项**：\n\n> **server**：服务器主机信息\n>\n> **date**：响应时间\n>\n> **last-modified**：文件最后修改时间（对应请求中：if-modified-since）\n>\n> **content-length**：响应主体的长度（字节）\n>\n> **content-type**：响应内容的数据类型：text/html，image/png等\n>\n> ==**location**==：重定向，浏览器遇到这个选项，就立马跳转（不会解析后面的内容）\n>\n> ==**refresh**==：重定向（刷新），浏览器遇到这个选项就会准备跳转，刷新一般有时间限制，时间到了才跳转，浏览器会继续向下解析\n>\n> **content-encodeing**：文件编码格式\n>\n> **cache-control**：缓存控制，no-cached不要缓存\n\n\n\n#### 空白行\n\n专门用于分隔响应头和响应数据的结构。\n\n**==图例==**：\n\n![1529896688121](11.png)\n\n\n\n#### 响应数据\n\n包含完整的返回给浏览器的内容。\n\n**==图例==**：\n\n![1529896737945](12.png)\n\n响应数据指的就是程序处理完成之后返回给浏览器的所有数据内容。\n\n\n\n#### 小结\n\n1. HTTP响应包含4个组成部分：1）状态行；2）响应头；3）空白行；4）响应数据；\n\n2. 四个组成部分分别包括\n\n   状态行包括 协议名与协议版本号、响应状态码值和响应状态码值对应的响应信息\n\n   响应头是由一个一个的响应协议项所组成；\n   空白行是用于分隔响应头和相应数据的；\n\n   响应数据就是程序返回给浏览器的所有数据内容；\n\n\n\n## 3. HTTP协议的特点\n\n1) 不仅支持B/S模式，还支持C/S模式。\n\n2) 灵活，支持任意类型的数据。\n\n3) ==无连接特性==，指的是每次完整的请求之后，本次连接要断开。\n\n4) ==无状态特性==，HTTP协议对会话过程中产生的数据不具有记忆能力。\n\n\n\n## 4. HTTP协议的应用\n\n### 跳转\n\n**==需求==**：实现访问A页面就直接跳转到B页面的效果。\n\n**==解答==**：构建一个名为code2.php的程序文件，代码如下：\n\n```php\n<?php\n\necho '这是code2.php文件'; \n\n//跳转(重定向)\nheader('Location:http://www.home.com/class/day3/code/code3.php');\n```\n\n构建一个名为code3.php的程序文件，代码如下：\n\n```php\n<?php\n\necho '这是code3.php文件'; \n\n```\n\n访问code2.php，浏览器展示的效果为：\n\n![1529898326089](13.png)\n\n\n\n**==小结==**：在本案例中使用到了http响应协议项的知识点。\n\n\n\n### 刷新跳转\n\n**==需求==**：实现访问A页面，在A页面停留3秒钟展示提示信息\"别眨眼，3秒后我就要跳转了！\"，3秒后再跳转到B页面。\n\n**==解答==**：构建一个名为code4.php的程序文件，代码如下：\n\n```php\n<?php\n\necho '别眨眼，3秒后我就要跳转了！'; \n\n//刷新跳转(刷新重定向)\n//               浏览器在当前页面停留3秒，然后再重新请求新的页面\nheader('Refresh:3; url=http://www.home.com/class/day3/code/code5.php');\n```\n\n构建名为code5.php的程序文件，代码如下：\n\n```php\n<?php\n\necho '这是code5.php文件'; \n```\n\n访问code4.php的效果：\n\n![1529898633121](14.png)\n\n在code4.php停留了3秒后效果为跳转到了code5.php：\n\n![1529898655166](15.png)\n\n\n\n### SSL安全访问协议\n\n#### https简介\n\nHTTPS  即  Secure Hypertext Transfer Protocol  翻译为中文：==安全的超文本传输协议==\n\n\n\n> 它是由Netscape开发并**内置于其浏览器中**，用于**对数据进行压缩和解压操作**，**并用于网络传输**的一种技术。\n>\n> HTTPS实际上应用了Netscape的完全套接字层（SSL）作为HTTP应用层的子层。（==HTTPS使用端口443==，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）SSL使用40 位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTPS和SSL支持使用==X.509==数字认证，如果需要的话用户可以确认发送者是谁。\n>\n> https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，https的安全基础是SSL。\n>\n> 它是一个URI scheme(抽象标识符体系)，句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。\n\n\n\n#### 配置SSL协议\n\n**==目标==**：使用  https://www.t1.com/t.php  访问 day3/code目录中  的t.php文件。\n\n**==步骤==**：\n\n第一步，将day3/source目录下的key文件夹拷贝到apache安装目录下的==conf目录==中\n\n![1529908501211](16.png)\n\n\n\n第二步，打开apache的配置文件httpd.conf，开启mod_socache_shmcb 和mod_ssl模块，同时开启引入ssl配置文件，\n\n去掉下图中引入模块的注释，开启模块引入配置，\n\n![1529908874056](17.png)\n\n引入ssl配置文件，\n\n![1529908984899](18.png)\n\n\n\n第三步，调整apache安装目录下的extra/httpd-ssl.conf配置文件SSLSessionCache配置项的路径，同时注释VirtualHost示例，\n\n![1529909171565](19.png)\n\n将VirtualHost所有代码全部注释掉，从121行到290行，\n\n![1529909250903](20.png)\n\n第四步，打开虚拟主机配置文件，增加如下虚拟主机配置项：\n\n```mysql\n#ssl默认监听的端口是443，所以如果要使用默认的端口，就不能再使用80，而应该使用443端口\n<VirtualHost *:443>\n#开启SSL引擎的支持\n\tSSLEngine on\n#指定支持的SSL协议版本\n\tSSLProtocol all -SSLv2 -SSLv3\n#SSL加密计算的方式\n\tSSLCipherSuite HIGH:MEDIUM:!aNULL:!MD5\n#认证证书文件\n\tSSLCertificateFile \"F:/usr/apache24/conf/key/server.crt\"\n#证书私钥\n\tSSLCertificateKeyFile \"F:/usr/apache24/conf/key/server.key\"\n#根证书\n\tSSLCertificateChainFile \"F:/usr/apache24/conf/key/ca.crt\"\n\tDocumentRoot \"F:/home/class/day3/code\"\n\tServerName www.t1.com\n\t<Directory />\n\tOptions +Indexes +FollowSymLinks +ExecCGI\n\tAllowOverride All\n\tOrder allow,deny\n\tAllow from all\n\tRequire all granted\n\t</Directory>\n</VirtualHost>\n```\n\n\n\n第五步，重启apache，向hosts文件中新增如下配置，\n\n![1529910013192](21.png)\n\n在hosts文件中增加如下配置，(C:/Windows/system32/drivers/etc/hosts)\n\n```\n127.0.0.1  www.t1.com\n```\n\n\n\n第六步，在day3/code目录中创建名为t.php的程序文件，代码如下\n\n```php\n<?php\n\necho '哈哈，https配置成功啦！'; \n```\n\n\n\n第七步，在浏览器中使用  https://www.t1.com/t.php  访问t.php，测试使用效果\n\n![1529910287320](22.png)\n\n\n\n**==小结==**：\n\n1. SSL技术实际就是将http协议传输数据进行加密、解密和传输的一个技术手段。\n2. 实现了SSL技术的http协议，访问时效果会变成使用https进行访问。\n\n\n\n# ==二、文件编程==\n\n## 1. 文件编程相关概念\n\n### 为什么使用文件编程\n\n在web项目中，文件编程的应用相当广泛，比如：文件下载（软件，电影，照片....），生成报表文件并支持下载功能等都需要使用到文件编程技术。\n\n\n\n### 什么是文件编程\n\n所谓的文件编程技术，指的就是对文件或目录的增删改查操作！\n\n\n\n## 2. 文件编程的分类\n\n- [x] 对目录的操作\n- [x] 对文件的操作\n\n\n\n### 对目录的操作\n\n**设置操作**（增删改）\n\n> 涉及的函数：\n>\n> **mkdir**(新目录名[,  目录权限[,  是否递归创建]])      创建一个目录（make directory）\n>\n> **rmdir**(目录全路径)      删除一个目录（remove directory）\n>\n> **rename**(旧名字,  新名字)     给目录改名或转移目录\n\n\n\n**==操作需求1==**：在code目录中执行创建目录操作，要求：\n\n1. 创建名为dir1和dir2两个目录；\n2. 递归创建dir3/dir3_1/dir3_1_1目录；\n\n**==解答==**：构建一个名为code6.php的程序文件，代码如下：\n\n```php\n<?php\n\n#新增目录操作\n$re = mkdir('dir1');//在当前目录创建一个名为dir1的目录\nvar_dump( $re ); echo '<hr/>';\n$re = mkdir('dir2');//在当前目录创建一个名为dir2的目录\nvar_dump( $re );  echo '<hr/>';\n\n//如果不指定第三个参数，则默认为false，false表示不进行递归创建，如需递归创建，则需要将第三个参数指定为true\n$re = mkdir('./dir3/dir3_1/dir3_1_1', 0777, true);\nvar_dump( $re ); \n\n```\n\n**==操作需求1小结==**\n\n1. mkdir函数可以实现创建目录操作；\n2. mkdir函数如果不指定第三个参数，则第三个参数默认为false，false表示不进行递归创建，如需递归创建，则需要将第三个参数指定为true；\n\n\n\n**==操作需求2==**：在code目录中执行修改目录操作，要求：\n\n1. 将dir1的目录名改为dir100；\n2. 将dir2目录转移到dir3目录中，并且重命名为dir200；\n\n**==解答==**：构建一个名为code7.php的程序文件，代码如下：\n\n```php\n<?php\n#修改目录操作\n$re = rename('./dir1', './dir100');//直接将旧名字dir1改为新名字dir100\nvar_dump( $re );  echo '<hr/>';\n\n$re = rename('./dir2', './dir3/dir200');//将dir2转移到dir3中，转移后将dir2改名为dir200\nvar_dump( $re );\n```\n\n**==操作需求2小结==**\n\n1. rename函数可以实现修改目录名称的操作；\n2. rename函数还能够实现转移某个目录到指定的新目录中，同时还可以转移后重命名；\n\n\n\n**==操作需求3==**：在code目录中执行删除目录操作，要求：\n\n1. 将dir100删除；\n2. 尝试将dir3目录删除；\n\n**==解答==**：构建一个名为code8.php的程序文件，代码如下：\n\n```php\n<?php\n\n#删除目录操作\n$re = rmdir('./dir100');//dir100中是空的，所以能够直接被删除\nvar_dump( $re ); echo '<hr/>';\n\n$re = rmdir('./dir3');//dir3目录中不是空的，里面有内容，所以不支持直接删除\nvar_dump( $re ); \n```\n\n访问code8.php后的效果：\n\n```\nbool(true)//dir100删除成功\n\nWarning: rmdir(./dir3): Directory not empty in F:\\home\\class\\day3\\code\\code8.php on line 7\nbool(false)//dir3不为空，所以不支持直接删除\n```\n\n**==操作需求3小结==**\n\n1. rmdir可以实现删除空目录的操作；\n2. 如果目录有内容则不支持直接删除，必须先清空目录下的所有内容，才能够删除；\n\n\n\n**查询操作**\n\n> 涉及的函数：\n>\n> **opendir**(目录全路径)      打开一个目录\n>\n> **readdir**(打开的目录资源)      读取目录中的内容\n>\n> **closedir**(打开的目录资源)     关闭一个打开的目录\n\n\n\n**==操作需求==**：查询code下的demo目录，要求：\n\n1. 读取并输出该目录下的所有文件的文件名；\n\n**==解答==**：构建一个名为code9.php的程序文件，代码如下：\n\n```php\n<?php\n\n#1.打开目录\n$op = opendir('./demo');//将会返回资源类型的数据\nvar_dump( $op ); echo '<hr/>';\n\n#2. 读取打开目录资源中的内容\n$fileName = readdir($op);\t//第一次读取，读取打开的目录资源中的文件名\nvar_dump( $fileName ); echo '<br/>';\n$fileName = readdir($op);\t//第二次读取\nvar_dump( $fileName ); echo '<br/>';\n$fileName = readdir($op);\t//第三次读取\nvar_dump( $fileName ); echo '<br/>';\n$fileName = readdir($op);\t//第四次读取\nvar_dump( $fileName ); echo '<br/>';\n$fileName = readdir($op);\t//第五次读取\nvar_dump( $fileName ); echo '<br/>';\n$fileName = readdir($op);\t//第六次读取\nvar_dump( $fileName ); echo '<br/>';\n$fileName = readdir($op);\t//第七次读取\nvar_dump( $fileName ); echo '<br/>';\n$fileName = readdir($op);\t//第八次读取\nvar_dump( $fileName ); echo '<hr/>';\n\n$re = closedir($op);\nvar_dump( $re ); echo '<br/>';\nvar_dump( $op ); \n```\n\n访问code9.php输出的内容：\n\n```mysql\nresource(3) of type (stream)#使用opendir打开的文件资源\n\nstring(1) \".\" #第一次使用readdir得到的数据\nstring(2) \"..\" #第二次使用readdir得到的数据\nstring(11) \"article.txt\" #第三次使用readdir得到的数据\nstring(4) \"dir1\" #第四次使用readdir得到的数据\nstring(4) \"dir2\" #第五次使用readdir得到的数据\nstring(4) \"dir3\" #第六次使用readdir得到的数据\nbool(false) #第七次使用readdir得到的数据\nbool(false)#第八次使用readdir得到的数据\n\nNULL #closedir函数的返回值，说明没有返回值\nresource(3) of type (Unknown)#使用closedir关闭$op之后，再次打印出来的$op的值\n```\n\n\n\n**==操作需求小结==**\n\n1. 如果要读取一个目录中的内容，首先得使用opendir函数打开一个目录，然后再使用readdir逐个解析出资源中的文件名；\n2. closedir函数的作用是关闭打开的文件资源；\n\n\n\n**查询辅助操作**\n\n> 涉及的函数：\n>\n> ==**realpath**==(路径)      将给定的路径转换为绝对路径地址\n>\n> **==basename==**(路径)      返回当前给定路径的基础文件（或文件夹）名部分\n>\n> ==**dirname**==(路径)      返回当前给定路径的目录部分\n>\n> **is_dir**(全路径)      判断一个给定文件是否是一个目录\n\n\n\n**==操作需求==**：在code目录下对相对路径\"./\"进行操作，要求：\n\n1. 将相对路径\"./\"转换为绝对路径，并将转换后的结果输出；\n2. 获得\"1\"中转换的绝对路径中的基础文件名并将其输出；\n3. 获得\"1\"中转换的绝对路径中的目录部分并将其输出；\n4. 判定\"./code1.php\"是否是一个目录；\n5. 判定\"./dir3\"是否是一个目录；\n\n**==解答==**：构建一个名为code10.php的程序文件，代码如下：\n\n```php\n<?php\n\n$path = './';\n\n#1. 将相对路径转换成绝对路径\n$realPath = realpath($path);//可以将相对路径转换为绝对路径\nvar_dump( $realPath ); echo '<br/>';\n\n$re = realpath('F:\\home\\class\\day3\\code');//虽然也可以将绝对路径传递进去，但是没有意义\nvar_dump( $re ); echo '<hr/>';\n\n#2. 获得\"1\"中转换的绝对路径中的基础文件名并将其输出\n$re = basename($realPath);\nvar_dump( $re ); echo '<hr/>';\n\n#3. 获得\"1\"中转换的绝对路径中的目录部分并将其输出\n$re = dirname($realPath);\nvar_dump( $re ); echo '<hr/>';\n\n#4. 判定\"./code1.php\"是否是一个目录\n$re = is_dir('./code1.php');\nvar_dump( $re ); echo '<hr/>';\n\n#5. 判定\"./dir3\"是否是一个目录\n$re = is_dir('./dir3');\nvar_dump( $re ); \n```\n\n访问code10.php输出的结果：\n\n```mysql\nstring(23) \"F:\\home\\class\\day3\\code\" //第1点的输出\nstring(23) \"F:\\home\\class\\day3\\code\" //第1点的输出\nstring(4) \"code\"  //第2点的输出\nstring(18) \"F:\\home\\class\\day3\"  //第3点的输出\nbool(false)  //第4点的输出，返回false说明不是一个目录\nbool(true)  //第5点的输出，返回true说明是一个目录\n```\n\n**==操作需求小结==**\n\n1. realpath函数可以将路径转换为结对路径；\n2. basename函数可以获得路径中的基础文件名部分；\n3. dirname函数可以获得路径中的除去基础文件名后的目录路径部分；\n4. is_dir函数可以判断一个给定的文件是否是一个目录；\n\n\n\n### 对文件的操作\n\n因php版本更替原因，在php中对文件的操作分为两类：\n\n- [ ] php4相关文件操作\n- [ ] php5相关文件操作\n\n\n\n#### PHP4相关文件操作\n\n涉及的函数：\n\n> **fopen**(文件全路径,  打开模式)    打开一个文件\n>\n> **fread**(打开的文件资源,  读取内容的长度)    读取文件中的内容\n>\n> **fwrite**(打开的文件资源,  写入的内容)    向文件中写入内容\n>\n> **fclose**(打开的文件资源)    关闭打开的文件\n>\n> **filesize**(文件全路径)  获取文件的大小\n\n\n\n**==操作需求==**：操作code目录下的article.txt文件，要求：\n\n1. 将文件中的所有内容读取并输出；\n2. 向文件中最末尾写入\"这是一篇好文章\"；\n3. 关闭打开的文件；\n\n**==解答==**：构建一个名为code11.php的程序文件，代码如下：\n\n```php\n<?php\n\n#打开指定的文件\n//$fp = fopen('./article.txt', 'r');//使用r模式只能读不能写\n$fp = fopen('./article.txt', 'a+');//是a+模式即能读，又能写，而是从最末尾写入\nvar_dump( $fp ); echo '<hr/>';\n\n#1. 读取文件打开资源中的内容\n$fileSize = filesize('./article.txt');//获取文件的大小\nvar_dump( $fileSize ); echo '<br/>';\n\n$content = fread($fp, $fileSize);//读取文件打开资源中的所有内容\nvar_dump( $content ); echo '<hr/>';\n\n#2. 向文件中最末尾写入\"这是一篇好文章\"\n$writeContent = '这是一篇好文章';\n$re = fwrite($fp, $writeContent);\nvar_dump( $re ); echo '<hr/>';\n\n#3. 关闭打开的文件资源\n$re = fclose($fp);\nvar_dump( $re ); echo '<br/>';\nvar_dump( $fp ); \n```\n\n访问code11.php输出的结果为：\n\n```mysql\nresource(3) of type (stream)//输出的$fp\nint(5985) //输出文件的大小，单位字节\n\n//下面为输出文件读取的所有内容\nstring(5985) \"﻿君子曰：学不可以已。 青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规。虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。 故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。干、越、夷、貉之子，生而同声，长而异俗，教使之然也。诗曰：“嗟尔君子，无恒安息。靖共尔位，好是正直。神之听之，介尔景福。”神莫大于化道，福莫长于无祸。（此段教材无） 吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。 南方有鸟焉，名曰蒙鸠，以羽为巢，而编之以发，系之苇苕，风至苕折，卵破子死。巢非不完也，所系者然也。西方有木焉，名曰射干，茎长四寸，生于高山之上，而临百仞之渊，木茎非能长也，所立者然也。蓬生麻中，不扶而直；白沙在涅，与之俱黑。兰槐之根是为芷，其渐之滫，君子不近，庶人不服。其质非不美也，所渐者然也。故君子居必择乡，游必就士，所以防邪辟而近中正也。 物类之起，必有所始。荣辱之来，必象其德。肉腐出虫，鱼枯生蠹。怠慢忘身，祸灾乃作。强自取柱，柔自取束。邪秽在身，怨之所构。施薪若一，火就燥也，平地若一，水就湿也。草木畴生，禽兽群焉，物各从其类也。是故质的张，而弓矢至焉；林木茂，而斧斤至焉；树成荫，而众鸟息焉。醯酸，而蚋聚焉。故言有招祸也，行有招辱也，君子慎其所立乎！（此段教材无） 积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。 是故无冥冥之志者，无昭昭之明；无惛惛之事者，无赫赫之功。行衢道者不至，事两君者不容。目不能两视而明，耳不能两听而聪。螣蛇无足而飞，鼫鼠五技而穷。《诗》曰：“尸鸠在桑，其子七兮。淑人君子，其仪一兮。其仪一兮，心如结兮！”故君子结于一也。 昔者瓠巴鼓瑟，而流鱼出听；伯牙鼓琴，而六马仰秣。故声无小而不闻，行无隐而不形。玉在山而草润，渊生珠而崖不枯。为善不积邪？安有不闻者乎？ 学恶乎始？恶乎终？曰：其数则始乎诵经，终乎读礼；其义则始乎为士，终乎为圣人，真积力久则入，学至乎没而后止也。故学数有终，若其义则不可须臾舍也。为之，人也；舍 之，禽兽也。故书者，政事之纪也；诗者，中声之所止也；礼者，法之大分，类之纲纪也。故学至乎礼而止矣。夫是之谓道德之极。礼之敬文也，乐之中和也，诗书之博也，春秋之微 也，在天地之间者毕矣。君子之学也，入乎耳，着乎心，布乎四体，形乎动静。端而言，蝡而动，一可以为法则。小人之学也，入乎耳，出乎口；口耳之间，则四寸耳，曷足以美七尺之躯哉！古之学者为己，今之学者为人。君子之学也，以美其身；小人之学也，以为禽犊。故不问而告谓之傲，问一而告二谓之囋。傲、非也，囋、非也；君子如向矣。 学莫便乎近其人。礼乐法而不说，诗书故而不切，春秋约而不速。方其人之习君子之说，则尊以遍矣，周于世矣。故曰：学莫便乎近其人。 学之经莫速乎好其人，隆礼次之。上不能好其人，下不能隆礼，安特将学杂识志，顺诗书而已耳。则末世穷年，不免为陋儒而已。将原先王，本仁义，则礼正其经纬蹊径也。若挈裘领，诎五指而顿之，顺者不可胜数也。不道礼宪，以诗书为之，譬之犹以指测河也，以戈舂黍也，以锥餐壶也，不可以得之矣。故隆礼，虽未明，法士也；不隆礼，虽察辩，散儒也。 问楛者，勿告也；告楛者，勿问也；说楛者，勿听也。有争气者，勿与辩也。故必由其道至，然后接之；非其道则避之。故礼恭，而后可与言道之方；辞顺，而后可与言道之理；色从而后可与言道之致。故未可与言而言，谓之傲；可与言而不言，谓之隐；不观气色而言，谓瞽。故君子不傲、不隐、不瞽，谨顺其身。诗曰：“匪交匪舒，天子所予。”此之谓也。 百发失一，不足谓善射；千里蹞步不至，不足谓善御；伦类不通，仁义不一，不足谓善学。学也者，固学一之也。一出焉，一入焉，涂巷之人也；其善者少，不善者多，桀纣盗跖也；全之尽之，然后学者也。 君子知夫不全不粹之不足以为美也，故诵数以贯之，思索以通之，为其人以处之，除其害者以持养之。使目非是无欲见也，使耳非是无欲闻也，使口非是无欲言也，使心非是无欲虑也。及至其致好之也，目好之五色，耳好之五声，口好之五味，心利之有天下。是故权利不能倾也，群众不能移也，天下不能荡也。生乎由是，死乎由是，夫是之谓德操。德操然后能定，能定然后能应。能定能应，夫是之谓成人。天见其明，地见其光，君子贵其全也。这是一篇好文章\"\nint(21)//向文件中写入的内容\nbool(true) //关闭文件后$re返回值结果，值为true,说明关闭成功\nresource(3) of type (Unknown)//关闭文件资源后，再次输出的$fp的结果\n```\n\n**==小结==**：\n\n1. 在php4相关的文件操作中，能够对文件执行什么样的操作，取决于fopen是指定的第二个参数打开模式。\n\n\n\n#### PHP5相关文件操作\n\n涉及的函数：\n\n> **file_put_contents**(文件全路径,  写入的内容[,  写入方式])      向文件中写入内容\t\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t写入方式可指定为FILE_APPEND\n>\n> **file_get_contents**(文件全路径)      获得文件中的内容\n>\n\n\n\n演示案例：读取article.txt文件中的内容，并且向article1.txt文件中写入\"好酒哇！\"内容\n\n实现：构建名为code12.php的程序文件，代码如下：\n\n```php\n<?php\n\n#读取article.txt文件中的内容\n$content = file_get_contents('./article.txt');\nvar_dump( $content ); echo '<hr/>';\n\n#向文件中写入内容\n$writeContent = '好酒哇！';\n//$re = file_put_contents('./article.txt', $writeContent);//如果不指定第三个参数，则默认是覆盖写入\n$re = file_put_contents('./article1.txt', $writeContent, FILE_APPEND);\nvar_dump( $re ); \n```\n\n访问code12.php，输出的结果为：\n\n```mysql\nstring(12) \"好酒哇！\"//读取的article.txt文件中的所有内容\nint(12)//向文件中写入内容后的返回值，返回了写入内容的字节长度\n```\n\n\n\n## 4. 全天总结\n\n1. http协议分为：1）http请求；2）http响应\n\n2. http请求包含四个部分，分别是：1)请求行；2）请求头；3）空白行；4）请求数据；\n\n3. http响应包含四个部分，分别是：1）状态行；2）响应头；3）空白行；4）响应数据；\n\n4. http协议的特点：\n\n   不仅支持B/S模式，还支持C/S模式；\n\n   协议支持传输任意类型的数据；\n\n   无连接的特性，每次完整的请求之后，本次连接将会断开；\n\n   无状态的特性，协议本身不具有记忆能力；\n\n5. 文件编程分为：1）对目录的操作；2）对文件的操作；\n\n6. 对目录的操作：\n\n   mkdir函数负责创建目录\n\n   rmdir函数负责删除目录\n\n   rename函数负责对目录重命名或转移目录到指定的地方去\n\n   opendir函数负责打开一个文件\n\n   readdir函数负责读取打开的文件资源内容\n\n   closedir函数负责关闭打开的目录\n\n7. 对文件的操作：\n\n   php4:\n\n   ​\tfopen函数打开文件资源，需要指定打开模式\n\n   ​\tfwrite函数负责向打开的文件中写入内容\n\n   ​\tfread函数负责读取打开文件中的内容，需要指定读取的内容长度\n\n   ​\tfilesize函数负责获取文件的大小\n\n   php5:\n\n   ​\tfile_get_contents函数负责读取文件的所有内容\n\n   ​\tfile_put_contents函数负责向文件中写入指定的内容，如果不指定第三个参数，则默认为覆盖写入，如果要追加写入，则需要指定第三个参数为FILE_APPEND\n\n\n\n","categories":["http协议与文件编程"]},{"title":"博客项目2","url":"%2Fposts%2F2009405217%2F","content":"\n\n# 一、昨日回顾\n\n## 1. 知识回顾\n\n1. mvc的三大组件是什么？\n\n   M：model     模型\n\n   V：view          视图\n\n   C：Controller     控制器\n\n2. mvc的三大组件分别代表什么意思？\n\n   M：专门用来操作数据表的\n\n   V：专门用来展示视图模板的\n\n   C：专门用来处理业务逻辑，比如说什么时候该调用模型操作数据，什么时候该调用视图展示模板，都是由控制器里来处理。\n\n\n\n## 2. 昨日反馈\n\n![1531270551320](114)\n\n# 二、知识路径\n\n- web项目开发流程介绍\n\n- 需求分析\n\n  ​\t功能分析\n\n  ​\tER图设计\n\n- 表设计\n\n- 项目部署\n\n- 项目实现\n\n  ​\t实现后台用户管理系统\n\n  ​\t封装验证码工具类\n\n==目标：能够设计项目所需的表、能够部署自主框架、能够实现后台用户管理系统==\n\n# 三、今日课程内容：博客项目\n\n## 1. web项目开发流程介绍\n\n1)制定计划：博客项目(blog31)  开发周期：4天\n\n2)需求分析：功能分析  ER图设计\n\n3)软件设计：项目环境  表设计\n\n4)程序编写\n\n5)软件测试\n\n6)运行维护\n\n\n\n## 2. 需求分析\n\n### 功能分析\n\n1. 后台用户管理系统；\n2. 后台分类管理系统；\n3. 后台博文管理系统；\n4. 评论管理系统；\n5. 后台登陆和七天免登录；\n6. 前台首页；\n7. 前台注册和登陆功能；\n8. 前台博客文章详情页；\n\n\n\n### ER图设计\n\nE-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。它是描述现实世界概念结构模型的有效方法。是表示概念模型的一种方式，用矩形表示实体型，矩形框内写明实体名；用椭圆表示实体的属性，并用无向边将其与相应的实体型连接起来；用菱形表示实体型之间的联系，在菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1,1:n或m:n）。\n\n \n\n专业的ER图工具：Viso和Power Designer\n\n \n\n==实体== ==》表：矩形表示\n\n==属性== ==》表字段：椭圆\n\n==关系== ==》表与表的关系：菱形（1:1表示1对1关系；1:n表示1对多关系；m:n表示多对多关系）\n\n\n\n博客项目的ER关系图如下： \n\n![1531279764230](1)\n\n\n\n## 3. 表设计\n\n```mysql\ndrop database blog31;\ncreate database blog31;\n\n#############用户表：\nCREATE TABLE `bg_user` (\n  `id` int unsigned auto_increment,\n  `acc` varchar(50) not null default '' COMMENT '帐号',\n  `nickname` varchar(30) not null default '' COMMENT '昵称',\n  `pwd` char(32) not null default '' COMMENT '密码',\n  `cell` varchar(15) not null default '' COMMENT '手机号',\n  `regtime` int unsigned default 0 COMMENT '注册时间',\n  `type` tinyint unsigned not null default 0 COMMENT '用户类型 0:普通用户 1:管理员',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n#############博客文章表：\nCREATE TABLE `bg_article` (\n  `id` int(11) unsigned AUTO_INCREMENT,\n  `title` varchar(100) not null default '' COMMENT '文章标题',\n  `intro` varchar(255) not null default '' COMMENT '文章简介',\n  `content` text not null,\n  `post_date` int unsigned not null default 0 COMMENT '发布时间',\n  `user_id` int unsigned not null default 0 COMMENT '发布管理员id',\n  `user_nickname` varchar(30) not null default '' COMMENT '发布管理员昵称',\n  `comment_num` smallint unsigned not null default 0 COMMENT '评论数量',\n  `cat_id` int unsigned not null default 0 COMMENT '所属分类id',\n  `cat_name` varchar(30) not null default '' COMMENT '所属分类名称',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n#############博客文章分类表：\nCREATE TABLE `bg_category` (\n  `id` int unsigned AUTO_INCREMENT,\n  `name` varchar(30) not null COMMENT '分类名称',\n  `parent_id` int unsigned not null default '0' COMMENT '上级分类ID，0表示顶级分类',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n\n#############评论表：\nCREATE TABLE `bg_comment` (\n  `id` int unsigned AUTO_INCREMENT,\n  `content` text not null,\n  `post_date` int unsigned not null default 0 COMMENT '评论时间',\n  `article_id` int unsigned not null default 0 COMMENT '所属文章ID',\n  `article_title` varchar(50)  not null default '' COMMENT '所属文章标题',\n  `user_id` int unsigned not null default 0 COMMENT '用户ID',\n  `user_nickname` varchar(30)  not null default '' COMMENT '用户昵称',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n```\n\n\n\n## 4. 项目部署\n\n1. 将code/mvc目录改名为blog31，\n\n   下图这个mvc目录：\n\n   ![1531291206947](2)\n\n   改名为blog31:\n\n   ![1531291235746](3)\n\n2. 配置一个基于域名虚拟主机，域名为www.blog31.com\n\n   在httpd-vhosts.conf文件中增加如下图所示的虚拟主机配置项：\n\n   ![1531291311545](4)\n\n   修改hosts文件，\n\n   ![1531291371313](5)\n\n3. 重启apache，测试访问效果：\n\n   ![1531291456736](6)\n\n   访问效果为：\n\n   ![1531291515331](7)\n\n   能够看到上图，则说明部署成功。\n\n\n\n## 5. 项目实现\n\n### 实现后台用户管理系统\n\n#### 实现列表页\n\n1. 将code/templates/admin目录中如下图所示的目录复制一份，\n\n   ![1531291763786](8)\n\n   转移拷贝到code/blog31/app/admin/view目录中，\n\n   ![1531291818821](9)\n\n2. 在blog31/app/admin/controller目录中创建一个名为UserController.class.php的文件，\n\n   ![1531291945355](10)\n\n3. 在blog31/app/admin/controller/UserController.class.php中构建如下代码，展示三个页面，\n\n   ![1531292339989](11)\n\n4. 测试访问后台用户管理系统列表页\n\n   ![1531292433660](12)\n\n5. 进一步做调整，将后台模板使用到的资源文件全部转移进项目中，\n\n   在blog31/public目录中创建一个名为admin的目录，专门保存后台的资源文件，\n\n   ![1531292599939](13)\n\n   复制code/templates/admin/libs目录下的所有文件，如下图所示，\n\n   ![1531292644972](14)\n\n   转移拷贝到blog31/public/admin目录中，\n\n   ![1531292690333](15)\n\n6. 调整blog31/app/admin/view/User/userIndex.html中引入资源文件的路径，\n\n   在blog31/conf/conf.php中增加本网站域名配置项，\n\n   ![1531293146377](16)\n\n   然后在blog31/app/admin/view/User/userIndex.html使用配置项URL的值来引入配置文件，\n\n   ![1531293430682](17)\n\n   ![1531293486446](18)\n\n   上图中替换的是所有图片文件引入路径，截取不全，实际替换的内容以blog31/app/admin/view/User/userIndex.html中的为准。\n\n7. 再次测试访问后台新闻管理系统列表页，\n\n   ![1531293567621](19)\n\n8. 在blog31/app/model目录中创建UserModel.class.php文件，\n\n   ![1531293712684](20)\n\n   内容如下：\n\n   ![1531293731152](21)\n\n   调整blog31/conf/conf.php中PDO配置项的默认选择的数据库名，\n\n   ![1531294133397](22)\n\n9. 在blog31/app/admin/controller/UserController.class.php中showIndex方法里渲染模板之前调用模型查询数据，\n\n   ![1531294688749](23)\n\n   然后在blog31/app/admin/view/User/userIndex.html中回显查询得到的用户数据，\n\n   ![1531294782348](24)\n\n   测试访问后台用户管理系统列表页：\n\n   ![1531294828901](25)\n\n#### 实现添加页\n\n1. 访问后台用户管理系统添加页，\n\n   ![1531295330114](26)\n\n2. 调整blog31/app/admin/view/User/userAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531295483768](27)\n\n3. 调整blog31/app/admin/view/User/userAdd.html中的form表单域各项的值，\n\n   ![1531295777460](28)\n\n4. 在blog31/app/admin/controller/UserController.class.php中创建一个处理添加用户的方法，adh方法，\n\n   ![1531296464355](29)\n\n5. 测试添加用户使用效果：\n\n   在添加表单页面构建数据，点击提交，\n\n   ![1531296568559](30)\n   提交后的效果：\n\n   ![1531296591547](31)\n\n   效果为添加成功，说明功能实现OK。\n\n#### 实现编辑页\n\n1. 访问后台新闻管理系统编辑页：\n\n   ![1531296743041](32)\n\n2. 修改blog31/app/admin/view/User/userIndex.html中编辑按钮的链接：\n\n   ![1531296871382](33)\n\n3. 调整blog31/app/admin/view/User/userEdit.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531296956168](34)\n\n4. 调整blog31/app/admin/view/User/userEdit.html中form表单里的代码，\n\n   ![1531297468408](35)\n\n5. 在blog31/app/admin/controller/UserController.class.php中创建updh方法，代码如下：\n\n   ![1531301022079](36)\n\n6. 测试使用效果：\n\n   点击进入编辑也，如下图所示：\n\n   ![1531301120317](37)\n\n   修改数据，\n\n   ![1531301172674](38)\n\n   点击更新，\n\n   ![1531301192522](39)\n\n   跳回到更新页面：\n\n   ![1531301213845](40)\n\n   密码也是被改变了的，如下图所示：\n\n   ![1531301252698](41)\n\n   说明编辑功能实现OK。\n\n\n\n## 6. 全天总结\n\n1. 项目中的建表部分：\n\n   如果某字段是需要保存时间，一般在PHP的项目中给int数据类型；\n\n   如果某字段需要保存状态类型的值，使用tinyint会更加好；\n\n   如果某字段保存的数据，我们可以预期的很准确，比如说手机号码，通常就是11位，但是我们在项目中一般会采取宁大不小的原则，给11位以上的值，比如给varchar(15)；\n\n   在构建字段的时候，我们一般都会给字段设置default默认值，如果不设置默认值，则今后这个字段无论是否需要添加数据，都必须指定上值。\n\n2. 项目开发部分：\n\n   我们使用框架进行开发，一般程序开发人员从模板入手，先尝试展示出模板页面的效果，然后再考虑是否需要调用模型操作数据库的问题，所以我们通常在MVC框架中，1）首先会将模板页面转移进项目目录；2）然后会创建控制器类，构建方法调用视图展示模板页面；3）调试模板页面展示的效果；4）以上都成功之后，如果没有模型则需要创建模型，如果有模型则直接去考虑调用模型操作数据；\n\n\n\n# 四、昨日回顾\n\n## 1. 知识回顾\n\n1. 建表注意事项：\n\n   如果在项目中要保存一个时间的数据，则我们一般选择使用int类型来保存；\n\n   如果在项目中要保存一个状态或类型这样的数据时，我们一般选择使用tinyint类型来保存；\n\n   如果在项目中能够明确要保存的数据需要占多少个字节时，我们一般采用的做法是宁大不小，比如，保存手机号码一般是11位，但是我们通常会选择给varchar(15)\n\n   如果在项目中构建字段时，通常我们会给字段指定一个默认值，一方面方便程序的默认操作，比如注册时，如果给用户类型指定了默认值为0表示普通会员，则构建注册功能的代码就无需给这个字段设置值，MYSQL会直接给这个字段用上默认值；另外一方面可以避免在添加数据操作时，如果没给这个字段指定值，将会报错的情况。\n\n2. 在项目代码开发中的基本流程是：\n\n   1）从模板文件入手，创建相关的控制器类和该类中的相应方法，渲染模板展示到浏览器；\n\n   2）在方法中渲染模板之前调用模型操作数据，比如我们之前开发的后台用户管理系统列表页，在渲染列表页模板之前，我们需要调用模型把列表页需要展示的数据查询出来；如果没有模型，则需要创建模型，如果有，则直接使用；\n\n   3）在方法中构建逻辑处理代码，生成相关功能；\n\n\n\n## 2. 昨日反馈\n\n![1531406278112](42)\n\n\n\n# 五、知识路径\n\n# 六、今日课程内容：博客项目\n\n## 1. 封装验证码工具类\n\n1. 在blog31/plugins目录下创建CaptchaTool.class.php的文件，\n\n   ![1531449474729](50)\n\n   构建的代码如下，\n\n   ```php\n   <?php\n   namespace plugins;//创建一个   全局空间  下的  plugins空间\n   \n   class CaptchaTool{\n   \n       private $_w;//画布的宽度\n       private $_h;//画布的高度\n   \n       private $_img;//画布资源\n       \n       public function __construct($w=200, $h=80){ \n           \n           #初始化参数\n           $this->_w = $w;\n           $this->_h = $h;\n   \n           $this->_img = imagecreatetruecolor($this->_w, $this->_h);//创建画布\n   \n           #填充背景色\n           $color = $this->color();//获得随机色\n           imagefill($this->_img, 0, 0, $color);//填充背景色\n   \n           #写字\n           $randStr = $this->randStr();//构建4个随机字\n           $color = $this->color();//获得随机色\n           $fontPath = PUBLIC_PATH . '/fonts/font1.ttf';//字体文件所在路径\n           $bx = $this->_w/4;//左下角起点x坐标\n           $by = $this->_h*3/4;//左下角起点y坐标\n           $fontSize = $this->_h *37/80;//字体大小，高度尺寸的37/80\n   \n           imagettftext($this->_img, $fontSize, 0, $bx, $by, $color, $fontPath, $randStr);//写字\n   \n           #设置干扰元素\n           //设置干扰点\n           $this->setPoint(180);\n   \n           //设置干扰线\n           $this->setLine(8);\n       }\n   \n       #画干扰线\n       private function setLine($num){ \n   \n           for($i=0; $i<$num; $i++ ){ //画$num个点\n               $color = $this->color();//获得随机色\n   \n               $bx = mt_rand(0, $this->_w/2);//起点x坐标\n               $by = mt_rand(0, $this->_h);//起点y坐标\n               $ex = mt_rand($this->_w/2, $this->_w);//终点x坐标\n               $ey = mt_rand(0, $this->_h);//终点y坐标\n   \n               imageline($this->_img, $bx, $by, $ex, $ey, $color);//画点\n           }\n       }\n   \n       #画干扰点\n       private function setPoint($num){ \n   \n           for($i=0; $i<$num; $i++ ){ //画$num个点\n               $color = $this->color();//获得随机色\n   \n               $bx = mt_rand(0, $this->_w);//起点x坐标\n               $by = mt_rand(0, $this->_h);//起点y坐标\n               $ex = mt_rand($bx-2, $bx+2);//终点x坐标\n               $ey = mt_rand($by-2, $by+2);//终点y坐标\n   \n               imageline($this->_img, $bx, $by, $ex, $ey, $color);//画点\n           }\n       }\n   \n       #构建随机字\n       private function randStr($num=4){ \n           \n           $mixedArr = array_merge(range('a', 'z'), range('A', 'Z'), range(0, 9));//构建随机字采集库\n   \n           $str = '';\n           for($i=0; $i<$num; $i++ ){ //采集$num次\n               \n               $key = mt_rand(0, count($mixedArr)-1);//取得当前随机字符对应的元素下标\n               $str .= $mixedArr[$key];//从字库中取得下标为$key的元素值拼接给$str\n           }\n   \n           return $str;\n           \n       }\n   \n       #分配颜色\n       private function color($r='', $g='', $b=''){ \n           \n           //初始化三原色\n           $r = ($r==='') ? mt_rand(0, 255) : $r;//红\n           $g = ($g==='') ? mt_rand(0, 255) : $g;//绿\n           $b = ($b==='') ? mt_rand(0, 255) : $b;//蓝\n   \n           //分配颜色\n           return imagecolorallocate($this->_img, $r, $g, $b);\n       }\n   \n       #输出图像的方法\n       public function output(){ \n           \n           header('Content-type:image/jpeg');//指定一个响应协议项\n   \n           imagejpeg($this->_img);//直接将图像输出到浏览器\n       }\n   }\n   ```\n\n2. 在blog31/public下创建fonts目录，\n\n   ![1531449570234](51)\n\n   将F:\\home\\class\\day15\\source\\font1.ttf复制转移到blog31/public/fonts目录中，\n\n   ![1531449634142](52)\n\n3. 在blog31/conf/define.php中定义一个目录常量，\n\n   ![1531449686817](53)\n\n4. 在blog31/core/App.class.php中的autoload方法中实现对工具类的自动加载，\n\n   ![1531449747232](54)\n\n5. 测试使用工具类，\n\n   在blog31/app/admin/controller/UserController.class.php中构建测试方法test，代码如下：\n\n   ![1531449796360](55)\n\n   访问test方法，\n\n   ![1531449846347](56)\n\n   验证码制作成功。\n\n\n\n## 2. 实现后台分类管理系统\n\n在blog31/app/admin/controller中创建名为CatController.class.php文件，专门用于操作后台分类管理系统各程序，\n\n![1531406458061](43)\n\n代码如下：\n\n![1531406531563](44)\n\n\n\n### 实现列表页\n\n1. 在blog31/app/admin/controller/CatController.class.php中创建名为showList的方法，渲染后台分类列表页模板，\n\n   ![1531406637793](45)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=cat&a=showIndex访问后台分类管理系统列表页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/categoryIndex.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531406850800](46)\n\n3. 在blog31/app/model目录下创建CatModel.class.php的文件，\n\n   ![1531450315893](57)\n\n   代码如下：\n\n   ![1531450340259](58)\n\n4. 在blog31/app/admin/controller/CatController.class.php文件showList方法中构建如下代码，\n\n   ![1531451514806](59)\n\n   调整模板文件回显查询的数据blog31/app/admin/view/Category/categoryIndex.html：\n\n   ![1531451572387](60)\n\n5. 访问后台分类管理系统列表页：\n\n   ![1531451726375](61)\n\n\n\n我们进一步调整程序，将所有分类数据进行整理，\n\n#### 实现无限级递归分类\n\n1. 在blog31/app/admin/controller/CatController.class.php文件中创建两个方法，代码和作用如下图所示：\n\n   ![1531465269865](62)\n\n   ![1531465303880](63)\n\n2. 然后在blog31/app/admin/controller/CatController.class.php文件中的showList方法里调整获得所有分类数据的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531465362917](64)\n\n3. 调整模板页面中的代码，在输出分类名称之前还需要输出缩进符，\n\n   ![1531465455827](65)\n\n4. 测试最终效果：\n\n   访问后台分类管理系统列表页\n\n   ![1531465510155](66)\n\n\n\n### 实现添加页\n\n1. 在blog31/app/controller/CatController.class.php中创建名为showAd的方法，渲染后台分类添加页模板，\n\n   ![1531407090431](47)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=cat&a=showAd访问后台分类管理系统添加页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/categoryAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531406850800](46)\n\n3. \n\n\n\n\n\n### 实现编辑页\n\n1. 调整blog31/app/admin/view/Category/categoryIndex.html中的编辑按钮链接，\n\n   ![1531465870984](67)\n\n2. 在blog31/app/admin/controller/CatController.class.php中创建名为showUpd的方法，渲染后台分类编辑页模板，\n\n   ![1531465965417](68)\n\n3. 通过从后台分类列表页点击编辑按钮访问后台分类管理系统编辑页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/categoryEdit.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531466023359](69)\n\n4. 在blog31/app/admin/controller/CatController.class.php中的showUpd方法里构建相应的程序功能代码，如下图所示：\n\n   ![1531466996992](70)\n\n5. 调整blog31/app/admin/view/Category/categoryEdit.html中需要回显数据的部分及表单域的相关属性值，\n\n   ![1531467078936](71)\n\n6. 在blog31/app/admin/controller/CatController.class.php构建updh方法，代码如下：\n\n   ```php\n   //编辑处理方法\n   public function updh(){ \n   \n       //接收表单提交的数据\n       $id = $_GET['id'];\n   \n       $name = trim($_POST['name']);//新的分类名称\n       $old_name = trim($_POST['old_name']);//老的分类名称\n       $parent_id = trim($_POST['parent_id']);//新的父级id\n       $old_parent_id = trim($_POST['old_parent_id']);//老的父级id\n   \n       //检查是否有数据真的被修改了\n       $target = [];\n   \n       if( $name!=$old_name && $name!='' ){//如果新的名称不等于老的名称并且新的名称不为空，则需要修改name值\n           $target[] = \"name='{$name}'\";\n       }\n   \n       if( $parent_id!=$old_parent_id ){//如果新的父级id不等于老的父级id\n           $target[] = \"parent_id={$parent_id}\";\n       }\n   \n       if( !empty($target) ){//如果$target不为空，说明有数据需要被更新\n   \n           $strTarget = implode(', ', $target);//  $strTarget=\"name='xxxx', parent_id=xxxx\";\n           $sql = \"update bg_category set {$strTarget} where id={$id}\";\n   \n           //调用模型执行更新操作\n           $model = \\core\\App::single('\\model\\CatModel');\n           $re = $model->setData($sql);\n   \n           if( $re ){//更新成功\n               echo '嘿嘿嘿，运气不错，更新成功咯～'; \n           }else{//更新失败\n               echo '哈哈哈，你更新失败了！'; \n           }\n       }else{//否则给出提示没有数据被更新\n           echo '您当前还没有更新数据哟～'; \n       }\n   \n       //2秒之后跳转回编辑页\n       $url = C('URL') . '/index.php?p=admin&m=cat&a=showUpd&id='.$id;\n       header('Refresh:2; url='.$url);\n       exit;\n   }\n   ```\n\n7. 测试使用效果，效果OK，功能成功。\n\n\n\n### 实现删除功能\n\n\n\n\n\n## 3. 实现后台博文管理系统\n\n在blog31/app/admin/controller中创建名为ArticleController.class.php文件，专门用于操作后台博文管理系统各程序，\n\n![1531407704334](49)\n\n代码如下：\n\n![1531407665958](48)\n\n\n\n### 实现添加页\n\n1. 在blog31/app/controller/ArticleController.class.php中创建名为showAd的方法，渲染后台博文添加页模板，\n\n   ![1531468943273](72)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=article&a=showAd访问后台博文管理系统添加页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Article/articleAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531469128676](73)\n\n3. 调整无限级递归分类方法的归属\n\n   将blog31/app/admin/controller/CatController.class.php文件中如下图所示的方法剪切下来，\n\n   ![1531470492230](74)\n\n   将剪切下来的代码全部粘贴到blog31/app/model/CatModel.class.php的类中，\n\n   ![1531470605131](75)\n\n   再调整blog31/app/model/CatModel.class.php内的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531470734590](76)\n\n   将blog31/app/admin/controller/CatController.class.php中的showUpd和showList方法调用无限级递归分类方法的方式进行调整，如下图中将蓝框部分改为红框部分：\n\n   ![1531470829870](77)\n\n   ![1531470912888](78)\n\n   在blog31/app/controller/ArticleController.class.php中showAd方法里添加如下代码：\n\n   ![1531472987997](81)\n\n4. 调整blog31/app/admin/view/Article/articleAdd.html中的表单各成员代码：\n\n   ![1531472047225](79)\n\n5. 在blog31/app/model下创建ArticleModel.class.php的文件，如下图所示：\n\n   ![1531472247204](80)\n\n6. 在blog31/app/controller/ArticleController.class.php中添加adh方法，处理添加功能，\n\n   ![1531473089893](82)\n\n7. 测试使用效果：\n\n   在添加页构建如下内容，\n\n   ![1531473145850](83.png)\n\n   点击添加按钮，效果为：\n\n   ![1531473185491](83)\n\n   说明添加功能OK。\n\n\n\n### 实现列表页\n\n1. 在blog31/app/admin/controller/ArticleController.class.php中创建名为showIndex的方法，渲染后台博文列表页模板，\n\n   ![1531473364554](84)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=article&a=showIndex访问后台博文管理系统列表页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Article/articleIndex.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531473422417](85)\n\n3. 在blog31/app/admin/controller/ArticleController.class.php中的showList方法里在渲染模板之前查询数据，\n\n   ![1531473884257](86)\n\n4. 将查得的数据在blog31/app/admin/view/Article/articleIndex.html中回显，\n\n   ![1531473945005](87)\n\n5. 测试访问效果：\n\n   ![1531473996556](88)\n\n\n\n\n\n### 实现编辑页\n\n1. 调整blog31/app/admin/view/Category/articleIndex.html中的编辑按钮链接，\n\n   \n\n2. 在blog31/app/controller/ArticleController.class.php中创建名为showUpd的方法，渲染后台博文编辑页模板，\n\n   \n\n3. 通过从后台博文列表页点击编辑按钮访问后台博文管理系统编辑页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/articleUpd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   \n\n4. \n\n\n\n\n\n### 实现删除功能\n\n\n\n\n\n## 4. 整理模板文件\n\n\n\n\n\n## 5. 全天总结\n\n1. 制作的页面和功能：\n\n   封装验证码工具类\n\n   实现后台分类管理系统的列表页和编辑页\n\n   实现无限级递归分类\n\n   实现博客文章管理系统添加页\n\n   实现博客文章管理系统列表页基础功能\n\n\n\n\n\n\n","categories":["博客项目"]},{"title":"博客项目3","url":"%2Fposts%2F12724151%2F","content":"\n\n# 一、昨日回顾\n\n## 1. 知识回顾\n\n1. mvc的三大组件是什么？\n\n   M：model     模型\n\n   V：view          视图\n\n   C：Controller     控制器\n\n2. mvc的三大组件分别代表什么意思？\n\n   M：专门用来操作数据表的\n\n   V：专门用来展示视图模板的\n\n   C：专门用来处理业务逻辑，比如说什么时候该调用模型操作数据，什么时候该调用视图展示模板，都是由控制器里来处理。\n\n\n\n## 2. 昨日反馈\n\n![1531270551320](114)\n\n# 二、知识路径\n\n- web项目开发流程介绍\n\n- 需求分析\n\n  ​\t功能分析\n\n  ​\tER图设计\n\n- 表设计\n\n- 项目部署\n\n- 项目实现\n\n  ​\t实现后台用户管理系统\n\n  ​\t封装验证码工具类\n\n==目标：能够设计项目所需的表、能够部署自主框架、能够实现后台用户管理系统==\n\n# 三、今日课程内容：博客项目\n\n## 1. web项目开发流程介绍\n\n1)制定计划：博客项目(blog31)  开发周期：4天\n\n2)需求分析：功能分析  ER图设计\n\n3)软件设计：项目环境  表设计\n\n4)程序编写\n\n5)软件测试\n\n6)运行维护\n\n\n\n## 2. 需求分析\n\n### 功能分析\n\n1. 后台用户管理系统；\n2. 后台分类管理系统；\n3. 后台博文管理系统；\n4. 评论管理系统；\n5. 后台登陆和七天免登录；\n6. 前台首页；\n7. 前台注册和登陆功能；\n8. 前台博客文章详情页；\n\n\n\n### ER图设计\n\nE-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。它是描述现实世界概念结构模型的有效方法。是表示概念模型的一种方式，用矩形表示实体型，矩形框内写明实体名；用椭圆表示实体的属性，并用无向边将其与相应的实体型连接起来；用菱形表示实体型之间的联系，在菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1,1:n或m:n）。\n\n \n\n专业的ER图工具：Viso和Power Designer\n\n \n\n==实体== ==》表：矩形表示\n\n==属性== ==》表字段：椭圆\n\n==关系== ==》表与表的关系：菱形（1:1表示1对1关系；1:n表示1对多关系；m:n表示多对多关系）\n\n\n\n博客项目的ER关系图如下： \n\n![1531279764230](1)\n\n\n\n## 3. 表设计\n\n```mysql\ndrop database blog31;\ncreate database blog31;\n\n#############用户表：\nCREATE TABLE `bg_user` (\n  `id` int unsigned auto_increment,\n  `acc` varchar(50) not null default '' COMMENT '帐号',\n  `nickname` varchar(30) not null default '' COMMENT '昵称',\n  `pwd` char(32) not null default '' COMMENT '密码',\n  `cell` varchar(15) not null default '' COMMENT '手机号',\n  `regtime` int unsigned default 0 COMMENT '注册时间',\n  `type` tinyint unsigned not null default 0 COMMENT '用户类型 0:普通用户 1:管理员',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n#############博客文章表：\nCREATE TABLE `bg_article` (\n  `id` int(11) unsigned AUTO_INCREMENT,\n  `title` varchar(100) not null default '' COMMENT '文章标题',\n  `intro` varchar(255) not null default '' COMMENT '文章简介',\n  `content` text not null,\n  `post_date` int unsigned not null default 0 COMMENT '发布时间',\n  `user_id` int unsigned not null default 0 COMMENT '发布管理员id',\n  `user_nickname` varchar(30) not null default '' COMMENT '发布管理员昵称',\n  `comment_num` smallint unsigned not null default 0 COMMENT '评论数量',\n  `cat_id` int unsigned not null default 0 COMMENT '所属分类id',\n  `cat_name` varchar(30) not null default '' COMMENT '所属分类名称',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n#############博客文章分类表：\nCREATE TABLE `bg_category` (\n  `id` int unsigned AUTO_INCREMENT,\n  `name` varchar(30) not null COMMENT '分类名称',\n  `parent_id` int unsigned not null default '0' COMMENT '上级分类ID，0表示顶级分类',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n\n#############评论表：\nCREATE TABLE `bg_comment` (\n  `id` int unsigned AUTO_INCREMENT,\n  `content` text not null,\n  `post_date` int unsigned not null default 0 COMMENT '评论时间',\n  `article_id` int unsigned not null default 0 COMMENT '所属文章ID',\n  `article_title` varchar(50)  not null default '' COMMENT '所属文章标题',\n  `user_id` int unsigned not null default 0 COMMENT '用户ID',\n  `user_nickname` varchar(30)  not null default '' COMMENT '用户昵称',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n```\n\n\n\n## 4. 项目部署\n\n1. 将code/mvc目录改名为blog31，\n\n   下图这个mvc目录：\n\n   ![1531291206947](2)\n\n   改名为blog31:\n\n   ![1531291235746](3)\n\n2. 配置一个基于域名虚拟主机，域名为www.blog31.com\n\n   在httpd-vhosts.conf文件中增加如下图所示的虚拟主机配置项：\n\n   ![1531291311545](4)\n\n   修改hosts文件，\n\n   ![1531291371313](5)\n\n3. 重启apache，测试访问效果：\n\n   ![1531291456736](6)\n\n   访问效果为：\n\n   ![1531291515331](7)\n\n   能够看到上图，则说明部署成功。\n\n\n\n## 5. 项目实现\n\n### 实现后台用户管理系统\n\n#### 实现列表页\n\n1. 将code/templates/admin目录中如下图所示的目录复制一份，\n\n   ![1531291763786](8)\n\n   转移拷贝到code/blog31/app/admin/view目录中，\n\n   ![1531291818821](9)\n\n2. 在blog31/app/admin/controller目录中创建一个名为UserController.class.php的文件，\n\n   ![1531291945355](10)\n\n3. 在blog31/app/admin/controller/UserController.class.php中构建如下代码，展示三个页面，\n\n   ![1531292339989](11)\n\n4. 测试访问后台用户管理系统列表页\n\n   ![1531292433660](12)\n\n5. 进一步做调整，将后台模板使用到的资源文件全部转移进项目中，\n\n   在blog31/public目录中创建一个名为admin的目录，专门保存后台的资源文件，\n\n   ![1531292599939](13)\n\n   复制code/templates/admin/libs目录下的所有文件，如下图所示，\n\n   ![1531292644972](14)\n\n   转移拷贝到blog31/public/admin目录中，\n\n   ![1531292690333](15)\n\n6. 调整blog31/app/admin/view/User/userIndex.html中引入资源文件的路径，\n\n   在blog31/conf/conf.php中增加本网站域名配置项，\n\n   ![1531293146377](16)\n\n   然后在blog31/app/admin/view/User/userIndex.html使用配置项URL的值来引入配置文件，\n\n   ![1531293430682](17)\n\n   ![1531293486446](18)\n\n   上图中替换的是所有图片文件引入路径，截取不全，实际替换的内容以blog31/app/admin/view/User/userIndex.html中的为准。\n\n7. 再次测试访问后台新闻管理系统列表页，\n\n   ![1531293567621](19)\n\n8. 在blog31/app/model目录中创建UserModel.class.php文件，\n\n   ![1531293712684](20)\n\n   内容如下：\n\n   ![1531293731152](21)\n\n   调整blog31/conf/conf.php中PDO配置项的默认选择的数据库名，\n\n   ![1531294133397](22)\n\n9. 在blog31/app/admin/controller/UserController.class.php中showIndex方法里渲染模板之前调用模型查询数据，\n\n   ![1531294688749](23)\n\n   然后在blog31/app/admin/view/User/userIndex.html中回显查询得到的用户数据，\n\n   ![1531294782348](24)\n\n   测试访问后台用户管理系统列表页：\n\n   ![1531294828901](25)\n\n#### 实现添加页\n\n1. 访问后台用户管理系统添加页，\n\n   ![1531295330114](26)\n\n2. 调整blog31/app/admin/view/User/userAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531295483768](27)\n\n3. 调整blog31/app/admin/view/User/userAdd.html中的form表单域各项的值，\n\n   ![1531295777460](28)\n\n4. 在blog31/app/admin/controller/UserController.class.php中创建一个处理添加用户的方法，adh方法，\n\n   ![1531296464355](29)\n\n5. 测试添加用户使用效果：\n\n   在添加表单页面构建数据，点击提交，\n\n   ![1531296568559](30)\n   提交后的效果：\n\n   ![1531296591547](31)\n\n   效果为添加成功，说明功能实现OK。\n\n#### 实现编辑页\n\n1. 访问后台新闻管理系统编辑页：\n\n   ![1531296743041](32)\n\n2. 修改blog31/app/admin/view/User/userIndex.html中编辑按钮的链接：\n\n   ![1531296871382](33)\n\n3. 调整blog31/app/admin/view/User/userEdit.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531296956168](34)\n\n4. 调整blog31/app/admin/view/User/userEdit.html中form表单里的代码，\n\n   ![1531297468408](35)\n\n5. 在blog31/app/admin/controller/UserController.class.php中创建updh方法，代码如下：\n\n   ![1531301022079](36)\n\n6. 测试使用效果：\n\n   点击进入编辑也，如下图所示：\n\n   ![1531301120317](37)\n\n   修改数据，\n\n   ![1531301172674](38)\n\n   点击更新，\n\n   ![1531301192522](39)\n\n   跳回到更新页面：\n\n   ![1531301213845](40)\n\n   密码也是被改变了的，如下图所示：\n\n   ![1531301252698](41)\n\n   说明编辑功能实现OK。\n\n\n\n## 6. 全天总结\n\n1. 项目中的建表部分：\n\n   如果某字段是需要保存时间，一般在PHP的项目中给int数据类型；\n\n   如果某字段需要保存状态类型的值，使用tinyint会更加好；\n\n   如果某字段保存的数据，我们可以预期的很准确，比如说手机号码，通常就是11位，但是我们在项目中一般会采取宁大不小的原则，给11位以上的值，比如给varchar(15)；\n\n   在构建字段的时候，我们一般都会给字段设置default默认值，如果不设置默认值，则今后这个字段无论是否需要添加数据，都必须指定上值。\n\n2. 项目开发部分：\n\n   我们使用框架进行开发，一般程序开发人员从模板入手，先尝试展示出模板页面的效果，然后再考虑是否需要调用模型操作数据库的问题，所以我们通常在MVC框架中，1）首先会将模板页面转移进项目目录；2）然后会创建控制器类，构建方法调用视图展示模板页面；3）调试模板页面展示的效果；4）以上都成功之后，如果没有模型则需要创建模型，如果有模型则直接去考虑调用模型操作数据；\n\n\n\n# 四、昨日回顾\n\n## 1. 知识回顾\n\n1. 建表注意事项：\n\n   如果在项目中要保存一个时间的数据，则我们一般选择使用int类型来保存；\n\n   如果在项目中要保存一个状态或类型这样的数据时，我们一般选择使用tinyint类型来保存；\n\n   如果在项目中能够明确要保存的数据需要占多少个字节时，我们一般采用的做法是宁大不小，比如，保存手机号码一般是11位，但是我们通常会选择给varchar(15)\n\n   如果在项目中构建字段时，通常我们会给字段指定一个默认值，一方面方便程序的默认操作，比如注册时，如果给用户类型指定了默认值为0表示普通会员，则构建注册功能的代码就无需给这个字段设置值，MYSQL会直接给这个字段用上默认值；另外一方面可以避免在添加数据操作时，如果没给这个字段指定值，将会报错的情况。\n\n2. 在项目代码开发中的基本流程是：\n\n   1）从模板文件入手，创建相关的控制器类和该类中的相应方法，渲染模板展示到浏览器；\n\n   2）在方法中渲染模板之前调用模型操作数据，比如我们之前开发的后台用户管理系统列表页，在渲染列表页模板之前，我们需要调用模型把列表页需要展示的数据查询出来；如果没有模型，则需要创建模型，如果有，则直接使用；\n\n   3）在方法中构建逻辑处理代码，生成相关功能；\n\n\n\n## 2. 昨日反馈\n\n![1531406278112](42)\n\n\n\n# 五、知识路径\n\n# 六、今日课程内容：博客项目\n\n## 1. 封装验证码工具类\n\n1. 在blog31/plugins目录下创建CaptchaTool.class.php的文件，\n\n   ![1531449474729](50)\n\n   构建的代码如下，\n\n   ```php\n   <?php\n   namespace plugins;//创建一个   全局空间  下的  plugins空间\n   \n   class CaptchaTool{\n   \n       private $_w;//画布的宽度\n       private $_h;//画布的高度\n   \n       private $_img;//画布资源\n       \n       public function __construct($w=200, $h=80){ \n           \n           #初始化参数\n           $this->_w = $w;\n           $this->_h = $h;\n   \n           $this->_img = imagecreatetruecolor($this->_w, $this->_h);//创建画布\n   \n           #填充背景色\n           $color = $this->color();//获得随机色\n           imagefill($this->_img, 0, 0, $color);//填充背景色\n   \n           #写字\n           $randStr = $this->randStr();//构建4个随机字\n           $color = $this->color();//获得随机色\n           $fontPath = PUBLIC_PATH . '/fonts/font1.ttf';//字体文件所在路径\n           $bx = $this->_w/4;//左下角起点x坐标\n           $by = $this->_h*3/4;//左下角起点y坐标\n           $fontSize = $this->_h *37/80;//字体大小，高度尺寸的37/80\n   \n           imagettftext($this->_img, $fontSize, 0, $bx, $by, $color, $fontPath, $randStr);//写字\n   \n           #设置干扰元素\n           //设置干扰点\n           $this->setPoint(180);\n   \n           //设置干扰线\n           $this->setLine(8);\n       }\n   \n       #画干扰线\n       private function setLine($num){ \n   \n           for($i=0; $i<$num; $i++ ){ //画$num个点\n               $color = $this->color();//获得随机色\n   \n               $bx = mt_rand(0, $this->_w/2);//起点x坐标\n               $by = mt_rand(0, $this->_h);//起点y坐标\n               $ex = mt_rand($this->_w/2, $this->_w);//终点x坐标\n               $ey = mt_rand(0, $this->_h);//终点y坐标\n   \n               imageline($this->_img, $bx, $by, $ex, $ey, $color);//画点\n           }\n       }\n   \n       #画干扰点\n       private function setPoint($num){ \n   \n           for($i=0; $i<$num; $i++ ){ //画$num个点\n               $color = $this->color();//获得随机色\n   \n               $bx = mt_rand(0, $this->_w);//起点x坐标\n               $by = mt_rand(0, $this->_h);//起点y坐标\n               $ex = mt_rand($bx-2, $bx+2);//终点x坐标\n               $ey = mt_rand($by-2, $by+2);//终点y坐标\n   \n               imageline($this->_img, $bx, $by, $ex, $ey, $color);//画点\n           }\n       }\n   \n       #构建随机字\n       private function randStr($num=4){ \n           \n           $mixedArr = array_merge(range('a', 'z'), range('A', 'Z'), range(0, 9));//构建随机字采集库\n   \n           $str = '';\n           for($i=0; $i<$num; $i++ ){ //采集$num次\n               \n               $key = mt_rand(0, count($mixedArr)-1);//取得当前随机字符对应的元素下标\n               $str .= $mixedArr[$key];//从字库中取得下标为$key的元素值拼接给$str\n           }\n   \n           return $str;\n           \n       }\n   \n       #分配颜色\n       private function color($r='', $g='', $b=''){ \n           \n           //初始化三原色\n           $r = ($r==='') ? mt_rand(0, 255) : $r;//红\n           $g = ($g==='') ? mt_rand(0, 255) : $g;//绿\n           $b = ($b==='') ? mt_rand(0, 255) : $b;//蓝\n   \n           //分配颜色\n           return imagecolorallocate($this->_img, $r, $g, $b);\n       }\n   \n       #输出图像的方法\n       public function output(){ \n           \n           header('Content-type:image/jpeg');//指定一个响应协议项\n   \n           imagejpeg($this->_img);//直接将图像输出到浏览器\n       }\n   }\n   ```\n\n2. 在blog31/public下创建fonts目录，\n\n   ![1531449570234](51)\n\n   将F:\\home\\class\\day15\\source\\font1.ttf复制转移到blog31/public/fonts目录中，\n\n   ![1531449634142](52)\n\n3. 在blog31/conf/define.php中定义一个目录常量，\n\n   ![1531449686817](53)\n\n4. 在blog31/core/App.class.php中的autoload方法中实现对工具类的自动加载，\n\n   ![1531449747232](54)\n\n5. 测试使用工具类，\n\n   在blog31/app/admin/controller/UserController.class.php中构建测试方法test，代码如下：\n\n   ![1531449796360](55)\n\n   访问test方法，\n\n   ![1531449846347](56)\n\n   验证码制作成功。\n\n\n\n## 2. 实现后台分类管理系统\n\n在blog31/app/admin/controller中创建名为CatController.class.php文件，专门用于操作后台分类管理系统各程序，\n\n![1531406458061](43)\n\n代码如下：\n\n![1531406531563](44)\n\n\n\n### 实现列表页\n\n1. 在blog31/app/admin/controller/CatController.class.php中创建名为showList的方法，渲染后台分类列表页模板，\n\n   ![1531406637793](45)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=cat&a=showIndex访问后台分类管理系统列表页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/categoryIndex.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531406850800](46)\n\n3. 在blog31/app/model目录下创建CatModel.class.php的文件，\n\n   ![1531450315893](57)\n\n   代码如下：\n\n   ![1531450340259](58)\n\n4. 在blog31/app/admin/controller/CatController.class.php文件showList方法中构建如下代码，\n\n   ![1531451514806](59)\n\n   调整模板文件回显查询的数据blog31/app/admin/view/Category/categoryIndex.html：\n\n   ![1531451572387](60)\n\n5. 访问后台分类管理系统列表页：\n\n   ![1531451726375](61)\n\n\n\n我们进一步调整程序，将所有分类数据进行整理，\n\n#### 实现无限级递归分类\n\n1. 在blog31/app/admin/controller/CatController.class.php文件中创建两个方法，代码和作用如下图所示：\n\n   ![1531465269865](62)\n\n   ![1531465303880](63)\n\n2. 然后在blog31/app/admin/controller/CatController.class.php文件中的showList方法里调整获得所有分类数据的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531465362917](64)\n\n3. 调整模板页面中的代码，在输出分类名称之前还需要输出缩进符，\n\n   ![1531465455827](65)\n\n4. 测试最终效果：\n\n   访问后台分类管理系统列表页\n\n   ![1531465510155](66)\n\n\n\n### 实现添加页\n\n1. 在blog31/app/controller/CatController.class.php中创建名为showAd的方法，渲染后台分类添加页模板，\n\n   ![1531407090431](47)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=cat&a=showAd访问后台分类管理系统添加页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/categoryAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531406850800](46)\n\n3. \n\n\n\n\n\n### 实现编辑页\n\n1. 调整blog31/app/admin/view/Category/categoryIndex.html中的编辑按钮链接，\n\n   ![1531465870984](67)\n\n2. 在blog31/app/admin/controller/CatController.class.php中创建名为showUpd的方法，渲染后台分类编辑页模板，\n\n   ![1531465965417](68)\n\n3. 通过从后台分类列表页点击编辑按钮访问后台分类管理系统编辑页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/categoryEdit.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531466023359](69)\n\n4. 在blog31/app/admin/controller/CatController.class.php中的showUpd方法里构建相应的程序功能代码，如下图所示：\n\n   ![1531466996992](70)\n\n5. 调整blog31/app/admin/view/Category/categoryEdit.html中需要回显数据的部分及表单域的相关属性值，\n\n   ![1531467078936](71)\n\n6. 在blog31/app/admin/controller/CatController.class.php构建updh方法，代码如下：\n\n   ```php\n   //编辑处理方法\n   public function updh(){ \n   \n       //接收表单提交的数据\n       $id = $_GET['id'];\n   \n       $name = trim($_POST['name']);//新的分类名称\n       $old_name = trim($_POST['old_name']);//老的分类名称\n       $parent_id = trim($_POST['parent_id']);//新的父级id\n       $old_parent_id = trim($_POST['old_parent_id']);//老的父级id\n   \n       //检查是否有数据真的被修改了\n       $target = [];\n   \n       if( $name!=$old_name && $name!='' ){//如果新的名称不等于老的名称并且新的名称不为空，则需要修改name值\n           $target[] = \"name='{$name}'\";\n       }\n   \n       if( $parent_id!=$old_parent_id ){//如果新的父级id不等于老的父级id\n           $target[] = \"parent_id={$parent_id}\";\n       }\n   \n       if( !empty($target) ){//如果$target不为空，说明有数据需要被更新\n   \n           $strTarget = implode(', ', $target);//  $strTarget=\"name='xxxx', parent_id=xxxx\";\n           $sql = \"update bg_category set {$strTarget} where id={$id}\";\n   \n           //调用模型执行更新操作\n           $model = \\core\\App::single('\\model\\CatModel');\n           $re = $model->setData($sql);\n   \n           if( $re ){//更新成功\n               echo '嘿嘿嘿，运气不错，更新成功咯～'; \n           }else{//更新失败\n               echo '哈哈哈，你更新失败了！'; \n           }\n       }else{//否则给出提示没有数据被更新\n           echo '您当前还没有更新数据哟～'; \n       }\n   \n       //2秒之后跳转回编辑页\n       $url = C('URL') . '/index.php?p=admin&m=cat&a=showUpd&id='.$id;\n       header('Refresh:2; url='.$url);\n       exit;\n   }\n   ```\n\n7. 测试使用效果，效果OK，功能成功。\n\n\n\n### 实现删除功能\n\n\n\n\n\n## 3. 实现后台博文管理系统\n\n在blog31/app/admin/controller中创建名为ArticleController.class.php文件，专门用于操作后台博文管理系统各程序，\n\n![1531407704334](49)\n\n代码如下：\n\n![1531407665958](48)\n\n\n\n### 实现添加页\n\n1. 在blog31/app/controller/ArticleController.class.php中创建名为showAd的方法，渲染后台博文添加页模板，\n\n   ![1531468943273](72)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=article&a=showAd访问后台博文管理系统添加页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Article/articleAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531469128676](73)\n\n3. 调整无限级递归分类方法的归属\n\n   将blog31/app/admin/controller/CatController.class.php文件中如下图所示的方法剪切下来，\n\n   ![1531470492230](74)\n\n   将剪切下来的代码全部粘贴到blog31/app/model/CatModel.class.php的类中，\n\n   ![1531470605131](75)\n\n   再调整blog31/app/model/CatModel.class.php内的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531470734590](76)\n\n   将blog31/app/admin/controller/CatController.class.php中的showUpd和showList方法调用无限级递归分类方法的方式进行调整，如下图中将蓝框部分改为红框部分：\n\n   ![1531470829870](77)\n\n   ![1531470912888](78)\n\n   在blog31/app/controller/ArticleController.class.php中showAd方法里添加如下代码：\n\n   ![1531472987997](81)\n\n4. 调整blog31/app/admin/view/Article/articleAdd.html中的表单各成员代码：\n\n   ![1531472047225](79)\n\n5. 在blog31/app/model下创建ArticleModel.class.php的文件，如下图所示：\n\n   ![1531472247204](80)\n\n6. 在blog31/app/controller/ArticleController.class.php中添加adh方法，处理添加功能，\n\n   ![1531473089893](82)\n\n7. 测试使用效果：\n\n   在添加页构建如下内容，\n\n   ![1531473145850](83.png)\n\n   点击添加按钮，效果为：\n\n   ![1531473185491](83)\n\n   说明添加功能OK。\n\n\n\n### 实现列表页\n\n1. 在blog31/app/admin/controller/ArticleController.class.php中创建名为showIndex的方法，渲染后台博文列表页模板，\n\n   ![1531473364554](84)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=article&a=showIndex访问后台博文管理系统列表页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Article/articleIndex.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531473422417](85)\n\n3. 在blog31/app/admin/controller/ArticleController.class.php中的showList方法里在渲染模板之前查询数据，\n\n   ![1531473884257](86)\n\n4. 将查得的数据在blog31/app/admin/view/Article/articleIndex.html中回显，\n\n   ![1531473945005](87)\n\n5. 测试访问效果：\n\n   ![1531473996556](88)\n\n\n\n#### 实现列表页分页\n\n1. 将day16/source/page.php中的函数全部复制拷贝一份，\n\n   ![1531531410027](90)\n\n   将上图拷贝的函数转移粘贴到blog31/core/Func.php中，\n\n   ![1531531489801](91)\n\n2. 在blog31/app/admin/controller/ArticleController.class.php中的showList方法里计算分页所需各种参数，并且调整查询数据的SQL语句，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531533560360](92)\n\n   调整blog31/app/admin/view/Article/articleIndex.html中展示分页HTML部分的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531533622150](93)\n\n3. 测试访问效果：\n\n   ![1531533682781](94)\n\n\n\n#### 实现列表页序号\n\n1. 在blog31/app/admin/controller/ArticleController.class.php中showList方法里计算当前页第一条记录的序号，\n\n   ![1531535268048](95)\n\n2. 然后在模板文件blog31/app/admin/view/Article/articleIndex.html中构建每一条记录的序号，\n\n   ![1531535321745](96)\n\n3. 测试访问效果：\n\n   ![1531535366848](97)\n\n\n\n#### 实现搜索功能\n\n1. 在blog31/app/admin/controller/ArticleController.class.php中的showList方法里查询出所有的管理员和所有的分类数据，\n\n   ![1531536538080](98)\n\n   将上图中查得的数据回显到blog31/app/admin/view/Article/articleIndex.html中，\n\n   ![1531541167632](99)\n\n2. 在blog31/app/admin/controller/ArticleController.class.php中的showList方法里接收搜索表单提交的数据，检查搜索表单提交的数据并且根据搜索表单提交的数据构建查询条件，\n\n   ![1531540808004](100)\n\n   ![1531540883427](101)\n\n3. 测试使用效果：\n\n   ![1531541088045](102)\n\n\n\n\n\n### 实现编辑页\n\n1. 调整blog31/app/admin/view/Category/articleIndex.html中的编辑按钮链接，\n\n   ![1531549925587](103)\n\n2. 在blog31/app/controller/ArticleController.class.php中创建名为showUpd的方法，渲染后台博文编辑页模板，\n\n   ![1531550022313](104)\n\n3. 通过从后台博文列表页点击编辑按钮访问后台博文管理系统编辑页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/articleEdit.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531550157823](105)\n\n4. 在blog31/app/admin/controller/ArticleController.class.php中的showUpd方法里查找该页面需要的相关数据，\n\n   ![1531551056713](106)\n\n   在blog31/app/admin/view/Article/articleEdit.html中调整form表单中的各表单域并且回显本条博文数据，\n\n   ![1531551191790](107)\n\n   ![1531551212303](108)\n\n5. 在blog31/app/admin/controller/ArticleController.class.php中构建updh方法，代码如下：\n\n   ```php\n   public function updh(){ \n           \n       //接收表单传递的数据\n       //GET传递的\n       $id = $_GET['id'];\n   \n       //POST传递的\n       $new_title = trim($_POST['title']);\n       $new_intro = trim($_POST['intro']);\n   \n       $cat = $_POST['cat'];\n       $catArr = explode('|', $cat);//处理接收到的分类数据\n       $new_cat_id = $catArr[0];\n       $new_cat_name = $catArr[1];\n   \n       $new_content = trim($_POST['content']);\n   \n       //检查哪些数据真的被修改了\n       @session_start();\n       $target = [];\n   \n       if( $new_title!=$_SESSION['old_article']['title']&&!empty($new_title) ){//如果新的标题数据和老的标题数据不一样，则说明标题确实被修改了\n           $target[] = \"title='{$new_title}'\";\n       }\n   \n       if( $new_intro!=$_SESSION['old_article']['intro']&&!empty($new_intro) ){//如果新的简介数据和老的简介数据不一样，则说明简介确实被修改了\n           $target[]  = \"intro='{$new_intro}'\";\n       }\n   \n       if( $new_cat_id!=$_SESSION['old_article']['cat_id'] ){//如果新的分类id数据和老的分类id数据不一样，则说明分类确实被修改了\n           //                 cat_id=xxx, cat_name=\"xxx\"\n           $target[] = \"cat_id={$new_cat_id}, cat_name='{$new_cat_name}'\";\n       }\n   \n       if( $new_content!=$_SESSION['old_article']['content']&&!empty($new_content) ){//如果新的内容数据和老的内容数据不一样，则说明内容确实被修改了\n           $target[]  = \"content='{$new_content}'\";\n       }\n   \n       //根据检查的结果判断是否需要真的执行更新操作\n       if( !empty($target) ){//$target不为空，则说明确实有数据被修改了\n   \n           $strTarget = implode(',', $target);\n   \n           $model = \\core\\App::single('\\model\\ArticleModel');\n           $sql = \"update bg_article set {$strTarget} where id={$id}\";\n   \n           if( $model->setData($sql) ){//执行成功\n   \n               echo '修改成功！'; \n           }else{//执行失败\n               echo '修改失败，请联系超级管理员！'; \n           }\n   \n       }else{//否则，则说明没有数据需要被更新\n           echo '您还没有修改数据呐～';     \n       }\n   \n       //2秒之后跳回编辑页\n       $url = C('URL') . '/index.php?p=admin&m=article&a=showUpd&id='.$id;\n       header('Refresh:2; url='.$url);\n       exit;\n   }\n   ```\n\n   测试使用效果：\n\n   ![1531554638642](109)\n\n   点击提交：\n\n   ![1531554660616](110)\n\n编辑成功，说明功能制作OK。\n\n\n\n### 实现删除功能\n\n\n\n\n\n## 4. 整理模板文件\n\n1. 将blog31/app/admin/view/Article/articleEdit.html中的head部分提取出来，剪切转移到blog31//app/admin/view中新创建出来的Common目录中的head.html文件，\n\n   剪切下图所示代码：\n\n   ![1531556484467](111)\n\n   转移到Common/head.html中，\n\n   ![1531556565304](115)\n\n2. 将blog31/app/admin/view/Article/articleEdit.html中的页头部分提取出来，剪切转移到blog31//app/admin/view中Common目录中的bodyhead.html文件，\n\n   剪切如下代码：\n\n   ![1531556772556](116)\n\n   转移到Common/bodyhead.html中，\n\n   ![1531556873608](117)\n\n3. 将blog31/app/admin/view/Article/articleEdit.html中的sidebar部分提取出来，剪切转移到blog31//app/admin/view中Common目录中的sidebar.html文件，\n\n   剪切如下代码：\n\n   ![1531557000111](118)\n\n   转移到Common/sidebar.html中，\n\n   ![1531557131143](119)\n\n4. 然后将blog31/app/admin/view/Article/articleEdit.html中所有用到公共代码的部分，换成引入公共文件的操作：\n\n   ![1531561162334](125)\n\n   将blog31/app/admin/view/Article/articleAdd.html中所有用到公共代码的部分，换成引入公共文件的操作：\n\n   ![1531561333905](128)\n\n   将blog31/app/admin/view/Article/articleIndex.html中所有用到公共代码的部分，换成引入公共文件的操作：\n\n   ![1531561319749](127)\n\n5. 修改blog31/app/admin/view/Common/sidebar.html进入博文管理系统各页面的链接地址：\n\n   ![1531561252847](126)\n\n   再次访问后台博文管理系统编辑页：\n\n   ![1531561403077](129)\n\n\n\n## 5. 全天总结\n\n1. 制作的页面和功能：\n\n   封装验证码工具类\n\n   实现后台分类管理系统的列表页和编辑页\n\n   实现无限级递归分类\n\n   实现博客文章管理系统添加页\n\n   实现博客文章管理系统列表页基础功能\n\n\n\n# 七、昨日回顾\n\n## 1. 知识回顾\n\n1. 实现后台分类管理系统的列表页和编辑页\n2. 实现博客文章管理系统添加页\n3. 实现博客文章管理系统列表页基础功能\n\n\n\n## 2. 昨日反馈\n\n![1531530276586](89)\n\n\n\n# 八、知识路径\n\n- [ ] XSS攻击\n\n- [ ] 实现后台登陆页面和功能\n\n  ​\t防翻墙功能\n\n  ​\t7天免登录功能\n\n- [ ] 实现后台退出功能\n\n  ==目标：能够防范XSS攻击，能够实现后台登陆退出功能==\n\n# 九、今日课程内容：博客项目\n\n## 1. XSS攻击\n\n通常用户在表单界面输入的内容是不确定的，用户可以输入任何想要输入的内容进行提交，如果输入的是一些代码，并且我们在程序文件中还没有对用户输入提交的数据进行任何的过滤处理的话，那么，将会面临一定风险。 \n\n\n\nXSS的概念：Cross Site Scripting    全称   跨站脚本攻击，是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。\n\n\n\n**==XSS攻击的案例==**：\n\n在用户输入区域构建script内容，如下图所示：\n\n![1531558956738](120)\n\n点击提交，效果为：\n\n先弹出了提示框，\n\n![1531558988674](121)\n\n然后跳转到了一个大网站：\n\n![1531559026220](122)\n\n\n\n**==小结==**：\n\nXSS攻击其实就是用户在表单输入区域构建了客户端或浏览器能够解析的代码内容，以此来改变其他用户在访问当前这个页面的效果。\n\n\n\n==如何防？==\n\n1. 通过htmlspecialchars函数来进行过滤处理（主要用来处理富文本编辑器中的内容）；\n\n   ![1531560056083](124)\n\n2. 通过addslashes函数来进行过滤处理（主要用来处理非富文本编辑器的其他输入区域的内容）；\n   ![1531559577623](123)\n\n   addslashes可以将内容中的具有特殊意义的符号进行转义，如上图中将双引号转义了，这样一来，双引号将不再是包裹script代码标签信息的符号，而是普通的字符而已，这样就导致了script代码失效。\n\n3. 通过字符串替换或正则匹配的方式进行再过滤处理；\n\n\n\n\n\n## 2. 实现后台登陆页面和功能\n\n1. 在blog31/app/admin/controller目录中创建LoginController.class.php，\n\n   ![1531567007068](130)\n\n   在LoginController.class.php中创建相应的代码，如下图所示：\n\n   ![1531567088054](131)\n\n   访问登陆页面，\n\n   ![1531567136935](132)\n\n2. 调整登陆模板页面blog31/app/admin/view/Privilege/login.html的代码，\n\n   ![1531567350030](133)\n\n   再次访问，\n\n   ![1531567382848](134)\n\n3. 在blog31/app/admin/controller/LoginController.class.php中创建captcha方法，专门输出验证码，\n\n   ![1531567829511](135)\n\n   调整blog31/app/admin/view/Privilege/login.html回显验证码，并且实现局部刷新\n\n   ![1531567872097](136)\n\n   调整blog31/plugins/CaptchaTool.class.php中生成验证码字符串后的数据，将其记录到SESSION中，\n\n   ![1531571893188](139)\n\n4. 在blog31/app/admin/controller/LoginController.class.php创建loginh方法，代码如下，专门处理登陆验证功能：\n\n   ```php\n   //登陆验证方法\n   public function loginh(){ \n   \n       //接收表单提交的数据\n       $acc = trim($_POST['acc']);//帐号\n       $pwd = md5(addslashes(trim($_POST['pwd'])));//密码\n       $captcha = addslashes(trim($_POST['captcha']));//验证码\n   \n       //检查验证码是否填写正确\n       @session_start();\n       if( $captcha!==$_SESSION['captchaStr'] ){//用户填写的验证码和生成的验证码不相等，则说明用户输入的验证码是错误的\n           echo '你好棒棒哟，竟然写错了哟！～'; \n           $url = C('URL') . '/index.php?p=admin&m=login&a=showLogin';\n           header('Refresh:2; url='.$url);\n           exit;\n       }\n   \n       //检查帐号和密码是否正确\n       $userModel = \\core\\App::single('\\model\\UserModel');\n       $sql = \"select * from bg_user where acc='{$acc}' and pwd='{$pwd}'\";\n       $row = $userModel->getRow($sql);\n   \n       if( !empty($row) ){//帐号密码填写正确\n   \n           echo '客官，您又来了吖～'; \n           $url = C('URL') . '/index.php?p=admin&m=article&a=showList';\n           header('Refresh:2; url='.$url);\n       }else{//否则至少有一个填写错误\n   \n           echo '帐号或密码填写错误，请重新填写！'; \n           $url = C('URL') . '/index.php?p=admin&m=login&a=showLogin';\n           header('Refresh:2; url='.$url);\n       }\n       exit;\n   }\n   ```\n\n5. 测试使用效果：\n\n   访问登陆页面，输入帐号密码，\n\n   ![1531571702986](137)\n\n   点击登录，\n\n   ![1531571821435](138)\n\n6. 我们打开一个新的浏览器，在浏览器地址栏中直接手动输入后台博文管理系统列表页链接地址，发现，在没有登录的情况下都能直接访问，\n\n   ![1531571967694](140)\n\n   这种效果就是翻墙效果。\n\n\n\n那么，如何实现防翻墙呢？\n\n\n\n### 防翻墙功能\n\n1. 在blog31/app/admin/controller/LoginController.class.php中的loginh方法里，登陆成功时记录下登陆用户的完整信息，\n\n   ![1531572176835](141)\n\n2. 在父类控制器blog31/core/Controller.class.php中的构造方法里，进行防翻墙检查，\n\n   ![1531572269068](142)\n\n3. 测试防翻墙效果：\n\n   首先在未登录的情况下直接访问后台博文列表页，经过防翻墙处理，已经不能直接访问进去了：\n\n   ![1531572402694](143)\n\n   然后使用帐号密码登录后台，\n\n   ![1531572604535](145)\n\n   登陆成功后提示：\n\n   ![1531572625978](146)\n\n   登陆成功后再同一个浏览器中打开一个新的浏览器选项卡，直接在地址栏中输入后台博文管理系统列表页链接地址，\n\n   ![1531572685648](147)\n\n\n\n### 7天免登录\n\n\n\n\n\n## 3. 实现后台退出功能\n\n\n\n\n\n## 4. 全天总结","categories":["博客项目"]},{"title":"表单传值和文件上传","url":"%2Fposts%2F2418534610%2F","content":"\n\n\n# ==表单传值==\n\n\n### 课前补充\n\n==**提问**==：\n\n1. html后缀文件由谁进行解析？\n2. php后缀文件又由谁进行解析?\n3. html后缀文件中如果包含php代码，访问该html文件，php代码是否会被解析执行？\n4. php后缀文件中如果包含html代码，访问该php文件，html代码是否会被解析执行？\n\n**==解答==**：\n\n1. html后缀文件的内容只会被浏览器解析；\n2. php后缀文件的内容只会被服务器的php模块解析；\n3. php代码不会被解析，因为默认情况下，服务器会将html后缀文件的内容全部当成普通字符串返回给浏览器，而浏览器只会解析html的标签内容，不会解析php源代码，所以php内容不会被解析。\n4. html代码在服务器端不会被解析，只会原样返回给浏览器，但是返回给浏览器之后，将会被浏览器解析；\n\n\n\n==**浏览器与服务交互流程分析**==\n\n```sequence\n浏览器-->服务器:请求\\nhttp://www.xxx.com/a.html\nnote right of 服务器: a.html<?php \\necho 123;\\n?>\\n<html>\\n<body>\\nHow are u\\n<ahref=“http://www.xxx.com/b.php”>\\n跳转\\n</a>\\n</body>\\n</html>\n服务器-->浏览器:响应\\n<?php echo 123;?>\\n<html><body>\\nHow are u\\n<a href=“http://www.xxx.com/b.php”>\\n跳转\\n</a>\\n</body></html>\nnote left of 浏览器: <?php echo 123;?>\\n<html>\\n<body>\\nHow are u\\n<a href=“http://www.xxx.com/b.php”>\\n跳转\\n</a>\\n</body>\\n</html>\n浏览器-->服务器:点击a链接\\n发出新的请求\\nhttp://www.xxx.com/b.php\nnote right of 服务器:b.php\\n<?php \\necho 123;\\n?>\\n<html>\\n<body>\\nHow are u\\n</body>\\n</html>\n服务器-->浏览器:响应\\n123\\n<html><body>\\nHow are u\\n</body></html>\nnote left of 浏览器:123\\n<html><body>\\nHow are u\\n</body></html>\n```\n\n\n## 1. 表单传值的概念\n\n### 为什么使用表单传值\n\n绝大部分的网站几乎都拥有==登陆或注册==页面，并且也都拥有录入信息的后台。\n\n比如我们在网站的登陆页面或注册页面填写信息提交后，填写的信息之所以能够传递到服务器，就是因为网站的页面中使用了表单传值；\n\n\n\n### 什么是表单传值\n\n概念：表单传值指的是通过==表单==构建数据，传递给服务器。 \n\n\n\n## 2. ==表单传值的方式==\n\n表单传值的方式包含两种：\n\n- [ ] POST方式\n- [ ] GET方式\n\n\n\n### POST方式\n\n**==需求==**：使用POST方式实现一个会员注册页面，包含帐号，密码两个填写项。\n\n**==解答==**：构建一个名为code1.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>POST方式</title>\n</head>\n<body>\n\t<!-- 1. method必须指定为post才是POST方式 -->\n\t<!-- 2. action是控制之后表单中填写的数据将会被提交到哪个指定的页面中去（必须项） -->\n\t<form method=\"post\" action=\"\">\n\t\t<p>\n\t\t\t<span>帐号：</span>\n            <!-- 3. name属性的作用是指定之后程序页面接收该表单数据的名称（必须项） -->\n\t\t\t<input type=\"text\" name=\"acc\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>密码：</span>\n\t\t\t<input type=\"text\" name=\"pwd\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"注册\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n\n\n### GET方式\n\n==**需求**==：使用GET方式实现一个会员注册页面，包含帐号，密码两个填写项。\n\n**==解答==**：构建一个名为code2.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>GET方式</title>\n</head>\n<body>\n\t<!-- 1. method必须指定为get才是GET方式 -->\n\t<!-- 2. action是控制之后表单中填写的数据将会被提交到哪个指定的页面中去（必须项） -->\n\t<form method=\"get\" action=\"\">\n\t\t<p>\n\t\t\t<span>帐号：</span>\n\t\t\t<!-- 3. name属性的作用是指定之后程序页面接收该表单数据的名称（必须项） -->\n\t\t\t<input type=\"text\" name=\"acc\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>密码：</span>\n\t\t\t<input type=\"text\" name=\"pwd\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"注册\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n\n\n### 小结\n\n表单传值的方式包括两种：1)POST方式；2）GET方式\n\n表单传值的方式指的是：表单传递数据的方法；\n\n\n\n==**提问**==：有传递就则必定有接收，通过表单传递方式传递出去的数据，在服务器端的PHP程序页面需要如何接收呢？\n\n## 3. ==PHP接收数据的方式==\n\nPHP接收数据的方式包含三种：\n\n- [x] $_POST方式\n- [x] $_GET方式\n- [x] $_REQUEST方式\n\n\n\n### $\\_POST方式\n\n$_POST作用：==只==接收POST方式传递的数据。\n\n\n\n**==需求==**：使用POST方式实现一个会员注册表单页面，包含帐号，密码两个填写项，同时实现在程序页面中使用$\\_POST和$\\_GET接收并输出表单页面提交传递的数据。\n\n**==解答==**：\n\n第一步，构建一个名为code3.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>$_POST接收数据</title>\n</head>\n<body>\n\t<form method=\"post\" action=\"http://www.home.com/class/day1/code/code4.php\">\n\t\t<p>\n\t\t\t<span>帐号：</span>\n\t\t\t<input type=\"text\" name=\"acc\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>密码：</span>\n\t\t\t<input type=\"text\" name=\"pwd\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"注册\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n第二步，构建名为code4.php的程序处理页面，代码如下\n\n```php\n<?php\n\n//输出$_POST接收的数据\nvar_dump( $_POST ); \necho '<hr/>';\n//输出$_GET接收的数据\nvar_dump( $_GET ); \n```\n\n第三步，访问code3.html页面，填写注册数据，\n\n![1529633597332](4.png)\n\n第四步，点击提交按钮，查看最终提交后的效果，\n\n![1529633662124](5.png)\n\n**==小结==**：\n\n$_POST只会接收POST方式传递过来的数据，不会接收GET方式传递过来的数据。\n\n\n\n### $_GET方式\n\n作用：==只==接收GET方式传递的数据。\n\n\n\n**==需求==**：使用GET方式实现一个会员注册表单页面，包含帐号，密码两个填写项，同时实现在程序页面中使用$\\_GET和$\\_POST接收并输出表单页面提交传递的数据。\n\n**==解答==**：\n\n第一步，构建一个名为code5.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>$_GET接收数据</title>\n</head>\n<body>\n\t<form method=\"get\" action=\"http://www.home.com/class/day1/code/code6.php\">\n\t\t<p>\n\t\t\t<span>帐号：</span>\n\t\t\t<input type=\"text\" name=\"acc\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>密码：</span>\n\t\t\t<input type=\"text\" name=\"pwd\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"注册\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n第二步，构建名为code6.php的程序处理页面，代码如下\n\n```php\n<?php\n\n//输出$_POST接收的数据\nvar_dump( $_POST ); \necho '<hr/>';\n//输出$_GET接收的数据\nvar_dump( $_GET ); \n```\n\n第三步，访问code5.html页面，填写注册数据，\n\n![1529633851377](6.png)\n\n第四步，点击提交按钮，查看最终提交后的效果，\n\n![1529633891528](7.png)\n\n**==小结==**：\n\n$_GET只会接收GET方式传递过来的数据，不会接收POST方式传递过来的数据。\n\n\n\n#### 表单传值GET方式的核心特征\n\n使用GET方式传递数据时，提交后的链接地址的格式比较特殊，这个固定格式的链接地址就是GET方式提交数据的核心特征。\n\n\n\n==GET方式核心特征格式说明==：\n\n```\n以如下链接地址为例：\nhttp://www.home.com/class/day1/code/code6.php?acc=lisi&pwd=123aaa\n\n1. 该链接地址中 “http://www.home.com/class/day1/code/code6.php”是URL链接地址；\n2. “?acc=lisi&pwd=123aaa”这个部分是get方式提交的表单数据;\n```\n\n在这个数据中==“?==”问号的作用是==专门用来分隔URL链接地址和get参数数据==的；\n\n在这个数据中==\"&\"==符号的作用是==专门用来分隔get参数数据与数据==的；\n\n\n\n### $_REQUEST方式\n\n作用：同时包含$\\_POST，$\\_GET和$\\_COOKIE的数据。\n\n\n\n**==需求==**：\n\n1. 在一个form表单中同时使用POST方式和GET方式实现表单传值，其中POST方式传递帐号和密码两个需要填写的数据，GET方式固定传递国籍country=china数据；\n2. 实现在程序页面中使用$\\_GET、$\\_POST和$\\_REQUEST接收并输出表单页面提交传递的数据。\n\n**==解答==**：\n\n第一步，构建一个名为code7.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>$_REQUEST接收数据</title>\n</head>\n<body>\n\t<!-- 1. 指定method为post意味着之后在表单中填写的帐号和密码数据将会以POST方式进行提交和传递 -->\n\t<!-- 2. 在URL链接地址后面使用”?country=china“这种方式意味着还将同时以GET方式传递一个country国籍数据，值为china -->\n\t<form method=\"post\" action=\"http://www.home.com/class/day1/code/code8.php?country=china\">\n\t\t<p>\n\t\t\t<span>帐号：</span>\n\t\t\t<input type=\"text\" name=\"acc\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>密码：</span>\n\t\t\t<input type=\"text\" name=\"pwd\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"注册\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n第二步，构建名为code8.php的程序处理页面，代码如下\n\n```php\n<?php\n\n//输出$_POST接收的数据\necho '$_POST: <br/>'; \nvar_dump( $_POST ); \necho '<hr/>';\n//输出$_GET接收的数据\necho '$_GET: <br/>'; \nvar_dump( $_GET ); \necho '<hr/>';\n//输出$_REQUEST接收的数据\necho '$_REQUEST: <br/>'; \nvar_dump( $_REQUEST ); \n```\n\n第三步，访问code7.html页面，填写注册数据，\n\n![1529634896220](8.png)\n\n第四步，点击提交按钮，查看最终提交后的效果，\n\n![1529634934372](9.png)\n\n**==小结==**：\n\n$_REQUEST同时包含$\\_POST和$\\_GET的元素数据；\n\n\n\n==**提问**==：$\\_REQUEST即包含$_POST元素数据，又包含$\\_GET元素数据，那么当$\\_POST与$\\_GET存在下标同名的元素时，$\\_REQUET将会选择谁的数据作为最终值？\n\n解答：默认情况下，$_REQUEST将会采用$\\_POST的值作为冲突时的最终值；但是，我们还可以通过php的配置文件修改$\\_REUQEST最终采用谁的值。\n\n\n\n修改的方式和修改后的效果如下：\n\n第一步，打开php.ini配置文件，找到request_order配置项，如下图所示\n\n![1529635585858](10.png)\n\n第二步，修改配置项的值为\"PG\"\n\n![1529635627788](11.png)\n\n第三步，重启apache，再次进行测试\n\n![1529635736512](12.png)\n\n![1529635815366](13.png)\n\n\n\n\n\n## 4. ==POST方式与GET方式的区别==\n\n无论是POST方式，还是GET方式，都属于表单传值。而表单传值的最终目的就是构建数据传输给服务器，这也就意味着POST方式和GET方式都能用来==传输数据给服务器==。\n\n那么既然存在两种方式，我们在实际应用中应该如何来选择使用呢？\n\n为此，我们需要进一步学习POST方式与GET方式之间的区别。POST方式与GET方式主要区别有四点：\n\n\n\n- GET方式具有可见性，而POST方式不具有可见性；\n- 基于第一点，POST方式在安全性上比GET方式要高一些；\n- 在传输的数据量上，POST方式==可能==比GET方式要大；\n- 在支持的数据类型上，==GET方式仅支持ASCII码==数据类型，POST方式无限制；\n\n\n\n以上四点主要区别，无一例外，都说明了理论上POST方式比GET方式好，而在实际的使用中，我们在构建form表单时，method通常都是被指定为post方式。\n\n\n\n==**提问**==：既然POST方式比GET方式优越，为什么还会有GET方式呢？\n\n## 5. GET方式核心特征的应用\n\n#### 指定a标签的href属性\n\n**==需求==**：构建分类列表页，实现点击每个分类都将跳转到同一个页面，但是最终将会输出与点击的分类相关的产品信息。\n\n**==解答==**：\n\n第一步，构建一个名为code9.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>指定a标签的href属性</title>\n</head>\n<body>\n\t<!-- 在URL链接地址后面使用GET方式的核心特征拼接携带get方式传递的参数数据type值 -->\n\t<a href=\"http://www.home.com/class/day1/code/code10.php?type=1\">连衣裙</a>\n\t<a href=\"http://www.home.com/class/day1/code/code10.php?type=2\">半身裙</a>\n\t<a href=\"http://www.home.com/class/day1/code/code10.php?type=3\">xuyue裙</a>\n</body>\n</HTML>\n```\n\n第二步，构建名为code10.php的程序处理页面，代码如下\n\n```php\n<?php\n\nvar_dump( $_GET ); echo '<br/>';\nvar_dump( $_GET['type'] ); echo '<hr/>';\n\n//根据get方式传递的type值，判断究竟是哪一种分类，然后输出不同分类下的产品信息\nif( $_GET['type']==1 ){\n    echo '<span>连衣裙1</span><br/>'; \n    echo '<span>连衣裙2</span><br/>'; \n    echo '<span>连衣裙3</span><br/>'; \n}elseif( $_GET['type']==2 ){\n    echo '<span>半身裙1</span><br/>'; \n    echo '<span>半身裙2</span><br/>'; \n    echo '<span>半身裙3</span><br/>'; \n}elseif( $_GET['type']==3 ){\n    echo '<span>xuyue裙1</span><br/>'; \n    echo '<span>xuyue裙2</span><br/>'; \n    echo '<span>xuyue裙3</span><br/>'; \n}\n```\n\n第三步，访问code9.html，点击不同的分类，查看最终效果\n\n页面效果：\n\n![1529637998785](14.png)\n\n点击连衣裙之后的效果：\n\n![1529638039152](15.png)\n\n返回列表页，点击半身裙：\n\n![1529638071190](16.png)\n\n\n\n#### javascript中指定location对象的href属性\n\n**==需求==**：\n\n1. 构建商品购买页面，假设商品库存为100个，要求有填写购买数量的输入框和立即购买按钮；\n2. 在商品购买页面中需要实现当点击立即购买按钮时，会根据用户填写的商品购买数量进行判断，如果没有超出库存则允许购买，如果超出库存则给出提示且不允许购买；\n\n**==解答==**：\n\n第一步，构建一个名为code11.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>javascript中指定location对象的href属性</title>\n</head>\n<body>\n\t<span>商品购买数量：</span>\n\t<input type=\"text\" id='num' />\n\t<span>当前的库存为：100</span>\n\t<p>\n\t\t<button id=\"btn\">立即购买</button>\n\t</p>\n<script type=\"text/javascript\">\nvar totalNum = 100;//当前商品的库存数量\ndocument.getElementById('btn').onclick = function (){\n\n\tvar num = document.getElementById('num').value;//获取用户填写的购买数量\n\n\tif ( num>totalNum ){//给出提示，不进行跳转\n\t\n\t\talert('当前购买的数量超过了商品的库存数量，请重新输入购买数量！');\n\t}else{//跳转到目标程序页面，并且要携带上用户填写的购买数量\n\t\n\t\t//通过location对象的href属性，跳转到一个指定的链接地址\n\t\twindow.location.href = 'http://www.home.com/class/day1/code/code12.php?num='+num;\n\t}\n\n}\n</script>\n</body>\n</HTML>\n```\n\n第二步，构建名为code12.php的程序处理页面，代码如下\n\n```php\n<?php\n\n//输出接收到的get参数\necho '$_GET: <br/>'; \nvar_dump( $_GET );\n```\n\n第三步，访问code11.html，填写商品数量，测试使用效果，\n\n测试超出库存数量的情况：\n\n![1529639091747](17.png)\n\n测试没有超出库存数量的情况：\n\n填写数量\n\n![1529639133650](18.png)\n\n点击购买按钮后\n\n![1529639159131](19.png)\n\n\n\n**==小结==**：\n\n1. 如果使用form表单，则最佳的传输方式为post方式，所以通常指定method为post；\n2. 如果是通过链接跳转到另外一个页面的场景，或者是在跳转之前还需要做判断的场景，则利用GET方式的核心特征，使用a链接或者js代码的location对象href属性更佳；\n\n\n\n## 6. 单选按钮与复选框的处理\n\n在web项目中，我们经常会在表单页面构建一些统计选项，以便在后期实现对数据更加精准的定位。常用的统计选项如单选或多选，都是我们经常会用到的。\n\n在表单页面中单选使用的是单选按钮radio来实现的；多选使用的复选框checkbox来实现的。\n\n\n\n### 表单页面中的单选按钮\n\n**==需求==**：实现一个会员注册表单页面，包含帐号，密码和性别三个项，同时实现在程序页面中接收并输出表单页面提交传递的数据。\n\n**==解答==**：\n\n第一步，构建一个名为code13.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>表单页面中的单选按钮</title>\n</head>\n<body>\n\t<form method=\"post\" action=\"http://www.home.com/class/day1/code/code14.php\" >\n\t\t<p>\n\t\t\t<span>帐号：</span>\n\t\t\t<input type=\"text\" name=\"acc\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>密码：</span>\n\t\t\t<input type=\"password\" name=\"pwd\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>性别：</span>\n\t\t\t\t<!-- 如果要使用单选，则type值必须为radio，同时必须要设置name值和value值 -->\n\t\t\t男 <input type=\"radio\" name=\"sex\" value=\"male\" />\n\t\t\t女 <input type=\"radio\" name=\"sex\" value=\"female\"/>\n\t\t\t保密 <input type=\"radio\" name=\"sex\" value=\"secret\"/>\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"立即注册\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n第二步，构建名为code14.php的程序处理页面，代码如下\n\n```php\n<?php\n\n//输出接收到的post参数\necho '$_POST: <br/>'; \nvar_dump( $_POST );\n```\n\n第三步，访问code13.html页面，填写注册数据，\n\n![1529639961420](20.png)\n\n第四步，点击提交按钮，查看最终提交后的效果，\n\n![1529639979205](21.png)\n\n**==小结==**：\n\n单选按钮type值必须为radio.\n\n### 表单页面中的复选框\n\n**==需求==**：实现一个运动网站会员注册表单页面，包含帐号，密码和爱好三个项，其中爱好是多选选项，同时实现在程序页面中接收并输出表单页面提交传递的数据。\n\n**==解答==**：\n\n第一步，构建一个名为code15.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>表单页面中的复选框</title>\n</head>\n<body>\n\t<form method=\"post\" action=\"http://www.home.com/class/day1/code/code16.php\" >\n\t\t<p>\n\t\t\t<span>帐号：</span>\n\t\t\t<input type=\"text\" name=\"acc\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>密码：</span>\n\t\t\t<input type=\"password\" name=\"pwd\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>爱好：</span>\n\t\t\t<!-- 1.如果要指定为多选，则type值必须为checkbox -->\n\t\t\t<!-- 2.name和value值必须要指定 -->\n\t\t\t<!-- 3.必须在指定的name值后面加上中括号，否则提交的数据将会形成覆盖 -->\n\t\t\t足球 <input type=\"checkbox\" name=\"hobbies[]\" value=\"football\" />\n\t\t\t篮球 <input type=\"checkbox\" name=\"hobbies[]\" value=\"basketball\"/>\n\t\t\t乒乓球 <input type=\"checkbox\" name=\"hobbies[]\" value=\"pingpang\"/>\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"立即注册\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n第二步，构建名为code16.php的程序处理页面，代码如下\n\n```php\n<?php\n\n//输出接收到的post参数\necho '$_POST: <br/>'; \necho '<pre>';\nvar_dump( $_POST );\n```\n\n第三步，访问code15.html页面，填写注册数据，\n\n![1529649688583](22.png)\n\n第四步，点击提交按钮，查看最终提交后的效果，\n\n![1529649737602](23.png)\n\n\n\n**==小结==**：\n\n如果要构建复选框，则:\n\n1. type值必须为checkbox;\n2. name值和value值必须指定上；\n3. name值需要加上“[]”中括号这个符号，否则将会形成数据的覆盖；\n\n\n\n#  ==文件上传==\n\n### 文件上传的概念\n\n#### 为什么使用文件上传\n\n在web领域，文件上传的应用非常广泛。如上传头像，上传证件照，上传报表文件等，都需要用到文件上传技术。\n\n\n\n#### 什么是文件上传\n\n概念：文件上传指的是将文件从本地传输到指定的服务器。\n\n\n\n==**提问**==：将文件从本地传输到服务器，从实现的角度来看是一个什么样的过程呢？\n\n#### 文件上传的实现思路\n\n![1529651142445](24.png)\n\n\n\n### 文件上传核心步骤\n\n**==需求==**：根据文件上传的3步思路，实现注册页面头像图片上传页面及功能。\n\n**==解答==**：\n\n第一步，构建一个名为code17.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>文件上传核心步骤</title>\n</head>\n<body>\n\t<!-- 1. 如果要实现文件上传，method必须为post -->\n\t<!-- 2. form标签必须包含enctype属性，并且值必须固定为:multipart/form-data -->\n\t<form method=\"post\" action=\"http://www.home.com/class/day1/code/code18.php\" enctype=\"multipart/form-data\">\n\t\t<p>\n\t\t\t<span>帐号：</span>\n\t\t\t<input type=\"text\" name=\"acc\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>密码：</span>\n\t\t\t<input type=\"password\" name=\"pwd\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>头像：</span>\n\t\t\t<!-- 3. 文件上传域type值必须为file； -->\n\t\t\t<!-- 4. 必须为文件上传域指定name属性值； -->\n\t\t\t<input type=\"file\" name=\"headimg\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"立即注册\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n第二步，构建名为code17.php的程序处理页面，代码如下\n\n```php\n<?php\n\n//输出接收到的post参数\necho '$_POST: <br/>'; \necho '<pre>';\nvar_dump( $_POST );\necho '<hr/>';\necho '$_FILES：<br/>';\nprint_r( $_FILES ); \n\necho '<hr/>';\nvar_dump( $_FILES['headimg']['tmp_name'] ); \necho '<hr/>';\n\n//转移临时文件到指定的目录中去\n//参数一： 源文件，即 存储在临时目录中的文件全路径（包含文件路径部分和文件名部分）\n//参数二： 目标文件，即 转移文件的目标目录路径位置，同时需要将新的文件名指定上\n$re = move_uploaded_file($_FILES['headimg']['tmp_name'], './2.png');\nvar_dump( $re ); \n```\n\n第三步，访问code17.html页面，选定图片文件，\n\n![1529652806589](25.png)\n\n第四步，点击提交按钮，查看最终提交后的效果，\n\n```\n####输出到浏览器的内容\n$_POST: \narray(2) {                 //post方式接收到的表单数据\n  [\"acc\"]=>\n  string(8) \"zhangsan\"\n  [\"pwd\"]=>\n  string(6) \"112233\"\n}\n$_FILES：                 //接收到的表单文件数据\nArray\n(\n    [headimg] => Array\n        (\n            [name] => 2.png           \t\t\t\t\t//原始文件名\n            [type] => image/png\t\t\t\t\t\t\t//文件所属格式类型\n            [tmp_name] => C:\\Windows\\Temp\\php8DAB.tmp\t//文件存储在临时目录中的全路径名\n            [error] => 0\t\t\t\t\t\t\t\t//文件上传时的错误码值\n            [size] => 37143\t\t\t\t\t\t\t\t//文件的大小，单位字节\n        )\n\n)\nstring(27) \"C:\\Windows\\Temp\\php8DAB.tmp\"\t//提取的文件存储在临时目录中的全路径名\nbool(true)\t\t//move_uploaded_file函数的返回值，为true,说明文件上传成功\n```\n\n**==小结==**：\n\n1. 如果要实现文件上传，form的method属性必须为**post**；\n2. form标签必须包含enctype属性，并且值必须固定为:**multipart/form-data**；\n3. 文件上传域type值必须为**file**；\n4. 必须为文件上传域指定**name属性值**；\n5. 在PHP程序中，由**$_FILES**负责接收上传的文件数据；\n\n\n\n==**提问**==：网站项目中，实现文件上传的页面只会支持上传一个文件吗？\n\n#### 多文件上传\n\n在web项目中，实现文件上传的页面时常会包含多个文件。\n\n比如家装公司的效果图网站，一个房子内部的效果图不止一张，可能会包含多张，比如会分成客厅效果图，卧室效果图，玄关效果图，厨房效果图等等，那么，在上传文件时就需要支持多文件上传的功能了。\n\n\n\n在PHP中我们把多文件上传分成两类：\n\n- [x] 不同名多文件的上传\n- [x] 同名多文件的上传\n\n\n\n##### 不同名多文件的上传\n\n我们以家装公司的效果图网站来举一个例子。\n\n\n\n**==需求==**：\n\n1. 实现一个家装公司效果图网站的图片上传表单页面，包含客厅效果图，卧室效果图两个文件上传域；\n2. 实现文件上传的程序处理功能。\n\n**==解答==**：\n\n第一步，构建一个名为code19.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>不同名多文件的上传</title>\n</head>\n<body>\n\t<form method=\"post\" action=\"http://www.home.com/class/day1/code/code20.php\" enctype=\"multipart/form-data\" >\n\t\t<p>\n\t\t\t<span>客厅效果图：</span>\n\t\t\t<input type=\"file\" name=\"keting\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>卧室效果图：</span>\n\t\t\t<input type=\"file\" name=\"woshi\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"立即提交\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n第二步，构建名为code20.php的程序处理页面，代码如下\n\n```php\n<?php\n\n//输出$_FILES\necho '$_FILES：<br/>';\necho '<pre>';\nprint_r( $_FILES ); echo '<hr/>';\n\n\n//转移临时文件到指定的目录中去\nforeach( $_FILES as $file ){ //遍历$_FILES，$_FILES有几个元素，就意味着上传了几个文件\n    var_dump( $file ); echo '<br/>';\n    //转移当前这个文件，从临时目录中转移到指定的目录中去，并且还要重命名\n    $newFileName = './' . $file['name'];//为当前文件重命名，重命名为当前原始文件的名字\n    $re = move_uploaded_file($file['tmp_name'], $newFileName);\n    var_dump( $re );echo '<hr/>'; \n}\n```\n\n第三步，访问code19.html页面，选定图片文件，\n\n![1529654942403](26.png)\n\n第四步，点击提交按钮，查看最终提交后的效果，\n\n```\n####浏览器输出的信息如下\n$_FILES：\nArray            //$_FILES接收到的文件信息\n(\n    [keting] => Array     //第一个效果图客厅的图片文件信息\n        (\n            [name] => 27.jpg\n            [type] => image/jpeg\n            [tmp_name] => C:\\Windows\\Temp\\php3FC5.tmp\n            [error] => 0\n            [size] => 459695\n        )\n\n    [woshi] => Array\t\t//第二个效果图卧室的图片文件信息\n        (\n            [name] => 50ab616773400.jpg\n            [type] => image/jpeg\n            [tmp_name] => C:\\Windows\\Temp\\php3FD5.tmp\n            [error] => 0\n            [size] => 211851\n        )\n\n)\n\narray(5) {\t//在foreach遍历中输出的第一个效果图客厅的图片文件信息\n  [\"name\"]=>\n  string(6) \"27.jpg\"\n  [\"type\"]=>\n  string(10) \"image/jpeg\"\n  [\"tmp_name\"]=>\n  string(27) \"C:\\Windows\\Temp\\php3FC5.tmp\"\n  [\"error\"]=>\n  int(0)\n  [\"size\"]=>\n  int(459695)\n}\n\nbool(true)\t//表示第一张图片文件上传成功\n\narray(5) {//在foreach遍历中输出的第二个效果图卧室的图片文件信息\n  [\"name\"]=>\n  string(17) \"50ab616773400.jpg\"\n  [\"type\"]=>\n  string(10) \"image/jpeg\"\n  [\"tmp_name\"]=>\n  string(27) \"C:\\Windows\\Temp\\php3FD5.tmp\"\n  [\"error\"]=>\n  int(0)\n  [\"size\"]=>\n  int(211851)\n}\n\nbool(true)\t//表示第二张图片文件上传成功\n```\n\n**==小结==**：\n\n不同名多文件上传时$_FILES的结构为如下所示，每个文件都固定包含5个元素的信息，\n\n```\nArray\n(\n    [headimg] => Array\n        (\n            [name] => xx.xxxx           \t\t\t\t//原始文件名\n            [type] => xxx/xxx\t\t\t\t\t\t\t//文件所属格式类型\n            [tmp_name] => C:\\Windows\\Temp\\xxx.tmp\t\t//文件存储在临时目录中的全路径名\n            [error] => 整型数值\t\t\t\t\t\t\t//文件上传时的错误码值\n            [size] => 整型数值\t\t\t\t\t\t\t//文件的大小，单位字节\n        )\n\n)\n```\n\n\n\n##### 同名多文件的上传\n\n我们以证件审核网站来举一个例子。\n\n\n\n**==需求==**：\n\n1. 实现一个证件审核网站的身份证正反两面图片上传表单页面；\n2. 实现文件上传的程序处理功能。\n\n**==解答==**：\n\n第一步，构建一个名为code21.html的页面，代码如下\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>同名多文件的上传</title>\n</head>\n<body>\n\t<form method=\"post\" action=\"http://www.home.com/class/day1/code/code22.php\" enctype=\"multipart/form-data\" >\n\t\t<p>\n\t\t\t<span>身份证正面照：</span>\n\t\t\t<!-- 同名多文件上传的表单域同名name值后面必须加上\"[]\"中括号 -->\n\t\t\t<input type=\"file\" name=\"idcard[]\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<span>身份证反面照：</span>\n\t\t\t<input type=\"file\" name=\"idcard[]\" />\n\t\t</p>\n\t\t<p>\n\t\t\t<input type=\"submit\" value=\"立即提交\" />\n\t\t</p>\n\t</form>\n</body>\n</HTML>\n```\n\n第二步，构建名为code22.php的程序处理页面，代码如下\n\n```php\n<?php\n\n//输出$_FILES\necho '$_FILES：<br/>';\necho '<pre>';\nprint_r( $_FILES ); echo '<hr/>';echo '<hr/>';//输出$_FILES全部的信息\n\n\n//转移临时文件到指定的目录中去\n//遍历name元素的值，name元素有两个值，第一个值下标为0，表示第一个文件的原始文件名信息；第二个值下标为1，表示第二个文件的原始文件名信息；\nforeach( $_FILES['idcard']['name'] as $name_key=>$name ){ \n    echo 'name_key：'; \n    var_dump( $name_key ); echo '<br/>';//输出name元素的下标值\n    echo 'name：'; \n    var_dump( $name ); //输出name元素下标对应的值信息\n    echo 'tmp_name：'; \n    var_dump( $_FILES['idcard']['tmp_name'][$name_key] ); //利用name和tmp_name元素下标通用的特性，取得tmp_name元素下标对应的值信息\n\n    $newFileName = './'.$name;//构建新的文件名\n    $re = move_uploaded_file($_FILES['idcard']['tmp_name'][$name_key], $newFileName);//转移当前文件到指定的位置\n    var_dump( $re );     echo '<hr/>';\n}\n\n```\n\n第三步，访问code21.html页面，选定图片文件，\n\n![1529657040416](27.png)\n\n第四步，点击提交按钮，查看最终提交后的效果，\n\n```\n####在浏览器中输出的信息\n$_FILES：\nArray\t\t//$_FILES的信息\n(\n    [idcard] => Array\n        (\n            [name] => Array\n                (\n                    [0] => 50ab616773400.jpg\n                    [1] => 001.jpg\n                )\n            [type] => Array\n                (\n                    [0] => image/jpeg\n                    [1] => image/jpeg\n                )\n            [tmp_name] => Array\n                (\n                    [0] => C:\\Windows\\Temp\\php6874.tmp\n                    [1] => C:\\Windows\\Temp\\php6885.tmp\n                )\n            [error] => Array\n                (\n                    [0] => 0\n                    [1] => 0\n                )\n            [size] => Array\n                (\n                    [0] => 211851\n                    [1] => 109140\n                )\n        )\n)\n\nname_key：int(0)\t//遍历得到的第一个name元素的下标值\n\nname：string(17) \"50ab616773400.jpg\" \t//遍历得到的第一个name下标对应的值信息，即第一张图的原始文件名信息\ntmp_name：string(27) \"C:\\Windows\\Temp\\php6874.tmp\"\t//遍历得到的第一个tmp_name下标对应的值信息，即第一张图存储在临时目录的全路径信息\nbool(true)  //表示第一张图片上传成功\n\nname_key：int(1)\t//遍历得到的第二个name元素的下标值\n\nname：string(7) \"001.jpg\"\t//遍历得到的第二个name下标对应的值信息，即第二张图的原始文件名信息\ntmp_name：string(27) \"C:\\Windows\\Temp\\php6885.tmp\"\t//遍历得到的第二个tmp_name下标对应的值信息，即第二张图存储在临时目录的全路径信息\nbool(true)\t//表示第二张图片上传成功\n```\n\n**==小结==**：\n\n在同名多文件上传时，$_FILES结构如下图所示\n\n```\n$_FILES：\nArray\n(\n    [idcard] => Array\n        (\n            [name] => Array\t//文件的原始名称信息\n                (\n                    [0] => 50ab616773400.jpg\t//第一个文件的原始文件name信息\n                    [1] => 001.jpg\t\t\t\t//第二个文件的原始文件name信息\n                )\n            [type] => Array\t//文件的格式类型信息\n                (\n                    [0] => image/jpeg\t//第一个文件的格式类型type信息\n                    [1] => image/jpeg\t//第二个文件的格式类型type信息\n                )\n            [tmp_name] => Array\t//文件存放在临时目录下的全路径信息\n                (\n                    [0] => C:\\Windows\\Temp\\php3CEC.tmp\t//第一个文件存放在临时目录下的全路径tmp_name信息\n                    [1] => C:\\Windows\\Temp\\php3CED.tmp\t//第二个文件存放在临时目录下的全路径tmp_name信息\n                )\n            [error] => Array\t//文件上传时的错误码值信息\n                (\n                    [0] => 0\t//第一个文件上传时的错误码值error信息\n                    [1] => 0\t//第二个文件上传时的错误码值error信息\n                )\n            [size] => Array\t\t//文件的大小信息\n                (\n                    [0] => 211851\t//第一个文件的大小size信息\n                    [1] => 109140\t//第二个文件的大小size信息\n                )\n        )\n)\n```\n\n\n\n#### 案例：封装文件上传函数\n\n在web网站中，文件上传功能不可或缺，但是并不是每一个页面都需要文件上传功能。所以我们会将文件上传功能封装成函数，以便以后在项目中随用随取，而不需要每次都重复写相同的功能代码。\n\n\n\n##### error错误码值说明\n\n在手册中的位置：\n\n![1529565072550](2.png)![1529565094827](3.png)\n\n\n\n##### 功能分析\n\n1. 检查系统级别错误；\n2. 检查逻辑级别错误；\n3. 构建绝对不重复的文件名；\n4. 转移上传的文件到指定目录中；\n\n\n\n##### 代码实现\n\n以下是upfile.php封装的文件上传功能函数，具体的测试使用文件code23.html和code24.php\n\n```php\n/**\n * 功能：文件上传\n * @param  array   $file   上传文件包含的5个部分的信息\n        包含:\n        $file['name']             表示原始文件的文件名，如$file['name']='a.jpg';\n        $file['type']             表示文件的格式类型，如：$file['type']='image/jpeg'\n        $file['tmp_name']         表示文件存放在临时目录中的全路径，如：\n                                  $file['tmp_name']='C:/xxx/xxx/xx/tmp/xx.tmp';\n        $file['error']  表示文件上传时的错误码值，包含0，1，2，3，4，6，7\n                    \t\t\t\t0：表示没有任何错误\n                    \t\t\t\t1：表示上传的文件大小超过了系统的限定\n                    \t\t\t\t2：表示上传文件的大小超过了浏览器的限定\n                    \t\t\t\t3：表示只有部分文件被上传\n                   \t\t\t\t\t4：表示没有选择上传的文件\n                    \t\t\t\t6和7：表示服务器出现问题导致上传失败\n        $file['size']   表示源文件的大小，单位是字节\n */\nfunction upfile($file){ \n    #1.检查系统错误\n    switch ( $file['error'] ){\n        case 1:\n            echo '上传的文件大小超过了系统的限定'; \n        return false;\n        case 2:\n            echo '上传文件的大小超过了浏览器的限定'; \n        return false;\n        case 3:\n            echo '只有部分文件被上传'; \n        return false;\n        case 4:\n            echo '没有选择上传的文件'; \n        return false;\n        case 6:\n            case 7:\n            echo '服务器出现问题导致上传失败'; \n        return false;\n    }\n\n    #2.检查逻辑错误\n    //检查文件大小是否超出逻辑限定\n    $limitSize = 200 * 1024;//限定的大小为200KB\n    if( $file['size']>$limitSize ){//超出了限定的大小\n        echo '您上传的文件超过了限定的大小'.($limitSize/1024).'KB'; \n        return false;\n    }\n\n    //检查文件的格式类型是否在允许的范围内\n    $limitType = ['image/jpeg', 'image/png'];\n    if( !in_array($file['type'], $limitType) ){//上传的文件格式类型不在允许的范围内\n        echo '您上传的文件格式类型不正确，请重新选择上传的文件！'; \n        return false;\n    }\n\n    #3.构建绝对不重复的文件名\n    //(strchr)strstr — 查找字符串的首次出现\n    //返回 字符串中从指定字符 第一次出现的位置开始到结尾的字符串。 \n    $newFileName = uniqid('img_') . date('YmdHis') . mt_rand(0, 10000) . strchr($file['name'], '.');//构建绝对不重复的文件名，文件后缀保持和源文件名一致\n    $path = './';//定义文件的保存路径\n    $wholeFileName = $path . $newFileName;//拼接完整的文件全路径\n\n    #4.转移文件到指定的目录中\n    if( move_uploaded_file($file['tmp_name'], $wholeFileName) ){//文件上传成功\n        echo '文件上传成功！'; \n        return true;\n    }else{//文件上传失败\n        echo '文件上传失败'; \n        return false;\n    }\n}\n```\n\n\n\n## 8. 全天总结\n\n1. 表单传值的方式：POST方式和GET方式；\n\n2. PHP接收表单数据的方式：1）$_POST; 2)$\\_GET；3）$\\_REQUEST;\n\n3. GET方式的核心特征：在URL链接地址后面可以通过固定的格式拼接GET参数数据，其中?是用来分隔链接地址和GET参数数据的，&符号是用来分隔GET参数数据与数据的；\n\n4. POST方式与GET方式的区别：\n\n   a) GET方式具有可见性；\n\n   b) POST方式比GET方式相对安全；\n\n   c) POST方式传递的数据量==可能==比GET方式要大；\n\n   d) GET方式只支持ASCII码数据类型，POST方式无限制；\n\n5. 文件上传核心三步\n\n   a) 构建上传界面；\n\n   b) $_FILES接收文件数据；\n\n   c) move_uploaded_file函数转移文件\n\n6. $_FILES保存的文件数据包含几个部分的内容：\n\n   a) name表示源文件名\n\n   b) type表示文件的格式类型\n\n   c) tmp_name表示存储在临时目录下的文件全路径\n\n   d) error表示上传时出现的错误码值\n\n   e) size表示上传文件的大小\n\n7. 如果要构建一个表单的注册页面，包含帐号，密码，性别，爱好和头像文件上传域，则form表单应该如何构建\n\n```html\n<form method=\"post\" action=\"http://xxx.xx.com/xx.php\" enctype=\"multipart/form-data\">\n    <p>\n        <span>帐号：</span>\n        <input type=\"text\" name=\"acc\" />\n    </p>\n    <p>\n        <span>密码：</span>\n        <input type=\"password\" name=\"pwd\" />\n    </p>\n    <p>\n        <span>性别：</span>\n        男<input type=\"radio\" name=\"sex\" value=\"male\" />\n        女<input type=\"radio\" name=\"sex\" value=\"female\"/>\n    </p>\n    <p>\n        <span>爱好：</span>\n        足球<input type=\"checkbox\" name=\"hobbies[]\" value=\"football\" />\n        篮球<input type=\"checkbox\" name=\"hobbies[]\" value=\"basketball\"/>\n    </p>\n    <p>\n        <span>头像：</span>\n        <input type=\"file\" name=\"img\" />\n    </p>\n    <p>\n        <input type=\"submit\" value=\"立即注册\" />\n    </p>\n</form>\n```\n\n\n\n#### 课后练习\n\n实现运动网站会员注册页面，要求：\n\n1. 表单页面包含帐号，密码，性别（男，女，保密），爱好（足球，篮球，乒乓球），头像；\n2. 程序页面输出表单页面提交传递的帐号，密码，性别，爱好信息；\n3. 程序页面还需要实现头像图片的上传功能，要求实现检查上传时系统错误，图片不能大于50K，格式只允许为jpeg或png；\n\n","categories":["表单传值和文件上传"]},{"title":"Smarty模板技术","url":"%2Fposts%2F3997252698%2F","content":"\n\n# SMARTY模板技术\n\n## 1. SMARTY模板技术基本概念\n\n### 为什么使用SMARTY模板技术\n\n在web项目开发中，程序通常可以分为html模板页面和php程序页面，理想状态下，前端开发者负责编写html模板页面；而后台开发者负责编写php功能程序页面；\n\n```mermaid\ngraph LR\nA(前端开发) -->B(负责编写html页面和效果)\nC(后台开发) -->D(负责编写功能程序代码)\n```\n\n但是，由于长期以来html代码与php代码编写的特点，导致经常将html代码与php程序代码混合编写，这样的方式其实并不利于分工合作。\n\n比如当我需要对现有页面进行改版，前端人员由于不懂PHP程序，只能先写好HTML页面模板，再交给后台开发人员重复一次以前嵌套PHP程序的工作。\n\n \n\n而SMARTY模板技术，却很好的**将前端html代码与程序PHP代码进行的分离**，让前端开发者可以专心于开发前端的代码，而不必理会PHP程序；同时也让PHP程序开发者能够专注于PHP代码的构建，而不必为将数据嵌套进前端页面而烦恼。\n\n\n\n### 什么是SMARTY模板技术\n\nSMARTY模板技术**是众多模板技术中的一种**，而==模板技术==是一种==将HTML代码和PHP代码强制分离的模板机制==，它通过了某种方式让HTML代码与PHP代码在一起编写的过程中实现了强制分离。\n\n\n\n所以SMARTY模板技术也就是：**一种将HTML代码和PHP代码强制分离的模板机制。**\n\n\n\n### SMARTY模板技术的特点\n\nSMARTY模板技术的主要特点：\n\n> 1. smarty是一个基于PHP开发的PHP模板引擎，由于采用PHP编写，所以语法结构与PHP基本类似，语句比较自由；\n> 2. 相对其他的模板引擎，具有更快的响应速度（速度快）；\n> 3. Smarty插件非常灵活，可以任意的扩展；\n> 4. 也有==不适合使用Smarty的地方==，比如一些需要实时更新的项目（股票的走势），因为Smarty把数据都缓存起来了，没法实时更新！\n\n \n\n各框架和开源系统模板引擎使用一览：\n\n>  ThinkPHP框架（引入了模板引擎技术）\n>\n> CI、YII（引入了模板引擎技术）\n>\n> DEDECMS（引入了模板引擎技术）\n>\n> ECSHOP（引入了模板引擎技术，使用的就是smarty模板引擎）\n\n\n\n### SMARTY模板技术实现的基本原理\n\n**==需求==**：封装一个名为smarty1的类，实现通过该类展示模板页面并输出数据到页面的效果。\n\n**==解答==**：\n\n第一步，构建名为t1.html的程序文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n    <p>\n\t\t<span>标题：</span>{title}\n\t</p>\n\t<p>\n\t\t<span>作者：</span>{aa}\n\t</p>\n\t<p>\n\t\t<span>发布时间：</span>{date}\n\t</p>\n\t<p>\n\t\t{content}\n\t</p>\n</body>\n</HTML>\n```\n\n第二步，构建名为t1.php的程序文件，代码如下：\n\n```php\nclass Smarty1{\n\n    private $vars=array();\n\n    public function assign1($key, $value){ //负责将全局作用域中的数据转移到局部作用域中\n        \n        $this->vars[$key] = $value;\n    }\n\n    public function display1($file){ //负责渲染模板页面的\n\n\n        $content = file_get_contents($file);//读取html模板文件的内容\n\n        //$content = str_replace('{title}', $this->vars['title'], $content);//替换$content中所有title字符位置上的内容\n        //$content = str_replace('{aa}', $this->vars['aa'], $content);//替换$content中所有aa字符位置上的内容\n        //$content = str_replace('{date}', $this->vars['date'], $content);//替换$content中所有date字符位置上的内容\n        //$content = str_replace('{content}', $this->vars['content'], $content);//替换$content中所有date字符位置上的内容\n        foreach( $this->vars as $k=>$v ){ \n            \n            $search = '{' . $k . '}';\n            $content = str_replace($search, $v, $content);//替换模板中的占位符\n        }\n\n        echo $content; //输出模板文件的内容\n    }\n}\n\n$title = '劝学';\n$auth = '荀子';\n$date = '约公元前313年－公元前238年';\n\n$content = '故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。';\n\n#实例化Smarty1类的对象\n$smarty1 = new Smarty1;\n\n$smarty1->assign1('title', $title);//调用assign1方法将全局作用域中的$title变量的数据转移到局部作用域数组$vars属性中\n$smarty1->assign1('aa', $auth);//调用assign1方法将全局作用域中的$auth变量的数据转移到局部作用域数组$vars属性中\n$smarty1->assign1('date', $date);//调用assign1方法将全局作用域中的$date变量的数据转移到局部作用域数组$vars属性中\n$smarty1->assign1('content', $content);//调用assign1方法将全局作用域中的$content变量的数据转移到局部作用域数组$vars属性中\n\n\n$smarty1->display1('./t1.html');//调用display1方法展示（渲染）模板页面\n```\n\n\n\n**==小结==**：\n\n从演示的效果上来看，模板技术的实现就是：==读取==、==替换==和==输出==；\n\n\n\n## 2. ==SMARTY部署==\n\nSMARTY并不是PHP本身就自带的，在使用之前，需要先进行部署。\n\n\n\n**==步骤==**：\n\n第一步，下载SMARTY，www.smarty.cn下载SMARTY，解压，\n\n![1530932836313](3.png)\n\n第二步，在code目录下创建一个专有项目目录demo，\n\n![1530932944646](4.png)\n\n第三步，复制SMARTY核心类库目录libs，\n\n![1530932999781](5.png)\n\n转移粘贴到code/demo目录中，\n\n![1530933047032](6.png)\n\n将libs改名为smarty，\n\n![1530933077609](7.png)\n\n第四步，测试使用SMARTY，\n\n在code/demo目录中创建一个名为index1.php的程序文件，\n\n![1530933154106](8.png)\n\n在index1.php中构建如下代码：\n\n![1530933365685](9.png)\n\n访问index1.php程序文件，\n\n![1530933387977](10.png)\n\n当我们看到上图所示的输出内容，则说明SMARTY部署成功。\n\n\n\n==进一步测试使用SMARTY==\n\n第一步，在code/demo下创建templates目录，\n\n![1530933567428](11.png)\n\n第二步，将准备好的模板文件index.html拷贝到code/demo/templates目录中，\n\n![1530933630551](12.png)\n第三步，在code/demo目录下创建程序文件，index.php，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$title = '劝学';\n$auth = '荀子';\n$date = '约公元前313年－公元前238年';\n$content = '故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。';\n\n$smarty->assign('title', $title);//调用assign方法将全局作用域转移到局部作用域中，assign也被称为是分配模板变量的\n//第一个参数传递进去当作变量名，不包括$ ，但使用时要包括 $\n$smarty->assign('aa', $auth); \n$smarty->assign('date', $date);\n$smarty->assign('content', $content);\n\n\n$smarty->display('index.html');//渲染模板文件\n```\n\n修改code/demo/templates/index.html文件的内容，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n    <p>\n\t\t<span>标题：</span>{$title}\n\t</p>\n\n\t<p>\n\t\t<span>作者：</span>{$aa}\n\t</p>\n\n\t<p>\n\t\t<span>发布时间：</span>{$date}\n\t</p>\n\n\t<p>\n\t\t{$content}\n\t</p>\n</body>\n</HTML>\n```\n\n第四步，测试访问效果：\n\n![1530934209643](13.png)\n\n\n\n**==小结==**：\n\n在程序中使用SMARTY的基本步骤：\n\n1）引入SMARTY核心类文件；\n\n2）实例化一个基于Smarty类的对象；\n\n3）调用assign方法分配模板变量；\n\n4）调用display方法渲染模板；\n\n\n\n### SMARTY模板编译的原理\n\n当我们首次访问网站的某个页面时，SMARTY会自动在项目的smarty核心库目录同级的目录中创建一个名为templates_c的目录，这个目录存放的就是SMARTY的模板编译缓存文件。\n\n \n\nSMARTY有一个机制，如果第一次访问某个模板页面时，则会自动创建一个该模板页面对应的==编译缓存文件==；以后再来访问该页面，则SMARTY会判断该模板页面是否已经发生改变，如果没有发生改变，则直接去访问编译缓存文件，如果发现模板内容有被改变，则重新编译生一个新的缓存文件，覆盖老的缓存文件。\n\n\n\n**==测试1==**：测试首次访问一个模板页面，观察是否生成对应的编译缓存文件。\n\n![1530934608913](14.png)\n\n当我们首次访问时，确实在demo/templates_c目录中生成了一个新的文件。\n\n\n\n**==测试2==**：打开已经生成的编译缓存文件，输出\"哈哈\"，观察再次访问相同的页面时，是否会输出\"哈哈\"。\n\n![1530934844346](15.png)\n\n再次访问该页面，\n\n![1530934905253](16.png)\n\n说明再次访问该页面时，SMARTY将会自动去走缓存文件，而不会重新去编译Index.php及模板文件。\n\n\n\n**==测试3==**：改变模板文件的内容，再次访问此页面，观察是否还会访问之前的缓存文件输出缓存文件中的\"哈哈\"。\n\n修改index.html模板文件的内容，\n\n![1530935088553](17.png)\n\n再次访问index.php，\n\n![1530935128788](18.png)\n\n查看编译缓存文件的内容，如下图所示，\n\n![1530935172804](19.png)\n\n从测试的效果上看，如果我们对模板文件进行了修改，则SMARTY才会重新去生成新的编译缓存内容，覆盖掉老的编译缓存内容。\n\n\n\n**==小结==**：\n\nSMARTY模板编译缓存原理是：当首次访问时，SMARTY将会自动生成一个编译缓存文件，同时会记录下这个模板文件的最后修改时间；当再次进行访问时，SMARTY会先对比一下当前模板文件的最后修改时间和之前记录下来的模板文件最后修改时间是否一致，如果不一致，说明模板文件发生了改变，则将会重新生成一个编译缓存内容覆盖掉老的内容；如果一致，说明模板文件没有被修改，则SMARTY将会直接访问编译缓存文件的内容。\n\n\n\n### SMARTY模板技术分类\n\nSMARTY模板技术有两个分类：1）程序设计；2）模板设计；\n\n\n\n## 3. ==SMARTY程序设计==\n\n#### SMARTY属性设置\n\n##### 定界符\n\n在模板当中包裹SMARTY语句的符号，即定界符。\n\n默认的左定界符：**=={==**\n\n默认的右定界符：**==}==**\n\n\n\n我们可以通过SMARTY对象中的两个属性修改定界符\n\n> **left_delimiter**非静态属性          负责控制左定界符\n>\n> **right_delimiter**非静态属性      负责控制右定界符\n\n\n\n**==需求==**：测试修改默认的左定界符为\"{--\"，右定界符为\"?}\"，查看页面访问效果。\n\n**==解答==**：构建名为index2.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$title = '劝学';\n$auth = '荀子';\n$date = '约公元前313年－公元前238年';\n\n$content = '故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。';\n\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->left_delimiter = '{--';//修改默认的左定界符符号\n$smarty->right_delimiter = '?}';//修改默认的右定界符符号\n\n\n$smarty->assign('title', $title);//调用assign方法将全局作用域转移到局部作用域中，assign也被称为是分配模板变量的\n$smarty->assign('aa', $auth);\n$smarty->assign('date', $date);\n$smarty->assign('content', $content);\n\n$smarty->display('index2.html');\n```\n\n构建名为index2.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n    <p>\n\t\t<!-- {--$title?} 定界符和变量直接是否有空格要根据定界符的定义-->\n        <!--  定界符可包含数字或英文字母，但不推荐-->\n        <span>标题1111：</span>{--$title?}\n\t</p>\n\n\t<p>\n\t\t<span>作者：</span>{--$aa?}\n\t</p>\n\n\t<p>\n\t\t<span>发布时间：</span>{$date}\n\t</p>\n\n\t<p>\n\t\t{$content}\n\t</p>\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530945528671](20.png)\n\n**==小结==**：\n\n我们可以在程序中使用1)left_delimiter；2）right_delimiter修改SMARTY的左、右定界符。\n\n\n\n##### 目录设置\n\n在Smarty3.0以后的版本，我们可以调用Smarty对象的方法修改模板目录和编译缓存目录：\n\n> **setTemplateDir方法**   修改模板目录\n>\n> **setCompileDir方法**    修改编译目录\n\n\n\n**==需求1==**：在code/demo目录下创建名为view的目录，将存放模板文件的目录修改为code/demo/view目录，测试效果。\n\n**==解答1==**：在code/demo下创建view目录：\n\n![1530945963057](21.png)\n\n创建code/demo/index3.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$title = '劝学';\n$auth = '荀子';\n$date = '约公元前313年－公元前238年';\n\n$content = '故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。';\n\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->setTemplateDir('./view');//修改默认存放模板文件的目录为code/demo/view目录\n\n\n$smarty->assign('title', $title);//调用assign方法将全局作用域转移到局部作用域中，assign也被称为是分配模板变量的\n$smarty->assign('aa', $auth);\n$smarty->assign('date', $date);\n$smarty->assign('content', $content);\n\n$smarty->display('index3.html');\n```\n\n创建code/demo/view/index3.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n    <p>\n\t\t<span>标题1111：</span>{$title}\n\t</p>\n\n\t<p>\n\t\t<span>作者：</span>{$aa}\n\t</p>\n\n\t<p>\n\t\t<span>发布时间：</span>{$date}\n\t</p>\n\n\t<p>\n\t\t{$content}\n\t</p>\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530946332277](22.png)\n\n**==小结1==**：\n\n通过setTemplateDir方法可以改变存放模板文件的目录。\n\n\n\n**==需求2==**：在程序中将存放编译缓存文件的目录修改为code/demo/view_c目录，测试效果。\n\n**==解答2==**：创建code/demo/index4.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$title = '劝学';\n$auth = '荀子';\n$date = '约公元前313年－公元前238年';\n\n$content = '故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。';\n\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->setCompileDir('./view_c');//修改默认存放编译缓存文件的目录为code/demo/view_c目录\n\n\n$smarty->assign('title', $title);//调用assign方法将全局作用域转移到局部作用域中，assign也被称为是分配模板变量的\n$smarty->assign('aa', $auth);\n$smarty->assign('date', $date);\n$smarty->assign('content', $content);\n\n$smarty->display('index4.html');\n```\n\n创建code/demo/view/index4.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n    <p>\n\t\t<span>标题1111：</span>{$title}\n\t</p>\n\n\t<p>\n\t\t<span>作者：</span>{$aa}\n\t</p>\n\n\t<p>\n\t\t<span>发布时间：</span>{$date}\n\t</p>\n\n\t<p>\n\t\t{$content}\n\t</p>\n</body>\n</HTML>\n```\n\n访问后效果：\n\n![1530946699674](23.png)\n\n**==小结2==**：\n\n我们可以通过setCompileDir方法来改变存放编译缓存文件的目录位置。\n\n\n\n##### 常量设置\n\n通常情况下，我们在项目程序文件中，会定义一个名为SMARTY_DIR的常量，定义这个常量可以向下兼容老版本的SMARTY。\n\n\n\n**==需求==**：在程序中定义SMARTY_DIR常量，测试效果。\n\n**==解答==**：创建code/demo/index4.php文件，代码如下：\n\n```php\n//                               F:/xxx/.../demo\ndefine('SMARTY_DIR', dirname(__FILE__).'/smarty/');\n\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$title = '劝学';\n$auth = '荀子';\n$date = '约公元前313年－公元前238年';\n\n$content = '故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。';\n\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->setCompileDir('./view_c');//修改默认存放编译缓存文件的目录为code/demo/view_c目录\n\n\n$smarty->assign('title', $title);//调用assign方法将全局作用域转移到局部作用域中，assign也被称为是分配模板变量的\n$smarty->assign('aa', $auth);\n$smarty->assign('date', $date);\n$smarty->assign('content', $content);\n\n$smarty->display('index4.html');\n```\n\n访问后效果：\n\n![1530947688933](24.png)\n\n**==小结==**：\n\n定义这个常量一般是为了兼容低版本的SMARTY.\n\n\n\n## 4. ==SMARTY模板设计==\n\n### SMARTY模板注释\n\n语法：==**{\\***注释内容***}**== \n\n**注意**：  是在定界符的基础上加上 ``*`` \n\n**==测试==**：创建code/demo/index5.php文件，代码如下：\n\n```php\n<?php\n\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$title = '劝学';\n$auth = '荀子';\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n\n$smarty->assign('title', $title);//调用assign方法将全局作用域转移到局部作用域中，assign也被称为是分配模板变量的\n$smarty->assign('aa', $auth);\n\n$smarty->display('index5.html');\n```\n\n创建code/demo/templates/index5.html文件，代码如下：\n\n```php\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n\t<!-- 这是html的注释 -->\n\t{*这是SMARTY的注释*}\n    <p>\n\t\t<span>标题1111：</span>{$title}\n\t</p>\n\n\t<p>\n\t\t<span>作者：</span>{$aa}\n\t</p>\n\n</body>\n</HTML>\n```\n\n访问后的效果:\n\n![1530948220082](25.png)\n\n\n\n**==小结==**：\n\nSMARTY的注释在浏览器端是不可见的。\n\n\n\n### SMARTY模板变量\n\nSMARTY模板变量包括三个种类：1）简单模板变量；2）数组模板变量；3）对象模板变量；\n\n#### 简单模板变量\n\n概念：即分配的数据为标量数据类型的变量；\n\n\n\n**==测试==**：创建code/demo/index6.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$title = 100;\n$auth = '荀子';\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n//往模板当中分配了一些标量类型的数据，$title和$auth所保存的数据都是标量类型的数据\n$smarty->assign('title', $title);\n$smarty->assign('aa', $auth);\n\n$smarty->display('index6.html');\n\n```\n\n创建code/demo/templates/index6.html文件，代码如下：\n\n```php+HTML\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n\t<!-- 这是html的注释 -->\n\t{*这是SMARTY的注释*}\n    <p>\n\t\t<span>标题1111：</span>{$title}\n\t</p>\n\n\t<p>\n\t\t<span>作者：</span>{$aa}\n\t</p>\n\n</body>\n</HTML>\n```\n\n访问后效果：\n\n![1530948683771](26.png)\n\n**==小结==**：\n\n所谓的简单模板变量，指的是通过assign方法分配的是标量类型的数据。\n\n\n\n#### 数组模板变量\n\n概念：即分配的数据为数组数据类型的变量；\n\n\n\n**==测试==**：创建code/demo/index7.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$title = ['title1'=>'劝学', 'title2'=>'四书五经'];\n$auth = '荀子';\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('bb', $title);//bb就是被分配到模板文件中的数组模板变量，因为$title就是个数组\n$smarty->assign('aa', $auth);\n\n$smarty->display('index7.html');\n```\n\n创建code/demo/templates/index7.html文件，代码如下：\n\n```php\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n\t<!-- 这是html的注释 -->\n\t{*这是SMARTY的注释*}\n    <p>\n\t\t<span>标题1：</span>{$bb['title1']}   <!-- 读取数组变量元素的第一种方式 -->\n\t\t<span>标题2：</span>{$bb.title2}    <!-- 读取数组变量元素的第二种方式 -->\n\t</p>\n\n\t<p>\n\t\t<span>作者：</span>{$aa}\n\t</p>\n</body>\n</HTML>\n```\n\n访问后效果：\n\n![1530949741274](27.png)\n\n**==小结==**：\n\n所谓的数组模板变量，指的是通过assign方法分配的是数组类型的数据。\n\n\n\n#### 对象模板变量\n\n概念：即分配的数据为对象数据类型的变量；\n\n\n\n**==测试==**：创建code/demo/index8.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$title = ['title1'=>'劝学', 'title2'=>'四书五经'];\n\nclass A{\n    public $auth1='荀子';\n    public $auth2='孟子';\n}\n\n$a1 = new A;\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('bb', $title);\n$smarty->assign('aa', $a1);//aa就是分配到模板中的对象模板变量，因为$a1就是一个对象\n\n$smarty->display('index8.html');\n```\n\n创建code/demo/templates/index8.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n\t<!-- 这是html的注释 -->\n\t{*这是SMARTY的注释*}\n    <p>\n\t\t<span>标题1：</span>{$bb['title1']}   <!-- 读取数组变量元素的第一种方式 -->\n\t\t<span>标题2：</span>{$bb.title2}    <!-- 读取数组变量元素的第二种方式 -->\n\t</p>\n\n\t<p>\n\t\t<span>作者1：</span> {$aa->auth1}\n\t\t<span>作者2：</span> {$aa->auth2}\n\t</p>\n</body>\n</HTML>\n```\n\n访问后效果：\n\n![1530950120998](28.png)\n\n**==小结==**：\n\n所谓的对象模板变量，指的是通过assign方法分配的是对象数据类型的数据。\n\n\n\n### SMARTY系统变量\n\nSMARTY系统变量有：\n\n> ==**{$smarty.get.变量名称}**==    直接获取GET参数数据\n>\n> ==**{$smarty.post.变量名称}**==      直接获取POST参数数据\n>\n> **{$smarty.cookies.变量名称}**     直接获取COOKIE参数数据\n>\n> **{$smarty.session.变量名称}**     直接获取SESSION参数数据\n>\n> ==**{$smarty.const.常量名称}**==      直接获取常量参数数据\n>\n> ==**{$smarty.now}**==      直接获取当前时间的时间戳\n\n\n\n**==测试==**：测试**{$smarty.get.变量名称}**、**{$smarty.const.常量名称}**、**{$smarty.now}**\n\n创建code/demo/index9.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n\ndefine('PATH', './source');\ndefine('URL', 'www.home.com');\n\nsession_start();\n//$_SESSION['height'] = 1.6;\n//$_SESSION['weight'] = 200;\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n\n$smarty->display('index9.html');\n```\n\n创建code/demo/templates/index9.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n\t<p>\n\t\t<span>常量1：</span> {$smarty.const.PATH}\n\t\t<span>常量2：</span> {$smarty.const.URL}\n\t</p>\n\t<p>\n\t\t<span>GET数据1：</span> {$smarty.get.name}\n\t\t<span>GET数据2：</span> {$smarty.get.age}\n\t</p>\n\t<p>\n\t\t<span>SESSION数据1：</span> {$smarty.session.height}\n\t\t<span>SESSION数据2：</span> {$smarty.session.weight}\n\t</p>\n\t<p>\n\t\t<span>当前时间戳：</span> {$smarty.now}\n\t</p>\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530951354637](29.png)\n\n**==小结==**：\n\n使用系统变量，无需额外在程序中通过assign方法去分配，直接在模板中使用即可。\n\n\n\n### SMARTY内置函数（内建函数）\n\n#### foreach\n\n==作用==：在模板中实现foreach遍历，性质相当于PHP中的foreach遍历。\n\n==定义语法==：\n\n```php\n{foreach from=$目标数组的模板变量 [key=’保存元素下标的模板变量名’ ] item=’保存元素值的模板变量名’  [name=’当前foreach的别名’]}\n       foreach遍历结构体\n{/foreach}\n```\n\n\n\n**==测试==**：创建code/demo/index10.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$arr = [\n    0=>['title'=>'新闻1', 'intro'=>'简介1', 'auth'=>'荀子'],\n    1=>['title'=>'新闻2', 'intro'=>'简介2', 'auth'=>'孟子']\n];\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('datas', $arr);//分配了一个数组模板变量\n\n\n$smarty->display('index10.html');\n```\n\n创建code/demo/templates/index10.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n\t<table border=\"1px\">\n\t\t<tr>\n\t\t\t<td>新闻标题</td>\n\t\t\t<td>新闻简介</td>\n\t\t\t<td>新闻作者</td>\n\t\t</tr>\n\t\t{*  foreach($datas as $datas_key=>$datas_val){  *}\n\n\t\t{foreach from=$datas key='datas_key' item='datas_val'}\n\t\t<tr>\n\t\t\t<td>{$datas_val.title}</td>\n\t\t\t<td>{$datas_val.intro}</td>\n\t\t\t<td>{$datas_val.auth}</td>\n\t\t</tr>\n\t\t{/foreach}\n\n\t\t{* } *}\n\t</table>\n</body>\n```\n\n访问效果：\n\n![1530952177159](30.png)\n\n**==小结==**：\n\n内置函数foreach其实就相当于PHP中的foreach.\n\n\n\n#### foreachelse\n\n==作用==：当foreach遍历的数组为空数组或不存在时，则将执行foreachelse部分。\n\n\n\n**==测试==**：创建code/demo/index11.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n//$arr = [\n    //0=>['title'=>'新闻1', 'intro'=>'简介1', 'auth'=>'荀子'],\n    //1=>['title'=>'新闻2', 'intro'=>'简介2', 'auth'=>'孟子']\n//];\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$arr = [];\n$smarty->assign('datas', $arr);//分配了一个数组模板变量\n\n\n$smarty->display('index11.html');\n```\n\n创建code/demo/templates/index11.html文件，代码如下：\n\n```php\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n\t<table border=\"1px\">\n\t\t<tr>\n\t\t\t<td>新闻标题</td>\n\t\t\t<td>新闻简介</td>\n\t\t\t<td>新闻作者</td>\n\t\t</tr>\n\t\t{*  foreach($datas as $datas_key=>$datas_val){  *}\n\n\t\t{foreach from=$datas key='datas_key' item='datas_val'}\n\t\t<tr>\n\t\t\t<td>{$datas_val.title}</td>\n\t\t\t<td>{$datas_val.intro}</td>\n\t\t\t<td>{$datas_val.auth}</td>\n\t\t</tr>\n\t\t{foreachelse}\n\t\t<tr>\n\t\t\t<td>暂无数据</td>\n\t\t</tr>\n\t\t{/foreach}\n\n\t\t{* } *}\n\t</table>\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530953273491](31.png)\n\n**==小结==**：\n\nforeachelse结构是当遍历的数组不存在或者为空时将会执行的部分。\n\n\n\n#### foreach内置变量\n\nforeach内置变量包括：\n\n> {==**$smarty.foreach.**==foreach循环名==**.index**==}     表示获得当前循环的索引值\n>\n> {==**$smarty.foreach.**==foreach循环名==**.iteration**==}    表示获得当前遍历的次数（当前遍历到了第几次）\n\n\n\n**==测试==**：创建code/demo/index12.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$arr = [\n    0=>['title'=>'新闻1', 'intro'=>'简介1', 'auth'=>'荀子'],\n    1=>['title'=>'新闻2', 'intro'=>'简介2', 'auth'=>'孟子'],\n    2=>['title'=>'新闻3', 'intro'=>'简介3', 'auth'=>'孟子'],\n    3=>['title'=>'新闻4', 'intro'=>'简介4', 'auth'=>'孟子']\n];\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('datas', $arr);//分配了一个数组模板变量\n\n\n$smarty->display('index12.html');\n```\n\n创建code/demo/templates/index12.html文件，代码如下：\n\n```php\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n\t<table border=\"1px\">\n\t\t<tr>\n\t\t\t<td>序号</td>\n\t\t\t<td>当前遍历的索引号</td>\n\t\t\t<td>新闻标题</td>\n\t\t\t<td>新闻简介</td>\n\t\t\t<td>新闻作者</td>\n\t\t</tr>\n\t\t{*  foreach($datas as $datas_key=>$datas_val){  *}\n\n\t\t{foreach from=$datas key='datas_key' item='datas_val' name='f1'}\n\t\t<tr>\n\t\t\t<td>{$smarty.foreach.f1.iteration}</td>\n\t\t\t<td>{$smarty.foreach.f1.index}</td>\n\t\t\t<td>{$datas_val.title}</td>\n\t\t\t<td>{$datas_val.intro}</td>\n\t\t\t<td>{$datas_val.auth}</td>\n\t\t</tr>\n\t\t{/foreach}\n\n\t\t{* } *}\n\t</table>\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530953840696](32.png)\n\n**==小结==**：\n\n这两个foreach内置变量都需要foreach内建函数结构中才能够使用的。\n\n\n\n#### include\n\n==作用==：引入其他模板文件。\n\n==定义语法==：\n\n```php\n{include  file=’模板路径’  [额外分配模板变量的名1=额外分配模板变量的值1]  [额外分配模板变量的名2=额外分配模板变量的值2] […]  [额外分配模板变量的名n=额外分配模板变量的值n]}\n```\n\n\n\n**==测试==**：创建code/demo/index13.php文件，代码如下：\n\n```php\n\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$arr = [\n    0=>['title'=>'新闻1', 'intro'=>'简介1', 'auth'=>'荀子'],\n    1=>['title'=>'新闻2', 'intro'=>'简介2', 'auth'=>'孟子'],\n    2=>['title'=>'新闻3', 'intro'=>'简介3', 'auth'=>'孟子'],\n    3=>['title'=>'新闻4', 'intro'=>'简介4', 'auth'=>'孟子']\n];\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('datas', $arr);//分配了一个数组模板变量\n\n$smarty->display('index13.html');\n```\n\n创建code/demo/templates/common.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>{$head_title}</title>\n</head>\n<body>\n```\n\n创建code/demo/templates/index13.html文件，代码如下：\n\n```html\n<!-- 在引入文件时，给目标文件传递参数，替换其中的占位符 -->\n{include file='common.html' head_title='index13'}  \n\t<table border=\"1px\">\n\t\t<tr>\n\t\t\t<td>序号</td>\n\t\t\t<td>当前遍历的索引号</td>\n\t\t\t<td>新闻标题</td>\n\t\t\t<td>新闻简介</td>\n\t\t\t<td>新闻作者</td>\n\t\t</tr>\n\t\t{*  foreach($datas as $datas_key=>$datas_val){  *}\n\n\t\t{foreach from=$datas key='datas_key' item='datas_val' name='f1'}\n\t\t<tr>\n\t\t\t<td>{$smarty.foreach.f1.iteration}</td>\n\t\t\t<td>{$smarty.foreach.f1.index}</td>\n\t\t\t<td>{$datas_val.title}</td>\n\t\t\t<td>{$datas_val.intro}</td>\n\t\t\t<td>{$datas_val.auth}</td>\n\t\t</tr>\n\t\t{/foreach}\n\n\t\t{* } *}\n\t</table>\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530954556468](33.png)\n\n**==小结==**：\n\n我们可以通过include引入公共的模板文件。\n\n\n\n#### if...elseif...else\n\n==作用==：在模板中实现if..elseif..else分支。\n\n\n\n**==测试==**：创建code/demo/index14.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$score = 90;\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('score', $score);\n\n$smarty->display('index14.html');\n```\n\n创建code/demo/templates/index14.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index14</title>\n</head>\n<body>\n\t\n{if $score>90}\n<span>优秀</span>\n{elseif $score>60}\n<span>及格</span>\n{else}\n<span>请继续努力</span>\n{/if}\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530955099386](34.png)\n\n**==小结==**：\n\n可以通过这个内置函数在模板中实现分支条件判断。\n\n\n\n#### literal\n\n==作用==：被literal包裹的部分将不会被当成smarty内容解析。\n\n\n\n**==测试==**：创建code/demo/index15.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->display('index15.html');\n```\n\n创建code/demo/templates/index15.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index14</title>\n</head>\n<body>\n\n{literal}\n<style>\n.s1 {color:red}\n</style>\n{/literal}\n<span class=\"s1\">哈哈哈哈</span>\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530955366898](35.png)\n\n**==小结==**：\n\n被literal包裹的内容将不会当成smarty的内容来解析。\n\n\n\n#### ldelim和rdelim\n\n==作用==：ldelim专门保存左定界符符号；rdelim专门保存右定界符符号。\n\n\n\n**==测试==**：创建code/demo/index16.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->display('index16.html');\n```\n\n创建code/demo/templates/index16.html文件，代码如下：\n\n```php\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index14</title>\n</head>\n<body>\n\n<span>左定界符：</span>{ldelim}<br/>\n<span>右定界符：</span>{rdelim}\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530955596750](36.png)\n\n**==小结==**：\n\n在模板中我们可以使用ldelim和rdelim输出左右大括号符号。\n\n\n\n### SMARTY变量调节器\n\n基本语法：\n\n```php\n{变量名|调节器名1:参数1:参数2….|调节器名2:参数1:参数2….}\n```\n\n\n\n#### cat\n\n==作用==：拼接字符串。\n\n\n\n**==测试==**：创建code/demo/index17.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$name = '哪吒';\n$age = 12;\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('name', $name);\n$smarty->assign('age', $age);\n\n$smarty->display('index17.html');\n```\n\n创建code/demo/templates/index17.html文件，代码如下：\n\n```php\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>调节器</title>\n</head>\n<body>\n\n<span>cat调节器：</span>{$name|cat:$age}\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530955920528](37.png)\n\n**==小结==**：\n\ncat可以实现字符串拼接。\n\n\n\n#### date_format\n\n==作用==：将时间戳格式化为年月日时间日期格式。\n\n\n\n**==测试==**：创建code/demo/index17.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$name = '哪吒';\n$age = 12;\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('name', $name);\n$smarty->assign('age', $age);\n\n$smarty->display('index17.html');\n```\n\n创建code/demo/templates/index17.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>调节器</title>\n</head>\n<body>\n\n<span>cat调节器：</span>{$name|cat:$age}   <br/>\n<span>date_format调节器：</span>{$smarty.now|date_format:'%Y-%m-%d %H:%M:%S'}  <br/>\n<span>获得当前时间的年月日时分秒格式：</span>{date('Y-m-d H:i:s')}  <br/>\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530956204497](38.png)\n\n**==小结==**：\n\ndate_format可以将一个时间戳转换为年月日时分秒时间日格式。\n\n\n\n#### default\n\n==作用==：指定默认值。\n\n\n\n**==测试==**：创建code/demo/index17.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$name = '哪吒';\n$age = 12;\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('name', $name);\n$smarty->assign('age', $age);\n\n$smarty->display('index17.html');\n```\n\n创建code/demo/templates/index17.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>调节器</title>\n</head>\n<body>\n\n<span>cat调节器：</span>{$name|cat:$age}   <br/>\n<span>date_format调节器：</span>{$smarty.now|date_format:'%Y-%m-%d %H:%M:%S'}  <br/>\n<span>获得当前时间的年月日时分秒格式：</span>{date('Y-m-d H:i:s')}  <br/>\n<span>default调节器：</span>{$var2|default:'var2没有值就会用我'}  <br/>\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530956384720](39.png)\n\n**==小结==**：\n\ndefault可以为模板变量指定默认值。\n\n\n\n#### lower和upper\n\n==作用==：lower负责将字母转换为小写；upper负责将字母转换为大写。\n\n\n\n**==测试==**：创建code/demo/index17.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$name = '哪吒';\n$age = 12;\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('name', $name);\n$smarty->assign('age', $age);\n\n$smarty->display('index17.html');\n```\n\n创建code/demo/templates/index17.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>调节器</title>\n</head>\n<body>\n\n<span>cat调节器：</span>{$name|cat:$age}   <br/>\n<span>date_format调节器：</span>{$smarty.now|date_format:'%Y-%m-%d %H:%M:%S'}  <br/>\n<span>获得当前时间的年月日时分秒格式：</span>{date('Y-m-d H:i:s')}  <br/>\n<span>default调节器：</span>{$var2|default:'var2没有值就会用我'}  <br/>\n\n<span>lower调节器：</span>{'abcFEses'|lower}  <br/>\n<span>upper调节器：</span>{'abcFEses'|lower|upper}  <br/>\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530956589060](40.png)\n\n**==小结==**：\n\nlower和upper第一个是转换为小写字母，第二个是转换为大写字母。\n\n\n\n#### escape\n\n==作用==：负责将变量中的html标签当成普通字符串输出。\n\n\n\n**==测试==**：创建code/demo/index17.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$name = '哪吒';\n$age = 12;\n$str = '<span style=\"color:yellow;\">12345</span>';\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('name', $name);\n$smarty->assign('age', $age);\n$smarty->assign('str', $str);\n\n$smarty->display('index17.html');\n\n```\n\n创建code/demo/templates/index17.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>调节器</title>\n</head>\n<body>\n\n<span>cat调节器：</span>{$name|cat:$age}   <br/>\n<span>date_format调节器：</span>{$smarty.now|date_format:'%Y-%m-%d %H:%M:%S'}  <br/>\n<span>获得当前时间的年月日时分秒格式：</span>{date('Y-m-d H:i:s')}  <br/>\n<span>default调节器：</span>{$var2|default:'var2没有值就会用我'}  <br/>\n\n<span>lower调节器：</span>{'abcFEses'|lower}  <br/>\n<span>upper调节器：</span>{'abcFEses'|lower|upper}  <br/>\n\n<span>escape调节器：</span>{$str|escape}  <br/>\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530956783767](41.png)\n\n**==小结==**：\n\nescape可以把标签当成普通的字符来输出。\n\n\n\n#### nl2br\n\n==作用==：负责将文件的回车换行转换为html的\\<br/>标签。\n\n\n\n**==测试==**：创建code/demo/index17.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$name = '哪吒';\n$age = 12;\n$str = '<span style=\"color:yellow;\">12345</span>';\n\n$str1 = \"abcd\\r\\neeeeee\";\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('name', $name);\n$smarty->assign('age', $age);\n$smarty->assign('str', $str);\n\n$smarty->assign('str1', $str1);\n\n$smarty->display('index17.html');\n```\n\n创建code/demo/templates/index17.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>调节器</title>\n</head>\n<body>\n\n<span>cat调节器：</span>{$name|cat:$age}   <br/>\n<span>date_format调节器：</span>{$smarty.now|date_format:'%Y-%m-%d %H:%M:%S'}  <br/>\n<span>获得当前时间的年月日时分秒格式：</span>{date('Y-m-d H:i:s')}  <br/>\n<span>default调节器：</span>{$var2|default:'var2没有值就会用我'}  <br/>\n\n<span>lower调节器：</span>{'abcFEses'|lower}  <br/>\n<span>upper调节器：</span>{'abcFEses'|lower|upper}  <br/>\n\n<span>escape调节器：</span>{$str|escape}  <br/>\n\n<span>nl2br调节器：</span>{$str1|nl2br}  <br/>\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530957013953](42.png)\n\n**==小结==**：\n\nnl2br可以将\\r\\n回车换行符转换为html中的\\<br/>标签。\n\n\n\n#### strip_tags\n\n==作用==：负责将html标签字符直接去除 。\n\n\n\n**==测试==**：创建code/demo/index17.php文件，代码如下：\n\n```php\n#引入SMARTY核心类文件\ninclude './smarty/Smarty.class.php';\n\n$name = '哪吒';\n$age = 12;\n$str = '<span style=\"color:yellow;\">12345</span>';\n\n$str1 = \"abcd\\r\\neeeeee\";\n\n#实例化Smarty类的对象\n$smarty = new Smarty;\n\n$smarty->assign('name', $name);\n$smarty->assign('age', $age);\n$smarty->assign('str', $str);\n\n$smarty->assign('str1', $str1);\n\n$smarty->display('index17.html');\n```\n\n创建code/demo/templates/index17.html文件，代码如下：\n\n```html\n<!DOCTYPE html>\n<HTML>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>调节器</title>\n</head>\n<body>\n\n<span>cat调节器：</span>{$name|cat:$age}   <br/>\n<span>date_format调节器：</span>{$smarty.now|date_format:'%Y-%m-%d %H:%M:%S'}  <br/>\n<span>获得当前时间的年月日时分秒格式：</span>{date('Y-m-d H:i:s')}  <br/>\n<span>default调节器：</span>{$var2|default:'var2没有值就会用我'}  <br/>\n\n<span>lower调节器：</span>{'abcFEses'|lower}  <br/>\n<span>upper调节器：</span>{'abcFEses'|lower|upper}  <br/>\n\n<span>escape调节器：</span>{$str|escape}  <br/>\n\n<span>nl2br调节器：</span>{$str1|nl2br}  <br/>\n<span>strip_tags调节器：</span>{$str|strip_tags}  <br/>\n\n</body>\n</HTML>\n```\n\n访问效果：\n\n![1530957154621](43.png)\n\n**==小结==**：\n\nstrip_tags可以去除字符串中的标签。\n\n\n\n## 5. 全天总结\n\n1. 部署SMARTY\n\n   1)转移核心类库目录(libs)到项目中（最好重命名，我们把它改为了smarty）\n\n   2)在项目目录下还需创建一个名为tempates的目录\n\n   3)在程序中引入Smarty核心类文件，并且实例化Smarty类的对象\n\n   4)我们可以调用assign方法向模板中分配模板变量\n\n   5)我们可以调用display方法渲染模板文件\n\n2. SMARTY模板变量\n\n   1）简单模板变量；2）数组模板变量；3）对象模板变量；\n\n   简单模板变量：在模板中  \"{$变量名}\"\n\n   数组模板变量：在模板中  \"{$变量名['元素下标']}\"或\"{$变量名.元素下标}\"\n\n   对象模板变量：在模板中  \"{$变量名->属性名}\"\n\n3. 内置函数foreach、include、if..elseif..else、literal\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["PHP模板引擎Smarty"]},{"title":"面向对象1","url":"%2Fposts%2F285029296%2F","content":"\n\n# 面向对象\n\n## 1. 面向对象相关概念\n\n### 为什么使用面向对象\n\n编程思想有两个大类：1）面向过程思想；2）面向对象思想；\n\n\n\n#### 面向过程思想介绍\n\n我们来看以下场景：\n\n![1530236114530](2_1.png)\n\n==**小结**==：\n\n面向过程思想：面向的是**==过程==**，强调的是**==过程中==**每一个执行的**==步骤==**。\n\n\n\n#### 面向对象思想介绍\n\n同样是相同的场景，使用面向对象的方式来解决最终的问题：\n\n![1530236505036](3_1.png)\n\n==**小结**==：\n\n面向对象思想：面向的是**==对象==**，强调的是**==最终==**执行的**==结果==**。\n\n\n\n#### 面向过程思想的局限性\n\n1. 使用面向过程思想开发，代码冗余率高，重用性低；\n2. 使用面向过程思想开发，如果中途需求发生改变，那么代码的改动量将会相当庞大。\n\n \n\n正是由于有这些局限性，所以人们慢慢过渡到使用面向对象的方式来进行开发，解决上述局限性问题。\n\n### 什么是面向对象\n\n面向对象即==OOP== （Object Oriented Programming）\n\n**==概念==**：以面向对象思想为指导的一种编程方式。\n\n\n\n通俗的理解面向对象：==找个对象帮我做事==。\n\n\n\n## 2. ==PHP中的类与对象==\n\n### 类\n\n程序本质上就是对现实世界的模拟。\n\n \n\n现实世界中的类是一个比较抽象的概念，比如人类，鱼类，车类等，它其实就是**==拥有相同特性的事物的统称==**；\n\n程序当中也有类的概念。\n\n \n\n现实当中类的概念：具有相同 **==特征==** 和 **==行为==** 的一类群体的统称。\n\nPHP中的类的概念：具有相同 **==属性==** 和 **==方法==** 的一类事物的集合。\n\n\n\n==**PHP中类的定义语法**==\n\n```php\n//定义一个类，class是关键字\nclass 类名{\n    类成员\n}\n\n#定义类的案例\n<?php\n\n//定义一个类\nclass Person{\n\n}\n\necho '语法无误，成功定义出了一个名为Person的类'; \n```\n\n\n\n### 类成员\n\n类成员包括==三个大类==：\n\n```mermaid\ngraph LR\nA(类成员) --> B\nA --> E\nA --> I\nB[1.成员属性] --> C(静态成员属性)\nB --> D(非静态成员属性)\nE[2.成员方法] --> F(静态成员方法)\nE --> G(非静态成员方法)\nI[3.类常量]\n```\n\n### 对象\n\n对象需要**==基于类的定义==**创建出来。\n\n**==创建对象的语法==**\n\n```php\n//需要先定义一个类\nclass demoA{\n    \n}\n\n//然后再基于一个已有的类创建对象，关键字为：new\n//基于demoA类创建了一个对象，将创建的对象赋值给$obj变量\n$obj = new demoA;\n```\n\n构建一个名为code2.php的程序，代码如下：\n\n```php\n<?php\n\n//定义一个类\nclass demoA{\n\n}\n\n//然后再基于一个已有的类创建对象，关键字为：new\n//基于demoA类创建了一个对象，将创建的对象赋值给$obj变量\n$obj = new demoA;\nvar_dump( $obj ); echo '<hr/>';\n$obj1 = new demoA;\nvar_dump( $obj1 ); \n```\n\n访问code2.php，效果为：\n\n```mysql\nobject(demoA)#1 (0) { }   #这个是输出的$obj的内容\nobject(demoA)#2 (0) { }   #这个是输出的$obj1的内容\n```\n\n\n\n**==小结==**：\n\n1. 创建对象之前必须要类的定义；\n2. 根据一个已有的类使用关键字new来创建一个对象；\n\n\n\n### 对象创建的原理\n\n**==原理图==**：\n\n![1530240769584](4_1.png)\n\n\n\n**==小结==**：\n\n1. 一个类最多**==只有==**一份**==专有==**的静态成员空间；\n2. 每当new一个对象的时候，程序就会去内存中开辟一个全新的对象空间（也就是说new一次，就开一个）；\n3. 静态成员属性、类常量和静态成员方法将会被放置在静态成员空间中；非静态成员属性和非静态成员方法将会被放置在每次new时新开辟出来的对象空间中；\n\n\n\n### 类成员的定义\n\n#### 成员属性\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个非静态成员属性，名为\"name\"，值为\"zhangsan\"；\n2. 在Person类中定义一个非静态成员属性，名为\"age\"，不指定值；\n3. 在Person类中定义一个静态成员属性，名为\"height\"，值为\"1.78\"；\n4. 在Person类中定义一个静态成员属性，名为\"weight\"，不指定值；\n\n**==解答==**：构建名为code4.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    #成员属性\n    //定义非静态成员属性，关键字public\n    public $name='zhangsan';\n    public $age;\n\n    //定义静态成员属性，关键字是public、static，静态成员属性一定有static关键字，写在public后面\n    public static $height=1.78;\n    public static $weight;\n}\n\necho '本例中定义了成员属性'; \n```\n\n访问code4.php，输出的内容为，说明语法没有问题：\n\n```mysql\n本例中定义了成员属性\n```\n\n\n\n**==小结==**：\n\n1. 定义非静态成员属性的关键字为public，在定义的时候可以指定初始值也可以不指定；\n2. 定义静态成员属性的关键字为public、static，在定义的时候可以指定初始值也可以不指定；\n3. 类的定义，在程序执行的过程中不会被执行，程序会选择直接跳过，因为这只是一个定义出来的结构，不是执行的代码段；\n\n\n\n#### 成员方法\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个名为singing的非静态成员方法，方法中输出\"我会唱歌\"；\n2. 在Person类中定义一个名为dancing的静态成员方法，方法中输出\"我会跳舞\"；\n\n**==解答==**：构建名为code5.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    #成员方法\n    //非静态成员方法，关键字为public，结构与函数一致\n    public function singing(){ \n        echo '我会唱歌'; \n    }\n    //静态成员方法，关键字为public和static，结构与函数一致\n    public static function dancing(){ \n        echo '我会跳舞'; \n    }\n}\n\necho '本例中定义了成员方法'; \n```\n\n访问code5.php，输出的内容为，说明没有语法错误：\n\n```\n本例中定义了成员方法\n```\n\n**==小结==**：\n\n1. 定义非静态成员方法的关键字为public，结构与函数一致；\n2. 定义静态成员方法，关键字为public和static，结构与函数一致；\n3. 类的定义，在程序执行的过程中不会被执行，程序会选择直接跳过，因为这只是一个定义出来的结构，不是执行的代码段；\n\n\n\n#### 类常量\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个类常量，名为\"AREA\"，值为\"广东省广州市\"；\n\n**==解答==**：构建名为code6.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    #类常量，关键字是const，其实类常量与普通常量在性质上没有区别，只不过定义的地方不同和之后调用的方式有所区别；\n    const AREA='广东省广州市';\n}\n\necho '本例中定义了类常量'; \n```\n\n访问code6.php，输出的内容为，说明没有语法错误：\n\n```\n本例中定义了类常量\n```\n\n**==小结==**：\n\n1. 定义类常量的关键字是const，注意不能用define函数来进行定义；\n\n\n\n### 类成员的调用\n\n#### 类的外部调用类成员\n\n##### 成员属性\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个非静态成员属性，名为\"name\"，值为\"zhangsan\"；\n2. 在Person类中定义一个非静态成员属性，名为\"age\"，不指定值；\n3. 在Person类中定义一个静态成员属性，名为\"height\"，值为\"1.78\"；\n4. 在Person类中定义一个静态成员属性，名为\"weight\"，不指定值；\n5. 实现在类的外部输出四个属性的值；\n\n**==解答==**：构建名为code7.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    #成员属性\n    //定义非静态成员属性，关键字public\n    public $name='zhangsan';\n    public $age;\n\n    //定义静态成员属性，关键字是public、static，静态成员属性一定有static关键字，写在public后面\n    public static $height=1.78;\n    public static $weight;\n}\n\n\n#在类的外部调用类成员属性\n//调用非静态的成员属性\n$zhangsan = new Person;\nvar_dump( $zhangsan->name ); echo '<br/>';\nvar_dump( $zhangsan->age ); echo '<hr/>';\n\n//调用静态的成员属性\nvar_dump( Person::$height ); echo '<br/>';\nvar_dump( Person::$weight );\n\n```\n\n访问code7.php，输出的内容为：\n\n```mysql\nstring(8) \"zhangsan\" //$zhangsan对象调用$name属性的值\nNULL  //$zhangsan对象调用$age属性的值\n\nfloat(1.78) //Person类调用$height属性的值\nNULL  //Person类调用$weight属性的值\n```\n\n\n\n**==小结==**：\n\n1. 要想成功在类的外部调用非静态成员属性，需要：1）先使用new**创建一个对象**；2）然后使用这个对象来加上固定的符号\"**==->==**\"来实现调用；3）调用时指定的属性名字**==不需要加上\"$\"==**；\n2. 要想成功在类的外部调用静态成员属性，直接使用**==所属类的类名==**加上\"**==::==**\"访问属性，访问时需要加上\"**==$==**\"；\n3. \"::\"这个符号我们通常会称为\"冒冒\"，专业的叫法是：范围解析操作符；\n\n\n\n##### 成员方法\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个名为singing的非静态成员方法，方法中输出\"我会唱歌\"；\n2. 在Person类中定义一个名为dancing的静态成员方法，方法中输出\"我会跳舞\"；\n3. 实现在类的外部分别调用执行singing和dancing方法；\n\n**==解答==**：构建名为code8.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    #成员方法\n    //非静态成员方法，关键字为public，结构与函数一致\n    public function singing(){ \n        echo '我会唱歌'; \n    }\n    //静态成员方法，关键字为public和static，结构与函数一致\n    public static function dancing(){ \n        echo '我会跳舞'; \n    }\n}\n\n#在类的外部实现访问成员方法\n//访问非静态的成员方法\n$obj = new Person;\n$obj->singing();\n\necho '<hr/>';\n\n//访问静态的成员方法\nPerson::dancing();\n\n```\n\n访问code8.php，输出的内容为：\n\n```mysql\n我会唱歌  #访问非静态成员方法singing输出的结果\n我会跳舞  #访问静态成员方法dancing输出的结果\n```\n\n\n\n**==小结==**：\n\n1. 访问类中的方法其实和调用函数效果差不多；\n2. 访问非静态成员方法需要：1)先**创建一个对象**；2）再使用这个对象来加上\"**==->==**\"进行调用；\n3. 访问静态成员方法需要：1)**指定所属的类名**；2）再加上\"**==::==**\"来进行访问；\n\n\n\n##### 类常量\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个类常量，名为\"AREA\"，值为\"广东省广州市\"；\n2. 实现在类的外部调用输出类常量；\n\n**==解答==**：构建名为code9.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    #类常量，关键字是const，其实类常量与普通常量在性质上没有区别，只不过定义的地方不同和之后调用的方式有所区别；\n    const AREA='广东省广州市';\n}\n\n#在类的外部调用类常量\nvar_dump( Person::AREA ); \n```\n\n访问code9.php，输出的内容为：\n\n```mysql\nstring(18) \"广东省广州市\"  #输出类常量的值\n```\n\n\n\n**==小结==**：\n\n1. 要想在类的外部访问类常量，需要：1）指定所属的类名；2）还需要加上\"::\"来进行直接访问；\n\n\n\n**类的外部访问类成员总结**：\n\n1. 类的外部访问非静态的成员属性\n\n   ```php\n   #第一步，需要先实例化一个类的对象\n   $obj = new 类名;\n   #第二步，再使用创建的对象调用相关的非静态成员属性，属性名部分不包括\"$\"符号\n   var_dump($obj->属性名);\n   ```\n\n2. 类的外部访问静态成员属性\n\n   ```php\n   #直接使用所属的类名来进行访问\n   var_dump(类名::$属性名);\n   ```\n\n3. 类的外部访问类常量\n\n   ```php\n   #直接使用所属的类名来进行访问\n   var_dump(类名::类常量名);\n   ```\n\n4. 类的外部访问非静态成员方法\n\n   ```php\n   #第一步，需要先实例化一个类的对象\n   $obj = new 类名;\n   #第二步，再使用创建的对象调用相关的非静态成员方法\n   $obj->方法名([实参列表]);\n   ```\n\n5. 类的外部访问静态成员方法\n\n   ```php\n   #直接使用所属的类名来进行访问\n   类名::方法名([实参列表]);\n   ```\n\n\n\n#### 类的内部调用类成员\n\n##### 成员属性\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个非静态成员属性，名为\"name\"，值为\"zhangsan\"；\n2. 在Person类中定义一个静态成员属性，名为\"height\"，值为\"1.78\"；\n3. 在Person类中定义一个名为test的非静态成员方法，在test方法中实现输出\"name\"的值和\"height\"的值；\n4. 在Person类中定义一个名为test_static的静态成员方法，在test_static方法中实现输出\"height\"的值，并且尝试输出\"name\"的值；\n\n**==解答==**：构建名为code11.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n\n    #成员属性\n    //非静态成员属性\n    public $name='zhangsan';\n    //静态成员属性\n    public static $height=1.78;\n\n    #测试在非静态方法中访问成员属性\n    public function test(){ \n        //访问非静态成员属性\n        var_dump( $this->name ); echo '<br/>';\n        //访问静态成员属性\n        var_dump( Person::$height ); \n    }\n    #测试在静态方法中访问成员属性\n    public static function test_static(){ \n        //访问静态成员属性\n        var_dump( Person::$height ); \n        //尝试访问非静态成员属性\n        var_dump( $this->name ); \n    }\n}\n\n//调用非静态成员方法test\n$obj = new Person;\n$obj->test();\n\necho '<hr/>';\n\n//调用静态成员方法test_static\nPerson::test_static();\n```\n\n访问code11.php，输出的内容为：\n\n```mysql\nstring(8) \"zhangsan\"    #访问非静态方法test内部$this->name的输出内容\nfloat(1.78)             #访问非静态方法test内部Person::$height的输出内容\nfloat(1.78) \t\t   #访问静态方法test_static内部Person::$height的输出内容\n\n#访问静态方法test_static内部$this->name的出错信息\nFatal error: Uncaught Error: Using $this when not in object context in F:\\home\\class\\day6\\code\\code11.php:23 Stack trace: #0 F:\\home\\class\\day6\\code\\code11.php(34): Person::test_static() #1 {main} thrown in F:\\home\\class\\day6\\code\\code11.php on line 23\n```\n\n\n\n**==小结==**：\n\n1. 在**==类的内部==**访问**==静态成员属性==**的方式\n\n   ```php\n   //访问方式如下\n   本类的类名::$静态成员属性名\n   ```\n\n2. 在类的内部**==只有==**  **==非静态成员方法中==** 才能访问 **非静态成员属性**，访问方式是\n\n   ```php\n   //访问方式如下\n   $this->非静态成员属性名\n   ```\n\n3. 如果在静态成员方法中访问非静态成员属性，则会直接报错；\n\n\n\n##### 成员方法\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个名为singing的非静态成员方法，方法中输出\"我会唱歌\"；\n2. 在Person类中定义一个名为dancing的静态成员方法，方法中输出\"我会跳舞\"；\n3. 在Person类中定义一个名为test的非静态成员方法，在test方法中调用singing和dancing方法；\n4. 在Person类中定义一个名为test_static的静态成员方法，在test_static方法中实现dancing方法，并且尝试调用singing；\n\n**==解答==**：构建名为code12.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n\n    #成员方法\n    //非静态成员方法\n    public function singing(){ \n        echo '我会唱歌'; \n    }\n    //静态成员方法\n    public static function dancing(){ \n        echo '我会跳舞'; \n    }\n\n    #在类的内部测试访问成员方法\n    //非静态成员方法\n    public function test(){ \n        //访问非静态成员方法singing\n        $this->singing();\n        echo '<br/>';\n        //访问静态成员方法dancing\n        Person::dancing();\n    }\n\n    //静态成员方法\n    public static function test_static(){ \n        //访问静态成员方法dancing\n        Person::dancing();\n        //尝试访问非静态成员方法singing\n        $this->singing();\n    }\n    \n}\n\n//调用非静态成员方法test\n$obj = new Person;\n$obj->test();\n\necho '<hr/>';\n\n//调用静态成员方法test_static\nPerson::test_static();\n```\n\n访问code12.php，输出的内容为：\n\n```mysql\n我会唱歌      #访问非静态方法test内部$this->singing();的输出内容\n我会跳舞      #访问非静态方法test内部Person::dancing();的输出内容\n我会跳舞      #访问静态方法test_static内部Person::dancing();的输出内容\n\n#访问静态方法test_static内部$this->singing();的报错内容\nFatal error: Uncaught Error: Using $this when not in object context in F:\\home\\class\\day6\\code\\code12.php:30 Stack trace: #0 F:\\home\\class\\day6\\code\\code12.php(42): Person::test_static() #1 {main} thrown in F:\\home\\class\\day6\\code\\code12.php on line 30\n```\n\n\n\n**==小结==**：\n\n1. 在**==类的内部==**访问**==静态成员方法==**的方式\n\n   ```php\n   //访问方式如下\n   本类的类名::方法名([实参列表])\n   ```\n\n2. 在类的内部**==只有==**  **==非静态成员方法中==** 才能访问 **非静态成员方法**，访问方式是\n\n   ```php\n   //访问方式如下\n   $this->方法名([实参列表])\n   ```\n\n3. 如果在静态成员方法中访问非静态成员方法，则会直接报错；\n\n\n\n##### 类常量\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个类常量，名为\"AREA\"，值为\"广东省广州市\"；\n2. 在Person类中定义一个名为test的非静态成员方法，在test方法中输出类常量；\n3. 在Person类中定义一个名为test_static的静态成员方法，在test_static方法中输出类常量；\n\n**==解答==**：构建名为code13.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n\n    #类常量\n    const AREA='广东省广州市';\n\n    #在类的内部测试访问成员方法\n    //非静态成员方法\n    public function test(){ \n        var_dump( Person::AREA ); \n    }\n\n    //静态成员方法\n    public static function test_static(){ \n        var_dump( Person::AREA ); \n    }\n    \n}\n\n//调用非静态成员方法test\n$obj = new Person;\n$obj->test();\necho '<hr/>';\n\n//调用静态成员方法test_static\nPerson::test_static();\n```\n\n访问code13.php，输出的内容为：\n\n```mysql\nstring(18) \"广东省广州市\"    #访问非静态方法test内部Person::AREA的输出内容\nstring(18) \"广东省广州市\"    #访问静态方法test_static内部Person::AREA的输出内容\n```\n\n\n\n**==小结==**：\n\n1. 在类的内部直接使用本类的类名加\"::\"访问类常量。\n\n\n\n**==类的内部调用类成员总结==**：\n\n1. 我们以在类的内部访问成员属性为例，构建了一张原理图，如下：\n\n   ![1530257719530](5_1.png)\n\n   从分析原理图的原理流程中，我们了解学习到：\n\n   1. $this代表\"哪个对象调用，就代表那个对象\"，通俗的将就是，$this代表当前所在的这个对象空间，比如上图中的#1空间；\n   2. 我们在案例测试中发现，在静态的方法中，如果调用非静态成员（包括非静态成员属性和非静态成员方法）时，将会报错；原因是：1）调用非静态成员都需要使用对象，而对象是在执行过程中才能确定的；但是静态方法是在编译时就确定了，所以要在一个编译阶段确定的方法中去调用未来执行阶段才能确定的对象成员，显而易见，是不能成功调用到的，我们永远没有办法确定未来有多少个对象，要调用这些对象中的哪一个。\n\n\n\n### 对象的比较\n\n在程序中，对象是保存在**变量中**的，变量之间可以使用\"==\"等于和\"\\=\\=\\=\"全等于进行比较，也就意味着对象也可以进行这两种比较。\n\n\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个非静态成员属性，名为\"name\"，值为\"zhangsan\"；\n2. 在类的外部分别对Person类创建两个对象；\n3. 使用\"==\"等于 和  \"\\=\\=\\=\"全等于对两个对象进行比较，输出比较的结果；\n\n**==解答==**：构建名为code14.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    public $name='zhangsan';\n}\n\n$obj1 = new Person;\n$obj2 = new Person;\n\necho 'obj1：'; var_dump( $obj1 ); echo '<hr/>';\necho 'obj2：'; var_dump( $obj2 ); echo '<hr/>';\n\n$re = $obj1==$obj2;\necho '等于比较(==)：'; var_dump( $re ); echo '<hr/>';\n\n$re = $obj1===$obj2;\necho '全等于比较(===)：'; var_dump( $re ); echo '<hr/>';\n```\n\n访问code14.php，输出的内容为：\n\n```php\nobj1：object(Person)#1 (1) { [\"name\"]=> string(8) \"zhangsan\" }\nobj2：object(Person)#2 (1) { [\"name\"]=> string(8) \"zhangsan\" }\n等于比较(==)：bool(true)\n全等于比较(===)：bool(false)\n```\n\n\n\n**==小结==**：\n\n1. 如果使用等于比较(==)两个对象，则只比较对象的内容，不比较空间；\n2. 如果使用全等于比较(===)两个对象，则不仅要比较对象的内容，还需要比较对象所在的空间是否是同一个空间，如果空间不同，则比较的结果也将会是false；\n\n\n\n### self关键字\n\nself关键字的**作用**是，在**==本类的内部==**代替**==本类的类名==**。\n\n\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义一个静态成员属性，名为\"name\"，值为\"zhangsan\"；\n2. 在Person类中定义一个类常量，名为\"AREA\"，值为\"广东省广州市\"；\n3. 在Person类中定义一个名为test的非静态成员方法，在test方法中输出\"name\"的值和类常量的值；\n4. 在Person类中定义一个名为test_static的静态成员方法，在test_static方法中输出\"name\"的值和类常量的值；\n\n**==解答==**：构建名为code15.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    public static $name='zhangsan';\n    const AREA='广东省广州市';\n\n    #构建非静态的测试成员方法\n    public function test(){ \n        echo '使用类名进行访问：<br/>'; \n        echo '静态成员属性name：'; var_dump( Person::$name ); echo '<br/>';\n        echo '类常量AREA：'; var_dump( Person::AREA ); echo '<hr/>'; \n        \n        echo '使用self代替本类的类名进行访问：<br/>'; \n        echo '静态成员属性name：'; var_dump( self::$name ); echo '<br/>';\n        echo '类常量AREA：'; var_dump( self::AREA ); echo '<hr/>';  \n    }\n\n    #构建静态的测试成员方法\n    public static function test_static(){\n        echo '使用类名进行访问：<br/>'; \n        echo '静态成员属性name：'; var_dump( Person::$name ); echo '<br/>';\n        echo '类常量AREA：'; var_dump( Person::AREA ); echo '<hr/>'; \n        \n        echo '使用self代替本类的类名进行访问：<br/>'; \n        echo '静态成员属性name：'; var_dump( self::$name ); echo '<br/>';\n        echo '类常量AREA：'; var_dump( self::AREA ); echo '<hr/>';  \n    }\n}\n\n\n#调用非静态测试方法test\n$obj = new Person;\n$obj->test();\n\n#调用静态测试方法test_static\nPerson::test_static();\n```\n\n访问code15.php，输出的内容为：\n\n```mysql\n#下面这两个部分是调用test方法的输出\n使用类名进行访问：\n静态成员属性name：string(8) \"zhangsan\" \n类常量AREA：string(18) \"广东省广州市\"\n\n使用self代替本类的类名进行访问：\n静态成员属性name：string(8) \"zhangsan\" \n类常量AREA：string(18) \"广东省广州市\"\n\n#下面这两个部分是调用test_static方法的输出\n使用类名进行访问：\n静态成员属性name：string(8) \"zhangsan\" \n类常量AREA：string(18) \"广东省广州市\"\n\n使用self代替本类的类名进行访问：\n静态成员属性name：string(8) \"zhangsan\" \n类常量AREA：string(18) \"广东省广州市\"\n```\n\n\n\n**==小结==**：\n\n1. self只有一个作用，可以在本类的内部代替本类的类名\n\n\n\n### 构造方法\n\n==**定义语法**==\n\n```php\nclass 类名{\n    //定义类中的构造方法，__construct这个名字不允许改变为其他名字，注意前面是两个下划线\n    public function __construct([形参列表]){\n    \t#方法体 和 返回值\n\t}\n}\n```\n\n\n\n**==需求1==**：不使用构造方法完成对属性的赋值操作，定义名为Person的类，\n\n1. 在Person类中定义两个非静态成员属性，名分别为\"name\"和\"age\"，不指定值；\n2. 在类的外部基于Person类创建两个对象，第一个对象设置name的值为\"zhangsan\"，age的值为12，打印该对象；第二个对象设置name的值为lisi，age的值为16打印该对象；\n\n**==解答1==**：构建名为code16.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    //非静态成员属性\n    public $name;\n    public $age;\n}\n\n//创建一个$zhangsan对象\n$zhangsan = new Person;\n$zhangsan->name = 'zhangsan';\n$zhangsan->age = 12;\nvar_dump( $zhangsan ); echo '<hr/>';\n\n//创建一个$lisi对象\n$lisi = new Person;\n$lisi->name = 'lisi';\n$lisi->age = 16;\nvar_dump( $lisi ); \n```\n\n访问code16.php，输出的内容为：\n\n```mysql\n#下面这个为$zhangsan对象\nobject(Person)#1 (2) { [\"name\"]=> string(8) \"zhangsan\" [\"age\"]=> int(12) }\n#下面这个为$lisi对象\nobject(Person)#2 (2) { [\"name\"]=> string(4) \"lisi\" [\"age\"]=> int(16) }\n```\n\n\n\n**==小结1==**：\n\n1. 我们在这个操作案例中发现，如果每次实例化对象后，我们都要手动去为属性进行初始化赋值操作，当前创建两个对象，所以就做了2次这样的事情，如果以后有更多的对象被创建，那么我们需要重复的去做很多次同样性质的操作；非常的麻烦；\n\n\n\n所以，在php中，我们可以通过构造方法提供的功能，使我们能够快速的对属性进行初始化赋值操作。\n\n\n\n**==需求2==**：使用构造方法完成对属性的赋值操作，定义名为Person的类，\n\n1. 在Person类中定义两个非静态成员属性，名分别为\"name\"和\"age\"，不指定值；\n2. 在类的外部基于Person类创建两个对象，第一个对象设置name的值为\"zhangsan\"，age的值为12，打印该对象；第二个对象设置name的值为lisi，age的值为16打印该对象；\n\n**==解答2==**：构建名为code17.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    //非静态成员属性\n    public $name;\n    public $age;\n\n    //定义一个构造方法\n    public function __construct($v1, $v2){ \n        \n        $this->name = $v1;\n        $this->age = $v2;\n    }\n}\n\n//创建一个$zhangsan对象\n$zhangsan = new Person('zhangsan', 12);\nvar_dump( $zhangsan ); echo '<hr/>';\n\n//创建一个$lisi对象\n$lisi = new Person('lisi', 16);\nvar_dump( $lisi ); \n```\n\n访问code17.php，输出的内容为：\n\n```mysql\n#$zhangsan对象输出的内容\nobject(Person)#1 (2) { [\"name\"]=> string(8) \"zhangsan\" [\"age\"]=> int(12) }\n#$lisi对象输出的内容\nobject(Person)#2 (2) { [\"name\"]=> string(4) \"lisi\" [\"age\"]=> int(16) }\n```\n\n\n\n**==小结2==**：\n\n1. 构造方法的结构是固定的\n\n   ```php\n   public function __construct([形参列表]){\n       方法体\n   }\n   ```\n\n2. 只有当通过new关键字实例化一个对象时，构造方法才会被php自动调用执行，而且是new一次就自动调用执行一次；\n\n3. php不负责定义构造方法，只负责自动在第\"2\"点所说的时机中自动调用；\n\n\n\n#### 老版本的构造方法\n\n**说明**：在php中，早期版本的**==构造方法的方法名==**与所在**==类的类名==**一致。\n\n\n\n**==需求==**：使用老版本的构造方法完成对属性的赋值操作，定义名为Person的类，\n\n1. 在Person类中定义两个非静态成员属性，名分别为\"name\"和\"age\"，不指定值；\n2. 在类的外部基于Person类创建两个对象，第一个对象设置name的值为\"zhangsan\"，age的值为12，打印该对象；第二个对象设置name的值为lisi，age的值为16打印该对象；\n\n**==解答==**：构建名为code18.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    //非静态成员属性\n    public $name;\n    public $age;\n\n    //定义一个老版本的构造方法\n    public function Person($v1, $v2){ \n        \n        $this->name = $v1;\n        $this->age = $v2;\n    }\n}\n\n//创建一个$zhangsan对象\n$zhangsan = new Person('zhangsan', 12);\nvar_dump( $zhangsan ); echo '<hr/>';\n\n//创建一个$lisi对象\n$lisi = new Person('lisi', 16);\nvar_dump( $lisi ); \n```\n\n访问code18.php，输出的内容为：\n\n```php\n#因为老版本的构造方法在php7.x以后被归结到过时的语法中，所以，在项目中，应该选择使用__construct作为构造方法名\nDeprecated: Methods with the same name as their class will not be constructors in a future version of PHP; Person has a deprecated constructor in F:\\home\\class\\day6\\code\\code18.php on line 3\n#$zhangsan对象的输出内容\nobject(Person)#1 (2) { [\"name\"]=> string(8) \"zhangsan\" [\"age\"]=> int(12) }\n#$lisi对象的输出内容\nobject(Person)#2 (2) { [\"name\"]=> string(4) \"lisi\" [\"age\"]=> int(16) }\n```\n\n\n\n**==小结==**：\n\n1. 老版本的构造方法是一个过时的语法；\n\n\n\n### 析构方法\n\n==**定义语法**==\n\n```php\nclass 类名{\n    //定义类中的析构方法\n    public function __destruct(){\n    \t#方法体\n\t}\n}\n```\n\n\n\n**==需求==**：定义名为Person的类，\n\n1. 在Person类中定义1个非静态成员属性，名为\"link\"，不指定值；\n2. 在Person类中定义1个构造方法，实现创建一个画布，并且将创建的画布资源保存给\"link\"；\n3. 在类的外部创建2个基于Person类的对象，将2个对象打印出来；\n4. 然后使用unset删除第一个创建的对象，查看最终效果；\n\n**==解答==**：构建名为code19.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n    public $link;\n\n    public function __construct(){ \n        \n        $this->link = imagecreate(400, 300);\n    }\n\n    //定义析构方法\n    public function __destruct(){ \n        echo '执行了析构方法'; \n    }\n}\n\n//创建第一个对象\n$obj1 = new Person;\nvar_dump( $obj1 ); echo '<hr/>';\n$obj2 = new Person;\nvar_dump( $obj2 ); echo '<hr/>';\n\n//删除第一个对象\nunset($obj1);\n```\n\n访问code19.php，输出的内容为：\n\n```mysql\n#$obj1对象输出的内容\nobject(Person)#1 (1) { [\"link\"]=> resource(2) of type (gd) }\n#$obj2对象输出的内容\nobject(Person)#2 (1) { [\"link\"]=> resource(3) of type (gd) }\n#第一个输出的\"执行了析构方法\"内容是unset删除$obj1对象时输出的内容\n#第二个输出的\"执行了析构方法\"内容是程序执行完毕，保存对象的变量$obj2自动销毁，导致对象被销毁时触发php执行析构方法输出的内容\n执行了析构方法执行了析构方法\n```\n\n\n\n**==小结==**：\n\n1. 析构方法的结构是固定的：\n\n   ```php\n   public function __destruct(){\n       #方法体\n   }\n   ```\n\n2. php不负责定义析构方法，只负责调用析构方法；\n\n3. 当对象被销毁时，将会触发php自动调用执行析构方法；\n\n4. 对象被销毁的两种情况：1)手动使用unset函数删除保存对象的变量；2）当程序执行结束时，保存对象的变量也将会被自动销毁；\n\n\n\n### 对象的传值\n\n在程序中，对象是保存在变量中的，变量存在值传递和引用传递，所以对象也就存在值传递和引用传递。 \n\n\n\n#### 对象的引用传递与对象的值传递的效果\n\n**==需求1==**：实现对象的引用传递，定义名为Person的类，\n\n1. 在Person类中定义1个非静态成员属性，名为\"name\"，值为\"zhangsan\"；\n2. 在类的外部创建第一个基于Person类的对象保存到变量$obj1中，将$obj1以引用传递赋值的方式赋值给$obj2变量，分别将两个对象都打印出来；\n3. 改变$obj2中的name值为lisi，再次将两个对象打印出来，查看最终效果；\n\n**==解答1==**：构建名为code21.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n\n    public $name='zhangsan';\n}\n\n//创建一个对象\n$obj1 = new Person;\n\n//使用引用传递将$obj1赋值给$obj2\n$obj2 = &$obj1;\n\necho '改变$obj2的name属性值之前<br/>'; \necho '$obj1：'; var_dump( $obj1 ); echo '<br/>';\necho '$obj2：'; var_dump( $obj2 );  echo '<hr/>';\n\n//修改$obj2对象中$name属性的值\n$obj2->name = 'lisi';\n\necho '改变$obj2的name属性值之后<br/>';\necho '$obj1：'; var_dump( $obj1 ); echo '<br/>';\necho '$obj2：'; var_dump( $obj2 );  \n```\n\n访问code21.php，输出的内容为：\n\n```php\n改变$obj2的name属性值之前\n$obj1：object(Person)#1 (1) { [\"name\"]=> string(8) \"zhangsan\" } \n$obj2：object(Person)#1 (1) { [\"name\"]=> string(8) \"zhangsan\" }\n改变$obj2的name属性值之后\n$obj1：object(Person)#1 (1) { [\"name\"]=> string(4) \"lisi\" } \n$obj2：object(Person)#1 (1) { [\"name\"]=> string(4) \"lisi\" }\n```\n\n\n\n**==小结==**：\n\n1. 对象的引用 传递与变量的引用传递从效果上来是一样的，改变其中一个对象成员的值，也会影响另外一个对象成员的值；\n\n\n\n**==需求1==**：实现对象的值传递，定义名为Person的类，\n\n1. 在Person类中定义1个非静态成员属性，名为\"name\"，值为\"zhangsan\"；\n2. 在类的外部创建第一个基于Person类的对象保存到变量$obj1中，将$obj1以值传递赋值的方式赋值给$obj2变量，分别将两个对象都打印出来；\n3. 改变$obj2中的name值为lisi，再次将两个对象打印出来，查看最终效果；\n\n**==解答1==**：构建名为code22.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass Person{\n\n    public $name='zhangsan';\n}\n\n//创建一个对象\n$obj1 = new Person;\n\n//使用值传递将$obj1赋值给$obj2\n$obj2 = $obj1;\n\necho '改变$obj2的name属性值之前<br/>'; \necho '$obj1：'; var_dump( $obj1 ); echo '<br/>';\necho '$obj2：'; var_dump( $obj2 );  echo '<hr/>';\n\n//修改$obj2对象中$name属性的值\n$obj2->name = 'lisi';\n\necho '改变$obj2的name属性值之后<br/>';\necho '$obj1：'; var_dump( $obj1 ); echo '<br/>';\necho '$obj2：'; var_dump( $obj2 );  \n```\n\n访问code22.php，输出的内容为：\n\n```mysql\n改变$obj2的name属性值之前\n$obj1：object(Person)#1 (1) { [\"name\"]=> string(8) \"zhangsan\" } \n$obj2：object(Person)#1 (1) { [\"name\"]=> string(8) \"zhangsan\" }\n改变$obj2的name属性值之后\n$obj1：object(Person)#1 (1) { [\"name\"]=> string(4) \"lisi\" } \n$obj2：object(Person)#1 (1) { [\"name\"]=> string(4) \"lisi\" }\n```\n\n\n\n**==小结==**：\n\n1. 从效果上看，对象的值传递效果与对象的引用传递效果一致，改变其中一个对象成员的值，也影响到了另外一个对象成员的值。\n\n\n\n**==提问==**：为什么导致对象的值传递效果与对象的引用传递效果是一样呢？\n\n#### 对象的引用传递与对象的值传递的原理\n\n对象的引用传递 原理图：\n\n![1530264153036](6_1.png)\n\n\n\n对象的值传递 原理图：\n\n![1530264374560](7_1.png)\n\n\n\n**==小结==**：\n\n1. 通过以上案例和原理的分析，我们发现，无论是对象的值传递还是对象的引用传递，效果都一样，最终我们没有办法通过值传递或者是引用传递的方式得到一个全新的对象空间。\n2. 所以，到目前为止，我们只学习了一种方式能够得到全新的对象空间，这种方式就是实例化new的方式。\n\n\n\n### 对象的克隆\n\n==克隆语法==：\n\n```php\nclass A{}\n$obj1 = new A;\n\n#基于一个已有的对象克隆出一个新的对象操作如下\n$obj2 = clone $obj1;\n```\n\n\n\n**==需求1==**：定义名为soldierPig的类，\n\n1. 在soldierPig类中定义4个非静态成员属性，名分别为\"name、blood、defence、attack\"，不指定值；\n2. 在soldierPig类中定义一个构造方法，实现对4个属性的自动赋值；\n3. 在类的外部使用实例化的方式创建一个基于soldierPig类的对象，保存到$z_boss中，值分别为：（烈火，10000， 2000， 1000）；\n4. 在类的外部使用实例化的方式创建一个基于soldierPig类的对象，保存到$z1中，值分别为：（野猪，1000， 200， 100）；\n5. 基于$z1克隆出$z2、$z3对象，同时改名为野猪1和野猪2；\n\n**==解答1==**：构建名为code23.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass soldierPig{\n    \n    public $name;\n    public $blood;\n    public $defence;\n    public $attack;\n    //构造方法\n    public function __construct($v1, $v2, $v3, $v4){ \n        \n        $this->name = $v1;\n        $this->blood = $v2;\n        $this->defence = $v3;\n        $this->attack = $v4;\n    }\n}\n\n$z_boss = new soldierPig('烈火', 10000, 2000, 1000);\nvar_dump( $z_boss ); echo '<hr/>';\n\n$z1 = new soldierPig('野猪', 1000, 200, 100);\nvar_dump( $z1 ); echo '<br/>';\n#使用克隆的方式克隆出更多的小野怪对象，因为这些小野怪大部分的属性都是一样\n$z2 = clone $z1;\n$z2->name = '野猪1';\nvar_dump( $z2 ); echo '<br/>';\n\n$z3 = clone $z2;\n$z3->name = '野猪2';\nvar_dump( $z3 ); \n```\n\n访问code23.php，输出的内容为：\n\n```mysql\n#$z_boss输出的内容\nobject(soldierPig)#1 (4) { [\"name\"]=> string(6) \"烈火\" [\"blood\"]=> int(10000) [\"defence\"]=> int(2000) [\"attack\"]=> int(1000) }\n#$z1输出的内容\nobject(soldierPig)#2 (4) { [\"name\"]=> string(6) \"野猪\" [\"blood\"]=> int(1000) [\"defence\"]=> int(200) [\"attack\"]=> int(100) } \n#$z2输出的内容\nobject(soldierPig)#3 (4) { [\"name\"]=> string(7) \"野猪1\" [\"blood\"]=> int(1000) [\"defence\"]=> int(200) [\"attack\"]=> int(100) } \n#$z3输出的内容\nobject(soldierPig)#4 (4) { [\"name\"]=> string(7) \"野猪2\" [\"blood\"]=> int(1000) [\"defence\"]=> int(200) [\"attack\"]=> int(100) }\n```\n\n\n\n**==小结==**：\n\n1. 我们可以使用clone关键字来直接克隆（复制）一个已有的对象，形成一个全新的对象空间；\n\n\n\n**提问**：上面这个案例中，每次克隆后都需要手动改名，比较麻烦，有没有方法能够让我们在克隆的同时就自动按照设定好的规则将名字进行修改呢？\n\n### __clone魔术方法\n\n==定义语法==：\n\n```php\nclass 类名{\n    \n    public function __clone(){\n        #方法体\n    }\n}\n```\n\n\n\n**==需求1==**：使用克隆魔术方法实现自动改名，定义名为soldierPig的类，\n\n1. 在soldierPig类中定义4个非静态成员属性，名分别为\"name、blood、defence、attack\"，不指定值；\n2. 在soldierPig类中定义一个构造方法，实现对4个属性的自动赋值；\n3. 在类的外部使用实例化的方式创建一个基于soldierPig类的对象，保存到$z1中，值分别为：（野猪，1000， 200， 100）；\n4. 基于$z1克隆出$z2、$z3对象，同时实现自动改名为野猪1和野猪2；\n\n**==解答1==**：构建名为code24.php的程序文件，代码如下：\n\n```php\n<?php\n\nclass soldierPig{\n    \n    public $name;\n    public $blood;\n    public $defence;\n    public $attack;\n\n    public static $num=0;//定义了一个静态成员属性\n\n    //构造方法\n    public function __construct($v1, $v2, $v3, $v4){ \n        \n        $this->name = $v1;\n        $this->blood = $v2;\n        $this->defence = $v3;\n        $this->attack = $v4;\n    }\n    //定义一个__clone魔术方法\n    public function __clone(){ \n        \n        self::$num++;//先自增\n        $this->name = '野猪' . self::$num;//然后再拼接名字\n    }\n}\n\n$z1 = new soldierPig('野猪', 1000, 200, 100);\nvar_dump( $z1 ); echo '<br/>';\n#使用克隆的方式克隆出更多的小野怪对象，因为这些小野怪大部分的属性都是一样\n$z2 = clone $z1;\nvar_dump( $z2 ); echo '<br/>';\n\n$z3 = clone $z2;\nvar_dump( $z3 ); \n```\n\n访问code24.php，输出的内容为：\n\n```mysql\n#$z1输出的内容\nobject(soldierPig)#1 (4) { [\"name\"]=> string(6) \"野猪\" [\"blood\"]=> int(1000) [\"defence\"]=> int(200) [\"attack\"]=> int(100) } \n#$z2输出的内容\nobject(soldierPig)#2 (4) { [\"name\"]=> string(7) \"野猪1\" [\"blood\"]=> int(1000) [\"defence\"]=> int(200) [\"attack\"]=> int(100) } \n#$z3输出的内容\nobject(soldierPig)#3 (4) { [\"name\"]=> string(7) \"野猪2\" [\"blood\"]=> int(1000) [\"defence\"]=> int(200) [\"attack\"]=> int(100) }\n```\n\n\n\n**==小结==**：\n\n1. 克隆魔术方法结构是固定的\n\n```php\npublic function __clone(){\n        #方法体\n}\n```\n\n2. php不负责定义克隆魔术方法，只负责调用这个方法；\n3. 当clone一个对象时，将会触发php调用这个魔术方法自动执行一次；\n\n## 3. 全天总结\n\n1. 类的定义\n\n   ```php\n   class 类名{\n       \n       类成员\n   }\n   ```\n\n2. 类成员\n\n   1）成员属性；2）成员方法；3）类常量\n\n   成员属性包括：a)静态成员属性  b)非静态成员属性\n\n   成员方法包括：a)静态成员方法  b)非静态成员方法\n\n   类常量\n\n3. 类成员的定义\n\n   ```php\n   class demo{\n       \n       #成员属性\n       public $var1;//非静态\n       public static $var2;//静态\n       \n       #类常量\n       const AREA='GZ';\n       \n       #成员方法\n       public function f1(){//非静态\n           \n           #方法体或返回值\n       }\n       \n       public static function f2(){//静态\n           \n           #方法体或返回值\n       }\n   }\n   ```\n\n4. 类成员的调用\n\n   外部调用\n\n    \t1. 静态成员（属性和方法）:  类名::$属性名；       类名::方法名([实参列表]);\n   \t2. 非静态成员（属性和方法）： $对象变量名->属性名;        $对象变量名->方法名([实参列表]);\n   \t3. 类常量：  类名::类常量名；\n\n   内部调用\n\n   1. 静态成员（属性和方法）:  类名::$属性名；       类名::方法名([实参列表]);\n\n      **==类名可以被self关键字代替==**\n\n   2. 非静态成员（属性和方法）： $this->属性名;        $this->方法名([实参列表]);\n\n      在静态方法中不能访问非静态成员（属性和方法）\n\n   3. 类常量：  类名::类常量名；\n\n      **==类名可以被self关键字代替==**\n\n5. 构造方法\n\n   ```php\n   public function __construct([形参列表]){\n       #方法体\n   }\n   ```\n\n   php不负责定义，只负责在new一个对象时自动调用\n\n6. 析构方法\n\n   ```php\n   public function __destruct(){\n       #方法体\n   }\n   ```\n\n   php不负责定义，只负责在对象被销毁的时候自动调用（包括unset删除保存对象的变量或者程序执行结束）\n\n7. 对象的克隆\n\n   1. 使用关键字clone可以实现对象的克隆；\n\n   2. __clone魔术方法\n\n      ```php\n      public function __clone(){\n          #方法体\n      }\n      ```\n\n      php不负责定义，只负责在使用clone关键字克隆对象时被php自动调用；\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["PHP面向对象编程"]},{"title":"博客项目4","url":"%2Fposts%2F2661724692%2F","content":"\n\n# 一、昨日回顾\n\n## 1. 知识回顾\n\n1. mvc的三大组件是什么？\n\n   M：model     模型\n\n   V：view          视图\n\n   C：Controller     控制器\n\n2. mvc的三大组件分别代表什么意思？\n\n   M：专门用来操作数据表的\n\n   V：专门用来展示视图模板的\n\n   C：专门用来处理业务逻辑，比如说什么时候该调用模型操作数据，什么时候该调用视图展示模板，都是由控制器里来处理。\n\n\n\n## 2. 昨日反馈\n\n![1531270551320](114)\n\n# 二、知识路径\n\n- web项目开发流程介绍\n\n- 需求分析\n\n  ​\t功能分析\n\n  ​\tER图设计\n\n- 表设计\n\n- 项目部署\n\n- 项目实现\n\n  ​\t实现后台用户管理系统\n\n  ​\t封装验证码工具类\n\n==目标：能够设计项目所需的表、能够部署自主框架、能够实现后台用户管理系统==\n\n# 三、今日课程内容：博客项目\n\n## 1. web项目开发流程介绍\n\n1)制定计划：博客项目(blog31)  开发周期：4天\n\n2)需求分析：功能分析  ER图设计\n\n3)软件设计：项目环境  表设计\n\n4)程序编写\n\n5)软件测试\n\n6)运行维护\n\n\n\n## 2. 需求分析\n\n### 功能分析\n\n1. 后台用户管理系统；\n2. 后台分类管理系统；\n3. 后台博文管理系统；\n4. 评论管理系统；\n5. 后台登陆和七天免登录；\n6. 前台首页；\n7. 前台注册和登陆功能；\n8. 前台博客文章详情页；\n\n\n\n### ER图设计\n\nE-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。它是描述现实世界概念结构模型的有效方法。是表示概念模型的一种方式，用矩形表示实体型，矩形框内写明实体名；用椭圆表示实体的属性，并用无向边将其与相应的实体型连接起来；用菱形表示实体型之间的联系，在菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1,1:n或m:n）。\n\n \n\n专业的ER图工具：Viso和Power Designer\n\n \n\n==实体== ==》表：矩形表示\n\n==属性== ==》表字段：椭圆\n\n==关系== ==》表与表的关系：菱形（1:1表示1对1关系；1:n表示1对多关系；m:n表示多对多关系）\n\n\n\n博客项目的ER关系图如下： \n\n![1531279764230](1)\n\n\n\n## 3. 表设计\n\n```mysql\ndrop database blog31;\ncreate database blog31;\n\n#############用户表：\nCREATE TABLE `bg_user` (\n  `id` int unsigned auto_increment,\n  `acc` varchar(50) not null default '' COMMENT '帐号',\n  `nickname` varchar(30) not null default '' COMMENT '昵称',\n  `pwd` char(32) not null default '' COMMENT '密码',\n  `cell` varchar(15) not null default '' COMMENT '手机号',\n  `regtime` int unsigned default 0 COMMENT '注册时间',\n  `type` tinyint unsigned not null default 0 COMMENT '用户类型 0:普通用户 1:管理员',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n#############博客文章表：\nCREATE TABLE `bg_article` (\n  `id` int(11) unsigned AUTO_INCREMENT,\n  `title` varchar(100) not null default '' COMMENT '文章标题',\n  `intro` varchar(255) not null default '' COMMENT '文章简介',\n  `content` text not null,\n  `post_date` int unsigned not null default 0 COMMENT '发布时间',\n  `user_id` int unsigned not null default 0 COMMENT '发布管理员id',\n  `user_nickname` varchar(30) not null default '' COMMENT '发布管理员昵称',\n  `comment_num` smallint unsigned not null default 0 COMMENT '评论数量',\n  `cat_id` int unsigned not null default 0 COMMENT '所属分类id',\n  `cat_name` varchar(30) not null default '' COMMENT '所属分类名称',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n#############博客文章分类表：\nCREATE TABLE `bg_category` (\n  `id` int unsigned AUTO_INCREMENT,\n  `name` varchar(30) not null COMMENT '分类名称',\n  `parent_id` int unsigned not null default '0' COMMENT '上级分类ID，0表示顶级分类',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n\n\n#############评论表：\nCREATE TABLE `bg_comment` (\n  `id` int unsigned AUTO_INCREMENT,\n  `content` text not null,\n  `post_date` int unsigned not null default 0 COMMENT '评论时间',\n  `article_id` int unsigned not null default 0 COMMENT '所属文章ID',\n  `article_title` varchar(50)  not null default '' COMMENT '所属文章标题',\n  `user_id` int unsigned not null default 0 COMMENT '用户ID',\n  `user_nickname` varchar(30)  not null default '' COMMENT '用户昵称',\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM CHARSET=utf8;\n```\n\n\n\n## 4. 项目部署\n\n1. 将code/mvc目录改名为blog31，\n\n   下图这个mvc目录：\n\n   ![1531291206947](2)\n\n   改名为blog31:\n\n   ![1531291235746](3)\n\n2. 配置一个基于域名虚拟主机，域名为www.blog31.com\n\n   在httpd-vhosts.conf文件中增加如下图所示的虚拟主机配置项：\n\n   ![1531291311545](4)\n\n   修改hosts文件，\n\n   ![1531291371313](5)\n\n3. 重启apache，测试访问效果：\n\n   ![1531291456736](6)\n\n   访问效果为：\n\n   ![1531291515331](7)\n\n   能够看到上图，则说明部署成功。\n\n\n\n## 5. 项目实现\n\n### 实现后台用户管理系统\n\n#### 实现列表页\n\n1. 将code/templates/admin目录中如下图所示的目录复制一份，\n\n   ![1531291763786](8)\n\n   转移拷贝到code/blog31/app/admin/view目录中，\n\n   ![1531291818821](9)\n\n2. 在blog31/app/admin/controller目录中创建一个名为UserController.class.php的文件，\n\n   ![1531291945355](10)\n\n3. 在blog31/app/admin/controller/UserController.class.php中构建如下代码，展示三个页面，\n\n   ![1531292339989](11)\n\n4. 测试访问后台用户管理系统列表页\n\n   ![1531292433660](12)\n\n5. 进一步做调整，将后台模板使用到的资源文件全部转移进项目中，\n\n   在blog31/public目录中创建一个名为admin的目录，专门保存后台的资源文件，\n\n   ![1531292599939](13)\n\n   复制code/templates/admin/libs目录下的所有文件，如下图所示，\n\n   ![1531292644972](14)\n\n   转移拷贝到blog31/public/admin目录中，\n\n   ![1531292690333](15)\n\n6. 调整blog31/app/admin/view/User/userIndex.html中引入资源文件的路径，\n\n   在blog31/conf/conf.php中增加本网站域名配置项，\n\n   ![1531293146377](16)\n\n   然后在blog31/app/admin/view/User/userIndex.html使用配置项URL的值来引入配置文件，\n\n   ![1531293430682](17)\n\n   ![1531293486446](18)\n\n   上图中替换的是所有图片文件引入路径，截取不全，实际替换的内容以blog31/app/admin/view/User/userIndex.html中的为准。\n\n7. 再次测试访问后台新闻管理系统列表页，\n\n   ![1531293567621](19)\n\n8. 在blog31/app/model目录中创建UserModel.class.php文件，\n\n   ![1531293712684](20)\n\n   内容如下：\n\n   ![1531293731152](21)\n\n   调整blog31/conf/conf.php中PDO配置项的默认选择的数据库名，\n\n   ![1531294133397](22)\n\n9. 在blog31/app/admin/controller/UserController.class.php中showIndex方法里渲染模板之前调用模型查询数据，\n\n   ![1531294688749](23)\n\n   然后在blog31/app/admin/view/User/userIndex.html中回显查询得到的用户数据，\n\n   ![1531294782348](24)\n\n   测试访问后台用户管理系统列表页：\n\n   ![1531294828901](25)\n\n#### 实现添加页\n\n1. 访问后台用户管理系统添加页，\n\n   ![1531295330114](26)\n\n2. 调整blog31/app/admin/view/User/userAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531295483768](27)\n\n3. 调整blog31/app/admin/view/User/userAdd.html中的form表单域各项的值，\n\n   ![1531295777460](28)\n\n4. 在blog31/app/admin/controller/UserController.class.php中创建一个处理添加用户的方法，adh方法，\n\n   ![1531296464355](29)\n\n5. 测试添加用户使用效果：\n\n   在添加表单页面构建数据，点击提交，\n\n   ![1531296568559](30)\n   提交后的效果：\n\n   ![1531296591547](31)\n\n   效果为添加成功，说明功能实现OK。\n\n#### 实现编辑页\n\n1. 访问后台新闻管理系统编辑页：\n\n   ![1531296743041](32)\n\n2. 修改blog31/app/admin/view/User/userIndex.html中编辑按钮的链接：\n\n   ![1531296871382](33)\n\n3. 调整blog31/app/admin/view/User/userEdit.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531296956168](34)\n\n4. 调整blog31/app/admin/view/User/userEdit.html中form表单里的代码，\n\n   ![1531297468408](35)\n\n5. 在blog31/app/admin/controller/UserController.class.php中创建updh方法，代码如下：\n\n   ![1531301022079](36)\n\n6. 测试使用效果：\n\n   点击进入编辑也，如下图所示：\n\n   ![1531301120317](37)\n\n   修改数据，\n\n   ![1531301172674](38)\n\n   点击更新，\n\n   ![1531301192522](39)\n\n   跳回到更新页面：\n\n   ![1531301213845](40)\n\n   密码也是被改变了的，如下图所示：\n\n   ![1531301252698](41)\n\n   说明编辑功能实现OK。\n\n\n\n## 6. 全天总结\n\n1. 项目中的建表部分：\n\n   如果某字段是需要保存时间，一般在PHP的项目中给int数据类型；\n\n   如果某字段需要保存状态类型的值，使用tinyint会更加好；\n\n   如果某字段保存的数据，我们可以预期的很准确，比如说手机号码，通常就是11位，但是我们在项目中一般会采取宁大不小的原则，给11位以上的值，比如给varchar(15)；\n\n   在构建字段的时候，我们一般都会给字段设置default默认值，如果不设置默认值，则今后这个字段无论是否需要添加数据，都必须指定上值。\n\n2. 项目开发部分：\n\n   我们使用框架进行开发，一般程序开发人员从模板入手，先尝试展示出模板页面的效果，然后再考虑是否需要调用模型操作数据库的问题，所以我们通常在MVC框架中，1）首先会将模板页面转移进项目目录；2）然后会创建控制器类，构建方法调用视图展示模板页面；3）调试模板页面展示的效果；4）以上都成功之后，如果没有模型则需要创建模型，如果有模型则直接去考虑调用模型操作数据；\n\n\n\n# 四、昨日回顾\n\n## 1. 知识回顾\n\n1. 建表注意事项：\n\n   如果在项目中要保存一个时间的数据，则我们一般选择使用int类型来保存；\n\n   如果在项目中要保存一个状态或类型这样的数据时，我们一般选择使用tinyint类型来保存；\n\n   如果在项目中能够明确要保存的数据需要占多少个字节时，我们一般采用的做法是宁大不小，比如，保存手机号码一般是11位，但是我们通常会选择给varchar(15)\n\n   如果在项目中构建字段时，通常我们会给字段指定一个默认值，一方面方便程序的默认操作，比如注册时，如果给用户类型指定了默认值为0表示普通会员，则构建注册功能的代码就无需给这个字段设置值，MYSQL会直接给这个字段用上默认值；另外一方面可以避免在添加数据操作时，如果没给这个字段指定值，将会报错的情况。\n\n2. 在项目代码开发中的基本流程是：\n\n   1）从模板文件入手，创建相关的控制器类和该类中的相应方法，渲染模板展示到浏览器；\n\n   2）在方法中渲染模板之前调用模型操作数据，比如我们之前开发的后台用户管理系统列表页，在渲染列表页模板之前，我们需要调用模型把列表页需要展示的数据查询出来；如果没有模型，则需要创建模型，如果有，则直接使用；\n\n   3）在方法中构建逻辑处理代码，生成相关功能；\n\n\n\n## 2. 昨日反馈\n\n![1531406278112](42)\n\n\n\n# 五、知识路径\n\n# 六、今日课程内容：博客项目\n\n## 1. 封装验证码工具类\n\n1. 在blog31/plugins目录下创建CaptchaTool.class.php的文件，\n\n   ![1531449474729](50)\n\n   构建的代码如下，\n\n   ```php\n   <?php\n   namespace plugins;//创建一个   全局空间  下的  plugins空间\n   \n   class CaptchaTool{\n   \n       private $_w;//画布的宽度\n       private $_h;//画布的高度\n   \n       private $_img;//画布资源\n       \n       public function __construct($w=200, $h=80){ \n           \n           #初始化参数\n           $this->_w = $w;\n           $this->_h = $h;\n   \n           $this->_img = imagecreatetruecolor($this->_w, $this->_h);//创建画布\n   \n           #填充背景色\n           $color = $this->color();//获得随机色\n           imagefill($this->_img, 0, 0, $color);//填充背景色\n   \n           #写字\n           $randStr = $this->randStr();//构建4个随机字\n           $color = $this->color();//获得随机色\n           $fontPath = PUBLIC_PATH . '/fonts/font1.ttf';//字体文件所在路径\n           $bx = $this->_w/4;//左下角起点x坐标\n           $by = $this->_h*3/4;//左下角起点y坐标\n           $fontSize = $this->_h *37/80;//字体大小，高度尺寸的37/80\n   \n           imagettftext($this->_img, $fontSize, 0, $bx, $by, $color, $fontPath, $randStr);//写字\n   \n           #设置干扰元素\n           //设置干扰点\n           $this->setPoint(180);\n   \n           //设置干扰线\n           $this->setLine(8);\n       }\n   \n       #画干扰线\n       private function setLine($num){ \n   \n           for($i=0; $i<$num; $i++ ){ //画$num个点\n               $color = $this->color();//获得随机色\n   \n               $bx = mt_rand(0, $this->_w/2);//起点x坐标\n               $by = mt_rand(0, $this->_h);//起点y坐标\n               $ex = mt_rand($this->_w/2, $this->_w);//终点x坐标\n               $ey = mt_rand(0, $this->_h);//终点y坐标\n   \n               imageline($this->_img, $bx, $by, $ex, $ey, $color);//画点\n           }\n       }\n   \n       #画干扰点\n       private function setPoint($num){ \n   \n           for($i=0; $i<$num; $i++ ){ //画$num个点\n               $color = $this->color();//获得随机色\n   \n               $bx = mt_rand(0, $this->_w);//起点x坐标\n               $by = mt_rand(0, $this->_h);//起点y坐标\n               $ex = mt_rand($bx-2, $bx+2);//终点x坐标\n               $ey = mt_rand($by-2, $by+2);//终点y坐标\n   \n               imageline($this->_img, $bx, $by, $ex, $ey, $color);//画点\n           }\n       }\n   \n       #构建随机字\n       private function randStr($num=4){ \n           \n           $mixedArr = array_merge(range('a', 'z'), range('A', 'Z'), range(0, 9));//构建随机字采集库\n   \n           $str = '';\n           for($i=0; $i<$num; $i++ ){ //采集$num次\n               \n               $key = mt_rand(0, count($mixedArr)-1);//取得当前随机字符对应的元素下标\n               $str .= $mixedArr[$key];//从字库中取得下标为$key的元素值拼接给$str\n           }\n   \n           return $str;\n           \n       }\n   \n       #分配颜色\n       private function color($r='', $g='', $b=''){ \n           \n           //初始化三原色\n           $r = ($r==='') ? mt_rand(0, 255) : $r;//红\n           $g = ($g==='') ? mt_rand(0, 255) : $g;//绿\n           $b = ($b==='') ? mt_rand(0, 255) : $b;//蓝\n   \n           //分配颜色\n           return imagecolorallocate($this->_img, $r, $g, $b);\n       }\n   \n       #输出图像的方法\n       public function output(){ \n           \n           header('Content-type:image/jpeg');//指定一个响应协议项\n   \n           imagejpeg($this->_img);//直接将图像输出到浏览器\n       }\n   }\n   ```\n\n2. 在blog31/public下创建fonts目录，\n\n   ![1531449570234](51)\n\n   将F:\\home\\class\\day15\\source\\font1.ttf复制转移到blog31/public/fonts目录中，\n\n   ![1531449634142](52)\n\n3. 在blog31/conf/define.php中定义一个目录常量，\n\n   ![1531449686817](53)\n\n4. 在blog31/core/App.class.php中的autoload方法中实现对工具类的自动加载，\n\n   ![1531449747232](54)\n\n5. 测试使用工具类，\n\n   在blog31/app/admin/controller/UserController.class.php中构建测试方法test，代码如下：\n\n   ![1531449796360](55)\n\n   访问test方法，\n\n   ![1531449846347](56)\n\n   验证码制作成功。\n\n\n\n## 2. 实现后台分类管理系统\n\n在blog31/app/admin/controller中创建名为CatController.class.php文件，专门用于操作后台分类管理系统各程序，\n\n![1531406458061](43)\n\n代码如下：\n\n![1531406531563](44)\n\n\n\n### 实现列表页\n\n1. 在blog31/app/admin/controller/CatController.class.php中创建名为showList的方法，渲染后台分类列表页模板，\n\n   ![1531406637793](45)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=cat&a=showIndex访问后台分类管理系统列表页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/categoryIndex.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531406850800](46)\n\n3. 在blog31/app/model目录下创建CatModel.class.php的文件，\n\n   ![1531450315893](57)\n\n   代码如下：\n\n   ![1531450340259](58)\n\n4. 在blog31/app/admin/controller/CatController.class.php文件showList方法中构建如下代码，\n\n   ![1531451514806](59)\n\n   调整模板文件回显查询的数据blog31/app/admin/view/Category/categoryIndex.html：\n\n   ![1531451572387](60)\n\n5. 访问后台分类管理系统列表页：\n\n   ![1531451726375](61)\n\n\n\n我们进一步调整程序，将所有分类数据进行整理，\n\n#### 实现无限级递归分类\n\n1. 在blog31/app/admin/controller/CatController.class.php文件中创建两个方法，代码和作用如下图所示：\n\n   ![1531465269865](62)\n\n   ![1531465303880](63)\n\n2. 然后在blog31/app/admin/controller/CatController.class.php文件中的showList方法里调整获得所有分类数据的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531465362917](64)\n\n3. 调整模板页面中的代码，在输出分类名称之前还需要输出缩进符，\n\n   ![1531465455827](65)\n\n4. 测试最终效果：\n\n   访问后台分类管理系统列表页\n\n   ![1531465510155](66)\n\n\n\n### 实现添加页\n\n1. 在blog31/app/controller/CatController.class.php中创建名为showAd的方法，渲染后台分类添加页模板，\n\n   ![1531407090431](47)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=cat&a=showAd访问后台分类管理系统添加页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/categoryAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531406850800](46)\n\n3. \n\n\n\n\n\n### 实现编辑页\n\n1. 调整blog31/app/admin/view/Category/categoryIndex.html中的编辑按钮链接，\n\n   ![1531465870984](67)\n\n2. 在blog31/app/admin/controller/CatController.class.php中创建名为showUpd的方法，渲染后台分类编辑页模板，\n\n   ![1531465965417](68)\n\n3. 通过从后台分类列表页点击编辑按钮访问后台分类管理系统编辑页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/categoryEdit.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531466023359](69)\n\n4. 在blog31/app/admin/controller/CatController.class.php中的showUpd方法里构建相应的程序功能代码，如下图所示：\n\n   ![1531466996992](70)\n\n5. 调整blog31/app/admin/view/Category/categoryEdit.html中需要回显数据的部分及表单域的相关属性值，\n\n   ![1531467078936](71)\n\n6. 在blog31/app/admin/controller/CatController.class.php构建updh方法，代码如下：\n\n   ```php\n   //编辑处理方法\n   public function updh(){ \n   \n       //接收表单提交的数据\n       $id = $_GET['id'];\n   \n       $name = trim($_POST['name']);//新的分类名称\n       $old_name = trim($_POST['old_name']);//老的分类名称\n       $parent_id = trim($_POST['parent_id']);//新的父级id\n       $old_parent_id = trim($_POST['old_parent_id']);//老的父级id\n   \n       //检查是否有数据真的被修改了\n       $target = [];\n   \n       if( $name!=$old_name && $name!='' ){//如果新的名称不等于老的名称并且新的名称不为空，则需要修改name值\n           $target[] = \"name='{$name}'\";\n       }\n   \n       if( $parent_id!=$old_parent_id ){//如果新的父级id不等于老的父级id\n           $target[] = \"parent_id={$parent_id}\";\n       }\n   \n       if( !empty($target) ){//如果$target不为空，说明有数据需要被更新\n   \n           $strTarget = implode(', ', $target);//  $strTarget=\"name='xxxx', parent_id=xxxx\";\n           $sql = \"update bg_category set {$strTarget} where id={$id}\";\n   \n           //调用模型执行更新操作\n           $model = \\core\\App::single('\\model\\CatModel');\n           $re = $model->setData($sql);\n   \n           if( $re ){//更新成功\n               echo '嘿嘿嘿，运气不错，更新成功咯～'; \n           }else{//更新失败\n               echo '哈哈哈，你更新失败了！'; \n           }\n       }else{//否则给出提示没有数据被更新\n           echo '您当前还没有更新数据哟～'; \n       }\n   \n       //2秒之后跳转回编辑页\n       $url = C('URL') . '/index.php?p=admin&m=cat&a=showUpd&id='.$id;\n       header('Refresh:2; url='.$url);\n       exit;\n   }\n   ```\n\n7. 测试使用效果，效果OK，功能成功。\n\n\n\n### 实现删除功能\n\n\n\n\n\n## 3. 实现后台博文管理系统\n\n在blog31/app/admin/controller中创建名为ArticleController.class.php文件，专门用于操作后台博文管理系统各程序，\n\n![1531407704334](49)\n\n代码如下：\n\n![1531407665958](48)\n\n\n\n### 实现添加页\n\n1. 在blog31/app/controller/ArticleController.class.php中创建名为showAd的方法，渲染后台博文添加页模板，\n\n   ![1531468943273](72)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=article&a=showAd访问后台博文管理系统添加页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Article/articleAdd.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531469128676](73)\n\n3. 调整无限级递归分类方法的归属\n\n   将blog31/app/admin/controller/CatController.class.php文件中如下图所示的方法剪切下来，\n\n   ![1531470492230](74)\n\n   将剪切下来的代码全部粘贴到blog31/app/model/CatModel.class.php的类中，\n\n   ![1531470605131](75)\n\n   再调整blog31/app/model/CatModel.class.php内的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531470734590](76)\n\n   将blog31/app/admin/controller/CatController.class.php中的showUpd和showList方法调用无限级递归分类方法的方式进行调整，如下图中将蓝框部分改为红框部分：\n\n   ![1531470829870](77)\n\n   ![1531470912888](78)\n\n   在blog31/app/controller/ArticleController.class.php中showAd方法里添加如下代码：\n\n   ![1531472987997](81)\n\n4. 调整blog31/app/admin/view/Article/articleAdd.html中的表单各成员代码：\n\n   ![1531472047225](79)\n\n5. 在blog31/app/model下创建ArticleModel.class.php的文件，如下图所示：\n\n   ![1531472247204](80)\n\n6. 在blog31/app/controller/ArticleController.class.php中添加adh方法，处理添加功能，\n\n   ![1531473089893](82)\n\n7. 测试使用效果：\n\n   在添加页构建如下内容，\n\n   ![1531473145850](83.png)\n\n   点击添加按钮，效果为：\n\n   ![1531473185491](83)\n\n   说明添加功能OK。\n\n\n\n### 实现列表页\n\n1. 在blog31/app/admin/controller/ArticleController.class.php中创建名为showIndex的方法，渲染后台博文列表页模板，\n\n   ![1531473364554](84)\n\n2. 通过http://www.blog31.com/index.php?p=admin&m=article&a=showIndex访问后台博文管理系统列表页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Article/articleIndex.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531473422417](85)\n\n3. 在blog31/app/admin/controller/ArticleController.class.php中的showList方法里在渲染模板之前查询数据，\n\n   ![1531473884257](86)\n\n4. 将查得的数据在blog31/app/admin/view/Article/articleIndex.html中回显，\n\n   ![1531473945005](87)\n\n5. 测试访问效果：\n\n   ![1531473996556](88)\n\n\n\n#### 实现列表页分页\n\n1. 将day16/source/page.php中的函数全部复制拷贝一份，\n\n   ![1531531410027](90)\n\n   将上图拷贝的函数转移粘贴到blog31/core/Func.php中，\n\n   ![1531531489801](91)\n\n2. 在blog31/app/admin/controller/ArticleController.class.php中的showList方法里计算分页所需各种参数，并且调整查询数据的SQL语句，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531533560360](92)\n\n   调整blog31/app/admin/view/Article/articleIndex.html中展示分页HTML部分的代码，如下图所示将蓝框中的代码改为红框中的代码：\n\n   ![1531533622150](93)\n\n3. 测试访问效果：\n\n   ![1531533682781](94)\n\n\n\n#### 实现列表页序号\n\n1. 在blog31/app/admin/controller/ArticleController.class.php中showList方法里计算当前页第一条记录的序号，\n\n   ![1531535268048](95)\n\n2. 然后在模板文件blog31/app/admin/view/Article/articleIndex.html中构建每一条记录的序号，\n\n   ![1531535321745](96)\n\n3. 测试访问效果：\n\n   ![1531535366848](97)\n\n\n\n#### 实现搜索功能\n\n1. 在blog31/app/admin/controller/ArticleController.class.php中的showList方法里查询出所有的管理员和所有的分类数据，\n\n   ![1531536538080](98)\n\n   将上图中查得的数据回显到blog31/app/admin/view/Article/articleIndex.html中，\n\n   ![1531541167632](99)\n\n2. 在blog31/app/admin/controller/ArticleController.class.php中的showList方法里接收搜索表单提交的数据，检查搜索表单提交的数据并且根据搜索表单提交的数据构建查询条件，\n\n   ![1531540808004](100)\n\n   ![1531540883427](101)\n\n3. 测试使用效果：\n\n   ![1531541088045](102)\n\n\n\n\n\n### 实现编辑页\n\n1. 调整blog31/app/admin/view/Category/articleIndex.html中的编辑按钮链接，\n\n   ![1531549925587](103)\n\n2. 在blog31/app/controller/ArticleController.class.php中创建名为showUpd的方法，渲染后台博文编辑页模板，\n\n   ![1531550022313](104)\n\n3. 通过从后台博文列表页点击编辑按钮访问后台博文管理系统编辑页，发现页面虽然能够展示，但是样式乱了，\n\n   于是进一步调整blog31/app/admin/view/Category/articleEdit.html中引入资源文件的路径，将\"../libs\"全部替换为\"{C('URL')}/public/admin\"，如下图所示，代码截取不全，以实际文件中的代码为准，\n\n   ![1531550157823](105)\n\n4. 在blog31/app/admin/controller/ArticleController.class.php中的showUpd方法里查找该页面需要的相关数据，\n\n   ![1531551056713](106)\n\n   在blog31/app/admin/view/Article/articleEdit.html中调整form表单中的各表单域并且回显本条博文数据，\n\n   ![1531551191790](107)\n\n   ![1531551212303](108)\n\n5. 在blog31/app/admin/controller/ArticleController.class.php中构建updh方法，代码如下：\n\n   ```php\n   public function updh(){ \n           \n       //接收表单传递的数据\n       //GET传递的\n       $id = $_GET['id'];\n   \n       //POST传递的\n       $new_title = trim($_POST['title']);\n       $new_intro = trim($_POST['intro']);\n   \n       $cat = $_POST['cat'];\n       $catArr = explode('|', $cat);//处理接收到的分类数据\n       $new_cat_id = $catArr[0];\n       $new_cat_name = $catArr[1];\n   \n       $new_content = trim($_POST['content']);\n   \n       //检查哪些数据真的被修改了\n       @session_start();\n       $target = [];\n   \n       if( $new_title!=$_SESSION['old_article']['title']&&!empty($new_title) ){//如果新的标题数据和老的标题数据不一样，则说明标题确实被修改了\n           $target[] = \"title='{$new_title}'\";\n       }\n   \n       if( $new_intro!=$_SESSION['old_article']['intro']&&!empty($new_intro) ){//如果新的简介数据和老的简介数据不一样，则说明简介确实被修改了\n           $target[]  = \"intro='{$new_intro}'\";\n       }\n   \n       if( $new_cat_id!=$_SESSION['old_article']['cat_id'] ){//如果新的分类id数据和老的分类id数据不一样，则说明分类确实被修改了\n           //                 cat_id=xxx, cat_name=\"xxx\"\n           $target[] = \"cat_id={$new_cat_id}, cat_name='{$new_cat_name}'\";\n       }\n   \n       if( $new_content!=$_SESSION['old_article']['content']&&!empty($new_content) ){//如果新的内容数据和老的内容数据不一样，则说明内容确实被修改了\n           $target[]  = \"content='{$new_content}'\";\n       }\n   \n       //根据检查的结果判断是否需要真的执行更新操作\n       if( !empty($target) ){//$target不为空，则说明确实有数据被修改了\n   \n           $strTarget = implode(',', $target);\n   \n           $model = \\core\\App::single('\\model\\ArticleModel');\n           $sql = \"update bg_article set {$strTarget} where id={$id}\";\n   \n           if( $model->setData($sql) ){//执行成功\n   \n               echo '修改成功！'; \n           }else{//执行失败\n               echo '修改失败，请联系超级管理员！'; \n           }\n   \n       }else{//否则，则说明没有数据需要被更新\n           echo '您还没有修改数据呐～';     \n       }\n   \n       //2秒之后跳回编辑页\n       $url = C('URL') . '/index.php?p=admin&m=article&a=showUpd&id='.$id;\n       header('Refresh:2; url='.$url);\n       exit;\n   }\n   ```\n\n   测试使用效果：\n\n   ![1531554638642](109)\n\n   点击提交：\n\n   ![1531554660616](110)\n\n编辑成功，说明功能制作OK。\n\n\n\n### 实现删除功能\n\n\n\n\n\n## 4. 整理模板文件\n\n1. 将blog31/app/admin/view/Article/articleEdit.html中的head部分提取出来，剪切转移到blog31//app/admin/view中新创建出来的Common目录中的head.html文件，\n\n   剪切下图所示代码：\n\n   ![1531556484467](111)\n\n   转移到Common/head.html中，\n\n   ![1531556565304](115)\n\n2. 将blog31/app/admin/view/Article/articleEdit.html中的页头部分提取出来，剪切转移到blog31//app/admin/view中Common目录中的bodyhead.html文件，\n\n   剪切如下代码：\n\n   ![1531556772556](116)\n\n   转移到Common/bodyhead.html中，\n\n   ![1531556873608](117)\n\n3. 将blog31/app/admin/view/Article/articleEdit.html中的sidebar部分提取出来，剪切转移到blog31//app/admin/view中Common目录中的sidebar.html文件，\n\n   剪切如下代码：\n\n   ![1531557000111](118)\n\n   转移到Common/sidebar.html中，\n\n   ![1531557131143](119)\n\n4. 然后将blog31/app/admin/view/Article/articleEdit.html中所有用到公共代码的部分，换成引入公共文件的操作：\n\n   ![1531561162334](125)\n\n   将blog31/app/admin/view/Article/articleAdd.html中所有用到公共代码的部分，换成引入公共文件的操作：\n\n   ![1531561333905](128)\n\n   将blog31/app/admin/view/Article/articleIndex.html中所有用到公共代码的部分，换成引入公共文件的操作：\n\n   ![1531561319749](127)\n\n5. 修改blog31/app/admin/view/Common/sidebar.html进入博文管理系统各页面的链接地址：\n\n   ![1531561252847](126)\n\n   再次访问后台博文管理系统编辑页：\n\n   ![1531561403077](129)\n\n\n\n## 5. 全天总结\n\n1. 制作的页面和功能：\n\n   封装验证码工具类\n\n   实现后台分类管理系统的列表页和编辑页\n\n   实现无限级递归分类\n\n   实现博客文章管理系统添加页\n\n   实现博客文章管理系统列表页基础功能\n\n\n\n# 七、昨日回顾\n\n## 1. 知识回顾\n\n1. 实现后台分类管理系统的列表页和编辑页\n2. 实现博客文章管理系统添加页\n3. 实现博客文章管理系统列表页基础功能\n\n\n\n## 2. 昨日反馈\n\n![1531530276586](89)\n\n\n\n# 八、知识路径\n\n- [ ] XSS攻击\n\n- [ ] 实现后台登陆页面和功能\n\n  ​\t防翻墙功能\n\n  ​\t7天免登录功能\n\n- [ ] 实现后台退出功能\n\n  ==目标：能够防范XSS攻击，能够实现后台登陆退出功能==\n\n# 九、今日课程内容：博客项目\n\n## 1. XSS攻击\n\n通常用户在表单界面输入的内容是不确定的，用户可以输入任何想要输入的内容进行提交，如果输入的是一些代码，并且我们在程序文件中还没有对用户输入提交的数据进行任何的过滤处理的话，那么，将会面临一定风险。 \n\n\n\nXSS的概念：Cross Site Scripting    全称   跨站脚本攻击，是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。\n\n\n\n**==XSS攻击的案例==**：\n\n在用户输入区域构建script内容，如下图所示：\n\n![1531558956738](120)\n\n点击提交，效果为：\n\n先弹出了提示框，\n\n![1531558988674](121)\n\n然后跳转到了一个大网站：\n\n![1531559026220](122)\n\n\n\n**==小结==**：\n\nXSS攻击其实就是用户在表单输入区域构建了客户端或浏览器能够解析的代码内容，以此来改变其他用户在访问当前这个页面的效果。\n\n\n\n==如何防？==\n\n1. 通过htmlspecialchars函数来进行过滤处理（主要用来处理富文本编辑器中的内容）；\n\n   ![1531560056083](124)\n\n2. 通过addslashes函数来进行过滤处理（主要用来处理非富文本编辑器的其他输入区域的内容）；\n   ![1531559577623](123)\n\n   addslashes可以将内容中的具有特殊意义的符号进行转义，如上图中将双引号转义了，这样一来，双引号将不再是包裹script代码标签信息的符号，而是普通的字符而已，这样就导致了script代码失效。\n\n3. 通过字符串替换或正则匹配的方式进行再过滤处理；\n\n\n\n\n\n## 2. 实现后台登陆页面和功能\n\n1. 在blog31/app/admin/controller目录中创建LoginController.class.php，\n\n   ![1531567007068](130)\n\n   在LoginController.class.php中创建相应的代码，如下图所示：\n\n   ![1531567088054](131)\n\n   访问登陆页面，\n\n   ![1531567136935](132)\n\n2. 调整登陆模板页面blog31/app/admin/view/Privilege/login.html的代码，\n\n   ![1531567350030](133)\n\n   再次访问，\n\n   ![1531567382848](134)\n\n3. 在blog31/app/admin/controller/LoginController.class.php中创建captcha方法，专门输出验证码，\n\n   ![1531567829511](135)\n\n   调整blog31/app/admin/view/Privilege/login.html回显验证码，并且实现局部刷新\n\n   ![1531567872097](136)\n\n   调整blog31/plugins/CaptchaTool.class.php中生成验证码字符串后的数据，将其记录到SESSION中，\n\n   ![1531571893188](139)\n\n4. 在blog31/app/admin/controller/LoginController.class.php创建loginh方法，代码如下，专门处理登陆验证功能：\n\n   ```php\n   //登陆验证方法\n   public function loginh(){ \n   \n       //接收表单提交的数据\n       $acc = trim($_POST['acc']);//帐号\n       $pwd = md5(addslashes(trim($_POST['pwd'])));//密码\n       $captcha = addslashes(trim($_POST['captcha']));//验证码\n   \n       //检查验证码是否填写正确\n       @session_start();\n       if( $captcha!==$_SESSION['captchaStr'] ){//用户填写的验证码和生成的验证码不相等，则说明用户输入的验证码是错误的\n           echo '你好棒棒哟，竟然写错了哟！～'; \n           $url = C('URL') . '/index.php?p=admin&m=login&a=showLogin';\n           header('Refresh:2; url='.$url);\n           exit;\n       }\n   \n       //检查帐号和密码是否正确\n       $userModel = \\core\\App::single('\\model\\UserModel');\n       $sql = \"select * from bg_user where acc='{$acc}' and pwd='{$pwd}'\";\n       $row = $userModel->getRow($sql);\n   \n       if( !empty($row) ){//帐号密码填写正确\n   \n           echo '客官，您又来了吖～'; \n           $url = C('URL') . '/index.php?p=admin&m=article&a=showList';\n           header('Refresh:2; url='.$url);\n       }else{//否则至少有一个填写错误\n   \n           echo '帐号或密码填写错误，请重新填写！'; \n           $url = C('URL') . '/index.php?p=admin&m=login&a=showLogin';\n           header('Refresh:2; url='.$url);\n       }\n       exit;\n   }\n   ```\n\n5. 测试使用效果：\n\n   访问登陆页面，输入帐号密码，\n\n   ![1531571702986](137)\n\n   点击登录，\n\n   ![1531571821435](138)\n\n6. 我们打开一个新的浏览器，在浏览器地址栏中直接手动输入后台博文管理系统列表页链接地址，发现，在没有登录的情况下都能直接访问，\n\n   ![1531571967694](140)\n\n   这种效果就是翻墙效果。\n\n\n\n那么，如何实现防翻墙呢？\n\n\n\n### 防翻墙功能\n\n1. 在blog31/app/admin/controller/LoginController.class.php中的loginh方法里，登陆成功时记录下登陆用户的完整信息，\n\n   ![1531572176835](141)\n\n2. 在父类控制器blog31/core/Controller.class.php中的构造方法里，进行防翻墙检查，\n\n   ![1531572269068](142)\n\n3. 测试防翻墙效果：\n\n   首先在未登录的情况下直接访问后台博文列表页，经过防翻墙处理，已经不能直接访问进去了：\n\n   ![1531572402694](143)\n\n   然后使用帐号密码登录后台，\n\n   ![1531572604535](145)\n\n   登陆成功后提示：\n\n   ![1531572625978](146)\n\n   登陆成功后再同一个浏览器中打开一个新的浏览器选项卡，直接在地址栏中输入后台博文管理系统列表页链接地址，\n\n   ![1531572685648](147)\n\n\n\n==优化==：回显登陆成功者的昵称\n\n在blog31/app/admin/view/Common/bodyhead.html中调整登陆成功者的昵称信息，\n\n![1531704858362](148)\n\n使用效果如下：\n\n![1531704913746](149)\n\n\n\n### 7天免登录\n\n1. 在blog31/app/admin/view/Privilege/login.html中调整7天免登录按钮的value值，\n\n   ![1531707569136](150)\n\n2. 在blog31/app/admin/controller/LoginController.class.php中的loginh方法里的登陆成功的部分判断是否有勾选7天免登录按钮，\n\n   ![1531707663741](151)\n\n3. 在父类控制器blog31/core/Controller.class.php的构造方法中，检查在没有登录的情况下是否有勾选过7天免登录按钮，\n   ![1531707742856](152)\n\n4. 测试使用效果：\n\n   直接访问后台页面：\n\n   ![1531707837168](153)\n\n   重新登录，并且勾选7天免登录按钮：\n\n   ![1531707883082](154)\n\n   登陆成功后：\n\n   ![1531707970274](155)\n\n   再次关闭浏览器，直接访问后台页面，\n\n   ![1531708045868](156)\n\n\n\n## 3. 实现后台退出功能\n\n1. 在blog31/app/admin/view/Common/bodyhead.html构建退出链接，\n\n   ![1531709743128](157)\n\n2. 在blog31/app/admin/controller/LoginController.class.php中创建logout方法，代码如下：\n\n   ![1531709788262](158)\n\n3. 测试使用效果：\n\n   ![1531709920344](160)\n\n   点击退出按钮后：\n\n   ![1531709946903](161)\n\n优化：\n\n1. 优化接收7天免登录按钮参数：在blog31/app/admin/controller/LoginController.class.php中的loginh方法里，\n\n   ![1531710130529](162)\n\n\n\n# 十、昨日回顾\n\n## 1. 知识回顾\n\n1. 后台博文管理系统列表页搜索功能和分页功能；\n\n2. 后台博文管理系统编辑页；\n\n3. 整理后台公共模板页面；\n\n4. XSS攻击怎防？\n\n   1)都使用trim函数处理一遍；2）非富文本编辑器的数据一般使用addslashes函数处理一次；3）富文本编辑器的数据一般使用htmlspecialchars函数处理一次；\n\n5. 后台登陆功能和防翻墙功能；\n\n\n\n## 2. 昨日反馈\n\n![1531702845532](../../day16/doc/img4/148)\n\n\n\n# 十一、知识路径\n\n- [ ] 实现前台首页\n- [ ] 实现前台博文详情页\n- [ ] 实现前台注册功能\n- [ ] 实现前台登陆功能\n- [ ] 实现评论功能\n- [ ] SQL注入\n\n==目标：能够实现前台首页和详情页、能够实现前台注册登陆功能、能够实现评论功能、掌握如何防范SQL注入==\n\n\n\n# 十二、今日课程内容：博客项目\n\n## 1. 实现前台首页\n\n1. 将day17/code/templates/home目录下的两个模板文件拷贝一份，\n\n   ![1531710294998](163)\n\n   将复制的两个模板文件转移粘贴到blog31/app/home/view目录中，\n\n   ![1531710354064](164)\n\n2. 在blog31/app/home/controller中创建IndexController.class.php文件，代码如下：\n\n   ![1531710462143](165)\n\n3. 在IndexController中创建index方法，渲染首页模板，\n\n   ![1531710582255](166)\n\n   访问前台首页，发现样式乱了，\n\n   ![1531710608065](167)\n\n4. 进一步调整模板页面引入资源文件的代码，\n\n   将day17/code/templates/home/libs文件夹复制一份，\n\n   ![1531710684596](168)\n\n   拷贝到blog31/public目录中，\n\n   ![1531710755716](169)\n\n   改名为home\n\n   ![1531710778933](170)\n\n   将blog31/app/home/view/blogShowList.html中引入资源文件的地址进行调整，代码如下，截图不全，以实际文件中的为准：\n\n   ![1531710911771](171)\n\n5. 在blog31/app/home/controller/IndexController.class.php中index方法里查询所有需要的数据，代码如下：\n\n   ![1531713340247](178)\n\n6. 将查询的数据回显到blog31/app/home/view/blogShowList.html中，\n\n   ![1531712508505](173)\n\n   ![1531712530002](174)\n\n7. 测试访问效果：\n\n   ![1531712570392](175)\n\n   首页数据基本展示正常，但是发布者的昵称没有，所以我们还需要到后台中做进一步调整，在发表文章时关联上发布者的昵称，\n\n8. 调整后台blog31/app/admin/controller/ArticleController.class.php中adh方法里新增文章数据的代码，关联上添加者的信息，如下图所示将蓝框改为红框：\n\n   ![1531713057113](176)\n\n   再次从后台发表一篇文章，访问前台首页，\n\n   ![1531713119395](177)\n\n\n\n## 2. 实现前台博文详情页\n\n1. 调整blog31/app/home/view/blogShowList.html跳转到文章详情页的链接地址，\n\n   ![1531713462113](179)\n\n2. 在blog31/app/home/controller/IndexController.class.php中新增showInfo方法，渲染详情页模板，\n\n   ![1531713508874](180)\n\n   测试访问详情页：\n\n   ![1531713533738](181)\n\n   将blog31/app/home/view/blogShow.html中所有引入资源的路径全部修改，如下图所示，代码截取不全，以实际程序文件中为准：\n\n   ![1531713688089](182)\n\n3. 在blog31/app/home/controller/IndexController.class.php中的showInfo方法里查询需要回显的文章数据，\n\n   ![1531723918342](183)\n   将查询出来的数据在模板页面blog31/app/home/view/blogShow.html回显，\n\n   ![1531723997562](184)\n\n4. 测试使用效果：\n\n   ![1531724056571](185)\n\n   效果OK。\n\n\n\n## 3. 实现前台注册功能\n\n1. 调整前台首页模板页面注册表单区域blog31/app/home/view/blogShowList.html，\n\n   ![1531724453798](186)\n\n2. 在blog31/app/home/controller/IndexController.class.php中创建名为register的方法，实现注册功能，、\n\n   ![1531725351718](187)\n\n3. 测试使用效果：\n\n   填写注册信息\n\n   ![1531725397373](188)\n\n   点击注册后：\n\n   ![1531725427003](189)\n\n   \n\n## 4. 实现前台登陆功能\n\n1. 调整前台首页blog31/app/home/view/blogShowList.html登录区域的表单，\n\n   ![1531725653917](190)\n\n2. 将父类控制器中构造方法里的session_start前置到公共的部分，让前台和后台都能够开启，\n\n   ![1531726610985](191)\n\n3. 在blog31/app/home/controller/IndexController.class.php中创建一个login方法，代码如下：\n\n   ![1531726715166](192)\n\n4. 调整blog31/app/home/view/blogShowList.html中登陆状态的显示区域：\n\n   ![1531726775186](193)\n\n5. 测试使用效果：\n\n   ![1531726815832](194)\n\n\n\n## 5. 实现前台评论功能\n\n1. 调整博文详情页评论form表单区域，\n\n   ![1531727822958](195)\n\n2. 在blog31/app/model目录下创建CommentModel.class.php文件，代码如下：\n\n   ![1531728563916](196)\n\n3. 在blog31/app/home/view/blogShow.html中新增携带两个数据，分别是本篇文章的id和本篇文章的title，\n\n   ![1531728660359](197)\n\n4. 在blog31/app/home/controller/IndexController.class.php中构建talk方法，实现评论功能，\n\n   ![1531728709440](198)\n\n5. 测试使用效果：\n\n   填写评论数据：\n\n   ![1531728771814](199)\n\n   点击发布：\n\n   ![1531728788361](200)\n\n   功能实现成功，但是在详情页中还没能回显评论数据，\n\n\n\n==优化==：在博文详情页中回显评论数据\n\n1. 在blog31/app/home/controller/IndexController.class.php中的showInfo方法里查询出所有本篇文章的评论数据，\n\n   ![1531729304596](201)\n\n2. 然后在模板文件blog31/app/home/view/blogShow.html中回显评论数据\n\n   ![1531729370633](202)\n\n\n\n## 6. SQL注入\n\nSQL注入式攻击：指的是利用PHP程序拼接SQL语句使用的是字符串的特性，强行的在表单区域输入某些字符串数据与原本的SQL语句形成拼接，改变SQL语句条件性质的做法。\n\n![1531730761310](203)\n\n如何防？\n\n1. 通过addslashes处理接收的表单数据，以达到将接收的数据中所包含的引号转义掉；\n\n2. 通过逻辑处理，如在blog31/app/home/controller/LoginController.class.php的loginh方法中所作的针对检查帐号密码是否填写正确的调整：\n\n   ![1531735941694](204)\n\n\n\n==小结==：我们在程序中针对SQL注入式攻击行为，需要进行防御处理是：\n\n1. 通过addslashes过滤；\n2. 通过业务逻辑精确查找过滤；\n\n\n\n","categories":["博客项目"]},{"title":"TP5框架","url":"%2Fposts%2F1124976518%2F","content":"\n\n# ==TP5第一天==\n\n# 一、框架概述 \n\n## 1、什么是框架 \n\n**框架(Framework)**，它是许多代码文件的集合，这些代码文件是程序结构的代码，不是业务代码，里面包含了许多函数、类库(分页类、验证码类、文件上传类、DB类、Image类\\...)、设计模式(mvc、单例、AR..)等。\n\n以后使用框架开发项目只需要写业务代码即可。\n\n\n\n**现在企业中开发模式基本有三种:**\n\n从快到慢排序：二次开发(需要修改源码)\\-\\--\\>==**框架开发**==\\-\\-\\--\\>源码开发\n\n**源码建房子**：从零开始-\\>打地基-\\>浇筑混泥土-\\>装修\\....\n\n**框架建房子**：相当于毛坯房-\\>各种装修。\n\n**二次开发建房子**：相当于精装修的房子，只需要拎包入住。\n\n现在企业开发较多的模式属框架开发。\n\n\n\n## 2、框架开发的好处 \n\n-   **框架能节省开发时间**\n\n    每个项目中常用的类库框架都已经封装好，如分页类、图像类,文件上传类等，直接调用即可,非常方便。（减少重复造轮子）\n\n-   **利于团队的合作开发**\n\n    因为框架都是mvc设计模式,模块划分清晰，可以帮助我们快速、稳定、高效搭建web应用，从而提高开发效率。\n\n-   **使用框架的过程中可以使得我们的注意力全部集中在业务层面，而无需关心程序的底层架构。**\n\n\n\n## 3、框架的设计模式(MVC) \n\n基本现在主流的框架(CI、TP、laravel、YII、zend framework、symfony、cakephp),都是采用**单一入口**(index.php)，且都是采用**mvc**的设计模式，把一个web应用程序分为三块,**控制器**、**模型**、**视图**。\n\nC-Controller 控制器\n\n主要作用:就是接收用户的请求,在模型和视图之间起一个调度的作用\n\nM-Model 模型\n\n作用:对数据库做增删改查(curd)的\n\nV-View视图\n\n展示模板内容,给用户一个可操作的界面\n\n\n\n**mvc(框架)形象理解-酒店（难以理解的东西一定要把抽象的东西给生活化，助于理解）**\n\n![](media1/image1.png)\n\n\n\n## 4、常见的php开发框架\n\n### （1）ThinkPHP框架（TP框架）\n\nTP框架的logo：\n\n![](media1/image2.png)\n\n主要开发中小型项目\n\nThinkPHP框架是我们国人开发采用mvc模式设计的一款比较优秀的框架。在我们国内使用量较多，且开发文档也多，方便学习。\n\n### （2）CodeIgniter 框架\n\nCodeIgniter框架：简称CI框架，主要开发中小型项目\n\n![](media1/image3.png)\n\n### （3）YII(易框架)\n\nYII(简称易框架):主要开发大型的web应用程序:\n\n\n\n![](media1/image4.png)\n\n### （4）Laravel框架 \n\n此框架使用量世界排名第一,有最优雅的框架称号。\n\n注：Laravel底层代码很多都是借鉴了SymFony的优点。\n\n![](media1/image5.png)\n\n### （5）Zend官方框架\n\nZend Framework：php官方提供的框架，非常笨重，主要开发大型的web应用程序。\n\n![](media1/image6.png)\n\n### （6）Symfony国外框架\n\n![](media1/image7.png)\n\n==框架只有最合适的，没有最好的，需结合自己的实际业务去选择最合适的。==\n\n国内使用较多的框架是**TP**、**laravel**、**CI**。\n\n**YII**，**Symfony**框架一般外企使用较多\n\n----\n\n\n\n# 二、ThinkPHP5框架\n\n## 1、下载TP5框架\n\n下载地址：<http://www.thinkphp.cn/down.html>\n\n![](media1/image8.png)\n\n![](media1/image9.png)\n\n## 2、TP5框架的目录结构\n\n手册位置：基础\\--\\>目录结构\n\n![](media1/image10.png)\n\n```\n1.\tproject  应用部署目录\n2.\t├─application           应用目录（可设置）\n3.\t│  ├─common             公共模块目录（可更改）\n4.\t│  ├─index              模块目录(可更改)\n5.\t│  │  ├─config.php      模块配置文件\n6.\t│  │  ├─common.php      模块函数文件\n7.\t│  │  ├─controller      控制器目录\n8.\t│  │  ├─model           模型目录\n9.\t│  │  ├─view            视图目录\n10.\t│  │  └─ ...            更多类库目录\n11.\t│  ├─command.php        命令行工具配置文件\n12.\t│  ├─common.php         应用公共（函数）文件\n13.\t│  ├─config.php         应用（公共）配置文件\n14.\t│  ├─database.php       数据库配置文件\n15.\t│  ├─tags.php           应用行为扩展定义文件\n16.\t│  └─route.php          路由配置文件\n17.\t├─extend                扩展类库目录（可定义）\n18.\t├─public                WEB 部署目录（对外访问目录）\n19.\t│  ├─static             静态资源存放目录(css,js,image)\n20.\t│  ├─index.php          应用入口文件\n21.\t│  ├─router.php         快速测试文件\n22.\t│  └─.htaccess          用于 apache 的重写\n23.\t├─runtime               应用的运行时目录（可写，可设置）\n24.\t├─vendor                第三方类库目录（Composer）\n25.\t├─thinkphp              框架系统目录\n26.\t│  ├─lang               语言包目录\n27.\t│  ├─library            框架核心类库目录\n28.\t│  │  ├─think           Think 类库包目录\n29.\t│  │  └─traits          系统 Traits 目录\n30.\t│  ├─tpl                系统模板目录\n31.\t│  ├─.htaccess          用于 apache 的重写\n32.\t│  ├─.travis.yml        CI 定义文件\n33.\t│  ├─base.php           基础定义文件\n34.\t│  ├─composer.json      composer 定义文件\n35.\t│  ├─console.php        控制台入口文件\n36.\t│  ├─convention.php     惯例配置文件\n37.\t│  ├─helper.php         助手函数文件（可选）\n38.\t│  ├─LICENSE.txt        授权说明文件\n39.\t│  ├─phpunit.xml        单元测试配置文件\n40.\t│  ├─README.md          README 文件\n41.\t│  └─start.php          框架引导文件\n42.\t├─build.php             自动生成定义文件（参考）\n43.\t├─composer.json         composer 定义文件\n44.\t├─LICENSE.txt           授权说明文件\n45.\t├─README.md             README 文件\n46.\t├─think                 命令行入口文件\n```\n\n==重点目录：==\n\n-   应用**application**目录\n\n-   框架的核心目录**thinkphp**\n\n-   **public**目录供外访问的\n\n\n\n每个application下面的模块目录都有mvc分层结构，如index模块\n\n![](media1/image11.png)\n\n当然也可以在application目录中创建多个模块（分组）。\n\n----\n\n\n\n# 三、使用TP5框架部署项目\n\n我们是使用ThinkPHP5+JavaScipt+Ajax+jquery以及和第三方插件结合起来，做一个文章管理系统，掌握怎样使用ThinkPHP5快速开发一个项目。\n\n## 1、配置项目虚拟主机\n\n**主要三个核心步骤：**\n\n1. 使用phpStudy建立虚拟主机，把tp5框架部署在web虚拟目录中\n\n2. 设置hosts文件ip和域名的映射\n\n3. 重启apache服务器\n\n\n\n步骤如下：\n\n**步骤1**：把下载下来的框架程序复制到web虚拟目录\n\n![](media1/image12.png)\n\n**步骤2**：使用phpstudy建立虚拟主机\n\n![](media1/image13.png)\n\n![](media1/image14.png)\n\n![](media1/image15.png)\n\n![](media1/image16.png)\n\n==注：域名是绑定在项目的public目录下面==\n\n**步骤3**：设置hosts文件ip和域名的映射\n\n![](media1/image17.png)\n\n## 2、访问虚拟主机\n\n输入配置的域名直接访问：\n\n![](media1/image18.png)\n\n\n\n为什么会出现上面的一个笑脸？\n\n答：那是因为受到框架的应用配置文件`application/config.php`的影响，默认访问index模块的index控制器的index方法，如下：\n\n![](media1/image19.png)\n\n\n\n注：tp5默认支持老本tp3的**pathinfo**模式进行访问。\n`http://域名/index.php/模块/控制器/方法名/参数1/值1/参数2/值2/`\n\n例：访问index模块的index 控制器的index方法\n\n`http://域名/index.php/index/index/index/参数1/值1/参数2/值2/`\n\n\n\n当然tp5框架也支持像laravel框架那样定义路由来访问。\n\n\n\n\n## 3、响应输出\n\n控制器的所有操作方法都是`return`返回而不是直接输出，系统会调用`Response::send`方法将最终的应用返回的数据输出到页面或者客户端，并自动转换成配置项`default_return_type`（默认为html）配置的格式。所以，应用执行的数据输出只需要返回一个正常的PHP数据即可。\n\ntp5也是建议统一使用`return`返回数据，而不是`echo`输出，如非必要，请不要使用`exit`或者`die`中断执行。\n\n![](media1/image20.png)\n\n----\n\n\n\n# 四、控制器 \n\n## 1、控制器的作用\n\nC：Controller\n\n==作用==：主要是接受用户的请求，在模型和视图之间起调度的作用。\n\n## 2、创建控制器\n\n### （1）修改控制器后缀\n\n由于国人命名的习惯，一般控制器名称后面都习惯加`controller`，我们可以通过以下配置文件设置后缀。\n\n打开配置文件，`[项目目录]/application/config.php`，做如下修改：\n\n![](media1/image21.png)\n\n上面改好之后，控制器==文件的命名==和==控制器类名==都需要更改：\n\n![](media1/image22.png)\n\n##### !important \n\n**==注意： 不管是否修改，访问时都不能加后缀，因为默认会自动添加此后缀的。==**\n\n![1534121418781](media1/1534121418781.png)\n\n\n\n### （2）创建控制器语法\n\n**==语法规则：==**\n\n\n**控制器类名**：控制器名（首字母大写）+Controlle\n**控制器文件名**：控制器名+Controller.php\n**控制器文件所在路径**：application/模块名/controller/\n\n\n\n如在index模块下定义一个Test控制器：\n\n控制器类名： `TestController`\n\n控制器类文件名：` TestController.php`\n\n文件定义位置：`index/controller/TestController.php`\n\n==注：类名首字母大写==\n\n代码如下：\n\n![](media1/image23.png)\n\n访问：\n![](media1/image24.png)\n\n\n\n### （3）隐藏入口文件进行访问（rewrite重写模式）\n\n省去`index.php`入口文件访问，需要以下几步。\n\n-   步骤1：在apache配置文件`httpd.conf`开启重写文件：\n\n    ![](media1/image25.png)\n\n    \n\n-   步骤2：找到重写文件`.htaccess`，在`[项目根目录]/Public/.htaccess` ,做如下修改：\n\n    ```.htaccess\n    <IfModule mod_rewrite.c>\n      Options +FollowSymlinks -Multiviews\n      RewriteEngine On\n    \n      RewriteCond %{REQUEST_FILENAME} !-d\n      RewriteCond %{REQUEST_FILENAME} !-f\n      RewriteRule ^(.*)$ index.php?/$1 [QSA,PT,L]\n    </IfModule>\n    ```\n\n    ![](media1/image26.png)\n\n    (==注==：上图可能需要在index.php后边加\"?\"号)\n\n\n\n-   **步骤3**：修改虚拟主机`httpd-vhosts.conf`的配置：加上`AllowOverride All `，默认phpstudy创建的虚拟主机自带这一行。\n\n    ![](media1/image27.png)\n\n    最后重启apache服务器，省去入口文件index.php进行访问，输入：`http://域名/模块/控制器/方法`\n\n    ![](media1/image28.png)\n\n\n\n### （4）开启调试模式\n\n为了在开发过程中，开发者能够及时看到详细的错误信息，我们在开发阶段可以把`application/config.php`配置文件中的`app_debug`配置项设置为**true**,\n\n![](media1/image29.png)\n\n如访问一个不存在的方法indexdd,会报详细的错误，这样有利于错误的排查\n\n![](media1/image30.png)\n\n在如：访问一个不存在的控制器，报错如下：\n\n![](media1/image31.png)\n\n若设置为`app_debug`为**false**,则会出现友好的提示：\n\n![](media1/image32.png)\n\n==所以，项目上线后，我们要把此配置改为**false**，不要让用户看到我们网站报错。==\n\n----\n\n\n\n# 五、项目分组(模块)\n\n## 1、创建分组\n\n一个项目中一般都有**Home**、**Admin**分组，即前台和后台，那对应框架中就是一个具体的文件夹，每个项目文件夹都有对应的**控制器**、**模型**、**视图**对应的文件夹，tp5框架中默认有一个分组**index**。\n\n我们只需要把`index`默认分组复制一份改名（如`admin`）放在**Application**目录下即可，同时修改对应类所在分组的命名空间即可。\n\n![](media1/image33.png)\n\n在admin模块下面要建立一个**控制器**、**模型**、**视图**对应的文件夹，和一个**配置文件**和**公共函数文件**\n\n![](media1/image34.png)\n\n复制分组的时候，记得更改类名所在的模块命名空间：\n\n![](media1/image35.png)\n\n## 2、默认分组的设置\n\n需修改框架的`application/config.php`配置文件，如设置默认访问admin分组的index控制器的index方法，做如下修改：\n\n![](media1/image36.png)\n\n再次输入域名访问，访问的则是admin模块下的index控制器的index方法：\n\n![](media1/image37.png)\n\n## 3、分组的访问权限控制\n\n有些分组若不想让用户访问，可以设置为禁止访问。需修改框架的`application/config.php`的配置文件：\n\n![](media1/image38.png)\n\n上图是设置禁止访问common和index分组。\n\n再次访问禁止的index模块，会报错，模块不存在。\n\n![](media1/image39.png)\n\n# 六、命令行操作(了解) \n\n手册位置： 命令行-->自动生成目录结构\n\n## 1、命令行创建分组\n\n自动生成以`APP_PATH`为起始目录，并且会自动生成模块的默认的Index访问控制器文件用于显示框架的欢迎页面。\n\n* `__dir__` 表示生成目录（支持多级目录）\n* `__file__` 表示生成文件（不定义默认会生成 config.php 文件）\n* `controller` 表示生成**controller**类\n* `model`  表示生成**model**类\n* `view`  表示生成**html**文件（支持子目录）\n\n\n\n创建文件`application/build.php`并填充内容，可以参考根目录` build.php`\n\n```php\nreturn [\n    // 生成应用公共文件，位于 application 目录下\n    '__file__' => ['common.php', 'config.php', 'database.php'],\n\n    // 定义demo模块的自动生成\n    // '模块名'=> [<模块下的内容，可空>]\n    'demo' => [\n        //创建文件，直接位于模块名目录下\n        '__file__' => ['common.php'],   \n        //创建目录，直接位于模块名目录下\n        '__dir__' => ['behavior', 'controller', 'model', 'view'],  \n        \n        ############### 对上面的目录进一步构建 ###############\n        //创建的控制器目录下的内容（控制器文件及控制器类）\n        'controller' => ['Index', 'Test', 'UserType'],  \n        //创建模型目录下的内容（文件及模型类）\n        'model' => [], \n        //创建视图目录下的内容（模版文件，不需要加后缀，默认html后缀）\n        'view' => ['index/index'], //相当于 view/index/index.html\n    ],\n    // …… 其他更多的模块定义\n];\n```\n\n##### !important\n\n**注意**：模版文件，不需要加后缀，默认html后缀。控制器等==后缀不会自动添加==。已存在的不受影响\n\n\n\n创建`application/build.php`并填充如下内容：\n\n![](media1/image40.png)\n\n\ncmd切换到**项目目录**执行如下命令(需要添加php到环境变量)：\n\n```cmd\nphp think build\n```\n\n成功后，会生成对应设置的模块、控制器、模型和文件等\n\n\n\n## 2、命令行创建控制器\n\n同样，cmd切换到**项目目录**执行如下命令：\n```\nphp think make:controller 分组/控制器名称\n```\n\n##### !important \n\n**注**：不写分组名会直接创建在`common`分组 `controller`中，`控制器名称`==不需要写后缀==，自动添加后缀的。\n\n\n\n例：在admin模块中生成一个User的控制器\n\n项目根目录\\> php think make:controller admin/User\n\n成功会提示successfully。\n\n生成如下所示：\n\n![](media1/image41.png)\n\n例如下述，要在index分组下创建UserController.php控制器文件\n\n\\[项目根目录\\] \\> php think make:controller index/User\n\n生成的文件：\n\n![](media1/image42.png)\n\n\n\n## 3、命令行创建模型类\n\n同样，cmd切换到**项目目录**执行如下命令：\n```\nphp think make:model 分组/模型名称\n```\n\n**注**： `模型名称`  后面并不会有自动添加的后缀\n\n\n\n如，执行下面的指令可以生成`index`模块的`Blog`模型类库文件\n\n```cmd\nphp think make:model index/Blog\n```\n\n生成的模型类文件如下：\n\n```php\nnamespace app\\index\\model;\nuse think\\Model;\n\nclass Blog extends Model\n{\n\n}\n```\n\n----\n\n\n\n# 七、路由（重要）\n\n我们之前是通过`pathInfo`模式进行访问控制器中的方法,但是这种访问模式url太长，难以记住，能不能通过简单的地址就可以访问？,可以的！，通过tp5提供的路由就可以实现。\n\n\n\n## 1、路由模式\n\n手册位置：路由-\\>路由模式\n\n\n\n在tp5中，路由模式有三种，分别是：\n\n* 普通模式（默认模式pathinfo）\n* 混合模式\n* 强制模式\n\n\n\n### （1）普通模式\n\n此模式是框架的默认模式，默认是关闭路由的。在` appcation/config.php`文件中：\n```\n'url_route_on'  =>  false,\n```\n\n上面路由关闭后，不会解析任何的路由规则，只能采用默认的pathInfo模式访问url。如：\n\nhttp:/域名/index.php/模块/控制器/方法/参数1/值1\n\n\n### （2）混合模式\n\n开启路由，并使用路由定义+默认pathInfo模式的混合。在` appcation/config.php`文件中：\n```\n'url_route_on'  =>  true,\n'url_route_must'=>  false,\n```\n\n在`application/config.php`配置文件中开启路由功能后，访问的时候就会经过路由规则，根据定义的路由规则从而访问到某个控制器中的方法。\n\n路由图解：\n\n![](media1/image43.png)\n\n\n### （3）强制模式\n\n开启路由，并设置必须定义路由才能访问。在` appcation/config.php`文件中：\n```\n'url_route_on'  =>  true,\n'url_route_must'=>  true,\n```\n\n**注**：这种方式下面必须严格给每一个访问地址定义路由规则（包括首页），否则将抛出异常。\n\n==推荐使用强制模式，方便后面url统一管理。==\n\n\n\n## 2、定义路由\n\n手册位置：路由-\\>路由定义\n\n\n\n把路由规则定义在`application/route.php`文件中。\n\n需要先引入路由类`Route`\n```php\nuse think\\Route;\n```\n\n\n**==最简洁的定义方式如下：==**\n\n```php\nRoute::get('路由表达式','路由地址');\nRoute::post('路由表达式','路由地址');\nRoute::any('路由表达式','路由地址');\n或\nRoute::Rule('路由表达式','路由地址',['method'=>'get']);\n\n其中any代表任意请求方式（get/post）都支持的路由规则\n```\n\n\n\n**例如**：\n\n`Route::get('login','home/User/login');`\n\n访问：[http://域名/index.php/login](http://域名/index.php/login)\n\n路由到：[http://域名/index.php/home/User/login](http://域名/index.php/home/User/login)\n\n\n\n`Route::get('houtai','admin/index/index');`\n\n访问：[http://域名/houtai](http://域名/houtai)\n\n路由到：[http://域名/admin/index/index](http://域名/admin/index/index)\n\n\n\n如下的一个控制器**login**方法：\n\n![](media1/image44.png)\n\n定义路由访问：\n\n![](media1/image45.png)\n\n效果：\n\n![](media1/image46.png)\n\n## 3、定义路由分组\n\n一般前台的路由地址都含有**home**,后台则为**admin**,我们可以把相同的路由地址进行分组。\n\n**路由分组语法：**\n\n```php\nRoute::group('分组名',function(){\nRoute::get('路由表达式','路由地址');\n});\n```\n\n`分组名` 只适用于 `路由表达式`，`路由地址`还是需要完整书写。\n\n\n\n\n例如：\n\n```php\nRoute::group('admin',function(){\nRoute::any('user/index','admin/user/index);\n//定义更多...\n});\n```\n\n\n\n访问：[http://域名/admin/user/index](http://域名/admin/user/index)\n\n路由到：[http://域名/admin/user/index](http://域名/admin/user/index)\n\n代码如下：\n\n![](media1/image47.png)\n\n定义路由：\n\n![](media1/image48.png)\n\n访问路由：\n\n![](media1/image49.png)\n\n## 4、定义路由参数(路由参数绑定) \n\n### （1）定义单个路由参数\n\n【**==定义==**】在路由表达式后面通过`:参数名`形式定义路由参数，`/`为参数分割符。\n\n```php\nRoute::get(\"user/:id\",'admin/test/test);\n```\n\n\n\n【**==传递==**】在url中传递参数方式为`http://域名/user/34` ，注意，直接写参数的值即可，如34。\n\n\n\n【**==接收==**】上面对应路由规则方法，必须定义一个==相同形参名==id来接收，如：\n\n```php\nfunction test($id){\necho $id;\n}\n```\n\n\n\n若路由参数**可缺省**，则在路由表达式通过`[:参数名]` 来指定，同样用`/`为参数分割符。\n\n```php\nRoute::get(\"user/[:id]\",'admin/test/test');\n```\n\n上面参数可缺省，且定义的\\$id参数必须有**默认值**，否则报错\n\n```php\nfunction test($id = 0){\n\techo $id;\n}\n```\n\n\n\n### （2）定义多个路由参数\n\n````php\nRoute::get(\"user/:id/:name/:email\",'admin/test/test');\n````\n\n则对应的形参名也必须一致，如：\n\n```php\nfunction test($id,$name,$email){\n\techo $id.$name.$email;\n}\n```\n\n----\n\n\n\n# 八、输出视图(模版)\n\n**输出视图**（==渲染模版==）\n\n\n\n**语法**：控制器中调用fetch方法，常用写法，支持跨模块：\n\n```php\nreturn $this -> fetch(模块@控制器/操作);  \n```\n\n\n\n注意：\n\n==控制器要调用fetch方法，则必须继承Controller类==：``use think\\Controller``\n\n**fetch()一般下述3种用法：**\n\n-   \\[重点掌握\\]调用：`view目录下/当前控制器名同名目录/当前操作名.html`同名模板文件\n\n    `return $this -> fetch();`\n\n-   调用：`view目录下/当前控制器/add.html`模板文件\n\n    `return $this -> fetch('add');`\n\n-   调用：`view目录下/user控制器/login.html`模板文件\\[跨控制器\\]\n\n    `return $this -> fetch('user/login'); `\n\n    \n\n    代码如下：\n\n1.  控制器输出模板内容\n\n    ![](media1/image50.png)\n\n    定义好路由（`application/route.php`）：\n\n    `Route::get('login/[:id]/[:name]','admin/user/login'); `\n\n2.  建立对应的模板文件：\n\n    ![](media1/image51.png)\n\n    效果：\n\n    ![](media1/image52.png)\n\n----\n\n\n\n# 九、模板分配变量 \n\n\n**==语法==**：在控制器调用`assign`方法\n```php\n\tpublic function index()\n    {\n        // 模板变量赋值\n        $this->assign('name','ThinkPHP');\n        $this->assign('email','thinkphp@qq.com');\n        // 或者批量赋值\n        $this->assign([\n            'name'  => 'ThinkPHP',\n            'email' => 'thinkphp@qq.com'\n        ]);\n        // 模板输出\n        return $this->fetch('index');\n    }\n```\n\n【推荐】或者把模板变量直接传递给fetch方法第二个数组参数：\n```php\npublic function index()\n{\n        return $this->fetch('index', [\n            'name'  => 'ThinkPHP',\n            'email' => 'thinkphp@qq.com'\n        ]);\n}\n```\n\n\n\n代码如下：\n\n![](media1/image53.png)\n\n\n在模板中默认通过一对花括号{ }，里面写分配过来的变量。\n\n![](media1/image54.png)\n\n效果：\n![](media1/image55.png)\n\n----\n\n\n\n# 十、修改模版的定界符\n\n注意：默认模板变量的边界符是一对{}，可以通过以下配置进行修改，`application/config.php`\n\n![](media1/image56.png)\n\n----\n\n\n\n# 十一、模板常用标签\n\n手册位置： 模版-->内置标签\n\n\n\n## 1、volist和foreach\n\n**作用**：都是主要用来遍历数组\n\n\n\n-   **volist标签**\n\n    ```php\n    {volist name=\"list\" id=\"vo\"}\n    {$vo.id}:{$vo.name}<br/>\n    {/volist}\n    ```\n\n    Volist标签的**name**属性表示模板赋值的变量名称，因此不可随意在模板文件中改变。**id**表示当前的循环变量，可以随意指定，但确保不要和name属性值冲突。\n\n    \n\n-   **foreach标签**\n\n    ```php\n    {foreach name=\"list\" item=\"vo\"}\n        {$vo.id}:{$vo.name}\n    {/foreach}\n    ```\n\n    name表示数据源 item表示循环变量。\n\n    \n\n    代码如下：\n\n    控制器分配变量：\n\n    ![](media1/image59.png)\n\n    模板输出变量：\n\n    ![](media1/image60.png)\n\n    效果：\n\n    ![](media1/image61.png)\n\n## 2、php标签\n\n如果模板标签语法很难记，这里可以使用php标签统一进行一些代码的编写：\n\n\n\nPhp代码可以和标签在模板文件中混合使用，可以在模板文件里面书写任意的PHP语句代码 ，包括下面两种方式：\n\n**使用php标签**\n\n例如：\n\n```html\n{php}echo 'Hello,world!';{/php}\n```\n\n我们建议需要使用PHP代码的时候尽量采用php标签，因为原生的PHP语法可能会被配置禁用而导致解析错误。\n\n**使用原生php代码**\n\n```php+HTML\n<?php echo 'Hello,world!'; ?>\n```\n\n\n\n注意：在php标签和原生的php中，可以自定义变量，同时也可以使用控制器分配过来的变量。\n\n![](media1/image63.png)\n\n效果：\n\n![](media1/image64.png)\n\n\n\n注：上面的原生php写法，可以通过配置文件进行禁用\n\n![](media1/image65.png)\n\n## 3、include标签\n\n**作用**：\n\n一般网站页面的头部或尾部的网页效果都是一样的，我们就可以把这些网页的代码抽离出来放在一个html文件中，需要使用这些文件的时候，在模板中用include标签引入即可，从而**提高代码的复用性**。\n\n\n\n**语法：**\n\n```php\n{include file='模版文件1,模版文件2,...' /}\n```\n\n\n\n**使用模版表达式**\n\n模版表达式的定义规则为：**模块@控制器/操作**\n\n例如：\n\n```html\n{include file=\"public/header\" /} // 包含头部模版header\n{include file=\"public/menu\" /} // 包含菜单模版menu\n{include file=\"blue/public/menu\" /} // 包含blue主题下面的menu模版\n```\n\n可以一次包含多个模版，例如：\n\n```\n{include file=\"public/header,public/menu\" /}\n```\n\n> 注意，包含模版文件并不会自动调用控制器的方法，也就是说包含的其他模版文件中的变量赋值需要在当前操作中完成。\n\n==注意：file的路径是从当前模块的view目录下开始找起。==\n\n更多参考手册\n\n\n\n如：有一个`header.html`模板，其所在路径为：`admin/view/public/header.html`\n\n在模板中引入此文件： `{include file=\"public/header\" /}`\n\n![](media1/image67.png)\n效果：\n\n![](media1/image68.png)\n\n----\n\n\n\n\n# 十二、助手函数\n\n## 1、url()\n\n手册位置：路由-\\>URL生成。\n\n\n\n**语法**：\n\n```php\nurl('模块/控制器/方法'，参数); \n```\n\n**作用**：会生成指定的url地址，第二个参数指定跳转携带的参数，若在模板中使用助手函数需要在花括号{}前面加个冒号：，如 `{:url()}`\n\n`<a href=\"{:url('index/index/index',['id'=>1])}\">跳转</a>`\n\n注:如果路由模式为强制模式，则url中的第一个参数只能是定义的路由规则。\n\n更多的助手函数,手册位置：附录-\\>助手函数\n\n\n\n## 2、config()\n\n\n\n**语法**：\n\n```php\nconfig('配置名',[值]);\n```\n\n**作用**：获取和设置配置文件中的值。\n\n传递第一个参数就是获取。\n\n传递第二个参数就是设置。\n\n\n\n注意：\n\n**配置文件的优先级（==就近原则==）**：\n\n动态配置(`config()`) \\> 模块配置(`admin/config.php`) \\>应用配置(`application/config.php`) \\> 惯例配置（核心配置`thinkphp/convention.php`）\n\n\n\n## 3、dump()和halt()\n\n这是两个调试变量的函数：\n\n```php\ndump($data)\n```\n`dump()`函数等价`<pre /> + var_dump()`\n\n而halt函数会停止代码的执行。\n```php\nhalt($data)\n```\n`halt()`函数等价`<pre /> + var_dump()+die;`\n\n----\n\n\n\n\n# 十三、Request对象\n\n手册位置：请求\\--\\>请求信息\n\n## 1、获取Request对象 \n\n图解Request对象、response对象：\n\n![](media1/image82.png)\n\n图解说明：\n\n-   服务端server把客户端请求过来的相关信息都封装在一个**Request**对象中。如请求地址、请求参数、请求类型、上传的文件信息等。\n\n-   服务端server把响应给浏览器的相关信息都封装在一个**Response**对象。如响应http状态码200给客户端等。\n\n    \n\n**获取Request对象的方式：**\n\n方式一：\n\n引用`think\\Request`类 ，`$request = Request::instance();`\n\n![](media1/image83.png)\n\n方式二（最简单的方式）：\n\n通过tp5框架提供的助手函数`request()`\n\n```php\n$request = request();\n```\n\n![](media1/image84.png)\n\n方式三：通过依赖注入（闭包）的方式，把Request对象注入到方法内部\n\n```php\npublic function test(Request $request){  //声明参数类型\n\tdump($request);\n}\n```\n\n![](media1/image85.png)\n\n更多的助手函数在手册： 附录-\\>助手函数\n\n所有的助手函数源码位置：`thinkphp/helper.php`\n\n\n\n## 2、获取请求信息\n\n手册参考位置：请求\\--\\>请求信息\n\n```php\n$request->domain();     // 获取当前域名\n$request->url();         // 获取当前URL地址\n$request->url(true);    // 包含域名的完整URL地址\n$request->baseUrl();    // 获取当前URL地址 不含QUERY_STRING\n$request->header();     // 获取当前请求的HTTP 请求头信息\n$request->ip();          // 获取访问ip地址 \n\n$request->module();      //获取当前访问模块名称\n$request->controller(); //获取当前访问控制器名称\n$request->action();     //获取当前访问操作名称 \n$request->isAjax();     // 判断 是否是ajax请求\n$request->isPost();     // 判断 是否是post请求\n$request->isGet();     // 判断 是否是get请求\n```\n\n代码：\n\n![](media1/image86.png)\n\n效果：\n![](media1/image87.png)\n\n\n\n## 3、获取请求参数\n\n手册参考位置：请求\\--\\>输入变量\n\n**语法**：`变量类型方法('变量名/变量修饰符','默认值','过滤方法')`\n\n\n\n### （1）获取GET和POST参数\n\n==注：input()会自动获取get或post传递的参数==\n\n这里推荐使用内置的助手函数`input()`可以获取到get或post参数\n\n```php\n input('id'); // 接收id参数\n input('name');// 接收name参数\n input('get.'); //获取整个get数组参数\n input('post.'); //获取整个post数组参数\n```\n\n\n\n如果要获取的数据为数组的时候，一定要加`/a`修饰符才能正确获取到。\n\n如：\n\n```html\n <input type='text' name='ids[]' />\n```\n\n接收ids参数\n\n```php\ninput('ids/a'); // 接收ids数组参数\n```\n\n\n\ntp5框架默认的修饰符为`/s`,如果传入字符串之外的变量可以使用下面的修饰符，包括：\n\n-   `/s `  强制转换为字符串类型\n\n-   `/d ` 强制转换为整型类型\n\n-   `/b `  强制转换为布尔类型\n\n-   `/a `  强制转换为数组类型\n\n-   `/f` 强制转换为浮点类型\n\n    \n\n\n代码如下：\n\n![](media1/image88.png)\n\n注：input函数底层默认默认采用PARAM方式进行读取变量，自动识别GET或POST提交的参数。\n\n```php\n// 获取当前请求的name变量\n$request->param('name');\n```\n\n\n\n### （2）参数默认值\n\n说明：当参数没有值的时候，可以在input的第二个参数设置其默认值。\n\n如，当参数id没有值时候，设置默认值为0\n\n```php\ninput('id',0); // 接收id参数\n```\n\n\n\n### （3）参数过滤\n\n我们对接收到的参数往往需要对其做一些过滤处理，如下几个常用过滤方法：\n\n-   **strip\\_tags** :去除字符串的html和php标记\n\n-   **strtolower** : 转化为小写\n\n-   **htmlspecialchars**：把html标签转化为html实体符号（防止xss（js）攻击）\n\n    如：大于号`>`会被转化为 `&gt;`\n\n    如：大于号`<`会被转化为 `&lt;`\n\n    \\.....\n\n    \n\n**只需要在input的第三个参数设置相应的过滤函数即可。**\n\n```php\ninput('name','','htmlspecialchars'); // 接收name参数,默认为空，经过htmlspecialchars处理\n```\n\n\n\n**也可以依次经过多个过滤函数处理：**\n\n```php\ninput('name','','strip_tags,strtolower'); // 先去除标记，在转化为小写\n```\n\n\n\n==注意：==\n\n框架默认**没有**设置任何过滤规则，你可以在配置文件`application/config.php`中设置全局的过滤规则。\n\n```php\n// 默认全局过滤方法 用逗号分隔多个\n 'default_filter'         => 'htmlspecialchars',\n```\n\n\n\n----\n\n\n\n# ==TP5第二天==\n\n# 一、数据库操作\n\n==**在TP5操作数据库常用有两种方式：**==\n\n-   **通过Db构造器**\n\n    ```php\n    如：Db::table('think_user')->where('status',1)->select(); // #带数据表前缀\n    如：Db::name('user')->where('status',1)->select(); #不带表前缀\n    ```\n\n-   **通过模型类**\n\n    如：取出主键为1的数据(首先配置数据库的连接信息)\n\n    ```php\n    $user = User::get(1);\n    ```\n\n    \n\n\n## 1、创建数据库数据\n\n创建好数据库和数据表：\n\n1. 创建数据库article:\n\n\t```mysql\n\tcreate database article;\n\t```\n\n2. 创建数据表**tp\\_user**(用户表)、**tp\\_category**（分类表）、**tp\\_article**（文章表）\n\n   **tp_user表结构：**\n\n   ```mysql\n    create table tp_user(\n        user_id int not null auto_increment,\n        username varchar(30) not null default '' comment '用户名',\n        password char(32) not null default '' comment '密码',\n        primary key(user_id)\n    )engine = Innodb default charset = utf8;\n   ```\n\n    **tp_category表结构：**\n   ```mysql\n    create table tp_category(\n        cat_id smallint not null auto_increment,\n        cat_name varchar(30) not null default '' comment '分类名称',\n        pid  smallint not null default 0 comment '父分类的id',\n        create_time int not null default 0 comment '创建时间',\n        update_time int not null default 0 comment '更新时间',\n        primary key(cat_id)\n    )engine = Innodb default charset = utf8;\n   ```\n\n   **tp_article表结构：**\n\n   ```mysql\n   create table tp_article(\n   \tarticle_id smallint not null auto_increment,\n   \ttitle varchar(30) not null default '' comment '文章标题',\n   \tcontent  text   comment '文章内容',\n   \tcat_id smallint not null default 0  comment '文章所属分类',\n   \tori_img varchar(150) not null default '' comment '原图的路径',\n   \tthumb_img varchar(150) not null default '' comment '缩略图的路径',\n   \tcreate_time int not null default 0 comment '创建时间',\n   \tupdate_time int not null default 0 comment '更新时间',\n   \tprimary key(article_id)\n   )engine = Innodb default charset = utf8;\n   ```\n\n==注：表名加前缀`tp_`，用于区分多个项目。==\n\n可以向表添加几条模拟数据，方便后面进行查询\n\n![](media2/image1.png)\n\n\n\n## 2、配置数据库信息\n\n在`application/database.php`文件中配置数据库相应参数（* 标记）：\n\n```php\nreturn [\n    // 数据库类型\n    'type'            => 'mysql',\n    // 服务器地址\n    'hostname'        => '127.0.0.1',\n    // * 数据库名\n    'database'        => 'article',\n    // * 用户名\n    'username'        => 'root',\n    // * 密码\n    'password'        => 'root',\n    // * 端口\n    'hostport'        => '3306',\n    // 连接dsn\n    'dsn'             => '',\n    // 数据库连接参数\n    'params'          => [],\n    // 数据库编码默认采用utf8\n    'charset'         => 'utf8',\n    // * 数据库表前缀\n    'prefix'          => 'tp_',\n```\n\n\n\n## 3、模型 \n\n### （1）模型作用\n\n**M:Model**    模型\n\n**作用**：主要对数据库进行一些增删改查的操作。\n\n\n\n### （2）模型的定义\n\n如文章分类表，名为`tp_category`，此表对应的模型类名和模型文件定义如下：\n\n**模型类名**： `Category`，驼峰法，除开表前缀的数据表名称。\n\n**模型类文件**： `Category.php `, 表名+.php\n\n**模型类文件所在位置**：`模块名/model/Category.php`\n\n\n\n给表`tp_category`建立模型文件如下：\n\n![](media2/image2.png)\n\n其中模型中定义的属性`$pk`为表的主 键名称，若不指定则框架会自动识别。\n\n\n\n==有关表名的注意事项：==\n\n手册位置： 模型-\\>定义\n\n![](media2/image3.png)\n\n\n\n### （3）实例化模型\n\n-   **方式一**（==推荐==）：在控制器中实化模型首先引入其模型类所在的命名空间，如引入上面的`Category`\n\n    控制器中引入：\n\n    ```php\n    use app\\admin\\model\\Category;\n    ```\n\n    然后实例化模型：\n\n    ```php\n    $catModel= new Category();\n    ```\n\n    \n\n-   **方式二**：通过助手函数`model`（就不需要引入类的所在空间）：\n\n    ```php\n    $catModel = model('Category');\n    ```\n\n\n![](media2/image4.png)\n\n打印结果：\n\n![](media2/image5.png)\n\n----\n\n\n\n# 二、模型CURD操作\n\n**C-create**： 新增数据\n\n**U-update**： 更新数据\n\n**R-read**： 查询数据\n\n**D-delete**： 删除数据\n\n\n\n## 1、新增数据-C\n\n手册位置：模型-\\>新增\n\n### （1）添加一条数据\n\n-   **方式一**【==推荐==】：通过`save`方法\n\n    ```php\n    $model->save($data);\n    ```\n\n    **参数**：$data为一维数组，其中[‘表字段名’=>’数据’]\n\n    **返回值**：成功返回写入的记录数\n\n    \n\n    入库成功后，可以通过字段名当做模型对象属性获取对应的值，如获取自增主键字段值：\n\n    ```php\n    $model->save($data);  \n    echo $model->cat_id; \n    ```\n\n    \n\n-   **方式二**：通过`create`方法\n\n    使用模型名静态调用`create($data)`，如模型名为`User`:\n\n    ```php\n    User::create($data); \n    ```\n\n    **参数**：\\$data为一维数组，其中\\['表字段名'=\\>'数据'\\]\n\n    **返回值**：和save方法不同的是，create方法返回的是当前模型的对象实例\n\n\n\nsave方式：\n\n![](media2/image6.png)\n\ncreate方式：\n\n![](media2/image7.png)\n\n\n\n### （2）添加多条数据\n\n   模型调用`saveAll`方法\n\n   ```php\n$model->saveAll($data); \n   ```\n\n   **参数** ：  \\$data为二维数组，见下图。\n\n   **返回值** ： 成功返回对象集合。`[obj,obj,obj,....]`\n\n\n   ![](media2/image8.png)\n\n\n\n### （3）过滤非数据表字段\n\n注意：`allowField`需要实例化模型，不能直接类调用\n\n-   只允许数据表中的字段写入\n\n    ```php\n    $model->allowField(true)->save($data) ;\n    ```\n\n    \n\n-   只允许name和email字段写入\n\n    ```php\n    $model->allowField(['name','email'])->save($data);\n    ```\n\n    ![](media2/image9.png)\n\n\n\n### （4）(补充)数据库操作AR模式\n\n**AR** ：Active Record 活跃的对象\n\n-   模型类映射成表\n\n-   对象映射表中的一条记录\n\n-   属性映射到记录中某个字段\n\n    \n\n    ![](media2/image10.png)\n\n    **所以，入库成功之后如果是返回一个当前记录的数据对象，可以通过`$model->字段名`去获取对应的字段值**\n\n\n\n## **2、更新数据-U**\n\n手册位置：模型\\--\\>更新\n\n\n\n### （1）更新方式一\n\n```php\n$model->save($data,更新条件);\n```\n\n==注==：之前save方法只传入第一个参数为新增，通过**第二个参数**指定更新条件则为更新。\n\n\n\n或者通过`isUpdate(true)`方法明确指定`save`为**更新**操作，其中`$data`中==必须==带更新的**主键值**\n\n```php\n$model->isUpdate(true)->save($data);\n```\n\n\n\n更新若需要过滤非数据表的字段数据，使用`allowField(true)`：\n\n```php\n$model->isUpdate(true)->allowField(true)->save($data);\n```\n\n![](media2/image11.png)\n\n\n\n### （2）更新方式二(推荐)\n\n   通过`update`方法实现，但这样就无法使用模型的**事件功能**。\n\n```php\n$model->update($data);\n```\n\n   **参数** ：\\$data为一维数组，键名为表字段名，其中更新必须指定==更新条件==，否则更新失败。\n\n   **返回值** : 成功返回当前数据对象。\n\n![](media2/image12.png)\n\n\n\n==注：==\n\n-   `save`只能是**模型**对象调用\n\n-   `update`方法可以是**模型**对象或模型**类名**进行调用\n\n\n\n## 3、删除数据-D\n\n### （1）删除方式一(推荐) \n\n通过模型名静态方法`destroy`方法实现删除一条或多条数据\n\n```php\nCategory::destroy(1);  // 删除主键为1的记录\nCategory::destroy('1,2,3');  //删除主键为1,2,3的记录\n# 或数组形式\nCategory::destroy([1,2,3]); \n```\n\n**参数**：主键值\n\n**返回值**：返回受影响的行数\n\n![](media2/image13.png)\n\n\n\n### （2）删除方式二AR模式 \n\n先获取当前数据的模型对象，在调用delete方法进行删除\n\n```php\n$category = Category::get(1);  // 获取主键为1的记录\n$category->delete();  //执行删除\n```\n\n**返回值**：delete删除成功返回受影响的行数。\n\n![](media2/image14.png)\n\n\n\n**一般数据是不会删除的，通过逻辑删除。**\n\n**逻辑删除** ：即通过表中的某个字段如`is_delete`进行维护 ,值为1就是删除，值为0就是未删除。\n\n**物理删除**：直接删除这一条记录。\n\n\n\n## 4、查询数据-R\n\n### （1）获取一条记录\n\n```php\nCategory::get(1);\t// 获取主键值为1的记录\nCategory::find(1);  // 或获取主键值为1的记录， 推荐\n```\n\n**参数**：主键值\n\n**返回值**：成功返回当前记录数据对象\n\n![](media2/image15.png)\n\n\n\n**get和find的区别：**\n\n-   `find()` ：可以是对象或类名调用，前面支持连贯操作（`where()`、`field()`、`order`等）。\n\n    ```php\n    $model->where('id = 1')->find()\n    ```\n\n-   `get()`： 也可以是对象或类名调用，前面==不==支持连贯操作，但可以传递一个闭包函数实现连贯操作。\n\n    ```php\n    Category::get(function($query){\n    \t$query->where('id = 1');\n    });\n    ```\n\n    \n\n![](media2/image16.png)\n\n### （3）获取多条记录\n\n通过`select`或`all`方法，==推荐`select`==\n\n```php\nCategory::all();  // 获取表所有数据\nCategory::all('1,2,3'); //获取主键值为1,2,3的记录\n# 或数组形式\nCategory::all([1,2,3]); //获取主键值为1,2,3的记录\n\nCategory::select();  //获取表中的所有数据\nCategory::select('1,2,3');  //获取主键值为1,2,3的记录\n```\n\n**返回值**：`all`和`select`都是返回对象集合。\\[obj,obj\\]\n\n![](media2/image17.png)\n\n\n\n**`all`和`select`的区别：**\n\n-   `select()` ：可以是类名和对象调用，前面支持连贯操作。\n\n-   `all()` ：可以是类名和对象调用，前面不支持连贯操作，但可以通过闭包函数实现。\n\n需要把数据对象转化为关联数组，可以调用`toArray()`进行转换，打印数据更加直观\n\n![](media2/image18.png)\n\n\n\n### （4）设置数据返回类型\n\n模型默认查询数据方法`get`和`find`都是返回当前的数据对象object，可以调用`toArray`转化为关联数组。\n\nall和select方法都是返回对象集合。如：\\[object，object，object,\\...\\]，他们是不可以调用调用toArray方法的，但可以修改`application/database.php`文件配置项，可以指定返回数据类型为集合方可调用`toArray`。\n\n```php\n    // 数据返回类型\n    'resultset_type'  => 'think\\Collection', \n```\n\n之后`all`和`selec()->toArray()`返回的就是二维关联数组\n\n\n\n## 5、连贯操作\n\n手册位置：数据库\\--\\>查询构造器\\--\\>链式操作\n\n\n\n**注： 模型的链式操作方法和Db构造器链式操作的方法都通用；**\n\n\n\n**TP5常用的模型或Db构造器连贯操作方法如下：**\n\n-   `field(\"field1,field2...\")`：查询指定的字段field1和field2，多个用逗号隔开。\n\n-   `alias('数据表别名')`：给当前模型设置别名，一般在**join**联表时使用较多。\n\n-   `where(查询条件)`：其中查询条件可以为表达式查询、数组查询、字符串查询。\n\n-   `order(\"field desc\")`：把查询的到结果集根据字段field降序（desc）或升序(asc)。\n\n-   `group(\"field\")` ： 把查询的结果集根据字段field分组。\n\n-   `limit(offset,length)` ： 获取结果集指定条数的数据， offset为起始位置，length为获取记录的条数。\n\n-   `join()`：与其他表进行关联查询\n\n    \n\n    注意：\n\n    以上的连贯操作方法都是**返回当前模型的对象**，即方法底层都是返回当前模型对象(`return $this`)，所以他们之间的调用顺序不用按照原生的sql顺序来调用，但如果是查询数据，查询语句的最末端一定要确保是select或者是find方法。\n\n    在原生的sql语句中一定要按照先后顺序调用：\n\n    顺序为:join==\\>where ==\\> group ==\\> having\\=\\=\\>order==\\>limit\n\n    但在tp5中以上的连贯操作都不需要按照顺序。\n\n    \n\n### （1）where条件查询\n\n-   **where表达式查询条件**\n\n    ![](media2/image19.png)\n\n    ![](media2/image20.png)\n\n-   **where数组查询条件(推荐)**\n\n    完整语法：\n\n    ```php\n    $where = [\n        '字段名1'=> [表达式，'值']\n        '字段名2'=> [表达式，'值']\n    ]\n    // 如果是等值（=）查询，可以不用指定表达式，直接写值即可,如下\n    $where = [\n    \t\t'字段名' =>'值'\n    ];\n    ```\n\n    \n\n    ![](media2/image21.png)\n\n-   **where字符串查询条件**\n\n    语法：\n\n    ```php\n    where('字符串条件')\n    ```\n\n    代码如下：\n\n    ![](media2/image22.png)\n\n    注：\n\n    -   默认多字段查询是**and**连接。如果想使用**or**连接,可以使用方法`whereOr()`  ；\n\n    -   当排查sql语句是否有错误时，可以在连贯方法后面调用 `buildSql()`获得组装的sql语句，再把sql语句复制进行如navicat工具中进行执行，获取详细的错误信息。\n\n        ![](media2/image23.png)\n\n        效果：\n\n        ![](media2/image24.png)\n\n\n\n### （2）join联表\n\n手册位置：数据库\\--\\>查询构造器\\--\\>链式操作\\--\\>join\n\n基本语法：\n\n```php\nobject join ( mixed join [, mixed $condition = null [, string $type = 'INNER']] )\n```\n\n**参数**：\n\n`join`：要关联的（完整）表名以及别名\n\n 支持三种写法：\n```\n写法1：[ '完整表名或者子查询'=>'别名' ]\n写法2：'完整表名 别名'\n写法3：'不带数据表前缀的表名'\n```\n\n`$condition`：关联条件。可以为字符串或数组， 为数组时每一个元素都是一个关联条件。\n\n`$type`：关联类型。可以为: `INNER`、`LEFT`、`RIGHT`、`FULL`，==不区分大小写==，默认为`INNER`。\n\n\n\n如：查询出文章所属分类名称：\n\nsql原生写法：\n\n![](media2/image26.png)\n\n使用模型的join实现上面的功能：\n\n![](media2/image27.png)\n\n效果：\n\n![](media2/image28.png)\n\n\n\n## 6、聚合（统计）函数\n\n常用的有以下几个聚合（统计）函数\n\n![](media2/image29.png)\n\n注意:调用统计函数前均支持连贯方法，但必须保证最末端是统计函数。\n\n![](media2/image30.png)\n\n\n\n## 7、模型完成时间戳的自动维护\n\n手册位置：模型\\--\\>时间戳\n\n**步骤1**：首先给表设置 `update_time`、`create_time`字段，类型为**int**。\n\n![](media2/image31.png)\n\n**步骤2：** 在当前表模型中开启时间戳的自动写入，在子类(`Category`)中设置覆盖父类。\n\n![](media2/image32.png)\n\n开启时间戳自动写入之后，后面只要使用模型完成新增或编辑的操作，就会对表的两个时间字段字段进行自动维护。\n\n----\n\n\n\n# 三、通过Db构造器操作数据库\n\n通Db构造器操作数据库无需实例化模型也可对数据进行CURD操作。但有些功能会没有，如模型的时间戳自动维护等。\n\n手册位置：数据库\\--\\>查询构造器\n\n\n\n## 1、查询数据-R\n\n-   需先引入Db类\n\n    ```php\n    use think\\Db;\n    ```\n\n\n\n\n-   **查询一条数据，返回一维关联数组**\n\n    ```php\n    Db::table('think_user')->field('username,email')->where(id,1)->find(); \n    // table('表名')\n    ```\n\n    \n\n-   **查询多条数据，返回二维关联数组**\n\n    ```php\n    Db::table('think_user')->where(id,1)->select(); \n    Db::name('user')->order('id desc')->select(); #不带表前缀\n    ```\n\n    \n\n-   通过助手函数`db(表名)`获取Db对象，其表名不含表前缀\n\n    ```php\n    db('category')->where(id,1)->find(); \n    ```\n\n    \n\n    ==注:==\n\n    `Db::table('t_category')`：需要完整表名，带表前缀。\n\n    `DB::name('category')`：是不带表前缀，且他们都支持连贯操作，只需保证最末端是select或是find或统计函数。\n\n    模型和Db构造器的连贯方法都是**通用**的。\n\n![](media2/image33.png)\n\n\n\n## 2、添加数据-C\n\n-   **添加一条数据**\n\n    ```php\n    Db::table('tp_category')->insert($data);\n    ```\n\n    **参数**：\\$data为一维数组，键名必须为表的字段名。\n\n    **返回值**：成功返回1\n\n    \n\n-   或者直接使用`insertGetId`方法新增数据并返回新增记录的主键值\n\n    ```php\n    Db::name('category')->insertGetId($data);\n    ```\n\n    \n\n-   **添加多条数据**\n\n    添加多条数据直接向 Db 类的` insertAll `方法传入需要添加的数据即可\n\n    ```php\n    $data = [\n        ['foo' => 'bar', 'bar' => 'foo'],\n        ['foo' => 'bar1', 'bar' => 'foo1'],\n        ['foo' => 'bar2', 'bar' => 'foo2']\n    ];\n    Db::name('user')->insertAll($data);\n    ```\n\n    返回值：成功返回添加记录的条数。\n\n![](media2/image35.png)\n\n\n\n## 3、删除数据-D\n\n-   **根据主键删除**\n\n    ```php\n    Db::table('think_user')->delete(1);\n    Db::table('think_user')->delete([1,2,3]);\n    ```\n\n    \n\n-   **条件删除**\n\n    ```php\n    Db::table('think_user')->where('id',1)->delete();\n    Db::table('think_user')->where('id','<',10)->delete();\n    ```\n\n    `delete `方法返回影响数据的条数，没有删除返回 0\n\n    \n\n## 4、更新数据-U\n\n手册位置：数据库\\--\\>查询构造器\\--\\>更新数据\n\n### （1）更新数据表中的数据\n\n```php\nDb::table('think_user')->where('id', 1)->update(['name' => 'thinkphp']);\n```\n\n**返回值** ：成功返回受影响的行数，没做任何修改返回 0\n\n![](media2/image36.png)\n\n若更新数据中包含主键id，可以省略where方法，可以直接使用：\n\n```php\n// 包含主键id  : 'id'=>1\nDb::table('think_user')->update(['name' => 'thinkphp','id'=>1]);\n```\n\n![](media2/image37.png)\n\n\n\n### （2）更新某个字段的值\n\n把id=1的记录name字段改为thinkphp\n\n```php\nDb::table('think_user')->where('id',1)->setField('name', 'thinkphp');\n```\n\n**返回值**：成功返回受影响记录的行数，没做任何修改返回 0\n\n![](media2/image38.png)\n\n\n\n### （3）自增或自减一个字段的值\n\n**自增** \n\n```php\nsetInc('字段名'，步长);\n```\n\n**自减**\n\n```php\nsetDec('字段名'，步长);\n```\n\n**注意：若不指定第二个参数，默认自增或自减数为1**\n\n\n\n**示例**\n\nscore 字段加 1\n\n```php\nDb::table('think_user')->where('id', 1)->setInc('score');\n```\n\n\nscore 字段加 5\n\n```php\nDb::table('think_user')->where('id', 1)->setInc('score', 5);\n```\n\n\nscore 字段减 1\n\n```php\nDb::table('think_user')->where('id', 1)->setDec('score');\n```\n\n\nscore 字段减 5\n\n```php\nDb::table('think_user')->where('id', 1)->setDec('score', 5);\n```\n\n\n\n## 5、执行原生sql语句\n\n**查询**\n\n```php\nDb::query('select... ');\n```\n\n**返回值**：成功返回二维关联数组\n\n\n\n**增删改**\n\n```php\nDb::execute('insert/update/delete');\n```\n\n**返回值**：成功返回受影响的行数\n\n![](media2/image34.png)\n\n----\n\n\n\n# ==TP5第三天==\n\n# 一、composer概述\n\n## 1、什么是composer\n\nComposer 是 PHP 的一个包==依赖管理工具== ， 不是一个包管理器。 能够帮助我们安装我们项目所需要的依赖包。\n\n假设有个文件A.php,我们项目中使用需要就include A.php 包含进来，但是A.php又基于B.php,所以我们在A.php文件中又需要include B,但是不幸的B.php又基于C.php和D.php,于是又要在B.php进行include C.php和D.php 。假设C和D文件又基于其他文件，那么这样互相依赖的关系可能无止境。\n\n![](media3/image1.png)\n\n那么在项目中使用**composer**就可以解决各个文件互相依赖的问题。\n\n除了解决文件依赖的关系，它还有更多的**优点**：\n\n-   下载网络上别人分享的优秀的类库（包）。\n-   可对下载的类库进行管理，如：删除、更新等众多便利的操作。\n\n\n\n其实composer也就类似与Linux中yum，前端中的npm、bower等操作。这些工具都是可以用来管理我们项目的依赖文件。\n\n\n\n## 2、安装composer\n\n**安装方式一般有两种方式：**\n\n-   第一种方式：\n\n    去composer官网( https://getcomposer.org/download/ )下载`Composer-setup.exe`进行在线安装，由于此软件安装需要联网且服务器在国外安装很难成功，所以这里推荐使用下面第二种方式进行安装。\n\n    ![](media3/image2.png)\n\n-   \\[**==推荐==**\\]第二种方式\n\n    去官网https://getcomposer.org/download 下载`composer.phar`文件。\n\n    ![](media3/image3.png)\n\n    找到并进入 PHP 的安装目录,将下载的`composer.phar` 复制到 ==PHP 的安装目录==下面，也就是和 php.exe 在同一级目录。\n\n    ![](media3/image4.png)\n\n    在 PHP 安装目录（`D:\\phpStudy\\php\\php-5.6.27-nts`）下新建一个` composer.bat `文件，并将下列代码保存到此文件中。\n\n    ```basic\n    @php \"%~dp0composer.phar\" %*\n    ```\n\n    至此composer的安装就完成。\n\n    进入对应php版本目录(`D:\\phpStudy\\php\\php-5.6.27-nts`)中输入`composer`指令，出现如下提示代表安装成功：\n\n    ![](media3/image5.png)\n\n    \n\n    为了可以全局（任意位置）访问composer，可以把php.exe的所在目录（`D:\\phpStudy\\php\\php-5.6.27-nts`）定义在环境变量path选项中。\n\n    ![](media3/image6.png)\n\n    设置好后输入`php -v`即可看到php版本号。\n\n    ![](media3/image7.png)\n\n    cmd中任意位置输入`composer`指令：\n\n    ![](media3/image8.png)\n\n\n\n## 3、为composer配置国内镜像\n\n由于composer需要去网址为https://packagist.org 获取代码库地址，再通过地址去github上去下载代码到我们项目本地，由于这两个地址服务器都在国外，访问比较慢，也不稳定。\n\n![](media3/image9.png)\n\n配置国内镜像：https://pkg.phpcomposer.com/\n\n输入命令\n\n**全局配置**：\n\n```\ncomposer config -g repo.packagist composer https://packagist.phpcomposer.com\n```\n\n![](media3/image10.png)\n\n如上，参看composer配置命令，可查看composer配置保存的路径，全局的默认在当前用户文件夹下。\n\n\n\n**局部配置**：若只想在当前项目中有效，把上面的命令去掉 -g 即可。\n\n```\ncomposer config  repo.packagist composer https://packagist.phpcomposer.com\n```\n\n\n\n## 4、composer相关命令\n\n**包地址**：https://packagist.org/\n\n\n\n**参考阅读**\n\n[Composer 基本使用](https://docs.phpcomposer.com/01-basic-usage.html)\n\n[Composer进阶使用 —— 常用命令和版本约束](https://segmentfault.com/a/1190000005898222)\n\n\n\n-   **查看所有的composer可以使用的命令**\n\n    ```\n    composer list\n    ```\n\n\n\n-   **查看某个命令的使用**\n\n    ```\n    composer require --help\n    ```\n\n    \n\n-   **composer创建项目**\n\n    该命令是用来安装项目的，可以通过该命令去下载对应的项目文件。如，下载thinkphp框架\n\n    ```\n    > composer create-project   团队名称/包名称[=版本号] [指定下载目录]  [-vvv打印交互信息]\n    ```\n\n    ```\n    composer create-project topthink/think  shop\n    ```\n\n    注：其中`shop`代表框架存放的目录，会自动生成，未指定则默认放在同名(`think`)目录\n\n\n\n-   **安装一些第三方包** \n\n    该命令是用来安装项目开发中的依赖文件，例如上传类库、验证码类库。\n\n    ```\n    composer require 厂商/包名=版本号\n    ```\n\n    注：若不指定版本号默认安装最新版本\n\n    如安装tp5验证码1.0.3 版本：`composer require topthink/think-captcha=1.0.3`\n\n    如安装tp5验证码1.0的最高版本：`composer require topthink/think-captcha=1.0.*`\n\n    \n\n    **包名所有的版本**：https://packagist.org/packages/topthink/think-captcha\n\n    \n\n\n-   **安装`composer.json`指定的依赖包**\n\n    ```\n    composer install\n    ```\n\n    会自动安装在composer.json文件中所指定的各种依赖包，执行成功后会**多处**生成一个composer.lock的锁文件。后面需要更新依赖库只能通过`composer update`实现安装。\n\n    `composer.json`文件说明：\n    https://docs.phpcomposer.com/01-basic-usage.html#composer.json-Project-Setup\n\n    `composer.json`文件架构详解：https://docs.phpcomposer.com/04-schema.html\n\n    \n\n-   **删除指定的包**\n\n    ```\n    composer remove topthink/think-captcha\n    ```\n\n    \n\n-   **搜索指定的包**\n\n    ```\n    composer search topthink/think-captcha\n    ```\n\n    \n\n-   **更新依赖包**\n\n    ```\n    composer update\n    ```\n\n    若修改`composer.json`中**require**指定的依赖包，则存在`composer.lock`文件，则只能通过\n\n    `composer update`进行更新。\n\n\n\n-   **取消镜像**\n\n    ```\n    composer config -g --unset repos.packagist\n    ```\n\n    \n\n-   **查看当前composer版本**\n\n    ```\n    composer -v\n    ```\n\n    \n\n-   **升级composer版本**\n\n    ```\n    composer selfupdate\n    ```\n\n---\n\n\n\n# 二、使用composer安装tp5验证码\n\n手册位置：杂项\\--\\>验证码\n\n**步骤1**：切换到项目根目录即`composer.json `所在的目录，输入指令 `composer require topthink/think-captcha=1.0.*`进行安装。 在指定目录打开cmd，快捷键：ctrl+shfit+鼠标右键\n\n![](media3/image11.png)\n\n**注：不要安装2.0以上版本，此版本需要tp5是5.1版本，我们tp5版本是5.0版本** \n\n默认下载的tp5框架已经帮我们下载好了验证码，不用composer安装可直接使用即可。\n\n![](media3/image12.png)\n\n----\n\n\n\n# ==TP5第四天==\n\n\n\n# 一、XSS攻击\n\n## 1、xss介绍\n\n![](media4/image31.png)\n\n**演示**\n\n如在输入框输入js代码：\n\n![](media4/image32.png)\n\n页面访问此标题的时候就会弹出1，从而达成攻击；\n\n![](media4/image33.png)\n\n\n\n## 2、防止xss攻击（防止js攻击） \n\n\n\n### 2.1、使用htmlspecialchars函数防止\n\n**htmlspecialchars**函数的作用：将html标签符号转化为实体符号。\n\n如：大于号\"\\>\"会被转化为 `&gt;`\n\n如：小于号\"\\<\"会被转化为 `&lt;`\n\ntp5框架的**input**函数第三个参数可以指定过滤函数，若想要==全局过滤==可以在配置文件`application/config.php`中添加全局的过滤函数：\n\n```php\n    // 默认全局过滤方法 用逗号分隔多个\n    'default_filter'         => 'htmlspecialchars',\n```\n\n\n\n**注**：百度富文本编辑器，默认会进行过滤js代码。\n\n设置好全局过滤函数之后，通过富文本编辑器添加的文章内容显示如下：\n\n![](media4/image34.png)\n\n可见，全局设置的==缺点==会把html和js代码的特殊符号都进行转义。我们只希望转义危险的js代码，虽然解决了xss攻击，但富文本编辑器设置的html代码没有正常显示，这是我们不希望看到的。但可以借助`htmlspecialchars_decode()`进行反转，把html实体符号转化为html标签，但这又可能会造成xss攻击。\n\n\n\n可见：\n\n1.  不使用函数`htmlspecialchars()`进行处理，可能会出现xss攻击。\n\n2.  使用`htmlspecialchars()`函数进行过滤，但页面的数据（富文本编辑器设置的内容）又不能正常显示出来，可以借助`htmlspecialchars_decode()`进行反转，把html实体符号转化为html标签，但这又可能会造成xss攻击。\n\n\n\n我们的希望是html标签可以正常显示，但是又不希望js代码被执行。\n\n**解决xss攻击办法：**\n\n这时可以借助第三方防止xss攻击的插件如：**==HTMLPurifier==**，此插件会把浏览器提交过来的数据有选择性的过滤。只过滤危险的js代码，保留html代码，这就刚好满足我们的需求。\n\n\n\n### 2.2、使用插件HTMLPurifier防止XSS攻击\n\n**步骤1**：复制防止xss攻击的文件到extends目录中去\n\n![](media4/image35.png)\n\n**步骤2**：把HTMLPurifier目录中的`example.php`中的`removeXSS` 函数复制到`common.php`文件中\n\n![](media4/image36.png)\n\n修改应用配置`config.php`文件的全局过滤函数为上面的函数\n\n![](media4/image37.png)\n\n测试如下：\n\n![](media4/image38.png)\n\n可见，html代码可以正常显示，js代码被过滤了。\n\n----\n\n\n\n\n\n","categories":["ThinkPHP5框架"]},{"title":"Index","url":"%2Fposts%2F1102202886%2F","content":"\n\n# 索引\n\n## ECMAScript 6 简介\n[本地预览](ECMAScript6.md)    [Blog](http://blog.kuma8866.top/posts/3811458831/)     [Github](https://github.com/KumaDocCenter/js.ES6/blob/master/doc/md/ECMAScript6.md)\n\n \n\n","categories":["js.ES6"]},{"title":"Index","url":"%2Fposts%2F2092856000%2F","content":"\n\n# 索引 \n \n## jQuery基础知识 \n[本地预览](jQuery基础知识.md)    [Blog](http://blog.kuma8866.top/posts/2797510404/)     [Github](https://github.com/KumaDocCenter/js.Jquery/blob/master/doc/md/jQuery基础知识.md)\n \n* jQuery概述\n* 快速入门\n* jQuery中的事件\n* jQuery中的效果\n* jQuery中的Ajax\n* jQuery文档处理\n* jQuery插件编写\n \n \n \n## jQuery案例 \n[本地预览](jQuery案例.md)    [Blog](http://blog.kuma8866.top/posts/2598484047/)     [Github](https://github.com/KumaDocCenter/js.Jquery/blob/master/doc/md/jQuery案例.md)\n\n* 可编辑的表格\n* 纵向导航菜单\n* 横向导航菜单\n* 标签页(选项卡)效果\n* 无刷新分页+可编辑表格\n* 自定义弹出窗口插件 \n \n \n","categories":["js.Jquery"]},{"title":"Index","url":"%2Fposts%2F3406373355%2F","content":"\n\n# 索引 \n \n## Node.js入门和企业级项目开发01 \n[本地预览](nodejs01.md)    [Blog](http://blog.kuma8866.top/posts/3057491457/)     [Github](https://github.com/KumaDocCenter/js.NodeJS/blob/master/doc/md/nodejs01.md)\n \n \n \n## Node.js入门和企业级项目开发02 \n[本地预览](nodejs02.md)    [Blog](http://blog.kuma8866.top/posts/791990203/)     [Github](https://github.com/KumaDocCenter/js.NodeJS/blob/master/doc/md/nodejs02.md)\n \n \n \n## Node.js入门和企业级项目开发03 \n[本地预览](nodejs03.md)    [Blog](http://blog.kuma8866.top/posts/1479802669/)     [Github](https://github.com/KumaDocCenter/js.NodeJS/blob/master/doc/md/nodejs03.md)\n \n \n \n## Node.js入门和企业级项目开发04 \n[本地预览](nodejs04.md)    [Blog](http://blog.kuma8866.top/posts/3327617678/)     [Github](https://github.com/KumaDocCenter/js.NodeJS/blob/master/doc/md/nodejs04.md)\n \n \n \n## Node.js入门和企业级项目开发05 \n[本地预览](nodejs05.md)    [Blog](http://blog.kuma8866.top/posts/2974833176/)     [Github](https://github.com/KumaDocCenter/js.NodeJS/blob/master/doc/md/nodejs05.md)\n \n \n \n## Node.js入门和企业级项目开发06 \n[本地预览](nodejs06.md)    [Blog](http://blog.kuma8866.top/posts/676924322/)     [Github](https://github.com/KumaDocCenter/js.NodeJS/blob/master/doc/md/nodejs06.md)\n \n \n \n","categories":["js.NodeJS"]},{"title":"Index","url":"%2Fposts%2F292888922%2F","content":"\n\n# 索引 \n \n## NoSQL_Memcache \n[本地预览](NoSQL_Memcache.md)    [Blog](http://blog.kuma8866.top/posts/402189821/)     [Github](https://github.com/KumaDocCenter/NoSQL.Memcache/blob/master/doc/md/NoSQL_Memcache.md)\n \n* NoSql 概念\n* Memcache技术\n* window下memcache安装\n* Memcache下的常见命令\n  * add命令\n  * get命令\n  * set命令\n  * delete命令\n  * stats命令\n  * incr 自增命令\n  * decr 自减命令\n* PHP操作memcache\n* Memcache实现session共享\n* linux下源码编译安装memcache\n  * memcache安装\n  * linux下安装php的扩展memcache\n \n","categories":["NoSQL.Memcache"]},{"title":"Index","url":"%2Fposts%2F556915760%2F","content":"\n\n# 索引 \n \n## mongodb \n[本地预览](mongodb.md)    [Blog](http://blog.kuma8866.top/posts/4026166152/)     [Github](https://github.com/KumaDocCenter/NoSQL.Mongodb/blob/master/doc/md/mongodb.md)\n \n* mongoDB简介\n* mongoDB使用\n  * 库操作\n  * 数据操作\n* Mongodb高级查询技巧-单一条件\n* Mongodb高级查询技巧-多条件处理\n* php操作mongoDB\n\n\n \n## mongodb案例 \n[本地预览](mongodb案例.md)    [Blog](http://blog.kuma8866.top/posts/3990249883/)     [Github](https://github.com/KumaDocCenter/NoSQL.Mongodb/blob/master/doc/md/mongodb案例.md)\n \n* 案例：Mongodb实现短网址\n \n","categories":["NoSQL.Mongodb"]},{"title":"Index","url":"%2Fposts%2F3754862861%2F","content":"\n\n# 索引 \n \n## Redis \n[本地预览](Redis.md)    [Blog](http://blog.kuma8866.top/posts/3355790013/)     [Github](https://github.com/KumaDocCenter/NoSQL.Redis/blob/master/doc/md/Redis.md)\n \n* Redis简介\n* Redis的安装和使用\n* Redis的数据类型\n* php操作Redis\n* redis的持久化\n  * 快照模式\n  * aof 模式\n* redis安全认证\n\n\n \n## Redis案例_使用PHP实现消息队列 \n[本地预览](Redis案例_使用PHP实现消息队列.md)    [Blog](http://blog.kuma8866.top/posts/3783825305/)     [Github](https://github.com/KumaDocCenter/NoSQL.Redis/blob/master/doc/md/Redis案例_使用PHP实现消息队列.md)\n \n* 案例-使用PHP实现消息队列\n \n","categories":["NoSQL.Redis"]},{"title":"Index","url":"%2Fposts%2F3108201712%2F","content":"\n\n# 索引 \n \n## XML_基础知识 \n[本地预览](XML_基础知识.md)    [Blog](http://blog.kuma8866.top/posts/2727003801/)     [Github](https://github.com/KumaDocCenter/XML/blob/master/doc/md/XML_基础知识.md)\n\n* XML语法\n* XML的用途\n* 操作XML\n  * 操作XML元素节点\n  * 操作XML属性节点\n* Xpath查询 \n \n \n## XML_案例 \n[本地预览](XML_案例.md)    [Blog](http://blog.kuma8866.top/posts/3698054443/)     [Github](https://github.com/KumaDocCenter/XML/blob/master/doc/md/XML_案例.md)\n\n* 获取天气信息\n* 电子词典\n \n \n","categories":["XML"]},{"title":"Index","url":"%2Fposts%2F82364248%2F","content":"\n\n# 索引 \n \n## vagrant技术 \n[本地预览](vagrant技术.md)    [Blog](http://blog.kuma8866.top/posts/1535111454/)     [Github](https://github.com/KumaDocCenter/Vagrant/blob/master/doc/md/vagrant技术.md)\n \n  * 产生的背景（常见问题描述）\n  * 什么是vagrant工具\n  * 基本使用\n \n","categories":["Vagrant"]},{"title":"Index","url":"%2Fposts%2F432646131%2F","content":"\n\n# 索引 \n \n## SVN \n[本地预览](SVN.md)    [Blog](http://blog.kuma8866.top/posts/3963543486/)     [Github](https://github.com/KumaDocCenter/svn/blob/master/doc/md/SVN.md)\n \n* SVN概述\n* svn软件的安装\n* 部署单仓库\n* 部署多仓库\n* 多仓库的权限设置\n* svn中的版本回退\n* svn监管服务注册成window系统服务\n* svn中的钩子程序\n \n","categories":["svn"]},{"title":"Index","url":"%2Fposts%2F2447481194%2F","content":"\n\n# 索引 \n \n## 正则表达式 \n[本地预览](正则表达式.md)    [Blog](http://blog.kuma8866.top/posts/794273428/)     [Github](https://github.com/KumaDocCenter/RegExp/blob/master/doc/md/正则表达式.md)\n \n* 正则语法\n* 分组/捕获和反向引用\n* 匹配中文\n* 环视\n* 正则对象的属性和方法\n* JS中支持正则表达式的 String 对象的方法\n* PHP中的正则表达式\n\n\n \n## 正则表达式案例 \n[本地预览](正则表达式案例.md)    [Blog](http://blog.kuma8866.top/posts/2800343177/)     [Github](https://github.com/KumaDocCenter/RegExp/blob/master/doc/md/正则表达式案例.md)\n \n* 匹配手机号格式是否正确\n* 匹配邮箱格式是否正确\n* 用户名验证\n* 去重复\n \n","categories":["RegExp"]},{"title":"Index","url":"%2Fposts%2F3161139035%2F","content":"\n\n# 索引 \n \n## Nginx \n[本地预览](Nginx.md)    [Blog](http://blog.kuma8866.top/posts/1706463495/)     [Github](https://github.com/KumaDocCenter/Nginx/blob/master/doc/md/Nginx.md)\n \n* Nginx简介\n* Nginx安装\n* Nginx使用\n* Nginx的虚拟主机的配置\n* 负载均衡配置\n \n","categories":["Nginx"]},{"title":"Index","url":"%2Fposts%2F2356263222%2F","content":"\n\n# 索引 \n \n## mysql \n[本地预览](mysql.md)    [Blog](http://blog.kuma8866.top/posts/2501908538/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/mysql.md)\n\n* 安装和配置Mysql\n* 连接Mysql数据库\n  * 通过cmd命令行窗口管理Mysql服务\n  * 通过Window的服务来管理Mysql服务\n  * 使用命令行窗口来作为Mysql客户端\n\n \n \n## MySQL 字符集和校对集 \n[本地预览](mysql_charset_collate.md)    [Blog](http://blog.kuma8866.top/posts/2831383651/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/mysql_charset_collate.md)\n\n* MySQL 字符集和校对集\n  * 数据存储的编码\n  * 客户端的编码\n  * 校对集\n\n \n \n## MySQL 字段约束 \n[本地预览](mysql_constraint.md)    [Blog](http://blog.kuma8866.top/posts/1492550196/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/mysql_constraint.md)\n\n\n* MySQL 字段约束\n  * 非空值约束\n  * 默认值约束\n  * 主键约束\n  * 唯一值约束\n  * 外键约束\n \n \n \n## MySQL 数据类型 \n[本地预览](mysql_datatype.md)    [Blog](http://blog.kuma8866.top/posts/3832727553/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/mysql_datatype.md)\n \n* MySQL 数据类型\n  * 数值类型\n  * 日期时间类型\n  * 字符串类型 \n\n\n  \n## MySQL 管理\n[本地预览](mysql_manage.md)    [Blog](http://blog.kuma8866.top/posts/1044743360/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/mysql_manage.md)\n \n* MySQL 管理\n  * 数据的备份\n  * 用户和权限管理\n \n \n \n## MySQL 操作 \n[本地预览](mysql_manipulation.md)    [Blog](http://blog.kuma8866.top/posts/4146397750/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/mysql_manipulation.md)\n \n* 库操作\n* 表操作\n* 数据操作\n* 事务\n \n \n \n## MySQL 编程 \n[本地预览](mysql_programme.md)    [Blog](http://blog.kuma8866.top/posts/3965222648/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/mysql_programme.md)\n \n* SQL编程\n  * 触发器\n  * 存储函数\n  * 存储过程\n \n \n \n## MySQL 高级查询 \n[本地预览](mysql_select.md)    [Blog](http://blog.kuma8866.top/posts/885461339/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/mysql_select.md)\n \n* MySQL 高级查询\n  * 数据查询\n  * 子查询\n  * 连接查询\n  * 联合查询\n \n \n \n## MySQL 视图 \n[本地预览](mysql_view.md)    [Blog](http://blog.kuma8866.top/posts/932476632/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/mysql_view.md)\n \n* MySQL 视图\n  * 创建视图\n  * 使用视图\n  * 修改视图\n  * 删除视图 \n \n \n \n## 表的设计范式 \n[本地预览](table_NormalFormat.md)    [Blog](http://blog.kuma8866.top/posts/2613340531/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/table_NormalFormat.md)\n \n* 关系（二维表）的设计范式\n \n \n \n## 表之间的关系 \n[本地预览](table_relation.md)    [Blog](http://blog.kuma8866.top/posts/2063222971/)     [Github](https://github.com/KumaDocCenter/Mysql/blob/master/doc/md/table_relation.md)\n \n* 表之间的关系\n \n","categories":["Mysql"]},{"title":"Index","url":"%2Fposts%2F3463402775%2F","content":"\n\n# 索引 \n \n## linux操作系统1 \n[本地预览](linux操作系统1.md)    [Blog](http://blog.kuma8866.top/posts/905642747/)     [Github](https://github.com/KumaDocCenter/Linux/blob/master/doc/md/linux操作系统1.md)\n\n* linux发展历史\n* CentOS安装\n* 文件系统树\n* Shell\n* 远程连接linux操作系统\n* 文件夹和文件相关命令\n* linux常用使用技巧\n \n \n \n## linux操作系统2 \n[本地预览](linux操作系统2.md)    [Blog](http://blog.kuma8866.top/posts/2901562177/)     [Github](https://github.com/KumaDocCenter/Linux/blob/master/doc/md/linux操作系统2.md)\n\n* VI/VIM-linux下的编辑器\n  * vim编辑器的三种模式\n* 用户和用户组\n  * 用户的管理（root）\n  * 组的管理（root）\n* linux下的权限操作\n \n \n \n## linux操作系统3 \n[本地预览](linux操作系统3.md)    [Blog](http://blog.kuma8866.top/posts/3690292183/)     [Github](https://github.com/KumaDocCenter/Linux/blob/master/doc/md/linux操作系统3.md)\n \n* linux软件安装管理\n  * 二进制包\n    * rpm\n    * yum\n  * 源码包\n    * 源码编译\n* linux服务管理\n  * linux的运行级别\n  * linux服务分类\n  * 查看已安装的服务\n  * 服务状态查看\n  * rpm服务-管理（yum）\n  * 源码包服务-管理\n* linux系统管理\n  * 进程查看\n  * 进程树查看\n  * 服务器负载查看\n  * 结束进程\n* linux后台作业\n* linux定时任务](linux操作系统3.md\n* lamp环境的搭建\n* Samba\n* Sudo\n \n \n","categories":["Linux"]},{"title":"Index","url":"%2Fposts%2F1102202888%2F","content":"\n\n# 索引 \n \n## js运行机制 \n[本地预览](js运行机制.md)    [Blog](http://blog.kuma8866.top/posts/3150218531/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/JavaScript运行机制/js运行机制.md)\n \n \n \n","categories":["JavaScript运行机制"]},{"title":"Index","url":"%2Fposts%2F1102202887%2F","content":"\n\n# 索引 \n\n## JavaScript_Basics \n[本地预览](JavaScript_Basics.md)    [Blog](http://blog.kuma8866.top/posts/912179596/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/Basics/JavaScript_Basics.md)\n\n \n\n","categories":["Basics"]},{"title":"Index","url":"%2Fposts%2F1102202886%2F","content":"\n\n# 索引 \n \n## JavaScript_DOM对象和事件 \n[本地预览](JavaScript_DOM对象和事件.md)    [Blog](http://blog.kuma8866.top/posts/1771752198/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/Advanced/doc/md/JavaScript_DOM对象和事件.md)\n \n \n \n## JavaScript_冒泡事件 \n[本地预览](JavaScript_冒泡事件.md)    [Blog](http://blog.kuma8866.top/posts/2780478422/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/Advanced/doc/md/JavaScript_冒泡事件.md)\n \n \n \n## JavaScript_基础知识 \n[本地预览](JavaScript_基础知识.md)    [Blog](http://blog.kuma8866.top/posts/2727413451/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/Advanced/doc/md/JavaScript_基础知识.md)\n \n* 变量和常量\n* 运算符\n* 流程控制\n* 数据类型和类型转换\n* 函数\n* 执行流程\n* 作用域\n \n \n \n## JavaScript_案例 \n[本地预览](JavaScript_案例.md)    [Blog](http://blog.kuma8866.top/posts/2023490148/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/Advanced/doc/md/JavaScript_案例.md)\n \n* 可编辑的表格\n* 隔行换色\n* 全选，反选，取消\n* 仿淘宝评分\n* 图片淡入淡出\n\n \n \n## JavaScript_闭包 \n[本地预览](JavaScript_闭包.md)    [Blog](http://blog.kuma8866.top/posts/994947546/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/Advanced/doc/md/JavaScript_闭包.md)\n \n \n \n## JavaScript_阻止默认行为 \n[本地预览](JavaScript_阻止默认行为.md)    [Blog](http://blog.kuma8866.top/posts/670022636/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/Advanced/doc/md/JavaScript_阻止默认行为.md)\n \n \n \n## JavaScript_面向对象编程和系统对象 \n[本地预览](JavaScript_面向对象编程和系统对象.md)    [Blog](http://blog.kuma8866.top/posts/412987062/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/Advanced/doc/md/JavaScript_面向对象编程和系统对象.md)\n \n \n \n## JavaScript_高级 \n[本地预览](JavaScript_高级.md)    [Blog](http://blog.kuma8866.top/posts/3348228145/)     [Github](https://github.com/KumaDocCenter/js.JavaScript/blob/master/doc/md/Advanced/doc/md/JavaScript_高级.md)\n \n* 原型和原型链\n* 定义“类”或对象的多种方式\n* 私有和封装\n* 静态属性和方法\n* 继承\n* 遍历对象\n* 顶层函数\n \n","categories":["Advanced"]},{"title":"Index","url":"%2Fposts%2F1102202885%2F","content":"\n\n# 索引 \n \n## HTML和HTML5 \n[本地预览](HTML和HTML5.md)    [Blog](http://blog.kuma8866.top/posts/1392188595/)     [Github](https://github.com/KumaDocCenter/Html/blob/master/doc/md/HTML和HTML5.md)\n \n \n \n","categories":["Html"]},{"title":"Index","url":"%2Fposts%2F2446584502%2F","content":"\n\n# 索引 \n \n## docker技术 \n[本地预览](docker技术.md)    [Blog](http://blog.kuma8866.top/posts/1951862235/)     [Github](https://github.com/KumaDocCenter/Docker/blob/master/doc/md/docker技术.md)\n\n  * 简介\n  * Docker安装\n  * Docker常用命令\n  * Docker基本使用\n  * Docker 容器管理\n  * Docker镜像管理\n  * Docker数据卷\n  * Dockerfile\n \n \n","categories":["Docker"]},{"title":"Index","url":"%2Fposts%2F2811536523%2F","content":"\n\n# 索引 \n \n## CSS \n[本地预览](CSS.md)    [Blog](http://blog.kuma8866.top/posts/3999917138/)     [Github](https://github.com/KumaDocCenter/CSS/blob/master/doc/md/CSS.md)\n \n \n \n","categories":["CSS"]},{"title":"Index","url":"%2Fposts%2F1019209027%2F","content":"\n\n# 索引 \n \n## Composer笔记 \n[本地预览](Composer笔记.md)    [Blog](http://blog.kuma8866.top/posts/2185734586/)     [Github](https://github.com/KumaDocCenter/Composer/blob/master/doc/md/Composer笔记.md)\n \n \n \n","categories":["Composer"]},{"title":"Index","url":"%2Fposts%2F1525278992%2F","content":"\n\n# 索引 \n \n## Bootstrap \n[本地预览](Bootstrap.md)    [Blog](http://blog.kuma8866.top/posts/3545416915/)     [Github](https://github.com/KumaDocCenter/Bootstrap/blob/master/doc/md/Bootstrap.md)\n \n \n \n","categories":["Bootstrap"]},{"title":"Index","url":"%2Fposts%2F1005662515%2F","content":"\n\n# 索引 \n\n## apache \n[本地预览](apache.md)    [Blog](http://blog.kuma8866.top/posts/3588426178/)     [Github](https://github.com/KumaDocCenter/Apache/blob/master/doc/md/apache.md)\n\n* Apache简介\n* 安装和配置\n* 目录结构\n* 配置虚拟主机\n* 权限配置 \n\n \n","categories":["Apache.httpd"]},{"title":"Index","url":"%2Fposts%2F1102202885%2F","content":"\n\n# 索引 \n\n## Ajax和JSON \n[本地预览](Ajax和JSON.md)    [Blog](http://blog.kuma8866.top/posts/2279573566/)     [Github](https://github.com/KumaDocCenter/Ajax/blob/master/doc/md/Ajax和JSON.md)\n\n* Ajax 概述\n* Ajax工作原理\n* XMLHttpRequest对象介绍\n* 使用Ajax的步骤\n* JSON 概述\n* 处理服务器返回json格式的数据\n* 处理服务器返回XML格式数据\n\n \n\n## Ajax和JSON案例 \n[本地预览](Ajax和JSON案例.md)    [Blog](http://blog.kuma8866.top/posts/2669275496/)     [Github](https://github.com/KumaDocCenter/Ajax/blob/master/doc/md/Ajax和JSON案例.md)\n\n* 省市县三级联动\n* Ajax跨域获取天气信息\n* Ajax无刷新分页\n\n \n\n## Ajax高级 \n[本地预览](Ajax高级.md)    [Blog](http://blog.kuma8866.top/posts/738503265/)     [Github](https://github.com/KumaDocCenter/Ajax/blob/master/doc/md/Ajax高级.md)\n\n* FormData\n* Ajax跨域问题\n  * 什么是跨域请求\n  * 解决跨域问题 \n\n \n\n","categories":["Ajax"]},{"title":"linux操作系统2","url":"%2Fposts%2F2901562177%2F","content":"\n\n\n# ==VI/VIM-linux下的编辑器==\n\n1. vim编辑器（linux下的一个文本编辑器）是vi的一个升级版，如果学会vim ，其实也就会了vi。\n2. 用户和用户组（linux一个非常重要概念）才能更好去掌握linux下的权限问题。（linux是一个多任务、多用户操作系统）【笔试：如何理解 755 或者 644 这个数字？】\n\n\n\n## 简介\n\n现在我们掌握了linux的基本命令之后，我们可以通过命令来进行linux的基本操作，现在假设我们要在`/var/www/html`目录下编写一个叫做phpinfo.php的文件？那么这时我们应该如何编写phpinfo.php这个文件呢？\n\n```\n# vim phpinfo.php\n```\n\n\n问题来了：在linux下没有**sublime Text**这样软件工具，那么我们如何在命令界面中编写phpinfo.php的代码呢？在Linux如果希望编辑文件我们可以使用vi或者vim来进行编辑操作。\n\n \n\nVI/VIM是一款编辑器，它们是Linux自带编辑器。VIM是VI的升级版。功能上VI和VIM都是一样的。\n\nVIM具有**语法着色**的功能而VI没有，所以人们会更加喜欢使用VIM。(vi vim是同一个东西)\n\n \n\n**linux下常见的编辑器有：**\n\n`nano `最早的一个编辑器，很原始，不要学习\n\n`vim` 只是vi编辑器的升级版（编辑器的神）（phpstorm 或sublime + vim插件 => 基本上可以完全脱离鼠标）\n\n`emacs Unix`编辑器（神的编辑器）\n\n \n\nvim 是编辑器中的神，所有编辑器 vim 最好用，一般的类Unix操作系统里面都自带vi(后期yum进行升级 `yum install -y vim`)；emacs是神的编辑器，使用的人是最牛的，一般在Unix的操作系统使用。\n\n  \n\n**注意**：一般linux操作系统也叫作 **类 Unix 操作系统，**早期linux由来是与Unix密不可分的。\n\n\n\n## vim编辑器测试\n\n```shell\n# vim\n\n当在命令行输入 vim 后，会打开如上的这个界面，代表vim可以正常使用，当输入 :q后（进来之后不要做任何的操作）可以实现vim的退出。\n```\n\n\n\n## vim打开文件的命令\n\n```shell\n# vim  fileName\n文件是可以存在的文件也可以是不存在的文件\nvim如果打开一个不存在的文件，那么会在底部显示一个新文件的标识。\n```\n\n\n\n## ==vim编辑器的三种模式【重要】==\n\n![1536155197372](1536155197372.png)\n\n\n\n当使用vim编辑器对某个文件进行操作的时候，需要注意vim存在三种模式，每种模式都存在一些特点的操作，例如在编辑模式下修改文件里面的内容，末行模式下实现文件的保存。并且这三种模式是可以相互进行切换的，已达到不同的目的。（`esc` 退出当前这种模式` i `代表是insert插入的意思 `w` 代表写入 `q` 代表退出 quit）\n\n\n\n操作步骤\n\n1. vim fileName 打开一个文件，当打开一个文件后，默认处在命令模式\n2. 按一下 i 键 可以对文件的内容做编辑，可以对文件最实质性的操作，往里面写东西\n3. 按一下 esc 键 回到命令模式\n4. 输入 **:**   ，然后在 输入 wq ，代表保存并退出\n\n\n\n### 编辑模式-文件内容编写\n\n当vim在打开一个文件之后，其实vim处于一个命令模式的状态在等待`用户输入正确的指令`才能切换到编辑模式【插入模式】当中，如果你输入的是1111这的内容在vim的命令模式下看来这个不是一个正确的指令，所以vim什么都不会做，这时有些人认为当前是死机的状态，然而不是，这是一个等待命令输入的状态。\n\n1. 输入表格中的命令就可以进入编辑模式\n\n| 命令         | 解释                       |\n| ------------ | -------------------------- |\n| i            | 在光标之前插入内容         |\n| I            | 让光标回到行首输入内容     |\n| o(小写字母o) | 在光标之下新起一行插入内容 |\n| O            | 在光标之上新起一行插入内容 |\n| a            | 在光标之后插入内容         |\n| A            | 让光标去到行末输入内容     |\n\n2. 退出编辑模式按esc键\n\n3. 输入 ：键，进入末行模式\n\n4. 输入 wq 保存并退出\n\n\n\n### 末行模式-文件保存退出查找\n\n一般末行模式也叫作**尾行模式。**当打开文件后，默认是在命令模式，如果需要修改文件的内容，需要按` i `键 进入插入模式， 当文件修改完之后，需要 按` esc`键 回到 命令模式， 按一下`  :`  键 回到末行模式，在输入 `wq `保存并退出。\n\n1. 输入` : `就可以让vim进入末行模式，以下命令是末行模式的常用功能\n\n| 命令      | 解释                                               |\n| --------- | -------------------------------------------------- |\n| :w        | w是write的意思，意思是写入内容。newFilename 时另存 |\n| :q        | quit退出vim                                        |\n| :wq       | 保存并退出                                         |\n| **:x**    | **保存并退出，相当于是:wq的简写**                  |\n| :q!       | 强制退出   ! 表示强制                              |\n| :w!       | 强制保存（写入）                                   |\n| :wq!      | 强制保存并退出（root去操作一些只读的文件）         |\n| :set nu   | 设置行号nu（number）                               |\n| :set nonu | 取消行号                                           |\n| :1        | 回到行首                                           |\n| :n        | 去到第n行，如去到第21行                            |\n| : /关键字 | 搜索关键字，如果有关键字，进行高亮                 |\n| :nohls    | 去除高亮显示 【highlights，高亮】                  |\n\n2. 使用两次esc键可以退出末行模式，进入命令模式\n\n\n\n#### 示例\n\n```\n1.末行模式下设置行号\n: set nu\n```\n\n\n\n```\n2.如何取消\n: set nonu\n```\n\n\n\n```\n3.文件的退出\n: q (文本没有修过的情况下，可以直接退出)\n\n问题：当文本内容本修改后，使用 :q 不能直接退出\n: q! (在文本内容被修改后，但是不希望文本里面的修改内容被保存下来)\n```\n\n\n\n```\n4. 文件保存\n: w \n\n: w  newFileName(另存为)\n```\n\n\n\n```\n5. 查找\n:/关键字\n注意：n 键 向下跳转 N键 向上跳转\n```\n\n\n\n```\n6.取消关键字的高亮(noh = no highlights高亮)\n: nohls \n```\n\n\n\n### 命令模式\n\n在命令模式下，主要是做做一些命令的操作，例如文本的复制，删除等。其主要操作如下\n\n| 命令 | 解释                                                         |\n| ---- | ------------------------------------------------------------ |\n| G    | 去到末行                                                     |\n| gg   | 去到首行，相当于输入:1                                       |\n| r    | replace的意思，替换光标选中的内容                            |\n| x    | 删除光标选择中内容  extract                                  |\n| u    | 撤销功能(undo)，相当于windows下的ctrl+z ，如果我们是切换到末行模式下可以输入: 3u 代表撤销三步 |\n| yy   | 复制一行 注意如果 3yy 代表复制3行                            |\n| p    | 粘贴 如果是小写p则在光标所在下一行进行粘贴，如果要想在光标上一行粘贴，按  P(大写) |\n| dd   | 删除一行                                                     |\n| ndd  | 删除n行，3dd删除3行                                          |\n\n**思考：如何快速的删除所有的行？**\n\n答：从头删除到尾\n\n1. gg（文首）\n2. d （delete 删除）\n3. G （文末）\n\n总结：在命令模式下快速  ggdG\n\n\n\n#### 光标移动相关演示操作\n\n只要键入vim打开文件就处于命令行模式，在命令模式下，可以使用键盘的 **上下左右** 做移动，也可以使用 如下按键：\n\n`h`  向左\n\n`j`  向下\n\n`k`  向上\n\n`l `  向右\n\n\n\n1. 光标级的移动\n\n   答： h  j   k  l \n\n2. 单词级别的移动\n\n   答：\n\n   e 键：可以跳到当前单词的末尾，或者下一个单词的末尾（end）\n\n   b 键：可以跳到当前单词的首部，或者上一个单词的首部（before）\n\n\n3. 行级别的跳动\n\n   答：\n\n   0：代表行首\n\n   $：代表行尾\n\n4. 指定行数跳转\n\n   答：NUMBER+G\n\n   例如：从第一行跳到第18行\n\n5. 跳到文档的第一行首部\n\n   答：gg\n\n6. 跳动文档的最后一行的首部或者尾部\n\n   答：G\n\n   \n\n\n#### **文本内容删除**\n\n1. 删除一行\n\n   答：dd\t\n\n2. 删除单个字符\n\n   答： x （使用 x 可以单个字符）\n\n3. 指定行数删除\n\n   答：NUMBER  +  dd \n\n4. 删除当前光标到行尾的所有字符\n\n   答：d$\n\n5. 删除当前光标到行首的所有字符\n\n   答：d0\n\n   \n\n#### **复制操作**\n\n1. 复制单行\n\n   答：在命令模式下使用 yy 复制一行，按 p 粘贴该行信息 （大写P： 当前光标的上一行粘贴）\n\n2. 复制多行\n\n   答：NUMBER+yy\n\n\n\n## vim常见开发技巧及问题\n\n### esc快捷键\n\n为什么在使用vim编辑器的时候，要使用esc键做模式的切换。\n\n答：早起的键盘的esc键是在Q旁边，非常方便小拇指的使用，现在的键盘esc键不方便使用。\n\n![1536114738118](1536114738118.png)\n\n\n\n**如何解决手指无法触及 esc 键？**\n\n答：在用户家目录的 .vimrc 文件中定义一个快捷键来代替 esc 键 \n\n```shell\n# cd (备注：cd 后面如果什么都不加，代表是回家，回到家目录 或者 cd ~ ~代表的是家目录)\n# vim .vimrc \n imap jj <Esc>\n```\n\n当打开文件，按 i键 进入插入模式，书写完内容后，然后快速的 按 jj , 这个时候就回到了 命令模式，然后在输入 ： 回到末行模式 ，在输入 wq 保存退出。\n\n\n\n### 默认行号\n\n使用 vim编辑器 打开文件默认有行号\n\n```shell\n# cd  \n# vim .vimrc \n  set nu\n```\n\n\n\n### 非法关闭文件\n\n当文件非法关闭之后，无法正常使用，如何解决？\n\n答：删除该隐藏文件即可\n\n![1536115323997](1536115323997.png)\n\n\n\n### 清屏\n\n有的时候 见到别人输入 cls 来清屏  （.bashrc  这个文件是当前` bash shell`的配置文件）\n\n```shell\n# cd  \n# vim .bashrc \nalias cls=\"clear\"\t\n```\n\n然后在执行如下重新读取配置`.bashrc`\n\n```shell\n#   .  .bashrc ( . 代表的含义是读取该配置文件 )\n```\n\n\n\n### 解锁vim锁住\n\n当有的时候用户习惯按 `ctrl+s `在vim下实现文件的保存\n\n解决：可以使用` ctrl  +  q` 键 \n\n\n\n### 编辑撤销\n\n文件编辑的撤销\n\n解决：在末行模式下输入` u `，也可以输入` NUMBER+u`  代表撤销NUMBER步操作\n\n\n\n----\n\n\n\n# ==用户和用户组==\n\n## 简介\n\nlinux是一个多用户 ：同一时间可以让多个用户登录到该操作系统、多任务：同一时刻可以完成多个任务，可以运行多个软件 的系统，Windows系统是多任务单用户的操作系统。\n\n \n\n**多任务**：操作系统可以同时完成多个任务，例如听歌、操作word、看电影\n\n**多用户**：同一时间，多个用户可以同时登录操作系统\n\n**单用户**：同一时间，只有一个用户登录操作系统\n\n \n\n对于一个linux操作系统，是一个多用户的操作系统，那么不可避免的要添加用户，删除用户....\n\n \n\n**用户的管理curd**：\n\n1. 用户的添加\n2. 用户的展示\n3. 用户的修改\n4. 用户的删除\n\n语法：user+ add|del\n\n\n\n## 用户的管理（root）\n\n### 用户添加\n\n```shell\n# useradd userName\n```\n\n**添加的用户信息保存到哪里？**\n\n答：保存到` /etc/passwd`文件\n\n```shell\n[root@dockerTest ~]# cat /etc/passwd\n\nroot:x:0:0:root:/root:/bin/bash\n...\nmysql:x:501:501::/home/mysql:/sbin/nologin\nasion:x:502:502::/home/asion:/bin/bash\n```\n\n**每一行代表一个用户信息，同时每行由七个部分组成：**\n\n1. **用户名**\n2. **密码位**(该位只是用户密码的占位符，并不实际存放用户的密码，用户的实际密码保存在`/etc/shadow`[影子文件]文件里面)\n3. **UID**  用户id（备注：500及之前的已经被linux操作系统默认保留使用的）\n4. **GID**  用户组id，体现分类管理的思想，一个组下可以存在多个用户，通过划分小组，可以更好的管理linux下的用户\n5. **注释信息**（有的时候在添加用户的时候给的备注信息）\n6. **用户的家目录**（系统在添加用户的时候，默认会在`/home/`下用户名同名的目录） 默认情况下，用户在自己的家目录可以做任何事情。\n7. **用户能够使用的命令解释器** (shell， 一般使用` /bin/bash`) \n   * `/sbin/nologin` 代表的含义：在linux下，当我们运行一个服务的时候，例如web服务，则这个服务需要一定的用户身份来启动 web服务的命令但不需要登录。如果分配的是这个 shell 则表示用户没权限登录到Linux系统。\n\n\n\n### 用户名修改\n\n```shell\n# usermod  -l  newName  oldName\n```\n\n`-l`  ，小写字母L ，表示后边要修改的是登录名\n\n\n\n### 修改密码 \n\n1. 超级管理员修改\n\n   ```shell\n   # passwd  USERNAME\n   ```\n\n2. 修改当前用户名的密码(后面不需用户名，直接回车)\n\n   ```shell\n   $ passwd \n   ```\n\n\n\n### 用户删除\n\n```shell\n# userdel  USERNAME\n```\n\n**注意**：当使用 userdel USERNAME 删除用户的时候，默认不会删除用户的家目录，需要加上一个参数` -r` 选项即可删除用户的同时也删除用户的家目录。\n\n\n\n## 组的管理（root）\n\n**为什么要设置组？**\n\n答：其主要的目的就是为了管理上的方便。管理一个组的成本远小于管理每个用户。\n\n\n\n例如：为某一个组设置了权限，那么相当于组内所有的用户全部拥有了该权限，方便设置管理。\n\n\n\n**主要操作是**\n\n添加、修改、删除、展示\n\n语法：group + add | del | mod\n\n\n\n### 组添加\n\n```shell\n#  groupadd superadmin\n```\n\n注意：当添加组信息之后，该信息被保存在` /etc/group`文件里面\n\n```\n[root@dockerTest ~]# cat /etc/group\nroot:x:0:\nbin:x:1:bin,daemon\ndaemon:x:2:bin,daemon\nsys:x:3:bin,adm\nadm:x:4:adm,daemon\ntty:x:5:\ndisk:x:6:\n...\n```\n\n注意：\n\n1. 组名\n2. 组密码的占位符（一般选择的linux操作系统不在使用组密码）\n3. 组ID\n4. 组成员，逗号分隔\n\n\n\n例如：添加用户的时候为用户指定组\n\n```shell\n# useradd -g 505 lilei\n```\n\n可以在该用户登录后，使用  id 命令查看组信息\n\n```shell\n[root@dockerTest ~]# id\nuid=0(root) gid=0(root) groups=0(root)\n```\n\n注意：当我们在linux下使用root创建一个普通用户的时候，如果没有使用` -g `指定当前用户所属的组，则linux默认会自动生成一个和当前用户同名的小组，并且把当前用户加入到该组里面。\n\n```shell\n# useradd liyang\n```\n\n\n\n### 组修改\n\n修改组名\n\n```shell\n# groupmod -n newGroup oldGroup\n```\n\n\n\n### 组删除\n\n```shell\n# groupdel groupName\n```\n\n**注意**：当组内还有成员的时候，不允许删除\n\n\n\n# ==linux下的权限操作==【重点】\n\n==【笔试题常见】== \n\n\n\n## 简介\n\n由于linux是一个多用户的操作系统，在同一时刻可能存在多个用户登录操作系统，每个用户都存在各自属于自己的文件，则这个时候需要一个合理的权限机制来管理这些信息，不然就会出现混乱。\n\n \n\n1. 在linux下的权限分为三个部分：**可读(Read)**、**可写(Write)**、**可执行(eXecute)** \n\n2. 同时按照用户将权限划分为三类\n\n   文件的拥有者： 主人 （**u**）user\n\n   文件所属组：所属组 （**g**）group\n\n   除开前面两类的其他人：其他人( **o**) others \n\n\n\n例如：可以使用  `ls -l fileName` 来查看文件的权限信息 \n\n```shell\n[root@dockerTest ~]# ls -l a.txt \n-rw-r--r-- 1 root root 0 Aug 30 16:03 a.txt\n\n-（文件类型）   rw-(文件的拥有者的权限信息)  r--(所属组的权限信息)   r--(其他人的权限信息)\n\n文件的拥有者的权限信息：描述文件的拥有者的权限，谁创建了这个文件，谁就是文件的拥有者\n```\n\n\n\n**这个权限字符串有10个字符组成，其含义如下：**\n\n* 文件类型：-代表是普通文本文件，d代表目录，l代表符号链接(快捷键 link)\n* 后面的9个字符，每三个字符为一组，分别代表代表文件的拥有者、所属组、其他人\n* 每组中存在 r、w、 x、 - 这四个字符的组合，分别为 可读、可写、可执行、没有权限\n\n\n\n`rw-`：此分为三个部分\n\n1. `r `    代表可读，`-` 没有权限\n2. `w`    代表可写 ，`-` 没有权限\n3. `x`   代表执行权限，`-` 没有权限\n   * 代表没有执行的权限（如果是一个普通的文本 ascii ，如果里面使用  shell 编程，这里代码可以被执行，但需要执行的权限\n\n\n\n\n\n## 可读、可写、可执行解释\n\n1. **如果是对普通文本文件的可读、可写、可执行操作是什么含义？**\n\n   答：\n\n\t**可读**：可以查看文件里面的内容（cat、more、less、tail、head）\n\n\t**可写**：对文件的内容做编辑（vim、echo），**但是不代表能删除该文件**，如果要删除该文件，需要对该文件的目录有可写的权限才可以删除。\n\n\t**可执行**：linux有一种编程叫做 shell编程，对脚本文件有可执行权限，表示可以执行文本文件里面的代码 \n\n\n\n2. **如果是对文件夹的可读、可写、可操作是什么含义？**\n\n   答： \n\n   **可读**：查看文件夹内部的信息(ls)\n\n   **可写**：表示可以 **删除**文件夹**内**的文件 或者 **修改**文件夹里面的文件的名称(mv、cp、rm、touch)\n\n   **可执行**：对目录的可执行，是可以进入该目录里面。如果对文件夹没有`x `权限表示不能进入文件夹内部，一般在建立文件夹的时候默认都是会有`x`权限的。\n\n\n\n\n## 具体权限分配解释\n\n1. 可以使用` chmod `来分配权限，分配的方式有两种：\n   * 字母法分配\n   * 数字法分配【首选】\n2. 查看文件权限` ls  -l  fileName`\n3. 查看文件夹权限 ` ls  -ld   directoryName`\n\n\n\n## 字母法设置权限\n\n使用` +`、`-`  操作来个文件的拥有者、所属组、其他人进行权限的设置，例如：\n\n例一、给fileName的拥有者设置可执行的权限 （u代表文件的拥有者  g 代表所属组  o代表其他人）\n\n```shell\n# chmod u+x fileName \n```\n\n\n\n例二、给fileName的拥有者减去执行的权限，给其他人设置可写的权限\n\n```shell\n# chmod u-x,o+w fileName \n```\n\n通过字母法进行权限的设置，需要知道原始的权限，然后还要写这么长的字符串，比较麻烦，一般使用都是数字法进行权限的设置。\n\n\n\n## 数字法设置权限\n\n可读 r   :  可以使用数字 **4** 表示\n\n可写 w  :  可以使用数字 **2** 表示\n\n可执行 x  :  可以使用数字 **1** 表示\n\n\n\n**例如**\n\n000 啥都没有  0\n\n001 有可执行的权限 1\n\n010 有可写的权限  2\n\n100 可读的权限   4\n\n110 可读可写，但是不可以执行 6\n\n \n\n例如：可读可写的权限如果用字母表示为rw，代表是用数字表示，只需要将对应的数字进行相加即可6。\n\n```\n-   rw-（6）   r--(4)    rw-(6)\n\n题目：如何理解 linux下的 一个 646 的数字字符串？\n答：代表linux下的一个权限信息，这个权限分为三个部分\n第一个整数 6 代表文件拥有者有 rw\n第二个整数 4  代表文件的所属组  r\n第三个整数 6 代表其他人 rw\n```\n\n\n\n一般常见的数字法权限为 7 7 7、755（文件夹）、644（文件）。例如这样的044权限信息是不可能在实际出现的，这个只是在教学演示中可能出现，为什么呢？\n\n```shell\n[root@localhost ~]# ls -ld dir2\ndrwxr-xr-x 2 root root 4096 09-05 15:52 dir2\n```\n\n\n\n## 数字法权限操作\n\n**语法格式**：\n\n` chmod  权限数字  文件或者文件夹`\n\n```shell\n[root@localhost dir]# ls -l a.txt \n-rw-r--r-- 1 lucy lily 0 09-05 16:14 a.txt\n\n[root@localhost dir]# chmod 755 a.txt \n\n[root@localhost dir]# ls -l a.txt \n-rwxr-xr-x 1 lucy lily 0 09-05 16:14 a.txt\n```\n\n\n\n## 权限的操作演示\n\n在做权限测试的时候，由于超级管理员root是不受权限的控制的，则我们我们先建立一个lily的普通用户，用超级管理员来编辑权限，使用普通用户来测试权限。【保持文件和文件夹默认的权限即可】\n\n \n\n1. 在lily家目录下使用root创建一个dir文件夹，文件夹下创建一个a.txt\n\n2. 由于该文件是有root创建，对应lily来说，属于其他人\n\n3. 先将文件夹的权限改为750，文件的权限改为640，代表其他人没有任何权限，接下来进行一步步的赋予权限，使用caoyang进行测试\n\n4. 先测试文件夹的可读754权限 (ls)\n\n5. 在测试文件夹的可执行755权限（r x 不可以在里面删除文件或者新建、移动文件）\n\n6. 测试文件的可读权限644\n\n7. echo测试文件的可写权限646\n\n8. 测试文件是否可删除？【不要看当前文件的权限，要看当前文件所处文件夹的权限信息 w 权限】\n\n学习：\n\n\n\n![1536135147397](1536135147397.png)\n\n\n\n## 其他的权限命令\n\n`chown `命令用来修改文件的所有者\n\n```shell\n# chown userName fileName\n```\n\n\n\n`chgrp` 命令用来修改文件的所属组，需要注意，在linux下添加一个用户的时候，默认会创建一个和该用户同名的组，并将该用户加入到该组\n\n```shell\n# chgrp groupName fileName\n```\n\n\n\n需要注意的，`chown`可以在修改文件的所有者的时候，可以同时设置文件的所属组\n\n```shell\n# chown userName:groupName fileName\n```\n\n\n\n递归操作，一次性的把所有的文件信息都改掉 (` -R` 代表的 递归操作 )\n\n```shell\n# chown -R  文件的拥有者:文件的所属组 dirName/\n```\n\n\n\n偷懒写法 (`. `代表当前文件夹)\n\n```shell\n # cd dirName\n # chown -R  文件的拥有者:文件的所属组  . \n```\n\n\n\n\n\n# 其他命令\n\n\n\n## 管道  | \n\n将多个命令连接起来，让前一个命令的输出作为下一个命令的输入，类似smarty里面的变量调节器。 \n\n查找关键字并排序\n\n```shell\n# vim demo.txt\n\td.txt\n\tb.txt\n\ta.txt\n\tc.txt\n\ta.txt\n\tthis is a file\n\t\n# grep txt a.txt\n\n# grep txt a.txt | uniq\n# grep txt a.txt | sort\n```\n\n\n\n列出目录信息，并查找关键字\n\n```shell\n# ls /bin/ | grep vi\n```\n\n\n\n##  gvim\n\nvim编辑器是linux下，==Windows==下也有对应的软件来实现vim的功能，叫做 **gvim**。\n\n![1536136063816](1536136063816.png)\n\n百度：【sublime vim插件  phpstorm vim插件】\n\n\n","categories":["Linux"]},{"title":"linux操作系统1","url":"%2Fposts%2F905642747%2F","content":"\n\n# linux发展历史\n\n**wamp** \n\n**w**：windows\n\n**a**：apache \n\n**m**：mysql数据库（Oracle 商业公司 ）   MariaDB（mysql分支 和mysql完全兼容）\n\n**p**: PHP 有可能是Python\n\n\n\n**lamp**：linux操作系统\n\n\n\n**lnmp** ：\n\n**l** ： linux操作系统 \n\n**n**：Nginx web服务器（俄国人开发的， 解决互联网Web2.0 问题：C10k问题  ）\n\n* <1. 硬件升级 2. 集群架构 LB集群 负载均衡集群 3. 优秀web软件>\n\n\n\n==**注意：黄金搭档 慢慢的被取代了。PHP市场被分割的很厉害。**==\n\n  1. Python web领域 爬虫（以前PHP里面的数据采集 dedecms系统 火车头采集系统 PHP第三方采集库）\n  2. golang web领域（不是太成熟、很有远景）\n\n\n\n## 常见操作系统简介\n\n常见的操作系统，你知道的有哪些？\n\n+ Windows 操作系统（傻瓜操作系统）：常见的有xp（国企 1. 买版权 2. 习惯操作 3. 内部系统）、Vista（安全 但很慢）、window7（成功）、window8（过渡的）、window10（成功）等，该桌面版操作系统非常适合大众使用；同时也有windows server服务器端的操作系统，适合运行服务（周期性的死机，闭源操作系统）。\n\n+ Ubuntu操作系统：中文叫做乌班图，是一个非常成熟的linux桌面版，非常的绚丽，这个操作系统下去一定要多了解，很多的公司使用的是该操作系统。( window > mac > linux（Ubuntu天生适合做开发） )\n\n+ MacOS 操作系统：苹果公司出的操作系统，需要使用苹果的硬件才可以使用，但是目前也可以在普通的PC上使用，俗称**黑苹果**。该操作系统天生适合做开发，一般被程序员和`设计师`钟爱。\n\n\n+ RedHat操作系统：俗称红帽，该操作系统一般被企业使用，当我们听到红帽子5、红帽子6、红帽子7 的时候，代表的就是该操作系统，一般来说这个操作系统是需要收取服务费，一年最基本大概10w左右。\n\n+ CentOS操作系统：该操作系统为社区版操作系统，适合在互联网企业，是完全免费的，但是这个操作系统没有提供服务支持，当遇到问题需要自己解决。并且该操作系统是完全基于红帽的，规则如下：centos5.5基于红帽子5； centos6.5 ，centos6.8 基于红帽子6等。\n\n\n\n==注意==：现在能接触到的都是 **分时操作系统**。\n\n* 即，**多任务**：同一时间可以运行多个任务（并行）。\n* 以前的是 **批处理**：一次只能做一件事 串行\n\ncpu 42亿次左右(1s)  1/60s-60个(单cpu 微观上还是串行) 宏观上并行。\n\n\n\n==注意==：**实时操作系统**。如，独享 ucosii 导航系统（导弹）。\n\n\n\n## linux发展史\n\n参考【linux发展史】\n\n![1535705160418](1535705160418.png)\n\n1. centos 和 reahat是完全一样的\n2. 都是类 Unix操作系统（为什么叫类Unix操作系统？遵循 postfix规范 到时候操作系统的目录结构是基本一样的、命令也是基本相同、管理方式也是基本相同....）\n\n\n\n## linux含义\n\nlinux狭义：指李纳斯开发的linux内核部分（3% ），最基本的内核代码，操作系统的核心，只负责最基本的设备管理（1. 内存管理 2. 硬件控制...）\n\n\n\nlinux广义：指linux各个厂商基于linux内核研发的linux产品，例如红帽、Debian、Ubuntu等。我们常用的就是 Centos5 或者 Centos6 基于RedHat公司的产品进行开发。完全免费。\n\n\n\n注意：目前这个内核代码版本是在 4.x左右。\n\nhttp://kernel.org/\n\n\n\n注意：虽说目前的最新的版本是4.x，但是在linux的发行版里面的使用的最多的还是**2.6.x**这个版本的内核。（因为从2.x之后的版本就不在由李纳斯本人开发维护，而是交给他的团队维护）。\n\n\n\n## CentOS简介\n\nCentOS（Community Enterprise Operating System：社区企业操作系统）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS是完全免费的，而RedHat的使用需要收取服务费的。但是Centos目前也被RedHat收购了。\n\n \n\n**其主要的特点如下：**\n\n1、简单易用,安全性高,且支持图形操作界面,并且linux对硬件的要求是非常的低的。如果不安装图形化的界面，只要给一个128M都完成可以使用。（单片机 ARM 几M即可）\n\n2、其安装步骤支持全图形操作，且有中文包补丁 \n\n3、能够免费实现在线软件安装服务(yum包管理器) \n\n4、被誉为世界上最适合作为服务器的底层的Linux操作系统,其性能十分稳定 （web业务来说， 基本都是linux ，比如，Ubuntu server|desktop）\n\n5、有32位和64位两种操作系统安装镜像 \n\n6、多任务，多用户的操作系统。\n\n \n\n**其主要的版本有：**\n\n1、CentOS5.5\n\n2、CentOS6.5\n\n3、CentOS6.8\n\n4、CentOS7.0 (区别还是很明显的：服务器管理方式不一样， 基本的命令也有一些不同)\n\n\n\n5和6之间基本没有区别。\n\n \n\n理论上会某个linux发行版，其他的linux操作系统全部都会。其他的发行版只是在linux的内核上加入一些自己的软件或者是软件管理器。\n\n\n\n\n\n# CentOS安装\n\n1. 下载操作系统镜像\n2. 安装（1. 裸机   2. 虚拟机模拟一台电脑）\n3. 购买阿里云的云服务\n\n\n\n## 什么是虚拟机？\n\n虚拟机实际上是一个虚拟PC的软件，它可以在现有的操作系统上虚拟出一个新的硬环境，相当于虚拟了一台新的计算机，从而实现了一台机器独立运行两个或者两个以上的操作系统。\n\n虚拟机软件：Vmware、VirtulBox\n\n\n\n## VMware软件安装\n\n一般软件的安装方式，全程下一步即可。\n\n\n\n## 虚拟电脑的创建\n\n参考【虚拟电脑创建和centos操作系统的安装.doc】\n\n![1535705188236](1535705188236.png)\n\n\n\n## centos操作系统的安装\n\n参考【虚拟电脑创建和centos操作系统的安装.doc】\n\n ![1535705190337](1535705190337.png)\n\n\n\n# ==文件系统树==\n\n在正式学习linux之前，我们有必要了解下linux的文件系统树，linux的这种树形结构是规定好了的，不允许随便更改。其实在windows下也存在文件系统树（是从盘符开始 c:/windows/a.txt）\n\n\n\n在Windows里面是存在多个盘符，每个盘符下存在很多的文件和文件夹。但是这个东西如果是在linux下则不再成立，因为linux有自己的文件系统树。\n\n\n\nlinux下没有那么多的盘符，linux下只存在一个盘符，叫做 根目录 （`/`），根下存在很多的目录，但是对于linux这些目录都是事先规定好，基本所有的发行版都是一样。\n\n```cmd\n/（c:/）\n├── bin\n│   ├── bash\n│   ├── ls\n│   ├── mkdir\n├── boot\n│   └── vmlinuz-2.6.32-696.6.3.el6.x86_64\n├── dev\n│   ├── block\n│   └── zero\n├── etc\n│   ├── yum.conf\n│   └── yum.repos.d\n├── home\n│   └── asion\n├── lib\n│   ├── libnss_dns.so.2 -> libnss_dns-2.12.so\n├── lib64\n│   ├── device-mapper\n│   ├── libxtables.so.4 -> /etc/alternatives/libxtables4.x86_64\n├── lost+found\n├── ls.txt\n├── media\n├── mnt\n├── opt\n├── patch\n│   └── libiconv-glibc-2.16.patch\n├── proc\n│   ├── vmallocinfo\n│   ├── vmstat\n│   └── zoneinfo\n├── root\n│   └── day1\n├── run\n│   └── cloud-init\n├── sbin\n│   ├── shutdown\n│   ├── wipefs\n│   └── xfs_repair\n├── selinux\n├── srv\n├── sys\n│   └── power\n├── tmp\n│   ├── Aegis-<Guid(5A2C30A2-A87D-490A-9281-6765EDAD7CBA)>\n│   └── test.pl\n├── usr\n│   ├── bin\n│   ├── src\n│   └── tmp -> ../var/tmp\n├── var\n    ├── bt_apacheVersion.pl\n    ├── tmp\n    └── yp\n```\n\n\n\n## bin目录\n\n简介： **binary**  的简写， 主要存放linux下可以执行的==二进制命令==（如常见的ls），普通用户和超级管理员都可以使用的二进制命令。\n\n\n\n## sbin目录\n\n简介：**super bin**，超级管理员可以执行的==二进制命令==，普通用户不可以执行。\n\n\n\n## home目录\n\n简介：home ==用户的家目录==，每当在linux下创建一个登陆用户，就会在该目录下创建对应的文件，其用户可以在该目录下执行可读可写的操作。\n\n\n\n## root目录\n\n简介：==root 超级管理员的家目录==。\n\n\n\n## etc 配置文件目录\n\n简介：etc 该目录主要存放系统的==配置文件==信息，例如apache、mysql等服务的配置文件。\n\n\n\n## usr目录\n\n简介：usr 是**Unix software resource**的简写，表示Linux的==软件资源==目录主要是存放用户自定义安装软件的目录，lamp环境的 Apache MySQL php都会安装在这里，类型Windows下的Program Files。\n\n\n\n## var目录\n\n简介：var是**variable**单词的简写，代表是可变的，到时候该目录主要存放系统的日志，以及网站的根目录等等。\n\n\n\n## Linux和Windows的区别（重要）\n\n1. Linux没有盘符，windows拥有盘符；在linux下一切都是从 根目录(`/`)开始的。\n2. Linux严格区分大小写，而windows不区分大小写，由于linux严格区分大小写，因此linux认为a.php和A.PHP是两个不同的文件，而在windows当中windows会认为这是2个相同的文件。\n3. windows大部分的工作是通过图形操作界面就能够完成，linux大部分的工作是通过命令行来完成\n\n\n\n# ==Shell==\n\n## 简介\n\n在linux使用的过程中，一般来说可以作为桌面系统进行使用，例如常见的Ubuntu操作系统，但是更多的是做为服务器进行使用。一般来说如果是在服务器模式下使用的话，这个时候是没有安装桌面的，这个时候我们就要一个人机交互的转换程序，这个工具一般被称为shell，也叫作cli（命令行接口）。现在由于我们是学习，所以安装了图像界面，在图形界面下，我们也是可以开启一个命令行终端的。除了常见的命令行shell，还有图形化的shell，一般简写为Gui，例如window操作系统。\n\n\n\n\n\n![1535705279428](1535705279428.png)\n\n\n\n## 常见的linux shell分类\n\n常见的shell有==sh==、==bash== 、==csh==等，一般来说我们都是使用的bash，该shell解释器位于`/bin/bash`，是一个二进制的命令，可以帮我们去翻译用户的行为，并且在linux下是存在编程的，叫做shell编程。可以做linux下的自动备份，定时任务等(运维，现在来说一般也不错shell编程 。现在一般使用Python进行运维管理，实现自动化运维)。\n\n现在云服务器太方便。（阿里云支持弹性升级）（BPG IDC机房 郊区）（1. 游戏公司 不可能买云服务器 I/O 虚拟化 2. 银行 3. 大型企业 平安银行 不用电脑记账 手工记账 打算盘 纸张抄）\n\n\n\n**如何查看当前系统使用的shell呢？**\n\n```shell\n# echo $SHELL\n```\n\n \n\n**那么当前linux操作系统支持哪些shell呢？**\n\n```powershell\n# cat /etc/shells\n```\n\n \n\n**如何使用sh呢？**\n\n```shell\n# sh\n```\n\n\n\n**如何退出呢？** \n\n```shell\n# exit\n```\n\n\n\n## 命令符解释器\n\n当打开一个shell终端后，会出现一个光标在闪烁，被称为命令提示符：\n\n![1536139009673](1536139009673.png)\n\n**注意**：由于linux在服务器环境下，一般来说都是没有图形化的界面，都是通过命令行进行操作，所以必须要掌握好相关的命令。到时候可以在命令提示符下输入相关的命令，然后通过这些命令完成相关的任务。\n\n\n\n## 命令格式讲解\n\n```shell\n# 命令  -选项  参数\n```\n\n**命令**：是linux系统提供的二进制的命令（`/bin`  `/sbin/`    `/usr/bin`），一般分为超级管理员命令和普通用户的命令，超级管理员没有权限限制。\n\n**选项**：选项是用来修饰命令的。\n\n**参数**：参数是命令作用的主体，命令在谁的身上产生效果。\n\n\n\n例如ls是展示某个目录下的文件信息，但是如果需要展示全部的文件信息，可以加-a选项。\n\n如果是要查看root家目录下的文件信息，则需要使用 \n\n``` shell\n# ls  -la \n# ls  -la  /root\n```\n\n\n\n## ls 列出文件命令\n\n\nlist： 列出目录里面的文件信息，在linux下有一个哲学，linux下一切皆文件，所以展示的既有文件，也包含文件夹。\n``` shell\n# ls\n```\n\n以详细的方式展示文件信息 `-l` (longtext 以长格式，详细信息)\n``` shell\n# ls -l\n```\n\n展示所有文件，包含隐藏文件\n``` shell\n# ls -la\n```\n\n列出指定文件夹下的文件信息\n``` shell\n# ls -l /\n```\n\n\n\n## ll命令\n\n\n小写字母 `l`，这个命令其实就是`ls -l`指令的简写。\n``` shell\n# ll\n```\n\n\n\n## clear 清屏\n\n```shell\n# clear\n```\n\n\n\n## su 切换用户命令\n\n**su**  :  全称 （switch user）\n\n如果当前是root用户切换为普通用户，那么是不需要输入任何密码的，因为root是超级管理员。如果当前的用户是一个普通的用户切换成为root，那么必须输入超级管理员的密码。同时需要注意，在输入密码的过程中，密码是没有回显的。\n\n```shell\n# su - root\n```\n\n注意：如果直接使用 `su` 用户名进行切换，一般也不会自动回到用户的家目录，这个时候我们可以在su后面加上` - `选项，在做切换后即可回到用户的家目录。\n\n\n\n## shutdown 关机命令\n\n需要注意：该命令只有**root**才可以执行。参见的选项如下\n\n```shell\n-h: 关机  相当于 halt\n-r：重启  相当于 reboot\n时间：分钟为单位。0 和 now 都是立即执行\n\n示例：\n# shutdown –h now\n# shutdown -h 5\n\n# shutdown –r  now\n```\n\n\n\n## halt 立刻关机命令\n\n需要注意：该命令只有**root**才可以执行。\n\n```shell\n# halt\n```\n\n\n\n## reboot重启命令\n\n需要注意：该命令只有**root**才可以执行。\n\n```shell\n# reboot\n```\n\n\n\n## pwd命令\n\n打印当前用户所处的位置(print working directory)\n\n```shell\n# pwd\n```\n\n\n\n## cd  目录切换命令\n\n在每个用户登录操作系统之后，默认是在其家目录里面，但是对于超级管理员和普通用户的家目录是不一样的。\n\n1. 超级管理员root 是在` /root`目录 \n2. 普通用户asion是在 `/home/asion`目录\n\n\n\n**问题：**当超级管理员登录系统之后(/root--->.. / --> /home/asion)，要去到asion的家目录，如何去？\n\n答：\n\n1. 使用**绝对路径**的方式：代表从根目录 (`/`) 开始到达指定位置的路程 `/home/asion`\n2. 使用**相对路径**的方式：参考点（当前的位置），然后经历的路程叫做相对路径 `../home/asion`\n\n\n\n==linux三个比较特殊的目录==\n\n1. 在linux里面` .` 和`  ./` 代表的含义当前目录\n2. 在linux里面` ..` 和`  ../ `代表上级目录\n3. `~ `代表当前用户的家目录\n\n\n\nchange directory改变当前的目录\n\n```shell\n# cd /\n# pwd\n```\n\n\n\n# ==远程连接linux操作系统==\n\n**为什么要使用远程连接工具去操作？**\n\n答：\n\n1. 实际生产环境里面的linux服务器都是没有桌面（CLI 命令行模式）\n2. 服务器一般来说都是部署在郊区的机房或者购买阿里云的云服务器。\n\n\n\n## 背景\n\n通过上面的学习，我们大致了解了linux的基本命令的使用方式，在实际的服务器使用过程中，一般来说都是购买的云服务器，这个时候云服务器的提供商会给我们提供一个服务器的公网IP（互联网是可以直接访问）地址和超级管理员的密码进行**远程的链接**管理。例如阿里云的服务器的管理如下:\n\n```\nConnecting to 47.52.65.14:22...\nConnection established.\nTo escape to local shell, press 'Ctrl+Alt+]'.\n\nLast login: Thu Aug 30 12:06:31 2018 from 157.122.54.188\nWelcome to Alibaba Cloud Elastic Compute Service !\n[root@dockerTest ~]# \n\n```\n\n\n\n## ssh简介\n\n如果要进行远程连接，这个时候需要在linux上运行一个sshd服务(是一个c/s架构)，然后通过一个ssh客户端进行连接操作远程服务器。该服务默认使用的端口是22端口，使用的通信协议使用 ssh协议，并且ssh协议是**加密传输的**，可以保证信息的安全不被窃取。现代的服务器上默认都是会安装该服务的，并且该服务器也是处于监听状态的。\n\n通常提供：\n\n1. 公网IP地址\n2. 账号root和密码（1. 初始化密码  2. 初始化公钥和私钥）\n\n\n\n## ssh客户端简介\n\n**ssh的客户端比较多，常见的如下：**\n\n1. **putty** 是最为最出名，最原始，最老牌的一款简洁工具 （功能非常简陋 瑞士军刀）\n\n2. **xshell** 是一款商业化工具，用户友好，提供免费的个人使用【首选 √】\n\n3. **secureCRT** 一款老牌工具\n\n4. **ssh 命令工具**，一般linux或者Mac自带(cmder： windows下加强版的命令行工具，可以模拟出来linux下常见命令)\n\n   ```shell\n   > ssh root@129.12.34.34\n   ```\n\n\n\n## ip地址查看\n\n```shell\n# ifconfig\n```\n\n```\n[root@dockerTest ~]# ifconfig\neth0      Link encap:Ethernet  HWaddr 00:16:3E:04:45:64  \n          inet addr:192.168.0.40  Bcast:192.168.0.255  Mask:255.255.255.0\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:14631 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:13924 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:13082659 (12.4 MiB)  TX bytes:3486380 (3.3 MiB)\n\nlo        Link encap:Local Loopback  \n          inet addr:127.0.0.1  Mask:255.0.0.0\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:608 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:608 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0 \n          RX bytes:199504 (194.8 KiB)  TX bytes:199504 (194.8 KiB)\n\n[root@dockerTest ~]# \n\n```\n\n\n\n## xshell使用\n\n在成功安装后，配置IP地址和用户名以及密码后即可链接服务器。\n\n1. 新建链接，输入服务器IP地址\n\n   ![1536049721105](1536049721105.png)\n\n2. 输入用户名和密码\n\n   ![1536049753827](1536049753827.png)\n\n3. 链接使用\n\n   ![1536049797691](1536049797691.png)\n\n\n\n## ssh命令使用\n\n以 `root`用户登录到 IP为 `120.23.34.42`的主机：\n\n```shell\n# ssh root@120.23.34.42\n```\n\n注意：在windows下的命令行需要使用特定的命令行工具cmder。\n\n![1536049842498](1536049842498.png)\n\n\n\n# ==文件夹和文件相关命令==\n\n常见操作：**增加**、**修改**、**删除**、**重命名**、**复制**、**移动**，其注意的命令如下：\n\n* `touch` 创建文件（本身的功能是用于更新某个文件的文件信息 例如文件的修改时间戳信息）\n\n* `mv`  移动或重命名文件（在相同位置时则重命名）\n\n* `rm`  删除文件\n\n* `cp `  复制文件\n\n* `mkdir` 创建文件夹\n\n* `file` 用于查看文件的类型（文件：不要单纯理解为文本文件，可以是一个文件夹。)\n\n  \n\n  ==一切皆文件== —-《linux/Unix哲学》\n\n\n\n## 文件相关的命令\n\n```shell\n创建文件的命令\n# touch fileName\n```\n\n\n\n```shell\n修改文件的名称(在相同位置)\n# mv  OldFileName  NewFileName\n```\n\n\n\n```shell\n文件删除的命令  -f 强制  -r 递归\n# rm fileName\n```\n\n\n\n```shell\n复制文件(源文件  目标文件)\n# cp  sourcefileName  destFileName\n```\n\n\n\n```shell\n移动文件到指定目录\n# mv  fileName  directoryName \n```\n\n\n\n学习：(根据视频进行一步一步学习)\n\n![1536044947959](1536044947959.png)\n\n\n\n## 文件夹相关操作\n\n文件夹：新增，改名，删除，文件移动到文件夹\n\n```shell\n文件夹的创建\n# mkdir  directoryName \n```\n\n\n\n```shell\n目录的名称修改\n# mv  oldDirName  newDirName\n```\n\n\n\n```shell\n文件夹的删除\n注意：当删除文件夹的时候需要加上 -r 参数递归删除  -f 代表强制删除\n# rm  -rf  dir1\n```\n\n解释：` -r `递归删除，如果文件夹下有文件，则先删除对应的文件，然后在删除文件夹， `-f `force代表强制删除，不做用户的交互提示。\n\n\n\n```shell\n文件夹的复制，需要加上 -r 参数 递归\n# cp  -r  dir1  newDir2\n```\n\n\n\n```shell\n文件夹的移动，文件夹的移动的时候不需要加上 -r 选项\n# mv dir1 dir2 \n```\n\n\n\n## 文件内容查看命令\n\n对于文件的内容查看，主要有如下命令：\n\n* `cat ` 阅读文件内容【记住】\n\n* `less` 翻页查看\n\n* `more` 翻页查看\n\n* `tail ` 查看文件尾部 【记住】（实际开发不是拿它看单个文件内容，而是用于做日志输出的查看） `-f `代表不断的刷新日志内容\n\n   ```shell\n   # tail -f nginx.log\n   1. 占据终端 取消 ctrl + c\n   2. 如果 nginx.log 文件有内容被加入了，则会立马在屏幕显示，一般用于调试\n   ```\n\n* `head`  查看文件头部\n\n* `file` 查看文件类型\n\n* `echo` 输出字符串\n\n* `>、>>`  输出重定向\n\n* `stat` 查看文件信息\n\n* `date` 查看日期\n\n\n\n复制一个文本文件，做演示\n\n```shell\n# cd \n# cp /etc/password ./\n```\n\n\n\n```shell\ncat fileName(cat 命令代表查看文件里面的内容)\n# cat fileName\n```\n\n\n\n```shell\necho 为文件追加内容 \n# echo hi \n# echo hi > a.txt\n注意：\n  1. > 代表的是覆盖\n  2. >> 代表的是追加\n```\n\n\n\n```shell\nless 也是查看文件内容的命令\n# less fileName\n注意：\n1. 需要使用 q 退出\n2. less命令在文本信息过多的情况下，可以做翻页查看，使用上下键来翻页\n3. 查找，查找该文本里面是否包含自己需要的内容 输入 /关键字 可以实现查找\n```\n\n\n\n```shell\nmore 命令也可以实现翻页[使用空格键做翻页]\n# more fileName\n```\n\n\n\n```shell\nhead 代表查看文件的头部行数\n# head fileName\n注意：\n\t-n Number head命令默认取出前10行的内容，如果使用 -n 则代表取出指定行数的内容。\n```\n\n\n\n```shell\ntail 查看文件尾部的行数\n# tail fileName\n```\n\n\n\n```shell\nfile 命令 查看文件的类型\n# file fileName\n```\n\n\n\n```shell\nstat 命名 查看文件时间戳信息\n# stat fileName\n```\n\n\n\n# ==linux常用使用技巧==\n\n## 终止操作\n\n```shell\n终止操作 【ctrl+c】\n# ls /\n```\n\n\n\n## 定位行首\n\n```shell\n光标定位 快速的从命令的尾部切换首部(ctrl+a)\n# ls -la /root\n```\n\n\n\n## 定位行尾\n\n```shell\n快速的从命令的首部切换尾部(ctrl+e)\n# ls -la /root\n```\n\n\n\n## 历史命令查看\n\n```shell\n使用键盘的上下键可以查看曾经输入过的命令\n# ls\n```\n\n\n\n## 历史命令查看\n\n```shell\n也可以使用history命令来显示之前执行的过的命令，可以通过 !数字 来执行之前的命令\n# history\n```\n\n\n\n## tab键补齐\n\n```\ntab补齐，可以使用 tab 键 快速的补齐命令 或者 文件 已经 文件夹的名称\n```\n\n\n\n## 重定向\n\n```shell\n重定向\n有的时候可能希望将某些命令的输出保存起来，保存到一个文本文件里面\n例如：希望将 date 命令输出的日期保存到 date.txt文件里面\n# date > a.txt\n# cat a.txt\n```\n\n\n\n## linux下的帮助\n\n如果在linux下对于有些命令记不清参数是什么了，这个时候可以通过如下的方式进行解决\n\n1. 百度\n2. 查看系统的帮助（英文）\n\n   * 在命令的后面加上 --help\n\n   ```\n   [root@dockerTest ~]# ls --help\n   Usage: ls [OPTION]... [FILE]...\n   List information about the FILEs (the current directory by default).\n   Sort entries alphabetically if none of -cftuvSUX nor --sort.\n   \n   Mandatory arguments to long options are mandatory for short options too.\n     -a, --all                  do not ignore entries starting with .\n     -A, --almost-all           do not list implied . and ..\n         --author               with -l, print the author of each file\n     -b, --escape               print octal escapes for nongraphic characters\n         --block-size=SIZE      use SIZE-byte blocks.  See SIZE format below\n     -B, --ignore-backups       do not list implied entries ending with ~\n     -c                         with -lt: sort by, and show, ctime (time of last\n                                  modification of file status information)\n                                  with -l: show ctime and sort by name\n                                  otherwise: sort by ctime\n     -C                         list entries by columns\n         --color[=WHEN]         colorize the output.  WHEN defaults to `always'\n                                  or can be `never' or `auto'.  More info below\n     -d, --directory            list directory entries instead of contents,\n   ```\n\n   \n\n   * 在命令的前面加上 man，使用空格翻页，q键退出\n\n   ```\n   # man ls\n   \n   LS(1)                            User Commands                           LS(1)\n   \n   NAME\n          ls - list directory contents\n   \n   SYNOPSIS\n          ls [OPTION]... [FILE]...\n   \n   DESCRIPTION\n          List information about the FILEs (the current directory by default).  Sort entries alphabetically if none of -cftuvSUX nor --sort.\n   \n          Mandatory arguments to long options are mandatory for short options too.\n   \n          -a, --all\n                 do not ignore entries starting with .\n   \n          -A, --almost-all\n                 do not list implied . and ..\n   \n          --author\n                 with -l, print the author of each file\n   \n          -b, --escape\n                 print octal escapes for nongraphic characters\n   \n          --block-size=SIZE\n                 use SIZE-byte blocks.  See SIZE format below\n   ```\n\n\n\n","categories":["Linux"]},{"title":"linux操作系统3","url":"%2Fposts%2F3690292183%2F","content":"\n\n# linux软件安装管理\n\n## 简介\n\n在window下我们进行软件管理还是比较容易的，通过图形界面直接下一步下一步即可，但是在linux服务器下，都是命令行的界面，我们一般会安装一些软件服务，例如apache、mysql、ftp....等，则该如何处理呢？\n\n \n\n## 软件包类型简介\n\n在linux下软件包一般分为\n\n1. 使用c语言编写的**源码包**，一般来说被称为 tar包；示例：httpd-2.2.18.tar.gz\n2. 二进制**rpm**包，一般来说的命名 vsftpd-2.12.3-el5.i386.rpm，一般就类似windows下的.exe文件包\n   * 红帽包管理用的是rpm包，debian是deb包\n\n\n\n注意：有的时候我们还经常听到脚本安装包（例如：install.sh 这个是一个linux的shell脚本，通过执行该脚本可以进行某些软件的安装，一般被称为**脚本安装包**，在linux里面其实是没有脚本包，方便一些不太懂linux人进行软件的安装），脚本安装包只是linux下的一个shell脚本，脚本里面的内容还是使用源码或者rpm包进行安装的。\n\n【lamp / lnmp环境搭建一般来说都是使用的一键安装包，里面其实就是使用的 shell编写的脚本安装。】\n\n\n\n### 源码包优缺点\n\n**优点：**\n\n1. 开源，自己可以修改里面的代码做定制化开发，一般遵循GPL、 apache、 MIT、lGPL....协议（代码可以自行修改，一般来说还要继续的开源）\n\n2. 在进行编译的时候，可以更加的灵活的配置，更适合自己的操作系统\n\n3. 卸载方便，注意：在linux下的源码包安装的软件，卸载特别方便，直接删除文件夹，不会产生任何的垃圾文件\n\n \n\n**弊端：**\n\n1. 安装的步骤比较多，容易出现问题，需要自行解决\n\n2. 编译时间比较长\n\n如果只有源码包，对于初学者都不知道如何编译，阻碍了linux发展，则很多linux的发行商进行了思考，制作出了可以使用的二进制包，不需要在进行编译。\n\n\n\n### 二进制包优缺点\n\n在centos相关的发行版里面使用的 rpm包(RedHat package manager) ；在以Debian系列(Ubuntu)的发行版里面的二进制包一般来说 deb包\n\n**优点**： \n\n1. 安装简单，不需要编译\n\n2. 安装速度快\n\n \n\n**弊端：**\n\n1. 不能看到源码\n\n2. 功能不够灵活\n\n3. 存在依赖性\n\n\n\n## rpm包的管理\n\n### rpm包的命名规则\n\n**rpm包在哪里呢？**\n\n答：在系统光盘里面，或者是在国内的一些镜像网站，一般被称为yum源，163、搜狐、清华、阿里云....\n\nhttp://mirrors.163.com/.help/centos.html\n\n\n\n示例：vsftpd-2.0.5-16.el5_4.1.i386.rpm\n\n包名-主版本.次版本.修改版本-发布次数-linux发行版-适用平台(i386  i686 x86_64).扩展名\n\n\n\n**注意：**一般一个完整的包被称为 **包全名** [vsftpd-2.0.5-16.el5_4.1.i386.rpm]\n\n一般来说包全名前面的部分被为 **包名**\n\n \n\n**注意：**\n\n* 见到 i386 i686这些都是32位操作系统使用；\n* 还有 x86_64都是64位操作系统使用。\n\n\n\n\n### 挂载\n\n**如何使用光盘里面的内容呢？**\n\n答：挂载光盘。\n\n注意：由于我们的虚拟电脑并没有物理光驱，我们只能通过虚拟的光驱将镜像挂载到linux文件系统树上面。\n\n\n\n注意：**什么是挂载？**\n\n答：将光驱里面的镜像文件和linux文件系统树产生一个关联。将物理光驱里面的内容放置在文件系统树的某个文件夹里面，文件夹被称为`挂载点`。当我们访问这个挂载点的时候，就相当于在访问这个镜像里面的内容。\n\n\n\n### 挂载实操\n\n1. 将镜像访问在虚拟的光驱里面，进行连接\n\n   ![1536286434100](1536286434100.png)\n\n2. 创建挂载点(/mnt/cdrom  约定俗成。 mnt代表的挂载的目录 ；cdrom代表的光驱)\n\n   ```\n   # mkdir /mnt/cdrom \n   ```\n\n3. 使用 mount 命令进行挂载\n\n   ```\n   # mount /dev/cdrom /mnt/cdrom\n   \n   注意：/dev代表是linux下的设备文件夹\n   ```\n\n4. 查看镜像里面的内容\n\n   ```\n   # cd /mnt/cdrom\n   \n   # ls\n   ```\n\n\n\n### rpm包的依赖性问题\n\nwindows下装一些软件的时候需要 .netframkework4.0，这个被称为依赖(缺少 xxxx.dll文件  文件丢失)。\n\nwindows下装一些软件的时候需要 kernerl.dll 动态链接库不存在，无法链接。\n\n\n\n一般在使用rpm包的时候，会产生一个依赖问题，主要包含如下三种依赖\n\n1. 树形依赖 A->B->C\n\n2. 环形依赖 A->B->C->A\n\n3. 模块依赖、库文件依赖 lib.so.2 文件不存在，www.rpmfind.net查询解决\n\n\n\n### rpm相关操作\n\n注意：在演示rpm包的时候的时候，必须确保自己的光盘已经被挂载，并且处于挂载点的CentOS目录下。\n\n\n\n1. 例如现在使用rpm的安装vsftpd软件包，安装的时候，需要`包全名`\n\n```\n# cd /mnt/cdrom/CentOS\n\n# rpm -ivh vsftpd-2.0.5-16.el5_4.1.i386.rpm \n\n-i install的简写\n-v view 可视化【verbose】\n-h hash 显示进度条\n由于上面的包没有任何的依赖性，一下就装好了。\n```\n\n\n\n2. 卸载软件包，只需要使用包名\n\n```\n# rpm -e vsftpd\n-e  卸载 erase\n```\n\n\n\n3. 系统已安装的rpm包查看\n\n```\n# rpm -qa\n\n-q query查询的意思\n-a all查询所有\n\n\n额外的命令，查看操作系统里面是否安装了 xxx rpm包\n# rpm -qa | grep xxx\n```\n\n\n\n4. rpm包里面的内容查看，可以通过该命令查看该安装包到时候安装在哪里，配置文件在哪里等\n\n```\n# rpm -qlp sound-juicer-2.16.0-3.el5\n\n-q query查询\n-l longtxt 详细信息\n-p package 显示包信息\n```\n\n\n\n### 依赖演示\n\n演示：rpm包的依赖问题，演示httpd软件的安装\n\n```\n# cd /mnt/cdrom/CentOS\n\n# ls | grep httpd\n```\n\n\n\n由于上面的http的包在安装的时候出现了依赖问题，不断的尝试去解决依赖，是不利于linux下的rpm包的软件的发展，所有官方进行进一步的升级，推出来一个在线软件安装的服务，叫做yum安装。\n\n\n\n## yum在线安装方式\n\n### 简介\n\n由于rpm的依赖性，造成用户体验不好，则这个时候redhat公司开发了一个在线安装方式，在网上提供了一个软件仓库，通过一些命令就可以该仓库下载软件，进行安装，并解决依赖性问题。一般软件仓库被称为yum源，可以在linux操作系统的指定目录查看该配置信息。\n\n1. 有点类似PHP里面的 composer\n\n   ```\n   # composer create-project laravel/laravel=5.1.* local.laravel.com -vvv\n   ```\n\n2. nodejs里面 npm\n\n   ```\n   # npm install jquery@2.13.3\n   ```\n\n3. 前端里面的 bower 包管理器\n\n   ```\n   # bower install bootstrap#2.3.4\n   ```\n\n\n1. 进入 `/etc/yum.repos.d` 目录，即可查看\n\n   ```\n   [root@dockerTest yum.repos.d]# cd /etc/yum.repos.d/\n   \n   [root@dockerTest yum.repos.d]# pwd\n   /etc/yum.repos.d\n   \n   [root@dockerTest yum.repos.d]# ls\n   CentOS-Base.repo  epel.repo  epel.repo.rpmnew  epel-testing.repo\n   \n   ```\n\n2. `CentOS-Base.repo`内容如下，里面记录了软件仓库的地址\n\n   ```\n   [root@dockerTest yum.repos.d]# cat CentOS-Base.repo \n   [base]\n   name=CentOS-$releasever\n   enabled=1\n   failovermethod=priority\n   baseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/\n   gpgcheck=1\n   gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-6\n   \n   [updates]\n   name=CentOS-$releasever\n   enabled=1\n   failovermethod=priority\n   baseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/\n   gpgcheck=1\n   gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-6\n   \n   [extras]\n   name=CentOS-$releasever\n   enabled=1\n   failovermethod=priority\n   baseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/\n   gpgcheck=1\n   gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-6[root@dockerTest yum.repos.d]# \n   ```\n\n3. 由于软件仓库的服务器在国外，一般不稳定。则我们可以将yum更改为国内的yum源，例如阿里云、163、sohu都有提供相应的yum源 清华大学的yum源\n\n   https://www.cnblogs.com/zzsdream/p/7405083.html\n\n\n### yum相关操作\n\n注意：\n\n1. 必须要联网才可以使用yum源\n\n2. 如果不是教室的这种环境（上网需要做认证），如果是家里，则我们的虚拟机使用桥接之后直接可以上网的。但是现在是在教室，有限制。\n\n3. 在给自己的虚拟机配置一个网卡（使用NAT服务进行转换）\n\n4. 注意：如果网络不通，建议修改下DNS\n\n   ![1536289002270](1536289002270.png)\n\n\n\n1. 查看yum里面的所有包 \n\n   ```\n   # yum list\n   ```\n\n\n2. 搜索某个rpm包 （httpd、Nginx、mysql、PHP）\n\n   ```\n   # yum search packageName\n   ```\n\n\n3. yum安装某个包\n\n   ```\n   # yum install packageName\n   注意：一般都会加上 -y （yes）选项，全自动执行，不需要用户在做确认操作\n   # yum install -y packageName\n   ```\n\n\n4. yum卸载某个包\n\n   ```\n   # yum remove -y packageName\n   ```\n\n\n\n   示例：使用yum安装vsftpd软件\n\n   ```\n   # yum install -y vsftpd\n   ```\n\n\n\n### yum源更新实操\n\n如果大家使用就是阿里云的ECS服务器，则不需要更新yum源。\n\n\n\n由于centos5.5默认自带的yum源已经不再提供维护，则需要用户自己去配置yum源。\n\n1. 备份之前的yum源配置文件【重视：以后在linux下做任何修改配置文件的操作，在改之前一定要备份】【修改apache、  nginx 、mysql等配置文件之前一定要备份】\n\n   ```\n   # cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n   ```\n\n2. 修改配置文件，增加如下信息\n\n   ```\n   # vim /etc/yum.repos.d/CentOS-Base.repo\n   \n   \n   # CentOS-Base.repo\n   #\n   # The mirror system uses the connecting IP address of the client and the\n   # update status of each mirror to pick mirrors that are updated to and\n   # geographically close to the client.  You should use this for CentOS updates\n   # unless you are manually picking other mirrors.\n   #\n   # If the mirrorlist= does not work for you, as a fall back you can try the \n   # remarked out baseurl= line instead.\n   #\n   #\n   [base]  \n   name=CentOS-$releasever - Base  \n   #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os  \n   #baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/  \n   baseurl=http://vault.centos.org/5.11/os/$basearch/  \n   gpgcheck=1  \n   gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5  \n   \n   \n   #released updates   \n   [updates]  \n   name=CentOS-$releasever - Updates  \n   #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=updates  \n   #baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/  \n   baseurl=http://vault.centos.org/5.11/updates/$basearch/  \n   gpgcheck=1  \n   gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5  \n   \n   \n   #additional packages that may be useful  \n   [extras]  \n   name=CentOS-$releasever - Extras  \n   #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=extras  \n   #baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/  \n   baseurl=http://vault.centos.org/5.11/extras/$basearch/  \n   gpgcheck=1  \n   gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5  \n   \n   \n   \n   \n   #additional packages that extend functionality of existing packages  \n   [centosplus]  \n   name=CentOS-$releasever - Plus  \n   #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=centosplus  \n   #baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/  \n   baseurl=http://vault.centos.org/5.11/centosplus/$basearch/  \n   gpgcheck=1  \n   enabled=0  \n   gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5  \n   \n   \n   \n   \n   #contrib - packages by Centos Users  \n   [contrib]  \n   name=CentOS-$releasever - Contrib  \n   #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=contrib  \n   #baseurl=http://mirror.centos.org/centos/$releasever/contrib/$basearch/  \n   baseurl=http://vault.centos.org/5.11/contrib/$basearch/  \n   gpgcheck=1  \n   enabled=0  \n   gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5</span></strong></span> \n   \n   ```\n\n3. 生成缓存\n\n   ```\n   # yum makecache\n   ```\n\n4. 查看yum仓库\n\n   ```\n   # yum list\n   ```\n\n\n\n\n\n## 源码编译\n\n### 编译前的准备\n\n源代码就是编译安装c语言开发的代码程序。需要使用一定的编译器，一般使用的编译器：**gcc编译**。\n\n```\n[root@dockerTest ~]# gcc -v\nUsing built-in specs.\nTarget: x86_64-redhat-linux\nConfigured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux\nThread model: posix\ngcc version 4.4.7 20120313 (Red Hat 4.4.7-23) (GCC) \n[root@dockerTest ~]# \n\n\n```\n\n如果使用上面的命令后，看到不着这些信息，或者见到 `gcc command not  found`，则使用如下安装`gcc`\n\n```\n# yum install -y gcc\n```\n\n\n\n时间同步【在编译的时候，要注意当前服务器的时间一定要是准确的时间】\n\n```\n# ntpdate time.windows.com\n\nntpdate 命令，是时间同步的\n在互联网上有一些服务器【 time.windows.com 】专门用来规范时间。\n```\n\n\n\n**小命令**：如何把windows下的源码包传递到linux服务器，除了ftp，还有一个小工具 lrzsz命令\n\n```\n# yum install -y lrzsz\n```\n\n上传：在linux服务器输入rz之后，然后回车，在windows下选择需要上传的文件\n\n```\n# rz \n```\n\n下载：在linux服务器下输入sz 待下载的文件，然后回车，将linux服务器下的文件下载到windows操作系统\n\n```\n# sz 待下载文件\n```\n\n\n\n### 实操\n\n1. 源码上传 (/usr/local/src 一般用于源码编译的时候，保存源码信息的目录)\n\n   ```\n   # cd /usr/local/src\n   ```\n\n   ```\n   # rz\n   ```\n\n   ![1536306787321](1536306787321.png)\n\n2. 解压源码\n\n   ```\n   # tar -zxvf  httpd-2.2.11.tar.gz\n   ```\n\n   `-z `代表含义这个包使用的 gzip(互联网上常见的压缩算法)进行压缩\n\n   `-x `代表是抽取、提取 e**x**tract \n\n   `-v` view 代表显示视图\n\n   `-f` file 文件\n\n3. 进入解压目录\n\n   ```\n   # cd httpd-2.2.11\n   ```\n\n4. 收集操作系统的相关信息，检测编译器是否存在，底层的函数库是否存在\n\n   ```\n   # ./configure --prefix=/usr/local/apache2\n   ```\n\n   注意：` --prefix=/usr/local/apache2` 指定软件安装的目录，一般用户自定义的软件安装在 `/usr/local`目录下\n\n5. 编译\n\n   ```\n   # make\n   ```\n\n6. 安装，将编译后的二进制命令复制到指定的目录\n\n   ```\n   # make install\n   ```\n\n7. 服务启动\n\n   ```\n   # /usr/local/apache2/bin/apachectl -k start\n   ```\n\n8. 源码包的软件，如果要卸载，直接删除安装目录即可\n\n   ```\n   # rm -rf /usr/local/apache2\n   ```\n\n\n\n\n\n# linux服务管理\n\n## 简介\n\nlinux是一个专业做服务器的软件，在上面会运行一些服务，这个时候我们需要对应服务进行相应的管理，例如服务的查看，启动，关闭等。在Windows下也是可以查看系统里面的服务信息。\n\n\n\n在正式讲解服务之前，我们需要先了解一下linux的运行级别的概念，这个到服务时候会有相关联系，所以我们要先了解下linux的运行级别。\n\n1. 命令行模式\n2. 桌面模式\n3. 单用户（windows下安全模式，修复）\n4. ....\n\n\n\n## linux的运行级别简介\n\n一般linux有7种运行模式，最常见的运行模式是 命令行模式 和 桌面模式，可以去 `/etc/inittab`文件查看。\n\n```\n[root@dockerTest ~]# cat /etc/inittab \n\n# inittab is only used by upstart for the default runlevel.\n#\n# ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.\n#\n# System initialization is started by /etc/init/rcS.conf\n#\n# Individual runlevels are started by /etc/init/rc.conf\n#\n# Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf\n#\n# Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,\n# with configuration in /etc/sysconfig/init.\n#\n# For information on how to write upstart event handlers, or how\n# upstart works, see init(5), init(8), and initctl(8).\n#\n# Default runlevel. The runlevels used are:\n#   0 - halt (Do NOT set initdefault to this)\n#   1 - Single user mode\n#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)\n#   3 - Full multiuser mode\n#   4 - unused\n#   5 - X11\n#   6 - reboot (Do NOT set initdefault to this)\n# \nid:3:initdefault:\n\n```\n\n0 代表：关机模式（此模式 linux是关机状态）\n\n1 代表：单用户模式（例如root的密码忘记了，可以在该模式下完成密码的找回）\n\n2 没有NFS网络共享的多用户模式（NFS：network file system）\n\n3 代表的是命令行模式（一般生产环境都是使用的该模式，该模式下没有桌面程序）\n\n4 暂时没有被使用（保留）\n\n5 代表的是 桌面模式（该模式是用户常见桌面操作， 常见的桌面程序有 gnome kde）\n\n6 代表重启\n\n\n\n## 模式切换\n\n在root登录下 ，可以使用 init命令做模式的切换\n\n```\n# init 3(命令行模式)\n\n# init 5(图形化模式)\n\n# init 6(重启操作系统)\n\n# init 0(关机)\n```\n\n\n\n## 默认模式\n\n`id:3:initdefault: `代表linux默认的运行模式，为命令行模式，在生成环境使用该模式。\n\n\n\n## 不同模式下程序行为\n\n在不同的运行模式下，程序的行为表现是不一样的，例如apache在命令行模式下是默认是启动的，但是在图形化模式默认是关闭的。进入默认运行模式对应的` /etc/rc.d/rcN.d/`目录下，里面以**K**开头的代码默认不启动，以**S**开头的代表开机启动。\n\n![1536291931321](1536291931321.png)\n\n\n\n## linux服务分类\n\n==【在运行模式3下的服务的管理】==\n\n\n\n**在linux下的服务主要分为两类：**\n\n1. rpm包安装的服务（yum）\n\n2. 源码包安装的服务\n\n \n\n由于服务的安装方式不一样形成了**两**类服务，造成服务的管理方式不一样的。\n\n\n\n## 查看已安装的服务\n\nrpm包安装的服务（yum本质还是 rpm包安装）\n\n```\n# chkconfig --list\n# chkconfig --list | grep 关键字 查看某个指定的服务的在某些级别下的状态\n```\n\n\n\n源码包安装的服务\n\n```\n一般在/usr/local/目录下查看\n# ls /usr/local\n```\n\n\n\n## 服务状态查看\n\n在linux下的服务的状态查看主要通过如下两个方式：\n\n1. 查看服务的进程，在linux下每当启动一个服务的时候，则会在linux操作系统里面创建对应的进程。可以通过查看进程的名称来得知服务是否在运行。\n\n   例如apache就叫做 httpd ，Nginx叫做 nginx。 一般服务的名称都是启动的脚本命令  或者就是 服务名称+d  (damon后台守护进程的意义，24小时常驻内存，监听端口，接收请求)\n\n   ```\n   # ps axu | grep 进程名称\n   ```\n\n   等价命令\n\n   ```\n   # ps -ef | grep 进程名称\n   ```\n\n2. 查看服务对应的端口\n\n   ```\n   # netstat -tunple  |  grep 端口  //如，80 、3306\n   ```\n\n\n\n测试: curl 发网络请求[百度一下 测试]\n\n```\n# curl localhost\n# curl -v localhost\n# curl -I localhost\n```\n\n\n\n##  rpm服务-管理（yum）\n\n由于服务一般分为**rpm**包服务，源码包服务，则对应的启动方式是不一样的。对于rpm包安装的服务的启动脚本都在` /etc/init.d/ ` 目录下，通过**service**命令进行操作。\n\n```\n# service httpd  start|stop|restart|status\n```\n\nhttpd 这个名称是这个httpd服务的脚本文件，里面有httpd服务启动的命令。\n\n需要注意：service命令都是去查看/etc/init.d/对应的服务脚本进行启动，所以我们**也**可以通过绝对路径的方式来启动rpm包服务。\n\n```\n# /etc/init.d/httpd start|stop|restart\n```\n\n\n\n**通过上面的命令我们可以对服务进行管理，如何实现服务的开机自启动呢？**\n\n方式一：通过`chkconfig `命令进行设置\n\n```\n# chkconfig --level 运行级别 服务名称 on|off\n```\n\n\n\n方式二：通过修改` /etc/rc.d/rc.local` 文件，加入启动的命令\n\n```\n# vim /etc/rc.d/rc.local\n\n /etc/init.d/httpd start\n```\n\n但是需要注意：以上两种方式是**互斥**的，只能使用启动一种来管理对应的服务，不然就会造成服务的重复启动，会保错。\n\n \n\nrpm包管理总结：\n\n1. 查看服务的状态\n\n   a) ps axu | grep  服务进程名称\n\n   b) netstat -tunple | 服务的端口\n\n   c) service 服务的名称 status | start | stop\n\n   d) /etc/init.d/服务的名称 start | status | stop\n\n \n\n2. 设置服务的自启动\n\n   a) chkconfig --level  2345 服务名称 on | off\n\n   b) /etc/rc.d/rc.local  里面定义服务的启动\n\n\n\n## 源码包服务-管理\n\n对于源码包安装的服务，需要通过绝对路径的方式进行管理，例如apache的管理：\n\n```\n# /usr/local/apache2/bin/apachectl -k start|stop\n```\n\n\n\n注意：源码包不能通过 service 服务的名称 start 进行启动，会报错，因为源码包里面的没有提供相应的服务器的启动的脚本放置在 /etc/init.d/服务启动脚本。\n\n\n\n# linux系统管理\n\n## 简介\n\nlinux下会运行很多的服务，当服务运行后，在系统里面的表现为一个进程，进程存在对应的进程信息，例如进程的id。对服务的管理，就是对该进程的管理。例如window下也可以查看进程的信息。\n\n那么在linux下如何查看进程信息呢？\n\n\n\n## 进程查看\n\n方式一：bsd风格\n\n```\n# ps aux \n```\n\n\n\n方式二：linux风格\n\n```\n# ps -ef\n```\n\n\n\n## 进程树查看\n\n```\n# pstree\n```\n\n一般进程有主进程，父进程，子进程等。通过pstree可以查看进程相关的信息，系统运行的第一个进程为init进程。\n\n\n\n小命令：使用 **tree** 可以查看目录的信息\n\n```\n# yum install -y tree\n\n\n[root@localhost home]# tree  /home/\n/home/\n|-- andy\n|-- asion\n|-- caoyang\n|-- lilei\n|-- lily\n|   |-- a.txt\n|   `-- dir\n|       |-- a.txt\n|       |-- b.txt\n|       `-- demo.txt\n|-- mark\n|-- test\n`-- xiaoming\n\n9 directories, 4 files\n\n```\n\n\n\n## 服务器负载查看\n\n通过top命令可以查看当前服务器的状态，判断其健康状态\n\n```\n# top\n```\n\n\n\ntop每隔3s刷新一次，可以通过输入交互命令，例如按h显示帮助；按P则按照cpu使用进行排序，按M（shift+m）使用内存进行排序。按q进行退出。\n\n\n\n## 杀死进程-[不要随便用]\n\n查进程信息\n\n```\nps axu | grep  关键字\nps -ef | grep 关键字\n```\n\n一般当某个进程无法正常关闭的时候，可以通过如下的方式进行进程的强制关闭。\n\n1. `kill `杀死单一进程\n\n2. `killall` 杀死全部进程(主进程负责协调、子进程干活， Nginx master\\woker)\n\n3. `pkill` 杀死全部进程\n\n\n\n一个进程运行中，表现形式就是一个数字，一般叫做pid。\n\n\n\n## 信号量查看\n\n在杀死进程的时候，一般都是通过命令然后传递一个进程信号进行处理，linux支持的进程信号有如下：\n\n```\n[root@localhost home]# kill -l\n 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\n 5) SIGTRAP\t 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\n 9) SIGKILL\t10) SIGUSR1\t11) SIGSEGV\t12) SIGUSR2\n13) SIGPIPE\t14) SIGALRM\t15) SIGTERM\t16) SIGSTKFLT\n17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP\n21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\n25) SIGXFSZ\t26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\n29) SIGIO\t30) SIGPWR\t31) SIGSYS\t34) SIGRTMIN\n35) SIGRTMIN+1\t36) SIGRTMIN+2\t37) SIGRTMIN+3\t38) SIGRTMIN+4\n39) SIGRTMIN+5\t40) SIGRTMIN+6\t41) SIGRTMIN+7\t42) SIGRTMIN+8\n43) SIGRTMIN+9\t44) SIGRTMIN+10\t45) SIGRTMIN+11\t46) SIGRTMIN+12\n47) SIGRTMIN+13\t48) SIGRTMIN+14\t49) SIGRTMIN+15\t50) SIGRTMAX-14\n51) SIGRTMAX-13\t52) SIGRTMAX-12\t53) SIGRTMAX-11\t54) SIGRTMAX-10\n55) SIGRTMAX-9\t56) SIGRTMAX-8\t57) SIGRTMAX-7\t58) SIGRTMAX-6\n59) SIGRTMAX-5\t60) SIGRTMAX-4\t61) SIGRTMAX-3\t62) SIGRTMAX-2\n63) SIGRTMAX-1\t64) SIGRTMAX\t\n```\n\n1 杀死某个单一进程，重新读取配置文件，重启\n\n5 全部干掉，可能造成数据丢失\n\n9 优雅的全部干掉\n\n\n\n## kill杀死单一进程\n\n例一、通过kill命令传递HUP信号关闭httpd，重新读取配置文件，并重启进程\n\n查看httpd进程\n\n```\n# ps aux | grep httpd\n```\n\n\n\n方式一：\n\n```\n# kill -1 httpd进程id\n```\n\n`-1`：数字 1 不是字母\n\n\n\n方式二：\n\n```\n# kill -HUP httpd进程id\n```\n\n注意：传递的HUP是通过 `kill -l `查询出来的信号量去掉SIG后的部分\n\n \n\n \n\n例二、通过kill命令传递KILL强制终止进程\n\n方式一：\n\n```\n# kill -9 httpd进程id\n```\n\n\n\n方式二：\n\n```\n# kill -KILL httpd进程id\n```\n\n\n\n## killall杀死全部进程\n\n通过killall命令杀死全部进程\n\n```\n# killall -9 进程名称\n```\n\n\n\n## pkill杀死全部进程\n\n```\n# pkill -9 进程名称\n```\n\n\n\n一般情况下不要尝试尝试杀死进行，因为服务的命令本身有提供开启、关闭、重启。杀掉进程有可能数据丢失。\n\n\n\n# linux后台作业\n\n## 简介\n\nlinux的后台作业，就是将某些操作放置后台进行处理，例如windows下的最小化操作，就是在后台操作。主要是为了多个任务进行操作，例如在当前终端复制一个比较大的文本，则会占据当前终端，例如mysql的服务器的启动，这些操作都要进行后台处理才合适。同时需要注意，当前操作的任务是和当前的终端进行绑定，如果当前终端关闭，则对应的操作会被关闭。\n\n\n\n## 相关操作\n\n**如何将某个操作放入后台呢？**\n\n1. 例如在后台压缩一个文件，在操作命令的后面加上 & 符号，在后台是执行的\n\n   ```\n   # tar -zcf  etc.tar.gz  /ect  &\n   ```\n\n   `-z` 代表使用的gzip算法进行压缩\n\n   `-c `  create 代表是要进行打包    `-x`代表是解压e**x**tract\n\n   `-f `  file 指定打包文件的名称【包名规范：名称.tar.gz    xxx.tar.bz   xxx.7z】\n\n2. 如果当前占据该终端，例如top命令，可以使用 ctrl + z 放入后台，进行暂停\n\n   ```\n   # top\n   \n    ctrl + z\n   ```\n\n3. 如何查看放在后台的任务呢?\n\n   ```\n   # jobs\n   [1]+  Stopped                 top\n   ```\n\n4. 如何将后台暂停的任务恢复到前台执行呢？\n\n   ```\n   方式一\n   # fg 工作信号id \n   方式二\n   # %工作信号id\n   ```\n\n\n\n#  linux定时任务\n\n## 简介\n\n在linux服务器里面，一般来说我们都要定期的去做某些操作，例如数据库的备份【1. 全量备份，但是一般这个需要消耗很大的系统资源，一般周期长，一般选择在凌晨3-5点左右完成，不能在人多的时候完成。  2. 增量备份，最小化的备份】，但是由于服务器在白天的压力一般比较大，则对于数据库的备份一般来说都是在夜晚2-5点进行操作。这个时候就需要使用linux的系统定时任务来进行操作。例如让定时任务定期执行某个PHP脚本，来做一些操作，例如每周五下午五点统计该网站注册的的用户总人数发送给相关人员。周一的上午统计上个星期的业务总量，下了多少的订单，出了多少货；获取是定期生成静态页，定期让缓存失效，重新生成缓存。队列服务。订阅号\n\n\n\n## crontab定时任务参数解释\n\n**如何编写定时任务呢**\n\n```\n# crontab -e\n\n* * * * * 执行程序，一般来说是一个shell脚本【shell编程】\n```\n\n其中这个五个星分别代表：\n\n| 项目    | 含义                 | 范围                    |\n| ------- | -------------------- | ----------------------- |\n| 第一个* | 一小时当中的第几分钟 | 1-59                    |\n| 第二个* | 一天中的第几个小时   | 0-23                    |\n| 第三个* | 一个月中的第几个天   | 1-31                    |\n| 第四个* | 一年中的第几个月     | 1-12                    |\n| 第五个* | 一个星期中的星期几   | 0-7（0和7都代表星期天） |\n\n\n\n对于前面的五个部分，有如下比较特殊符号需要讲解\n\n| 项目 | 含义                                                         |\n| ---- | ------------------------------------------------------------ |\n| *    | 代表任何时间，比如第一个*，代表一个小时里面的每分钟都执行一次命令 |\n| ,    | 代表不连续的时间，比如  0     9,12              * * * ，代表每天的9点0分，12点0分执行一次命令 |\n| -    | 代表连续的范围，比如  0   10   * *     1-6 ，代表周一到周六的每天上午10点执行一次命令 |\n| */n  | 代表每隔多久执行一次，比如 */10 * * * *，代表每个10分钟执行一次命令 |\n\n解释如下的命令代表的含义\n\n15 10 * * * /user/local/data.sh\n\n每天的上午10点15分钟执行这个命令\n\n \n\n30 8 * * 1 /user/local/data.sh\n\n每周的周一的的上午8点30分钟执行这个命令\n\n \n\n*/10  3 * * * /user/local/data.sh\n\n每天的凌晨3点到4点之间每隔10分钟执行一次\n\n \n\n0     10   1,15   *    2 /user/local/data.sh\n\n最大的坑 注意：每月的号最好不要和星期进行放在一起，因为linux操作系统默认是进行并集操作，不是执行与操作。\n\n相当于 每月的1号、15号，还有周二（只要是这个月的周二都要执行）的10点0分执行这个命令。\n\n\n\n## 定时任务管理\n\n### 添加\n\n```\n简单示例演示，每一分钟在 /var/date.log文件里面记录下当前时间\n# crontab -e\n* * * * * date >> /var/date.log\n```\n\n每一分钟向 /var/date.log 写入当前的时间信息，追加\n\n注意：crontab -e 本质其实就是想往 /etc/crontab 文件里面写入上面的定时任务信息。\n\n```\n# vim /etc/crontab\n```\n\n\n\n\n\n### 查看\n\n```\n# crontab -l\n```\n\n\n\n### 清除\n\n```\n# crontab -r [注意：-r代表是删除所有的定时任务，没法删除单条的任务，如果删除单个直接vim进行编辑]\n```\n\n\n\n### 扩展\n\n注意：linux下的定时任务的最小的精度是在分钟，没有秒级别的定时任务。如何设置秒级别的定时任务？\n\n<https://www.cnblogs.com/adtuu/p/5213352.html>\n\n \n\n注意：现在有这样需求，在每周五的下午五点统计该网站的这一周的注册会员的总数，发送给公司的XXX人员的 手机或者邮箱。\n\n1. 定期的执行某个脚本\n\n2. 统计网站的会员注册信息\n\n3. 发送邮件或者手机短信\n\n\n\n# lamp环境的搭建\n\n## 简介\n\n互联网上一般存在两种架构\n\n1. **lamp架构**\n\n   a) linux\n\n   b) apache\n\n   c) mysql 或者MariaDB；\n\n   * MariaDB是mysql的另外的一个分支，mysql被Oracle收购了，有可能闭源，所以出现其他的分支版本，\tMariaDB是原MySQL的作者之一进行主导开发，以他女儿名字命名。\n\n   d) PHP或者Python\n\n2. lnmp架构\n\n   a) linux\n\n   b) Nginx\n\n   c) mysql或者MariaDB\n\n   d) PHP或者Python\n\n\n\n## 环境准备\n\n关闭防火墙\n\n```\n# iptables -L \n# iptables -F\n# service iptables stop\n# chkconfig --level 35 iptables off\n\n```\n\n`-L `列出\n\n`-F` 删除\n\n`service iptables stop`\n\n\n\n关闭selinux\n\n```\n# setenforce 0\n\n# getenforce\n```\n\n\n\n时间同步(确保DNS的服务器需要正常)\n\n```\n# ntpdate  time.windows.com\n```\n\n如果上面的服务无法正常使用\n\n```\n[root@localhost ~]# date -s \"2018-09-07 17:04:00\"\n2018年 09月 07日 星期五 17:04:00 CST\n\n[root@localhost ~]# date \n2018年 09月 07日 星期五 17:04:01 CST\n```\n\n\n\n## ftp管理\n\n使用一个ftp上传工具将源代码上传到服务器上。ftp也是linux下的一个服务，需要先安装对应的服务，启动服务后，通过客户端软件上传源代码。\n\n安装\n\n```\n# yum install -y vsftpd\n```\n\n启动服务\n\n```\n# service vsftpd   start | status | restart | stop\n```\n\n注意：ftp也是一个 c/s 架构，并且监听的是 21 号端口。\n\n\n\n## ftp客户端使用\n\n1. 注意：这里不能使用root用户，需要使用普通用户andy进行ftp文件上传。一般来说，源码都会上传到 `/usr/local/src` 目录下。\n\n![1536311258735](1536311258735.png)\n\n\n\n\n\n2. 修改 `/usr/local/src `的其他人权限，是的其他用户可以把源码上传到该目录\n\n   ```\n   [root@localhost local]# chmod -R 757 /usr/local/src/\n   \n   [root@localhost local]# ls -ld /usr/local/src/\n   drwxr-xrwx 5 root root 4096 09-07 17:29 /usr/local/src/\n   ```\n\n3. 上传操作\n\n![1536311357128](1536311357128.png)\n\n\n\n## apache安装\n\n1. 解压Apache的tar包\n\n   ```\n   # cd /usr/local/src\n   \n   # tar -zxvf httpd-2.2.11.tar.gz\n   ```\n\n2. 进入解压后的目录，然后使用 configure命令收集操作系统的信息\n\n   ```\n   # cd httpd-2.2.11\n   # ./configure --prefix=/usr/local/apache2\n   ```\n\n3. 编译\n\n   ```\n   # make\n   ```\n\n4. 安装\n\n   ```\n   # make install \n   ```\n\n5. 成功安装后，启动apache服务器\n\n   ```\n   /usr/local/apache2/bin/apachectl -k start\n   ```\n\n\n\n\n\n## mysql安装\n\n1. 将mysql的压缩包解压到 `/usr/local` 目录下\n\n   ```\n   # cd /usr/local/src\n   \n   #  tar -zxvf msyql-5.5.38-linux2.6-i686.tar.gz -C /usr/local\n   ```\n\n   `-C`代表：解压到指定目录\n\n2. 为mysql的解压的目录创建一个软连接\n\n   ```\n   # cd /usr/local\n   # ln -sv mysql-5.5.38-linux2.6-i686 mysql\n   ```\n\n   ln： 代表创建一个符号链接，就是一个快捷键\n\n3. 进入mysql目录\n\n   ```\n   # cd /usr/local/mysql\n   ```\n\n4. 创建一个mysql的用户，来使得它运行MySQL软件\n\n   ```\n   # useradd mysql\n   ```\n\n5. 更改mysql目录及其子目录以及文件的所有者和所属组为mysql和mysql组\n\n   ```\n   # chown  -R  mysql:mysql  . \n   ```\n\n6. 执行MySQL安装的脚本\n\n   ```\n   # ./scripts/mysql_install_db --user=mysql\n   ```\n\n7. 复制MySQL的配置文件到 `/etc/`目录下\n\n   ```\n   # cp support-files/my-small.cnf /etc/my.cnf\n   ```\n\n8. 复制mysqld脚本到系统服务目录\n\n   ```\n   # cp support-files/mysql.server /etc/init.d/mysqld\n   ```\n\n9. 加入系统服务列表\n\n   ```\n   # chkconfig --add mysqld\n   ```\n\n10. 启动mysql服务\n\n  ```\n  # service mysqld start\n  ```\n\n11. 登录MySQL服务器，注意：此时root密码为空\n\n    ```\n    # /usr/local/mysql/bin/mysql -uroot -p\n    ```\n\n12. 更改MySQL服务器的root密码\n\n    ```\n    [root@localhost htdocs]# /usr/local/mysql/bin/mysql -uroot -p\n    Enter password: \n    \n    Welcome to the MySQL monitor.  Commands end with ; or \\g.\n    Your MySQL connection id is 8\n    Server version: 5.5.38 MySQL Community Server (GPL)\n    \n    Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.\n    \n    Oracle is a registered trademark of Oracle Corporation and/or its\n    affiliates. Other names may be trademarks of their respective\n    owners.\n    \n    Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n    \n    mysql> use mysql;\n    Database changed\n    \n    mysql> update user set password=password(\"admin88\") where user=\"root\";\n    Query OK, 0 rows affected (0.00 sec)\n    Rows matched: 4  Changed: 0  Warnings: 0\n    \n    mysql> flush privileges;\n    Query OK, 0 rows affected (0.00 sec)\n    \n    ```\n\n\n## php安装\n\n1. 解压PHP源码包\n\n   ```\n   # cd /usr/local/src\n   # tar -zxvf php-5.2.5.tar.gz\n   ```\n\n2. 进入解压后的PHP目录，在configure的时候，特别注意：需要指定**Apache**和**MySQL**的安装目录\n\n   ```\n   # cd php-5.2.5\n   # ./configure --prefix=/usr/local/php --with-mysql=/usr/local/mysql/ --with-apxs2=/usr/local/apache2/bin/apxs   --with-config-file-path=/usr/local/php\n   ```\n\n3. 编译\n\n   ```\n   # make\n   ```\n\n4. 安装\n\n   ```\n   # make install\n   ```\n\n5. 复制PHP配置文件到指定目录\n\n   ```\n   # cp php.ini-dist /usr/local/php/lib/php.ini\n   ```\n\n6. 配置Apache的httpd.conf文件，增加如下信息，以后有.php结尾的文件都交给php模块处理\n\n   ```\n   [root@localhost htdocs]# vim /usr/local/apache2/conf/httpd.conf\n   \n   \n   AddType application/x-httpd-php .php\n   ```\n\n7. 重启Apache\n\n   ```\n   # pkill -9 httpd\n   \n   # /usr/local/apache2/bin/apachectl -k start\n   ```\n\n8. 添加PHP测试文件\n\n   ```\n   # vim /usr/local/httpd/htdocs/test.php\n   \t\n   \tphpinfo();\n   ```\n\n9. 浏览器访问\n\n   ![1536313751040](1536313751040.png)\n\n\n\n# 扩展\n\n## samba\n\n### 简介\n\n有的时候在开发的环境中，是多种操作系统环境交叉使用，例如，Windows的电脑做开发，linux电脑做服务器，彼此之间需要相关的传递文件，共享信息。彼此沟通非常麻烦。这个时候可以使用一个叫做 Samba（作者和linux是同样有名）的软件完美的解决彼此之间的沟通。\n\n\n\n### 使用\n\n1. 使用yum安装Samba软件\n\n   ```\n   # yum install -y samba\n   ```\n\n2. 添加一个系统用户，等会配合Samba软件一起使用\n\n   ```\n   # useradd sambatest\n   # passwd sambatest\n   ```\n\n3. 添加上一步的用户到Samba服务里面\n\n   ```\n   # smbpasswd  -a  sambatest(将系统用户加入Samba的配置文件中，并为该用户设置密码)\n   ```\n\n4. 启动Samba服务\n\n   ```\n   # service smb start\n   ```\n\n5. Windows连接Samba服务的服务器\n\n   ```\n   window+r\n   \n   输入\n   \\\\linux服务器IP地址\n   ```\n\n\n\n## Sudo\n\n### 简介\n\n可以用**root的身份**去执行一个命令，主要是**为辅助超级管理员**完成一些超级管理员不能登录下的操作。因为在实际的生产环境，root一般是很少连接远程连接服务器的，root权限过大，一般来说都是以普通用户进行登录管理，但是有的时候普通用户也想执行一下root用户的权限（例如服务器重启），该怎么办呢？\n\n\n\n### 使用\n\n1. 查看sudo信息\n\n   ```\n   # visudo -V\n   ```\n\n   如果不能显示上面的信息，使用如下方式进行安装\n\n2. 安装sudo软件\n\n   ```\n   # yum install -y sudo\n   ```\n\n3. 编辑配置文件，使得一个普通用户可以使用root的身份去执行一些root才能操作的命令（例如关机 shutdown、 useradd）修改的其实是` /etc/sudoers`文件\n\n   ```\n   # visodu \n    caoyang ALL=(ALL) /sbin/shutdown\n    caoyang ALL=(ALL)  /usr/sbin/useradd\n   ```\n\n4. 切换成普通用户，执行命令\n\n   ```\n   # su - caoyang\n   ```\n\n   注意：需要输入普通用户的密码\n\n\n\n","categories":["Linux"]},{"title":"JavaScript 冒泡事件","url":"%2Fposts%2F2780478422%2F","content":"\n\n# 三、冒泡事件（了解）\n\n## 3.1、什么是冒泡事件\n\n02冒泡事件.html 代码：\n\n两个重叠的div，分别绑定单击事件：\n\n```javascript\n<body>\n<style>\n    #d1{\n        width:200px;\n        height:200px;\n        border:solid 1px #ccc;\n        background-color: #ccc;\n    }\n    #d2{\n        width:100px;\n        height:100px;\n        border:solid 1px #ccffcc;\n        background-color: #ccffcc;\n    }\n</style>\n\n<div id=\"d1\">\n    <div id=\"d2\"></div>\n</div>\n\n<script>\n    //给 d1 绑定单击事件\n    document.getElementById('d1').onclick = function () {\n        alert('d1');\n    };\n    //给 d2 绑定单击事件\n    document.getElementById('d2').onclick = function () {\n        alert('d2');\n    };\n</script>\n\n</body>\n```\n\n展示效果：\n\n![1532745074426](1532745074426.png)\n\n当点击内层（绿色）div的时候，不但会触发绿色div的单击事件，也会触发底层灰色div的单击事件。\n\n这种透过元素触发另一个元素的事件的情况，就叫做**冒泡事件**。\n\n\n\n## 3.2、阻止冒泡事件的发生\n\n标准浏览器使用  `evt.stopPropagation();  `    evt指的是事件对象\n\nIE内核浏览器使用  ``window.event.cancelBubble = true;  ``\n\n\n\n02冒泡事件.html  代码：\n\n```html\n<body>\n<style>\n    #d1{\n        width:200px;\n        height:200px;\n        border:solid 1px #ccc;\n        background-color: #ccc;\n    }\n    #d2{\n        width:100px;\n        height:100px;\n        border:solid 1px #ccffcc;\n        background-color: #ccffcc;\n    }\n</style>\n\n<div id=\"d1\">\n    <div id=\"d2\"></div>\n</div>\n\n<script>\n    //给 d1 绑定单击事件\n    document.getElementById('d1').onclick = function () {\n        alert('d1');\n    };\n    //给 d2 绑定单击事件\n    document.getElementById('d2').onclick = function (e) {\n        alert('d2');\n        /*************** 阻止冒泡事件发生 **********/\n        if(window.event){\n            window.event.cancelBubble = true;\n        }else{\n            e.stopPropagation();\n        }\n    };\n</script>\n\n</body>\n```\n\n\n\n","categories":["Advanced"]},{"title":"JavaScript 闭包","url":"%2Fposts%2F994947546%2F","content":"\n\n# 五、闭包（理解）\n\n## 5.1、闭包的定义\n\n官方解释是：**闭包**，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。\n\n我的理解是：闭包函数是对作用域的一个应用，应用的就是函数可以使用函数之外的变量，并且闭包函数所在的作用域会一直保存在内存中。\n\n\n\n**所以闭包函数的特点是：**\n\n- 闭包函数可以使用函数之外的变量；\n- 闭包函数会一直保存在内存中，不会被释放。\n\n\n\n## 5.2、使用到闭包函数的例子\n\n### 5.2.1、获取函数内部的局部变量\n\n05获取函数内部的局部变量.html  代码：\n\n```javascript\nfunction t1(){\n    var a = 1;\n    //定义一个函数，用于返回变量 a\n    function getA(){\n        console.log(a); //函数getA，可以使用它以外的变量a\n    }\n    return getA; //这里返回的getA是函数的引用，不能加小括号\n}\nvar myGetA = t1(); //返回值是getA函数\nmyGetA(); //相当于调用getA\n```\n\n**闭包函数所在的作用域不会被释放，一直存在内存中**，下面的例子中，如果闭包函数getA被释放了，则每次调用myGetA都会输出1，而输出结果是1/2/3，说明闭包函数所在的作用域不会被释放。\n\n```html\n<script>\n\n    function t1(){\n        var a = 1;\n        //定义一个函数，用于返回变量 a\n        function getA(){\n            console.log(a++);\n        }\n        return getA;\n    }\n\n    var myGetA = t1(); //返回值是getA函数\n    \n    myGetA(); //相当于调用getA  输出1\n    myGetA(); //输出 2\n    myGetA(); //输出 3\n</script>\n```\n\n\n\n### 5.2.2、每隔一秒，输出一个数\n\n07每隔一秒输出一个数.html\n\n```html\n\n<script>\n\n    //setInterval(js代码或函数, 间隔毫秒); //间隔多少毫秒重复执行前面的js代码或函数\n    //setTimeout(js代码或函数, 间隔毫秒); //间隔多少毫秒后，只执行一次js代码或函数\n\n    //setTimeout('alert(1)', 2000);\n\n    /*setTimeout(function(){\n        alert(2);\n    }, 2000);*/\n\n    //每隔一秒输出一个数，要求依次输出1 2 3 4 5\n    /*var i = 1;\n    var timer = null;\n    timer = setInterval(function () {\n        console.log(i++);\n        if(i>=6) {\n            clearInterval(timer);\n        }\n    }, 1000);*/\n\n    //使用闭包的方式\n    for(var i=1; i<=5; i++){\n        /*\n        1、 for循环执行的时间可以忽略不计，认为是瞬间执行了5 次循环\n        2、 执行一次循环，就会创建一个函数，并调用它。调用函数的时候，传递i的值\n        3、 每个函数接收到的 i 都是不同的，分别是12345\n         */\n        (function (x){\n            setTimeout(function(){\n                console.log(x);\n            }, 1000*x);\n        })(i);\n    }\n\n</script>\n```\n\n\n\n### 5.2.3、点击li 标签，弹出 li 对应的下标\n\n08点击li弹出对应的下标.html   代码\n\n```html\n<script>\n    /************* 简单的方式 *************/\n    //获取所有的li\n    /*var lis = document.getElementsByTagName('li');\n     //循环，分别绑定单击事件\n     for (var i=0; i<lis.length; i++) {\n     //console.log(typeof lis[i]);  //object\n     lis[i].aaa = i; //循环的时候，为每个li对象，添加一个成员属性，值就是他对应的下标\n     lis[i].onclick = function () {\n     //在事件处理函数中，this 表示绑定事件的对象，即 lis[i]\n     console.log(this.aaa);\n     }\n     }*/\n\n    /****************** 闭包的方式 ******************/\n\n    //先定义一个函数\n    var t = function(x){\n        //console.log('abc');\n        function bibao(){\n            console.log(x);\n        }\n        return bibao;\n    };\n\n    //获取所有的li\n    var lis = document.getElementsByTagName('li');\n    //循环，分别绑定单击事件\n    for (var i = 0; i < lis.length; i++) {\n        //console.log(typeof lis[i]);  //object\n        \n        // 调用t函数的返回值是 bibao\n        //实际的单击事件处理函数是 bibao 函数\n        lis[i].onclick = t(i); //for循环执行的时候，t()函数自动执行，并传入i的值。\n        \n    }\n</script>\n```\n\n![1532761709171](1532761709171.png)\n\n总之，很多高级的应用程序都会使用到闭包，但是滥用闭包会造成内存的消耗。\n\n后面我们会有一个综合的 “淡入淡出图片” 案例，那里面就会用到闭包。\n\n\n\n\n\n","categories":["Advanced"]},{"title":"JavaScript 阻止默认行为","url":"%2Fposts%2F670022636%2F","content":"\n\n# 四、阻止默认行为（了解）\n\n**默认行为**就是html标签的一些默认行为，比如点击a标签会跳转，比如点击了submit按钮表单会提交。这些都属于标签的默认行为。\n\n有些时候，点击了a标签或者submit按钮后不希望执行标签的默认行为，这时候就需要阻止默认行为。\n\n\n\n**阻止默认行为：**\n\n标准浏览器：`evt.preventDefault();`\n\nIE内核浏览器：`window.event.returnValue = false;`\n\n\n\n03阻止默认行为.html\n\n```html\n<body>\n\n<a href=\"02冒泡事件.html\">冒泡事件</a>\n\n<script>\n    //获取a 标签\n    document.getElementsByTagName('a')[0].onclick = function (evt) {\n        //标准浏览器：evt.preventDefault();\n        //IE内核浏览器：window.event.returnValue = false;\n        /*if(window.event){\n            window.event.returnValue = false;\n        }else{\n            evt.preventDefault();\n        }*/\n        //最简单的返回是直接 return false;\n        return false;\n    };\n</script>\n\n</body>\n```\n\n**延伸：**\n\n1. 在实际开发中，敏感操作一定要给提示。\n\n```html\n<a href=\"02冒泡事件.html\" onclick=\"return confirm('你确定要删除吗');\">删除</a>\n```\n\n2. 检测表单提交的两种方式\n\n```html\n<body>\n\n<form name=\"myform\" action=\"02冒泡事件.html\" method=\"post\">\n    用户名：<input type=\"text\" name=\"username\" />\n    <input type=\"submit\" name=\"sub\" value=\"提交\" />\n</form>\n\n<script>\n    //方式一：给submit按钮绑定onclick事件\n    /*document.myform.sub.onclick = function () {\n        alert('请填写用户名');\n        return false; //阻止表单提交\n    };*/\n\n    //方式二：给表单form绑定onsubmit事件\n    document.myform.onsubmit = function(){\n        alert('请再次填写用户名');\n        return false; //阻止表单提交\n    };\n</script>\n\n</body>\n```\n\n\n\n","categories":["Advanced"]},{"title":"js运行机制","url":"%2Fposts%2F3150218531%2F","content":"\n\n# 你真懂JavaScript运行机制吗？\n\n\n\n# 写在前面\n\n说起javascript（以下简称js）这门语言，相信大家已经非常熟悉了，不管是前端开发还是后端开发几乎无时无刻都要跟它打交道。虽说开发者每天几乎都要操作js，但是你真的确定你掌握了js的运行机制吗！下面我们就来聊聊这话题。\n\n\n\n# JavaScript运行机制图解\n\n![](111.jpg)\n\n上图我们可以分为两部分：浏览器中的`JS引擎`和`运行环境Runtime`，那它们的区别是什么？\n\n* JS引擎：编译并执行代码的地方。\n\n  如上图中可以看出JS引擎分为两大核心部分：`栈和堆`\n\n  栈（Stack）:js代码的执行都要压到此栈中执行。 \n\n  堆：存放对象、数组的地方，js垃圾回收就是检查这里。\n\n* Runtime：浏览器的运行环境，它提供了一些对外接口供JS调用，如网络请求接口。\n\n\n\n\n\n# JavaScript引擎是单线程的\n\nJS引擎是单线程的，也就是说在一个时间段内，事情只能一件一件的按先后顺序去做，第一件事没做完就不能第二件事。那么在js引擎中负责解释和执行js代码的线程只有一个，我们可以称之为**`主线程`**。\n\n当然浏览器的运行环境Runtime还提供一些其他的线程，如定时器线程、ajax线程、事件线程、网络请求和UI渲染的线程，为了和js主线程分开，我们这里都统称它们为`工作线程`。\n\n由于浏览器是多线程的，所以工作线程和js主线程都可以执行任务，线程间互不干扰。\n\n\n\n# JavaScript同步（异步）任务\n\n在JavaScript任务可以分为两种：\n\n* 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，若前一个任务耗费很长时间，则后面的任务会一直处于等待状态，即阻塞状态。\n\n* 异步任务：在栈执行代码的过程中，如遇到异步函数，如setTimeout、异步Ajax、事件处理程序，会将这些异步代码交给浏览器的工作线程来处理，我们把这些任务称之为异步任务。异步任务是不进入主线程，而是进入任务队列（queue task）。\n\n  - 什么异步函数？\n\n    异步函数通常是由**发起函数**和**回调函数**构成的。如：\n\n    `A（callback）`  \n\n    - 函数A就是发起函数\n    - callback就是回调函数\n\n    ​\n\n    它们都是在主线程调用的，其中发起函数用来发起异步过程，回调函数用来处理结果。\n\n    如：`setTimeout(callback,1000)`\n\n    setTimeout就是发起函数、callback就是回调函数。\n\n    如：异步的Ajax\n\n  ```javascript\n  \tvar xhr = new new XMLHttpRequest();\n  \txhr.onreadystatechange = callback; //callback为回调函数\n  \txhr.open('get',url,true);\n  \txhr.send(null); // send为发起函数\n  ```\n\n  可以看出发起函数和回调函数也可以是分离的。\n\n  ​\n\n  既然同步任务是在主线程中执行的，那么异步任务何时执行？\n\n  答：是这样的，一旦栈中同步任务执行完毕后，系统就会通过`事件循环`机制读取任务队列中的任务一个个移到栈中去执行。\n\n  ​\n\n\n\n\n# 事件循环\n\n当主线程中的任务执行完毕后，会从任务队列中获取任务一个个的放在栈中执行去执行，这个过程是循环不断的，所以整个的这种运行机制又称为事件循环。\n\n\n\n# 栈\n\n在js中，代码最终都是在栈中执行的，栈结构的特点是：**先进后出，后进先出**。\n\n我们来看下面代码的运行结果：\n\n``` javascript\nfunction bar(){\n    console.log(1);\n    foo();\n}\n\nfunction foo(){\n    par();\n    console.log(3);\n}\n\nfunction par(){\n    setTimeout(function(){\n        console.log(2);\n    },0);\n}\n\nbar();\n\n```\n运行的最终结果是：132。 为什么结果不是123呢？ \n\n下我们来分析下代码运行时入栈和出栈的过程。\n\n\n\n首先当调用函数`bar()`时，此函数就会先入栈，其内部的`console.log(1)`也会随之入栈执行。\n\n![入栈](1.jpg)\n\n执行完console.log(1)后，就要出栈，于是控制台先打印出结果**1**，只剩下bar()在栈中。接着再执行函数bar内部的函数foo，于是函数foo也开心的入栈了。\n\n![](2.jpg)\n\n执行函数foo的内部代码，调用函数`par()`，于是函数par()也要跟着入栈。\n\n![](3.jpg)\n\n由于函数par()内部执行遇到了`异步函数setTimeout`,异步函数则会由浏览器的Runtime运行环境的工作线程来处理，等定时器设置的时间到达就会被放到任务队列中，此时栈的同步任务继续执行。\n\n![](5.jpg)\n\n接着在执行par函数中的`console.log(3)`,控制台打印结果为**3** ,此时栈的代码执行完毕后，会按照栈的特点进行\n\n**先进后出，后进先出**顺序进行`出栈`。出栈顺序：**先函数par()----》后函数foo()----》最后函数bar**。\n\n\n\n最后只剩下异步任务，由主线程去获取任务队列中的任务放在栈中去执行。也可以认为栈中的同步代码执行总是在读取`异步任务`之前执行。\n\n![](6.jpg)\n\n最后执行setTimeout中的回调函数：结果控制台输出为2。\n\n```javascript\nsetTimeout(function(){\n        console.log(2);\n},0);\n```\n\n所以代码的最终运行结果为132。\n\n\n\n# 小结\n\n* js引擎是单线程执行js代码，同步任务在栈中按顺序执行，如果某一个同步任务没有执行完毕，则后面的代码将会处于阻塞等待状态\n* 栈中若执行遇到了异步任务（如定时器、异步Ajax、事件），会将此异步任务通过浏览器对应的工作线程来处理。\n* 工作线程中的所有异步任务均会按照设定的时间进行等待，时间一到会被加入任务队列。如果是异步ajax,则等待其返回结果后在加入到任务队列\n* 当栈中为空时，会通过事件循环来一个个获取任务队列中的任务放到栈中进行逐个运行。即栈中的同步任务总是在读取`异步任务`之前执行\n* 定时器设置的时间不一定按照设定的时间进行执行，这得取决于栈中同步任务耗费的时间。因为栈中执行的同步任务如果耗费很长时间，则会影响到异步任务回调函数的执行。\n\n","categories":["JavaScript运行机制"]},{"title":"JavaScript 案例","url":"%2Fposts%2F2023490148%2F","content":"\n\n# 六、案例--可编辑的表格\n\n文件名： ``可编辑的表格.html``\n\n\n\n页面效果：\n\n![1532690579842](1532690579842.png)\n\n\n## 6.1、设置html和css样式\n\nhtml代码：\n\n```html\n<table>\n    <tr>\n        <td>1</td>\n        <td>赖志丽</td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td>罗凯峰</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>小陈</td>\n    </tr>\n    <tr>\n        <td>4</td>\n        <td>小马</td>\n    </tr>\n</table>\n```\n\ncss样式：\n\n```css\n\t   *{\n            margin:0;\n            padding:0;\n            border:0 none;\n        }\n        table,td{\n            border:solid 1px #ccc;\n            border-collapse: collapse; /*合并边框*/\n        }\n        table{\n            width:400px;\n            margin:10px auto;\n        }\n        td{\n            line-height: 26px;\n        }\n```\n\n\n\n\n## 6.2、JS做隔行换色\n```html\n<script>\n    // 隔行换色\n    // 主要为操纵行（tr）的背景颜色\n    // 隔行，可用偶数奇数来判断\n    //\n    // 设置css样式\n    // elementNode.style.css样式 = 值\n    \n    //获取到所有的tr\n    var trs = document.querySelectorAll('tr');\n    for(var i=0; i<trs.length; i++) {\n        if(i%2 == 1){\n            trs[i].style.backgroundColor = '#ccc';\n        }\n    }\n</script>\n```\n\n## 6.3、找到包含姓名的td\n\n因为 id列通常为不可编辑，所以只需要姓名列的对象。\n\n![1532691082117](1532691082117.png)\n\n##  6.4、循环绑定单击事件\n\n```javascript\n    //遍历tds，给每个姓名td绑定单击事件\n    for (var i = 0; i < tds.length; i++) {\n\n        //绑定单击事件\n        tds[i].onclick = function () {\n\n            //注： 不能使用tds[i] ，应使用this表示 tds[i].onclick\n\n            //后面的this亦可用变量表示\n            var td = this; // this表示单击的td\n\n            //创建input\n            var input = document.createElement('input');\n\n            //获取td中的值\n            var tdValue = this.innerText;  //应使用innerText，获取文本内容\n\n            //设置input的value=td中的值\n            input.value = tdValue;\n\n            //清空td，appendChild 是追加\n            this.innerHTML = '';\n\n            //把input放到td 中\n            //this.innerHTML = \"<input value='\"+text+\"' />\";\n            this.appendChild(input);\n        };\n    }\n```\n\n\n\n到这一步，点击td之后，会生成一个input，并放到td中。\n\n## 6.5、处理input和td的样式，处理点击逻辑问题\n\n前提需要之前获取css样式的兼容方法getStyle。需要复制过来。\n\n```javascript\n    //遍历tds，给每个姓名td绑定单击事件\n    for (var i = 0; i < tds.length; i++) {\n\n        //--------------------样式储值-------------------------//\n        //获取td初始值\n        //宽 高\n        var td_width = getStyle(tds[i], 'width');\n        var td_height = getStyle(tds[i], 'height');\n        //字体大小  背景色\n        var td_fontSize = getStyle(tds[i], 'fontSize');\n        var td_backgroundColor = getStyle(tds[i], 'backgroundColor');\n        //--------------------样式储值-------------------------//\n\n        //绑定单击事件\n        tds[i].onclick = function () {\n\n            //注： 不能使用tds[i] ，应使用this表示 tds[i].onclick\n\n            //后面的this亦可用变量表示\n            var td = this; // this表示单击的td\n\n            //--------------------点击处理-------------------------//\n            // 首次点击后，td会被清空，再次点击，则获取的td内容为空\n            // 所以，需要处理点击的逻辑\n            //\n            //判断td 中的子节点长度（有一个input了，就不要在向下执行了）\n            if (td.children.length >= 1) {\n                return;\n            }\n            //--------------------点击处理-------------------------//\n\n            //创建input\n            var input = document.createElement('input');\n\n            //获取td中的值\n            var tdValue = this.innerText;  //应使用innerText，获取文本内容\n\n            //设置input的value=td中的值\n            input.value = tdValue;\n\n            //清空td，appendChild 是追加\n            this.innerHTML = '';\n\n            //把input放到td 中\n            this.appendChild(input);\n\n            //--------------------样式处理-------------------------//\n            //点击后，input的样式要和td的一样\n\t\t   //使用前面获取的td的初始值\n            \n            //宽 高\n            input.style.width = td_width;\n            input.style.height = td_height;\n            //字体大小  背景色\n            input.style.fontSize = td_fontSize;\n            input.style.backgroundColor = td_backgroundColor;\n            //边框为0 风格为none\n            input.style.border = '0 none';\n\n            //td 在点击后宽度会拉长，所以要用获取的初始宽高重新设置td\n            //宽 高\n            td.style.width = td_width;\n            td.style.height = td_height;\n            //--------------------样式处理-------------------------//\n            \n            \n        };\n    }\n```\n\n## 6.6、设置input的失去焦点事件和键盘事件\n\n```javascript\n\t\t   td.style.width = td_width;\n            td.style.height = td_height;\n            //--------------------样式处理-------------------------//\n/***************************  下面的代码接上面两行  ********************/\n            //--------------------事件处理-------------------------//\n\n            //首先input需要在点击同时，获取焦点\n            // input.select(); //[可选] 直接获取焦点并选中内容\n            input.focus();\n\n            //input在失去焦点事件（不保存修改，返回td的初始值）\n            input.onblur = function () {\n                // td.innerHTML = tdValue;\n            }\n\n            //input按键（回车键）事件（保存修改到td中）\n            // 形参evt 在事件触发时自动传值\n            input.onkeyup = function (evt) {\n                var e = window.event || evt; //兼容的事件对象\n                var keyCode=e.keyCode;\n\n                // console.log(this);\n                // console.log(this.value); //只能获取此值，innerHTML和innerText等都为空\n\n                if (keyCode==13){ //已按回车键\n                    td.innerHTML='';  //解决谷歌浏览器bug。谷歌认为按回车的时候，同时触发了失去焦点事件\n                    td.innerHTML=this.value;  //this 是input\n                    // TODO（可关联name属性，以便提交表单后获取）\n                }\n\n            }\n            //--------------------事件处理-------------------------//\n\n```\n\n----\n\n\n\n# 七、案例\n\n### 7.1、案例---隔行换色\n\n12隔行换色.html \n\n```html\n<table border=\"1\" cellpadding=\"2\" cellspacing=\"0\" rules=\"all\" align=\"center\" width=\"500\">\n    <tr>\n        <th>ID</th>\n        <th>姓名</th>\n    </tr>\n\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"1\">\n            1\n        </td>\n        <td>刘健</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"2\">\n            2\n        </td>\n        <td>赖志丽</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"3\">\n            3\n        </td>\n        <td>荔枝味</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"4\">\n            4\n        </td>\n        <td>赖志丽2</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"5\">\n            5\n        </td>\n        <td>赖志丽3</td>\n    </tr>\n</table>\n\n<script>\n    // 隔行换色\n    // 主要为操纵行（tr）的背景颜色\n    // 隔行，可用偶数奇数来判断\n    //\n    // 设置css样式\n    // elementNode.style.css样式 = 值\n    \n    //获取到所有的tr\n    var trs = document.querySelectorAll('tr');\n    for(var i=0; i<trs.length; i++) {\n        if(i%2 == 1){\n            trs[i].style.backgroundColor = '#ccc';\n        }\n    }\n</script>\n```\n\n效果：\n\n![1532677837446](1532677837446.png)\n\n----\n\n### 7.2、案例---全选，反选，取消\n\n11全选反选取消.html:\n\n```html\n<table border=\"1\" cellpadding=\"2\" cellspacing=\"0\" rules=\"all\" align=\"center\" width=\"500\">\n    <tr>\n        <th>ID</th>\n        <th>姓名</th>\n    </tr>\n\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"1\">\n            1\n        </td>\n        <td>刘健</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"2\">\n            2\n        </td>\n        <td>赖志丽</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"3\">\n            3\n        </td>\n        <td>荔枝味</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"4\">\n            4\n        </td>\n        <td>赖志丽2</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" name=\"id[]\" value=\"5\">\n            5\n        </td>\n        <td>赖志丽3</td>\n    </tr>\n</table>\n\n<p align=\"center\">\n    <input type=\"button\" value=\"全选\" onclick=\"t(1);\" />\n    <input type=\"button\" value=\"反选\" onclick=\"t(2);\" />\n    <input type=\"button\" value=\"取消\" onclick=\"t(3);\" />\n</p>\n```\n\njs代码：\n\n```javascript\n//函数，设置input标签选择或取消\n    function t(x){\n        //首先获取所有的input\n        var inputs = document.querySelectorAll('input[type=\"checkbox\"]'); //数组\n        if(x == 1){\n            //全选\n            for(var i=0; i<inputs.length; i++){\n                inputs[i].checked = true;\n            }\n        }else if(x == 2){\n            for(var i=0; i<inputs.length; i++){\n                inputs[i].checked = !inputs[i].checked;\n            }\n        }else if(x == 3){\n            for(var i=0; i<inputs.length; i++){\n                inputs[i].checked = false;\n            }\n        }\n    }\n```\n\n\n\n### 7.3、案例---仿淘宝评分\n\n09仿淘宝评分.html  代码：\n\n注意：需要复制图片。\n\n```html\n<img src=\"images/rank_3.gif\"/> <!-- 左半星星 -->\n<img src=\"images/rank_4.gif\"/> <!-- 右半星星 -->\n<img src=\"images/rank_3.gif\"/>\n<img src=\"images/rank_4.gif\"/>\n<img src=\"images/rank_3.gif\"/>\n<img src=\"images/rank_4.gif\"/>\n<img src=\"images/rank_3.gif\"/>\n<img src=\"images/rank_4.gif\"/>\n<img src=\"images/rank_3.gif\"/>\n<img src=\"images/rank_4.gif\"/>\n\n<script>\n    //获取所有的img\n    var imgs = document.getElementsByTagName('img');\n    //循环，为每个图片绑定鼠标移入事件\n    for(var i=0; i<imgs.length; i++){\n        imgs[i].index = i; //分别为每个图片对象添加index属性，值就是图片的下标\n        \n        imgs[i].onmouseover = function () {\n            //console.log(this.index);\n            \n            /*\n            通过对资源路径的替换，达到显示不同的图片\n            */\n            \n            //把鼠标移入的图片以及左侧的图片，变为黄色\n            for(var j=0; j<=this.index; j++){\n                imgs[j].src = imgs[j].src.replace('rank_3', 'rank_1'); //左半星星\n                imgs[j].src = imgs[j].src.replace('rank_4', 'rank_2'); //右半星星\n            } \n            \n            //把鼠标移入的图片右侧的图片，变为灰色\n            //this.index+1 ： 因为当前的(this.index)是亮的，所以右边暗的要+1\n            for(var k=this.index+1; k<imgs.length; k++){\n                imgs[k].src = imgs[k].src.replace('rank_1', 'rank_3'); //左半星星\n                imgs[k].src = imgs[k].src.replace('rank_2', 'rank_4'); //右半星星\n            }            \n        };\n        \n    }\n</script>\n```\n\n\n\n----\n\n\n\n# 十、案例--图片淡入淡出\n\n## 10.1、编写html+css\n\n```html\n\t<style>\n        *{\n            margin:0;\n            padding:0;\n            border:0 none;\n        }\n        div{\n            width:600px;\n            height:400px;\n            margin:10px auto;\n            position:relative; /*相对定位*/\n        }\n        img{\n            position: absolute;\n            left:0;\n            top:0;\n            z-index: 1;\n        }\n        /*让第一张图片显示在最上面*/\n        img:first-child {\n            z-index: 999;\n        }\n    </style>\n\n<body>\n\n<div>\n    <img src=\"images/1.jpg\" />\n    <img src=\"images/2.jpg\" />\n    <img src=\"images/3.jpg\" />\n    <img src=\"images/4.jpg\" />\n    <img src=\"images/5.jpg\" />\n    <img src=\"images/6.jpg\" />\n</div>\n\n</body>\n```\n\n## 10.2、实现切换效果，生硬的变化\n\n```javascript\nvar imgs = document.getElementsByTagName('img'); //获取了所有图片\nvar inIndex = 1; //表示即将要显示的图片的下标\nvar outIndex = 0; //表示马上要隐藏的图片的下标\n//先生硬的变化\nsetInterval(function(){\n    if(inIndex >= 6){\n        inIndex = 0;\n    }\n    if(outIndex >= 6){\n        outIndex = 0;\n    }\n    imgs[inIndex].style.zIndex = 999;\n    imgs[outIndex].style.zIndex = 1;\n    //变化完毕，inIndex和outIndex都自增\n    inIndex++;\n    outIndex++;\n}, 2000);\n```\n\n## 10.3、设置改变透明度的函数\n\n```javascript\n//定义函数，设置元素的透明度\nfunction setOpacity(ele, val) {\n    if(ele.filters){\n        ele.style.filter = \"alpha(opacity=\"+val+\")\";\n    }else{\n        ele.style.opacity = val/100;\n    }\n}\n```\n\n## 10.4、完成change函数，让图片慢慢的变化\n\n```javascript\n//定义一个函数，设置元素透明度的慢慢变化效果\n//参数ele，表示要进行慢慢变化的图片\n//参数fn是函数，表示变化完成之后，要执行的函数\nfunction change(ele, fn) {\n    //要求透明度从0~100.所以先设置元素的透明度为0\n    setOpacity(ele, 0);\n    //设想，1秒针，让图片的透明度从0 变化到100\n    //不能一次性变化到100,1秒是1000毫秒\n    // 50毫秒，透明度从0~5\n    //100毫秒，5~10\n    //...\n    //1000毫秒， 95~100\n    for(var i=1; i<=20; i++){\n        (function (x) {\n            setTimeout(function(){\n                //每过50毫秒，透明度变化+5\n                setOpacity(ele, 5*x);\n                if(x==20){\n                    fn&&fn(); //fn存在就执行，不存在就不执行\n                }\n            }, 50*x);\n        })(i);\n    }\n}\n```\n\n函数设置完毕，要配合z-index，一起使用：\n\n![1532942765162](1532942765162.png)\n\n","categories":["Advanced"]},{"title":"JavaScript 高级","url":"%2Fposts%2F3348228145%2F","content":"\n\n# 三、==原型和原型链==（重点）\n\n## 1、原型对象\n\n**原型对象，也是一个对象；原型对象用于保存同一个构造器的多个实例的共有方法**。\n\n默认的创建对象的内存表示：\n\n![1532914035717](1532914035717.png)\n\n如果要解决内存占用过多的问题，则使用原型对象，用==原型对象来保存同一个构造器的多个实例的共有方法==。内存表示如下：\n\n![1532914297540](1532914297540.png)\n\n==原型对象和构造器有关系，原型对象是构造器的原型对象==。\n\n- 通过构造器的prototype属性可以找到构造器的原型对象；\n- 可以通过constructor属性找到原型对象的构造器；\n\n构造器和原型对象的关系:\n\n![1532914487230](1532914487230.png)\n\n```javascript\n//定义构造器（构造函数、类）\nfunction Person(){\n    this.eyes = '大又圆';\n    this.legs = '短又粗';\n}\n//找到Person的原型对象，然后给原型对象添加方法job\nPerson.prototype.job = function(){\n    console.log('卖武大郎烧饼');\n};\n\n//原型对象和构造器的关系\nconsole.log(Person.prototype); //Object\nconsole.log(Person.prototype.constructor); //function Person\n\nvar wuda = new Person();     //Person构造器的一个对象\nvar zhaowei = new Person(); //Person构造器的一个对象\n\nwuda.job();\n```\n\n![1532914926010](1532914926010.png)\n\n\n\n## 2、原型链\n\n```javascript\n//定义Person构造器\nfunction Person() {\n    this.eyes = '大又圆';\n    this.legs = '短又粗';\n    this.age = 4;   //////////////////////////////////////////////////\n}\nvar p = new Person();\n//p.age = 3;   //////////////////////////////////////////////////\n\n//定义Boy构造器\nfunction Boy(){\n    //this.age = 2;  //////////////////////////////////////////////////\n}\n\n//把p对象 赋值 给Boy的原型对象。\n//换句话说，Boy的原型对象是是p对象。这个原型对象是自己指定的，不是系统默认的\nBoy.prototype = p;\n\n//实例化Boy\nvar b = new Boy();\n//b.age = 1;  //////////////////////////////////////////////////\n\nconsole.log(b.age); //输出b对象中的age属性  目前结果是4\n/**\n目前结果是4\n因为在查找一个对象的成员的时候，优先从对象自身查找，如果没有，则从对象的构造函数中查找，如果也没有则从\n构造函数的原型对象上查找，如果构造器的原型对象也没有，则向构造器的原型对象的构造器中去查找......\n*/\n```\n\n\n\n![1532915915126](1532915915126.png)\n\n\n\n​\t在查找一个对象的成员的时候，优先从对象自身查找，如果没有，则从对象的构造函数中查找，如果也没有则从构造函数的原型对象上查找，如果构造器的原型对象也没有，则向构造器的原型对象的构造器中去查找......，这种链式的查找方式就叫做==原型链==。\n\n**原型对象上的成员会被构造器的所有实例所拥有（除了覆盖的情况）**。\n\n## 3、扩展内置对象\n\n我们所学的String、Array等对象实际上JavaScript内置了String、Array等构造器。我们所学习的String中的substr等一系列方法都是String构造器的原型对象上的方法。\n\n比如内置的String对象中没有一个首字母大写的方法，我们可以自己添加一个。我们自己添加一个ucfirst方法，也应该添加到String的原型对象上。\n\n```javascript\n//模拟String中的方法是如何实现的\nString.prototype.substr = function(){\n};\nString.prototype.indexOf = function(){\n    \n};\nString.prototype.replace = function(x, y){\n    \n}\n\n//////////为String对象的原型对象添加一个ucfirst方法\n\t//扩展String对象，为其添加一个ucfirst方法。\n    String.prototype.ucfirst = function(flag){\n        //this 就是要处理的字符串\n        if(flag){\n            //传递进来参数为true，则首字母大写，其他字母小写\n            return this.substr(0,1).toUpperCase() + this.substr(1).toLowerCase();\n        }else{\n            //传递进来参数为false，则首字母大写，其他字母原样返回\n            return this.substr(0,1).toUpperCase() + this.substr(1);\n        }\n    };\n    console.log('heLLo'.ucfirst());  //HeLLo\n    console.log('heLLo'.ucfirst(true)); //Hello\n    /*var s = 'hello';\n    console.log(s.substr(1));*/\n```\n\n\n\n## 4、DOM对象的原型对象\n\nDOM对象是根据document.getElement....得到的对象。\n\n所有的DOM对象的原型对象都是Object对象。\n\n```javascript\n\t//所有DOM对象的原型对象都是Object\n\t//所以在Object的原型对象上，添加css方法，则每个DOM对象都可以使用css方法\n    Object.prototype.css  = function (styleName, styleValue) {\n        this.style[styleName] = styleValue;\n        return this; //this表示调用css的DOM对象，如下面的p对象。 返回this即返回p对象，可以使用链式的调用方式。\n    };\n\n    var p = document.getElementsByTagName('p')[0];\n    var a = document.getElementsByTagName('a')[0];\n    /*p.style.color = 'red';\n    p.style.backgroundColor = 'green';*/\n\n    p.css('color', 'red').css('backgroundColor', '#ccc').css('border', 'solid 1px #ccc');\n    a.css('color', 'green').css('display', 'block');\n```\n\n效果图：\n\n![1532919404666](1532919404666.png)\n\n# 四、定义“类”或对象的多种方式（理解）\n\nw3c手册位置：上面JavaScript --> 左侧的JavaScript --> 到页面最下方点击“马上学习JavaScript高级教程吧” --> 左侧找到定义类或对象。\n\n## 1、构造方法方式\n\n这是最原始的方式。\n\n```javascript\n\t/************************** 构造函数方式 ***************************/\n    //定义构造函数\n    function Person(){\n        this.height = '170cm';\n        this.weight = '170斤';\n        this.fn = function () {\n            console.log(123);\n        }\n    }\n    var p1 = new Person();\n    var p2 = new Person();\n```\n\n上面的方式，得到的多个对象，会为每个对象开辟内存。所以占用的内存较多。\n\n解决方式是使用原型对象。\n\n\n\n## 2、原型对象方式\n\n```javascript\n/************************** 原型对象方式 ***************************/\n    //定义构造函数\n    function Person(){\n\n    }\n    //将对象的成员全部放到原型对象上\n    Person.prototype.height = '170cm';\n    Person.prototype.weight = '170斤';\n    Person.prototype.info = ['马大帅', '30'];\n    Person.prototype.fn = function () {\n        console.log(123);\n    };\n    //实例化两个对象\n    var p1 = new Person();\n    var p2 = new Person();\n\n    //修改p1的info\n    p1.info.push('男');\n\n    console.log(p2.info); //[\"马大帅\", \"30\", \"男\"]\n```\n\n上述方式全部使用原型对象方式定义“类”。\n\n对象的多个实例，如果其中一个修改了数组类型的成员之后，另一个对象也会一起改了。\n\n\n\n## 3、混合方式（构造函数+原型对象）\n\n==原则是把对象的所有**成员属性**都放到构造函数中，把所有的**成员方法**都放到原型对象上==。\n\n```javascript\n/************************** 混合方式（构造函数+ 原型对象） ***************************/\n    function Person(){\n        //成员属性，全部放到构造函数中\n        this.height = '170cm';\n        this.weight = '170斤';\n        this.info = ['马大帅', '30'];\n    }\n    //成员方法，全部放到原型对象上\n    Person.prototype.fn = function () {\n        console.log(123);\n    };\n    var p1 = new Person();\n    var p2 = new Person();\n    //测试，修改p1 的info\n    p1.info.push('男');\n    console.log(p2.info);\n```\n\n==这种方式，既不会占用大量的内存，也能够将两个对象区分的开。所以这种方式推荐使用==。\n\n## 4、动态混合方式\n\n有些人认为上面的混合方式，看起来并不像php中的类，而是希望将成员属性和成员方法全部放到一个大括号中，所以出现了下面的动态混合方式。\n\n```javascript\n/************************** 动态混合方式 ***************************/\n    function Person(){\n        //成员属性，全部放到构造函数中\n        this.height = '170cm';\n        this.weight = '170斤';\n        this.info = ['马大帅', '30'];\n\n        //成员方法，全部放到原型对象上\n        //实例化一次，就会为Person的原型对象添加一个fn，所以加入下面的判断，保证只添加一次fn即可\n        if(!Person.prototype.fn){\n            console.log(111);\n            Person.prototype.fn = function () {\n                console.log(123);\n            };\n        }\n    }\n\n    var p1 = new Person();\n    var p2 = new Person();\n    //测试，修改p1 的info\n    p1.info.push('男');\n    console.log(p2.info);\n    p1.fn();\n```\n\n\n\n## 5、实际开发中，到底使用哪种方式定义类或对象\n\n如果根据构造器只实例化一个对象，那么直接使用构造函数方式。\n\n如果根据一个构造器实例化多个对象，那么使用混合方式或者动态原型方式。\n\n如果只是使用一个对象，这个对象用于配置、参数等，那么直接使用直接量语法（**{name:'anc'}**）最方便。\n\n```javascript\n/********** 下面是函数的参数需要一个对象，则直接使用{}的方式即可 *************/\n    function t(obj){\n        obj.name = '张三疯';\n    }\n    var p = {};\n    t(p);\n    console.log(p.name); //张三疯\n```\n\n\n\n# 五、私有和封装(了解)\n\n在JavaScript中，没有类，那么只能==模拟私有的成员==。\n\n私有成员有什么特点：不可以在构造函数之外调用。JavaScript在函数内部用var定义的变量，就可以叫做私有成员。\n\n```javascript\nfunction Person(){\n    //定义私有成员属性\n    var i = 1;\n    //定义私有成员方法\n    var a = function(){\n\n    };\n    this.fn = function () {\n        console.log(i);\n    }\n}\n\nvar p = new Person();\n//console.log(p.i); //undefined\np.fn();\n```\n\n\n\n# 六、静态属性和方法（了解）\n\nPHP中调用静态成员的方式是  类名::静态成员\n\nJavaScript中，如果有静态成员，该如何调用呢？  答： **构造函数.静态成员**。\n\n```javascript\n\tfunction Person(){\n        //定义静态成员\n        Person.i = 1;\n\n    }\n    //在类的外部也可以定义静态的\n    Person.x = 2;\n    var p = new Person(); //new，为了能够得到里面的i\n\n    console.log(Person.x);\n    console.log(Person.i);\n```\n\n\n\n# 七、继承(理解)\n\n## 1、原型链方式继承\n\n通过指定构造函数的原型对象方式，可以实现继承。\n\n原理图：\n\n![1532932707402](1532932707402.png)\n\n```javascript\n//父构造函数\nfunction Person() {\n    //成员\n    this.sex = '女';\n    this.age = 20;\n    this.fn = function () {\n        console.log(123);\n    };\n}\n\n//子构造函数\nfunction Girl() {\n\n}\n//通过指定Girl的原型对象来实现继承\nGirl.prototype = new Person();\n\nvar g = new Girl();\n\nconsole.log(g.age); // 20\ng.fn(); // 123\n```\n\n\n\n## 2、对象冒充方式继承\n\n### 1、原始的对象冒充\n\n```javascript\n\t//父构造函数\n    function Person() {\n        this.sex = '女';\n        this.age = 20;\n        this.fn = function () {\n            console.log(123);\n        }\n    }\n\n\n    //子构造函数\n    function Girl() {\n        /*this.x = function () {\n            this.sex = '女';\n            this.age = 20;\n            this.fn = function () {\n                console.log(123);\n            }\n        };*/\n\n        this.x = Person; //通过这行代码，把Person中的this变成了当前构造函数中的this了\n        //Girl的对象，代替了Person的对象\n        this.x();\n    }\n\n    var g = new Girl();\n    console.log(g.sex);\n    g.fn();\n```\n\n\n\n### 2、call和apply完成继承（重点）\n\n由于使用对象冒充的开发者比较多，所以在ES3中，js设计者提供了两个方法（call和apply），专门用于对象冒充。\n\n语法：\n\nA.call(); //不给参数，表示使用全局对象window\n\nA.call(b); //b对象冒充A构造函数中的this\n\nA.call(b, 参数1，参数2,…..); // 参数1和2是传递给A函数的\n\napply和call方法用法基本一致，只是传递参数的时候，后面不是一个个的传递，而是以数组的方式传递的。\n\n和使用call方法不同的是，在给父类(A)传递参数的时候，apply传递一个数组。\n\n![1532934286928](1532934286928.png)\n\napply的其他用法：\n\n找出数组中的最大值：\n\n```javascript\n//找出数组中的最大值\nvar arr = [2,5,7,1,0,9,3];\nconsole.log(Math.max.apply('', arr)); //apply的第一个参数传入什么都无所谓，关键第二个参数是arr\n\n\n/*function aa() {\n    this.fn = function () {\n        var arr = [2,5,7,1,0,9,3];\n        console.log(Math.max.apply('', arr));\n    }\n}\nvar a = new aa();\na.fn();*/\n```\n\n\n\n## 3、实际开发中，使用哪种方式实现继承\n\n答案是**两者（原型链和冒充）都用，对于成员属性，使用对象冒充的方式，对于成员方法使用原型链的方式**。\n\n\n\n# 八、遍历对象 for…in\n\n用来遍历数组和对象，和PHP中的foreach比较像。\n\n```javascript\n//语法\nfor(x in array/object){\n\n       x表示数组的下标或对象的成员名\n\n       array[x]表示数组的每个成员\n\n       object[x]表示对象的每个成员\n\n}\n\n```\n\n![1532935336242](1532935336242.png)\n\n用for…in可以遍历数组或对象，也可以用for…in实现继承。\n\n# 九、顶层函数\n\nw3c手册：上面的JavaScript --> 左侧的JavaScript  --> 右侧的参考书  --> 左侧的Functions\n\n顶层函数也就是全局函数，这些函数不属于任何一个对象，在任何位置都可以直接调用。\n\n \n\nencodeURI()         把字符串编码为 URI。这个函数**不会**对“;/?:@&=+$,#”符合进行编码的\n\ndecodeURI()         解码某个编码的 URI。\n\nencodeURIComponent()      把字符串编码为 URI 组件。这个函数**会**对“;/?:@&=+$,#”进行编码\n\ndecodeURIComponent()      解码一个编码的 URI 组件。 \n\n```javascript\nvar url = \"http://www.js.com?id=1&name=张三\";\nconsole.log(url);\nconsole.log(encodeURI(url));\nconsole.log(decodeURI(encodeURI(url)));\nconsole.log(encodeURIComponent(url));\nconsole.log(decodeURIComponent(encodeURIComponent(url)));\n```\n\neval()                     计算 JavaScript 字符串，并把它作为脚本代码来执行。\n\n```javascript\n//eval(\"alert(123);\");\nvar str = \"[{id:1,name:'张三'}, {id:2,name:'张三'}, {id:3,name:'张三'}]\"; //字符串\n//var arr = eval(str);\neval(\"var arr = \" + str);\nconsole.log(arr[0]);\n```\n\nisNaN()                  检查某个值是否是数字。如果是NaN，返回true，否则返回false \n\nparseInt()              解析一个字符串并返回一个整数。\n\nparseFloat()          解析一个字符串并返回一个浮点数。 \n\nNumber()              把对象的值转换为数字。\n\nString()                  把对象的值转换为字符串。\n\n \n\n\n\n","categories":["Advanced"]},{"title":"JavaScript 面向对象编程和系统对象","url":"%2Fposts%2F412987062%2F","content":"\n\n# 六、==JavaScript面向对象（重要）==\n\n## 6.1、什么是对象\n\n我喜欢大眼睛、长头发、大长腿、白皮肤、会洗衣服、会做饭、会生孩子的女孩，比如有孙俪，范冰冰。\n\n这句话中描述的人的特点就是对象的属性，后面的两个人就是符合这个类的实例，也就是对象。\n\n## 6.2、面向对象编程\n\n​\t面向对象编程简称OOP（Object-Oritened Programming）为软件开发人员敞开了一扇大门，它使得代码的编写更加简洁、高效、可读性和维护性增强。它实现了软件工程的三大目标：（代码）重用性、（功能）扩展性和（操作）灵活性，它的实现是依赖于面向对象的三大特性：封装、继承、多态。在实际开发中使用面向对象编程可以实现系统化、模块化和结构化的设计。它是每位软件开发员不可或缺的一项技能。\n\n## 6.3、JavaScript自定义对象\n\n​\t回顾PHP，要得到一个对象，必须先定义一个类，然后通过 `new` 关键字实例化类，才能得到对象。另外，在实例化对象的时候，构造函数会自动执行。\n\n```php\n\nclass Person {\n    public $eyes = '眼睛大';\n    public $legs = '腿长';\n    //\n    public function __construct(){\n        echo $this->eyes;\n    }\n    //\n    public function cook(){\n        echo '会做饭';\n    }\n}\n//实例化对象\n$sunli = new Person();\n$bingbing = new Person();\n```\n\n​\t在JavaScript中，准确的说是在==E==CMA==S==cript5中，没有明确类的概念，只有函数，所以要想得到一个自定义的对象，只能使用关键字 `new` 实例化一个函数。\n\n> 在ES6中，才有类的概念。\n\n==如果一个函数被实例化了，那么这个函数就叫做构造函数==，在学习的时候，==我们可以把构造函数当做类==。\n\n10自定义对象.html  代码：\n\n```javascript\n//定义一个函数,下面实例化了这个函数，所以这个函数就叫做构造函数，也可以认为是类\nfunction Person(){\n\n}\n\n//实例化这个函数，得到对象\nvar sunli = new Person();\nvar bingbing = new Person();\nconsole.log(typeof sunli, typeof bingbing);\n```\n\n在PHP中，构造函数，在实例化对象之后，会自动执行，JavaScript中的构造函数也有相同的特点：\n\n```javascript\n\t//定义一个函数,下面实例化了这个函数，所以这个函数就叫做构造函数，也可以认为是类\n    function Person(){\n        console.log('123');\n    }\n\n    //实例化这个函数，得到对象\n    var sunli = new Person();  // 123\n    var bingbing = new Person();  // 123\n```\n\n\n\n## 6.4、this关键字和对象成员\n\n在JavaScript面向对象中，this也是一个伪对象，只能出现在构造函数内部。表示该构造函数的任意对象。\n\n> this很好理解，它和PHP中的 $this一个意思。\n\n定义一个构造函数，并添加一些成员属性和成员方法：\n\n```javascript\n\n    //定义构造函数\n    function Person(){\n        //public $eyes = 'asdf';\n        //定义成员属性\n        this.eyes = '大';\n        this.legs = '短';\n        this.hair;\n\n        //定义成员方法\n        this.cook = function(){\n            console.log(this.eyes);\n        };\n        this.wash = function(){\n            this.cook();//调用当前对象的成员方法\n        };\n    }\n    var sunli = new Person();\n    sunli.wash(); //调用成员方法\n\t//在实例化得到对象之后，也可以为对象添加成员\n    sunli.hair = '短发';\n    console.log(sunli.hair);\n\t//为sunli 添加成员方法\n    sunli.sing = function(){\n        console.log('sing a song');\n    };\n    sunli.sing();\n\n```\n\n\n\n## 6.5、delete关键字删除对象成员\n\n前面学习过，在JavaScript中，delete可以删除没有var声明的变量。\n\ndelete关键字还可以删除对象中的成员，既可以删除成员属性，也可以删除成员方法\n\n12delete删除对象成员.html  \n\n```javascript\n/*var a = 1;\nb = 2;\ndelete a;\ndelete b;\nconsole.log(a, b);*/\n\nfunction Dog(){\n    this.eyes = '大';\n    this.name = '大黄';\n    this.jiao = function(){\n        console.log('汪汪汪');\n    }\n}\n\n//实例化一个小狗\nvar dog1 = new Dog();\n//delete dog1.eyes;  //删除对象的成员属性\nconsole.log(dog1.eyes);\n//delete dog1.jiao;  //删除对象的成员方法，方法不能带小括号。\ndog1.jiao();\n```\n\n\n\n## 6.6、对象在内存中的存在形式\n\n```javascript\n\tfunction Person(){\n        this.eyes = '长';\n        this.cook = function () {\n            console.log('做得一手好饭');\n        }\n    }\n\n    var sunli = new Person();\n\n    var bingbing = sunli; //将sunli赋值给bingbing，赋的是对象sunli指向堆区的地址\n    bingbing.eyes = '大'; //修改bingbing的eyes属性\n    console.log(sunli.eyes); //大\n```\n\n对应的内存图：\n\n![1532766667149](1532766667149.png)\n\n```javascript\nfunction Person(){\n    this.eyes = '长';\n    this.cook = function () {\n        console.log('做得一手好饭');\n    }\n}\n\nvar sunli = new Person();\n\nvar bingbing = sunli; //将sunli赋值给bingbing，赋的是对象sunli指向堆区的地址\n/*bingbing.eyes = '大'; //修改bingbing的eyes属性\nconsole.log(sunli.eyes); //大*/\n//bingbing = null;\n//console.log(sunli);\n\nfunction change(o){\n    o.eyes = '大又圆';\n}\n\nchange(bingbing);\n\nconsole.log(bingbing.eyes, sunli.eyes); //大又圆 大又圆\n```\n\n\n\n## 6.7、直接量语法定义对象\n\n直接量语法定义对象，也就是不用定义构造函数，而是直接定义一个变量，然后用一对大括号 `{}` 表示对象，这种形式的对象，里面也可以有成员属性和成员方法。\n\n这部分知识前面已经学习过了。下面试着定义几个对象：\n\n```javascript\nvar a = {}; //空对象\nvar b = {name:'赵伟', age:21}; //对象中可以有成员属性\nvar c = {\n    name:'宋江',\n    age:35,\n    nickname:'及时雨',\n    chaodai:'宋'\n};\nvar d = {\n    name:'宋江',\n    age:35,\n    nickname:'及时雨',\n    chaodai:'宋',\n    fn1:function () {\n        console.log(this.name);\n    },\n    fn2:function () {\n\n    }\n};\n\n//d.成员;\nd.fn1(); //宋江\n```\n\n\n\n# 七、==系统对象==（会查手册）\n\n内置对象，即JavaScript预定义的一些对象，这些对象中定义好了一些常用的方法。我们直接实例化（有些不需要实例化）这些对象，然后就可以使用这些方法了。\n\n这部分涉及到的方法非常多，要求会查手册。手册位置：w3c手册---点导航的JavaScript—点左侧的JavaScript—点右侧的参考书。 \n\n## 7.1、Object对象\n\n​\t目前，可以认为Object是一个空对象。\n\n​\tObject对象也是一个构造器（构造函数），这个对象是其他所有对象的父对象，也就是说其他所有的对象都继承Object对象。==其他所有对象，包括DOM对象==。\n\n## 7.2、String对象\n\n字符串对象，对象内置了很多实用的属性和方法。\n\n使用方法：\n\n1. 实例化String，并将要操作的字符串传递进去，然后通过对象调用成员。\n2. 把字符串当做对象，直接使用字符串调用成员。\n\n```javascript\n/****************** 下面演示使用String对象的两种方式 *******************/\n\n//方式一：实例化String、传入要操作的字符串。然后使用对象去调用String对象的成员\nvar s = new String('hello');\nconsole.log(s.length); // 5\n\n//方式二：直接把字符串当做对象，然后调用String对象中的属性或方法\nconsole.log('hello'.length); // 5\n```\n\n下面演示一些常用的字符串方法：\n\n```javascript\n/********************************* indexOf() ************************/\n/*\n检测字符串中是否含有指定字符，存在返回首次出现位置，不存在返回-1\n*/\nconsole.log('hello'.indexOf('e')); // 1\nconsole.log('hello'.indexOf('h')); // 0\nconsole.log('hello'.indexOf('a')); //-1\n\n\n/********************************* substr() ************************/\n/*\n截取字符串。\n两个参数，参数1表示起始位置,可以是负数；参数2可选，表示长度，非负，不填表示截取到结尾\n*/\nconsole.log('hello'.substr(1));// ello\nconsole.log('hello'.substr(1,2));// el\nconsole.log('hello'.substr(-3,2));// ll\n\n/********************************* substring() ************************/\n/*\n截取字符串。\n两个参数，都是非负数。分别表示起始位置和结束位置，参数2不写表示到结尾\n*/\nconsole.log('hello'.substring(1,2));//e\n\n/********************************* slice() ************************/\n/*\n截取字符串。\n两个参数，参数1表示起始位置，可以是负数。参数2表示结尾位置。注意结尾位置不能在起始位置之前。\n*/\nconsole.log('hello'.slice(1,2)); //e\nconsole.log('hello'.slice(-3,2)); //ll\n\n\n/********************************* split() ************************/\n/*\n将字符串分割成数组。\n两个参数，参数1表示分隔符，参数2可选，表示数组的最大长度\n*/\nconsole.log('hello'.split('l')); //Array [ \"he\", \"\", \"o\" ]\nconsole.log('hello'.split('l', 2)); //Array [ \"he\", \"\" ]\n\n/********************************* replace() ************************/\n/*\n替换字符串中的值。\n两个参数，参数1表示查找的值，参数2表示替换后的值。支持正则\n*/\nconsole.log('hello'.replace('l', 'k')); //heklo  只替换一次\nconsole.log('hello'.replace(/l/g, 'k')); //hekko 使用正则全部替换，有关正则，后天学习\n\n/********************************* trim()IE9支持 ************************/\n/*\n去掉字符串两边的空白。\n*/\nconsole.log('  world  '.trim()); //world\n```\n\n通过浏览器可以查到系统对象中有哪些成员，方法是在浏览器的console区，输出String.prototype.\n\n![1532769108592](1532769108592.png)\n\n## 7.3、Date对象\n\n使用方法，先new Date()，得到一个对象，然后用这个对象调用它里面的成员方法。 \n\n```javascript\nvar date = new Date(); //实例化Date对象\nconsole.log(date.getFullYear()); //调用getFullYear()方法，获取\"年\"\n```\n\n下面演示通过Date对象，获取当前的时间，格式为：“年-月-日 时:分:秒”\n\n```javascript\n//自定义函数，判断如果数字小于10，则在其前面加0。如把 9 变成 09\nfunction check(x){\n\tif(x<10){\n\t\treturn '0'+x;\n\t}\n\treturn x;\n}\n//实例化对象\nvar d = new Date();\n//console.log(d); //Date 2018-04-14T07:13:15.554Z\nvar year = check(d.getFullYear());\nvar month = check(d.getMonth() + 1);\nvar day = check(d.getDate());\nvar hour = check(d.getHours());\nvar minute = check(d.getMinutes());\nvar second = check(d.getSeconds());\n\nvar t = year+'-'+month+'-'+day+' '+hour+':'+minute+':'+second;\nconsole.log(t);\n```\n\n## 7.4、Array对象\n\n数组就是对象，所以可以直接使用数组调用Array对象的成员属性和方法。\n\n下面演示常用的Array对象的成员属性和方法：\n\n```javascript\n//定义用于测试的数组\nvar arr1 = ['a', 'b', 'c', 'd'];\n\n//length属性，表示数组中单元个数，即数组的长度\nconsole.log(arr1.length); // 4\n\n//concat()方法，连接一个或多个数组\nconsole.log(arr1.concat(arr2)); //Array [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\" ]\n\n//join()方法，将数组单元连接成字符串，默认的分隔符是逗号，也可以自己指定分隔符\nconsole.log(arr1.join()); //a,b,c,d\nconsole.log(arr1.join(''));//abcd\n\n//pop()方法，删除并返回数组的最后一个元素\nconsole.log(arr1.pop()); //d\nconsole.log(arr1);//Array [ \"a\", \"b\", \"c\" ]\n\n//定义用于测试的数组\nvar arr2 = ['e', 'f', 'g'];\n\n//push()方法，向数组的末尾添加一个或更多元素，并返回新的长度。\nconsole.log(arr2.push('hhh')); // 4\nconsole.log(arr2); //Array [ \"e\", \"f\", \"g\", \"hhh\" ]\n\n//reverse()方法，颠倒数组中元素的顺序。\nconsole.log(arr2.reverse()); //Array [ \"hhh\", \"g\", \"f\", \"e\" ]\n```\n\n## 7.5、Math对象\n\n用法：无需实例化对象，直接使用“ `Math.成员`”即可，比如 `Math.random();`  \n\n下面列举一些Math对象属性和方法：\n\n```javascript\n//属性：\n//PI : 表示圆周率，用法Math.PI\nconsole.log(Math.PI); //3.141592653589793\n\n//方法：\n//abs(x)   返回数的绝对值。 正数的绝对值是它本身，负数的绝对值是它的相反数。\nconsole.log(Math.abs(-3)); // 3\nconsole.log(Math.abs(3)); // 3\n\n//ceil(x)   对数进行上舍入。\nconsole.log(Math.ceil(3.1)); // 3\n\n//floor(x)  对数进行下舍入。\nconsole.log(Math.floor(3.8)); // 3\n\n//round(x)  把数四舍五入为最接近的整数。\nconsole.log(Math.round(2.5)); // 3\n\n//max(x,y) 返回 x 和 y 中的最高值。\nconsole.log(Math.max(3,1)); // 3\n\n//min(x,y) 返回 x 和 y 中的最低值。 \nconsole.log(Math.min(3,5)); // 3\n\n//random() 返回 0 ~ 1 之间的随机数。包含0，不包含1。[0,1) \nconsole.log(Math.random());\n\n//随机整数公式：Math.floor(i + Math.random() * (j – i + 1))\n//公式中的i表示小的数，j表示大的数\n//获取1~10之间的随机数\nvar suiji = Math.floor(1 + Math.random() * (10-1+1));\nconsole.log(suiji);\n```\n\n## 7.6、window对象\n\nwindow对象和下面要讲到的 Navigator、Screen 、History 、Location都属于浏览器对象，即BOM对象。\n\njavascript:ECMAScript  DOM  BOM\n\n==window对象的成员在被调用时，可以省略window==。\n\n下面列举window对象中常用方法：\n\n```javascript\nalert(); -- 弹出一个警告框\nconfirm('你确定要删除吗');  点击确定返回true，点击取消返回false\nprompt() – 弹出一个可输入的对话框，点击确定返回输入的内容，点击取消返回null\n```\n\n open方法用于打开一个新浏览器窗口，经常用于弹窗。下面演示open方法的使用：\n\n```html\n<input type=\"button\" value=\"手机预览\" id=\"btn\" />\n<script>\n    document.getElementById('btn').onclick = function () {\n\t\t//window.open('新窗口url','新窗口名字','新窗口属性');\n\t\twindow.open('http://www.blog.com', '手机版博客', 'width=600,height=500');\n\t}\n</script>\n```\n\nwindow对象中定时器方法也是非常有用且常见的方法：\n\n基本用法如下：\n\n```javascript\nvar s =setTimeout(\"js代码或js函数\", 毫秒数) //表示多少毫秒后，执行前面的js代码或函数，只执行一次\nvar t =setInterval(\"js代码或js函数\", 毫秒数) //表示每隔多少毫秒，执行一次前面的js代码或函数。\nclearTimeout(s); //清除由setTimeout产生的定时器\nclearInterval(t); //清除由setInterval产生的定时器\n```\n\n\n\n## 7.7、navigator对象\n\n navigator对象包含有关浏览器的信息。\n\n没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象。\n\n经检测，navigator对象中有用的属性只有一个，它是 `navigator.userAgent`，从这个结果中可以查看到浏览器及浏览器的版本。 \n\n```javascript\nconsole.log(navigator.userAgent); //不同浏览器结果不同\n```\n\n## 7.8、screen对象\n\n屏幕对象，通过该对象可以获取到电脑显示器的高度和宽度。\n\n```javascript\ndocument.write(screen.width + \"*\" + screen.height); //输出分辨率，宽度*高度\ndocument.write(screen.availWidth + \"*\" + screen.availHeight); //不包含任务栏的高度和宽度\n```\n\n## 7.9、history对象\n\nhistory 对象包含用户（在浏览器窗口中）访问过的 URL。\n\n```javascript\nhistory.back(); //加载 history 列表中的前一个 URL。 相当于后退 \nhistory.forward(); //加载 history 列表中的下一个 URL。 相当于前进\nhistory.go(); //加载 history 列表中的某个具体页面。 通过参数指定跳转到哪个页面\n```\n\n## 7.10、location对象\n\nlocation 对象包含有关当前 URL 的信息。\n\n下面是location对象的一些属性：\n\n```javascript\ndocument.write(location.hash + '<br>'); // 设置或返回从井号 (#) 开始的 URL（锚）。\ndocument.write(location.host + '<br>'); // 设置或返回主机名和当前 URL 的端口号。\ndocument.write(location.hostname + '<br>'); // 设置或返回当前 URL 的主机名。\ndocument.write(location.href + '<br>'); // 设置或返回完整的 URL。\ndocument.write(location.pathname + '<br>'); // 设置或返回当前 URL 的路径部分。\ndocument.write(location.port + '<br>'); // 设置或返回当前 URL 的端口号。\ndocument.write(location.protocol + '<br>'); // 设置或返回当前 URL 的协议。\ndocument.write(location.search + '<br>'); //设置或返回从问号 (?) 开始的 URL（查询部分）。\n```\n\nlocation对象中比较有用的方法是 `reload()`.它可以刷新当前的页面：\n\n```javascript\nlocation.reload(); //刷新页面，和点击刷新按钮一个效果\nlocation.reload(true); //清除缓冲刷新，和按住Ctrl点击刷新按钮一样\n```\n\n```html\n<input type=\"button\" value=\"刷新\" id=\"sx\">\n\n<script>\n    document.getElementById('sx').onclick = function () {\n        location.reload(); //和按F5、或点击浏览器的刷新按钮一样\n        location.reload(true); //强制刷新。和Ctrl+F5一样。表示清除缓存刷新\n    }\n</script>\n```\n\n\n\n\n\n","categories":["Advanced"]},{"title":"JavaScript DOM对象和事件","url":"%2Fposts%2F1771752198%2F","content":"\n\n# 三、==DOM==（重点）\n\n## 3.1、DOM介绍\n\n### 3.1.1、什么是DOM\n\n​\tDOM全称是Document Object Model（文档对象模型），它是JS将HTML按文档结构和内容层次抽象出的模型，==使得JavaScript有了访问HTML的能力，能够实现对HTML中内容的操作==。DOM存在广泛，PHP以及其他语言也有各自的DOM模型。\n\n\n\n### 3.1.2、节点与DOM模型\n\n​\tDOM模型呈现树状结构，因此也叫“树模型”，==树中的内容（标签、属性、文本）称为“节点”==，==节点在dom中就是对象==。包含有元素节点（标签）、属性节点、文本节点。dom模型中，每个节点，都是一个JavaScript对象。\n\n​\t根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：\n\n- 整个文档是一个文档节点，用document对象表示\n- 每个 HTML 元素是元素节点，比如html、head、body、a、h1\n- HTML 元素内的文本是文本节点 \n- 每个 HTML 属性是属性节点，比如href \n- 注释是注释节点\n\n![1532655701967](1532655701967.png)\n\n### 3.1.3、节点之间的关系\n\n节点之间的关系犹如人类家族中的族谱。节点之间的关系包括：\n\n- 父子关系\n- 兄弟（姐妹）关系\n\n![1532655986360](1532655986360.png)\n\n单词：\n\n- `first`：第一个\n- `last`：最后一个\n- `Child`：孩子（单数）\n- `Children`：孩子（复数，很多孩子）\n- `parent`：父亲\n- `Node`：节点\n- `next`：下一个\n- `previous`：上一个\n- `Sibling`：兄弟姐妹\n\n \n\n## 3.2、元素节点==查询==操作\n\n### 3.2.1、基于文档查询\n\n文档是document，基于文档查询即调用document对象中的方法查询页面中的节点。\n\n需要掌握的单词：\n\n- `get`：获取\n- `Element`：一个元素\n- `Elements`：多个元素\n- `By`：根据….\n- `Tag`：标签\n\n下表所列方法都是document对象中的方法，调用方式为 `document.getEle.....`\n\n| 方法名                            | 返回值            | 支持       |\n| --------------------------------- | ----------------- | ---------- |\n| ==getElementById(元素id)==        | 一个dom对象       | 所有浏览器 |\n| ==getElementsByTagName(标签名)==  | 包含dom对象的数组 | 所有浏览器 |\n| getElementsByClassName(类名)      | 包含dom对象的数组 | IE8+       |\n| getElementsByName(元素的name属性) | 包含dom对象的数组 | 所有浏览器 |\n| ==querySelector(css选择器)==      | 一个dom对象       | IE7+       |\n| ==querySelectorAll(css选择器)==   | 包含dom对象的数组 | IE7+       |\n\n01元素节点查询.html 代码如下：\n\n```html\n<body>\n\n<ul>\n    <li>赖志丽</li>\n    <li id=\"zw\">赵伟</li>\n    <li class=\"r\">陈贤栋</li>\n    <li class=\"r\">谢伟杰</li>\n</ul>\n<input type=\"text\" name=\"username\" />\n<p class=\"r\">以上是四个美女</p>\n\n<!--script标签 一定 要写到p下面-->\n<script>\n    //根据id获取元素\n    var zw = document.getElementById('zw');\n    //console.log(zw);\n    zw.style.color = 'green';\n\n    //根据标签名获取元素\n    var lis = document.getElementsByTagName('li'); //获取了所有的li，是一个数组\n    lis[0].style.color = 'yellow';\n\n    //根据class来获取元素\n    var rs = document.getElementsByClassName('r'); //获取的是类名为r的元素，是一个数组\n    rs[1].style.color = 'red';\n\n    //根据标签的name属性来获取元素\n    var inputs = document.getElementsByName('username'); //获取的是一个数组\n    inputs[0].style.backgroundColor = '#ccc';\n\n    //根据css选择器获取元素\n    var ul = document.querySelector('ul'); //获取的是 一个 元素，是对象\n    ul.style.backgroundColor = 'pink';\n\n    var lis_r = document.querySelectorAll('ul li.r'); //选择ul中类为r的li元素，是一个数组\n    for(var i=0; i<lis_r.length; i++) {\n        lis_r[i].style.fontSize = '30px';\n    }\n</script>\n\n</body>\n```\n\n效果：\n\n![1532658777029](1532658777029.png)\n\n\n\n### 3.2.2、相互关系查询\n\n相互关系查询可以分为下面三种情况：\n\n- 根据父节点查找子节点\n- 根据子节点查父节点\n- 查询兄弟节点\n\n具体属性/方法见下表：\n\n| 方法/属性                     | 说明                                    | 返回      | 支持       |\n| ----------------------------- | --------------------------------------- | --------- | ---------- |\n| 父节点.children               | 查询所有子节点，非w3c标准(不包含空白)   | 数组      | 所有浏览器 |\n| 父节点.**childNodes**         | 查询所有子节点，包括文本节点(包含空白)  | 数组      | 所有浏览器 |\n| 父节点.firstChild             | 查询第一个子节点，包括文本节点          | 对象      | 所有浏览器 |\n| 父节点.firstElementChild      | 查询第一个子节点，不包括文本节点        | 对象      | IE8+       |\n| 父节点.lastChild              | 查询最后一个子节点，包括文本节点        | 对象      | 所有浏览器 |\n| 父节点.lastElementChild       | 查询最后一个子节点，不包括文本节点      | 对象      | IE8+       |\n| 父节点.**getElementBy**....() | 节点继续调用getEle...系列方法查询子节点 | 数组/对象 | 所有浏览器 |\n| 子节点.parentNode             | 查询父节点                              | 对象      | 所有浏览器 |\n| 兄弟.previousSibling          | 查询上一个兄弟，包括文本节点            | 对象      | 所有浏览器 |\n| 兄弟.previousElementSibling   | 查询上一个兄弟，不包括文本节点          | 对象      | IE8+       |\n| 兄弟.nextSibling              | 查询下一个兄弟，包括文本节点            | 对象      | 所有浏览器 |\n| 兄弟.nextElementSibling       | 查询下一个兄弟，不包括文本节点          | 对象      | IE8+       |\n\n创建02相互关系查询.html ,代码如下：\n\n```html\n<body>\n\n<ul>\n    <li>赖志丽</li>\n    <li id=\"zw\">赵伟</li>\n    <li class=\"r\">陈贤栋</li>\n    <li class=\"r\">谢伟杰</li>\n</ul>\n\n<ul>\n    <li>赖志丽</li>\n    <li id=\"zw1\">赵伟</li>\n    <li class=\"r\">陈贤栋</li>\n    <li class=\"r\">谢伟杰</li>\n</ul>\n\n<script>\n    /******************* 根据父节点查询子节点 *********************/\n    var ul = document.getElementsByTagName('ul')[0]; //父节点\n\n    //children\n    var lis1 = ul.children;\n    for (var i=0; i<lis1.length; i++) {\n        lis1[i].style.color = 'green';\n    }\n\n    //childNodes  --  查找子元素，包含空白\n    var lis2 = ul.childNodes;\n    console.log(lis2.length);\n    console.log(lis2[0].nodeType);\n\n    //自定义函数，获取父元素里面的所有元素类型的节点\n    function myChildren(parentNode){\n        var children = parentNode.childNodes; //获取了父节点的所有子节点（包括文本节点和元素节点）\n        var result = []; //用于保存元素类型的子节点\n        for (var i=0; i<children.length; i++) {\n            //nodeType == 1, 表示元素节点\n            if(children[i].nodeType == 1) {\n                result.push(children[i]); //push方法，表示向result数组中添加单元\n            }\n        }\n        return result;\n    }\n    var lis3 = myChildren(ul); //传入父节点，然后拿到所有元素类型的子节点\n    for (var i=0; i<lis3.length; i++) {\n        lis3[i].style.backgroundColor = '#ccc';\n    }\n\n    //获取第一个子节点\n    var first1 = ul.firstChild; //获取的是一个空白\n    console.log(first1);\n    var first2 = ul.firstElementChild; //获取的是第一个li\n    first2.style.fontSize = '30px';\n\n    //父节点继续调用getEle...系列方法，查找子元素\n    var lis4 = ul.getElementsByTagName('li');\n    for (var i=0; i<lis4.length; i++) {\n        lis4[i].style.fontFamily = '隶书';\n    }\n\n    var zw = document.querySelector('#zw');\n    zw.parentNode.style.border = 'solid 2px red';\n    \n    //这里两个previousSibling，因为它会包含空白\n    zw.previousSibling.previousSibling.style.border = \"solid 1px blue\"; \n    zw.previousElementSibling.style.padding = '10px';\n</script>\n\n</body>\n```\n\n![1532661744469](1532661744469.png)\n\n\n\n### 3.2.3、遗留DOM\n\n早期DOM访问形式，在一些特定元素的获取上比较方便。被保留下来使用，W3C标准化之后 称为“0级DOM”。\n\n==document.body==                                          访问body节点             返回body节点  \n\n**document.forms**                                        访问所有的表单           返回数组\n\n==document.formName[index].name==       访问表单项                   返回单个表单项或数组\n\ndocument.anchors                                    访问所有的锚点           返回数组\n\ndocument.links                                          访问所有的链接           返回数组\n\ndocument.images                                     访问所有的图片           返回数组\n\ndocument.all                                              访问所有的元素           返回数组\n\n \n\n03遗留DOM.html ，代码：\n\n```html\n<body>\n\n<form name=\"myform1\">\n    <input type=\"text\" name=\"username\" />\n    <input type=\"text\" name=\"email\">\n</form>\n\n<form name=\"myform2\">\n    <input type=\"text\" name=\"username\" />\n    <input type=\"text\" name=\"email\">\n</form>\n\n\n<script>\n    var body = document.body;\n    body.style.backgroundColor = '#ccc';\n\n    //快速获取form\n    var myform1 = document.myform1;\n    myform1.style.border = 'solid 1px red';\n\n    var forms = document.forms[0]; //找第一个form的方式\n    //快速找form中的表单项\n    var user1 = document.myform1.username;\n    user1.style.backgroundColor = 'yellow';\n</script>\n\n</body>\n```\n\n效果：\n\n![1532662266308](1532662266308.png)\n\n## 3.3、元素节点==增删改==操作\n\n### 3.3.1、增加元素节点/创建节点\n\n方法一：**父节点.appendChild(子节点)**\n\n04添加新节点.html  代码：\n\n```html\n<body>\n<ul>\n    <li>西施</li>\n    <li>王昭君</li>\n    <li>貂蝉</li>\n    <li>杨玉环</li>\n</ul>\n\n<script>\n    //向ul中，添加一个li，内容是 赖志丽\n\n    //1、 先找到父节点，然后向里面添加子元素\n    var ul = document.querySelector('ul');\n    //2、创建li\n    var li = document.createElement('li');\n    //3、创建文本节点\n    var text = document.createTextNode('赖志丽');\n    //4、把文本节点放到li里面，相当于父节点添加子节点\n    li.appendChild(text);\n    //5、把组合好的li，放到ul里面\n    ul.appendChild(li);\n\n</script>\n\n</body>\n```\n\n预览效果：\n\n![1532662920275](1532662920275.png)\n\n方法二：**父节点.insertBefore(新节点, 参照的节点);**\n\n04添加节点.html 代码\n\n```html\n<ul>\n    <li>西施</li>\n    <li>王昭君</li>\n    <li>貂蝉</li>\n    <li>杨玉环</li>\n</ul>\n<script>\n    /*********** 把新的节点放到 貂蝉前面 ***********/\n    var ul1 = document.getElementsByTagName('ul')[0];\n    var li1 = document.createElement('li');\n    var text1 = document.createTextNode('荔枝味');\n    li1.appendChild(text1);\n    //必须找参照的节点貂蝉\n    var diaochan = ul1.children[2];\n    //添加\n    ul1.insertBefore(li1, diaochan);\n\n</script>\n```\n\n效果：\n\n![1532663358565](1532663358565.png)\n\n### 3.3.2、克隆节点\n\n05克隆节点.html:\n\n![1532663646082](1532663646082.png)\n\n### 3.3.3、修改节点\n\n方法：**父节点.replaceChild(新节点, 待替换的节点);**\n\n06替换节点.html  代码：\n\n```html\n<body>\n\n<ul>\n    <li>张飞</li>\n    <li>关羽</li>\n    <li>赵云</li>\n    <li>刘备</li>\n    <li>马超</li>\n</ul>\n\n<script>\n    //把刘备替换成黄忠  父节点.replaceChild(新节点, 待替换的节点)\n    var ul = document.querySelector('ul');\n    var hz = document.createElement('li'); //新节点\n    var text = document.createTextNode('黄忠');\n    hz.appendChild(text); //将新节点li和文本组合到一起\n\n    var lb = document.querySelectorAll('li')[3]; //原来的节点\n    //替换\n    ul.replaceChild(hz, lb);\n</script>\n\n</body>\n```\n\n效果：\n\n![1532673739392](1532673739392.png)\n\n### 3.3.4、删除节点\n\n方法：**父节点.removeChild(子节点);**\n\n07删除节点.html   代码：\n\n```html\n<body>\n\n<ul>\n    <li>张飞</li>\n    <li>关羽</li>\n    <li>赵云</li>\n    <li>刘备</li>\n    <li>马超</li>\n</ul>\n\n<script>\n    //把刘备删除， 父节点.removeChild(要删除的子节点);\n    var ul = document.getElementsByTagName('ul')[0];\n    var lb = document.getElementsByTagName('li')[3];\n    //删除\n    ul.removeChild(lb);\n\n</script>\n\n</body>\n```\n\n效果：（刘备被删除了）\n\n![1532673908943](1532673908943.png)\n\n\n\n## 3.4、属性节点操作\n\n==属性肯定属于元素，所以对属性的任何操作都要先找到元素节点==。\n\n### 3.4.1、获取元素的属性\n\n**元素节点.attributes**                                获取元素的所有属性\n\n**元素节点.getAttribute(属性名)**              获取指定属性的值\n\n**元素节点.属性名**                                      获取指定属性的值，用于获取元素不存在的属性的值比较准确\n\n\n\n08获取元素的属性.html  代码：\n\n![1532674726236](1532674726236.png)\n\n\n\n### 3.4.2、添加/修改元素的属性\n\n**元素节点.setAttribute(属性名，属性值)**           设置（==修改/添加==）一个属性值\n\n**元素节点.属性名 = 值**                                          设置元素的属性\n\n09添加、修改属性.html  代码：\n\n```html\n<body>\n\n<input type=\"text\" name=\"username\">\n\n<script>\n    var input = document.querySelector('input');\n    //添加value和size属性\n    input.setAttribute('value', '赵伟');\n    input.size = 5;\n\n    //修改属性\n    input.name = 'email';\n    input.setAttribute('type', 'password');\n</script>\n\n</body>\n```\n\n效果图：\n\n![1532675176223](1532675176223.png)\n\n### 3.4.3、删除元素的属性\n\n**元素节点.removeAttribute(属性名)**    删除一个属性\n\n![1532675475636](1532675475636.png)\n\n### 3.4.4、判断元素是否有哪个属性\n\n**elementNode.hasAttribute(属性名)**           检测是否有某个属性，有返回true，没有返回false\n\n见上图。\n\n\n\n\n\n\n## 3.5、操作css样式\n\n### 3.5.1、设置css样式\n\n语法： **elementNode.style.css样式 = 值**\n\n**css样式的写法：**\n\n①、一个单词的直接写即可。比如color height …\n\n②、样式名称带中横线的，去掉中横线，后面单词首字母大写。比如fontSize  lineHeight  backgroundColor\n\n\n\n### 3.5.3、获取节点全部css样式\n\n使用 \"**node.style.样式名称**\" 的方式只能获取==行内样式和js已经设置过的样式==。\n\n**要想获取全部的样式，则必须使用下面的方法：**\n\n- 在IE中支持 **node.currentStyle.样式名称**\n\n- 火狐支持 **getComputedStyle(node).样式**\n\n13获取css样式.html\n\n```html\n<body>\n\n<p>hello</p>\n\n<ul>\n    <li style=\"color:red;\">hello</li>\n</ul>\n\n<script>\n    //获取li的字体颜色\n    var li = document.getElementsByTagName('li')[0];\n    console.log(li.style.color);\n    //获取p的字体大小\n    var p = document.getElementsByTagName('p')[0];\n    //console.log(getComputedStyle(p).fontSize); //火狐、谷歌、IE8+\n    //console.log(p.currentStyle.fontSize); //IE8及更低版本浏览器\n\n    //设置一个兼容各个浏览器的获取css样式的方法\n    function getStyle(node, styleName){\n        if(node.currentStyle){ \n            //IE8及更低版本浏览器\n            return node.currentStyle[styleName];\n        }else{\n            //火狐、谷歌、IE8+\n            return getComputedStyle(node)[styleName];\n        }\n    }\n    console.log(getStyle(p, 'fontSize'));\n\n</script>\n\n</body>\n```\n\n\n\n## 3.6、DOM属性（了解）\n\nDOM属性指的是DOM对象的属性。\n\n**innerHTML**\n\n​       ==获取/设置元素里的html内容==\n\n**innerText**\n\n​    ==获取/设置元素里面的文本内容==\n\n获取节点里面的内容：\n\n![1532678907897](1532678907897.png)\n\n设置节点里面的内容：\n\n![1532679083481](1532679083481.png)\n\n==无论调用innerHTML还是innerText，给元素设置内容的时候，都会覆盖原来的内容==。\n\n**nodeName**\n\n​       nodeName 是只读的 \n\n​\t元素节点的 nodeName 与标签名相同 \n\n​\t属性节点的 nodeName 与属性名相同 \n\n​\t文本节点的 nodeName 始终是 #text \n\n​\t文档节点的 nodeName 始终是 #document\n\n**nodeValue**\n\n​       元素节点的 nodeValue 是 undefined 或 null \n\n​       ==文本节点的 nodeValue 是文本本身==\n\n​\t属性节点的 nodeValue 是属性值\n\n**nodeType**：调用nodeType属性会得到一个数字，这个数字表示节点的类型\n\n​        ==元素 1== \n\n​\t属性 2\n\n​        ==文本 3==\n\n​\t注释 8 \n\n​\t文档 9\n\n\n\n## 3.7、DOM获取元素位置（了解）\n\n**offsetLeft**                                    元素在网页中水平坐标值 \n\n**offsetTop**                                    元素在网页中垂直坐标值\n\n**offsetWidth**                                元素在页面中占据的宽度\n\n**offsetHeight**                               元素在页面中占据的高度\n\n01元素在页面中的位置.html   代码：\n\n```html\n<body>\n<style>\n    *{\n        margin:0;\n        padding:0;\n    }\n</style>\n<div style=\"width:100px; height:100px; padding:10px; margin:20px; border:solid 5px red;\"></div>\n\n<script>\n    //先获取div\n    var div = document.querySelector('div');\n\n    console.log(div.offsetLeft); //20   含有margin值\n    console.log(div.offsetHeight); //130  =  height + padding + border\n</script>\n\n</body>\n```\n\n\n\n**scrollLeft**                                     滚动条在容器中水平滚动的距离，多用于浏览器的滚动条\n\n**scrollTop**                                     滚动条在容器中垂直滚动的距离，多用于浏览器的滚动条\n\n```html\n<!--设置body比较宽，比较高，才会有滚动条-->\n<body style=\"width:2000px; height:2000px;\">\n<style>\n    *{\n        margin:0;\n        padding:0;\n    }\n</style>\n<div style=\"width:100px; height:100px; padding:10px; margin:20px; border:solid 5px red;\"></div>\n\n<script>\n    //先获取div\n    var div = document.querySelector('div');\n\n    console.log(div.offsetLeft); //20   含有margin值\n    console.log(div.offsetHeight); //130  =  height + padding + border\n\n    //滚动事件，当滚动条滚动时，输出滚动条滚动的距离\n    window.onscroll = function(){\n        console.log(document.documentElement.scrollLeft); //下面的滚动条横向滚动的距离\n        console.log(document.documentElement.scrollTop); //右侧的滚动条纵向滚动的距离\n    };\n\n</script>\n\n</body>\n```\n\n\n\n\n# 四、==事件绑定==（重点）\n\n## 4.1、何为事件\n\n浏览网页时，当我们做出点击鼠标、按键盘、移动鼠标等行为时，这些行为会被浏览器内置的JavaScript引擎所捕获，并执行对应的某些操作（函数）。==那么你的行为（动作）+ JavaScript引擎捕获 + 执行对应的操作 = 事件。==\n\n所以，一个完整的事件应该包括：\n\n- 用户行为；\n- 浏览器捕获你的行为；\n- 执行对应的操作（函数）\n\n常见行为有：鼠标点击、鼠标的移动、鼠标的移入和移出、键盘控制等等。\n\n事件的作用是：通过事件，我们（浏览网页的人）就可以和浏览器进行一些交互了。 \n\n\n\n## 4.2、==事件绑定与移除==\n\n​\t事件绑定就是添加事件，那么为谁添加事件呢？可以为页面中的所有标签（元素、节点）添加事件，大到整个文档（document），小到其中一个标签都可以添加事件。\n\n**在为一个节点添加事件的时候，有三种方式：**\n\n- 直接在标签中添加，即使用onclick、onmouseover等HTML属性；\n- DOM的方式添加，即通过dom方法获取节点，然后为其绑定事件；\n- 使用addEventListener或attachEvent（IE8及更低版本浏览器）。\n\n\n\n**为一个标签添加事件之后，还可以删除这个事件**。\n\n\n\n下面分别来学习这三种添加事件的方式：\n\n### 4.2.1、直接在标签中添加\n\n利用HTML标签的==on....==属性，为该标签添加事件。\n\n15事件绑定.html\n\n```html\n<input type=\"button\" value=\"点我\" onclick=\"alert('啊');\" />\n```\n\n如果说，点击的时候，要执行很多行js代码，可以封装一个函数，点击的时候，调用函数。\n\n```html\n<input type=\"button\" value=\"点我\" onclick=\"t();\" />\n\n<script>\n    function t(){\n        alert('1');\n        alert(2);\n    }\n</script>\n```\n\n\n\n### 4.2.2、DOM方式添加\n\nHTML代码中，没有任何的js代码。用dom的方式，获取标签，然后为其绑定事件：\n\n15事件绑定.html\n\n```html\n<input type=\"text\" id=\"username\" />\n\n<script>\n    //使用dom的方式，获取username，为其绑定事件\n    var input = document.getElementById('username');\n    //下面的函数，不会自动执行，当键盘弹起的时候，才会执行。\n    input.onkeyup = function(){\n        alert('你按到我了');\n    };\n</script>\n```\n\n问题？如果为一个节点，用上面两种方式都绑定了同一个事件，那么执行哪个事件？\n\n答：只执行DOM方式添加的事件。\n\n\n\n==删除事件，直接设置事件处理程序为null==。\n\n```javascript\ninput.onkeyup = null; //移除了事件，适用与行内绑定的事件和用DOM方式绑定的事件\n```\n\n\n\n### 4.2.3、使用addEventListener或attachEvent方法添加\n\nIE浏览器中用**attachEvent**；\n\n火狐浏览器用**addEventListener**；\n\n==事件监听函数的优点是可以为一个节点添加多个同类型的事件==。\n\n16事件监听.html  代码：\n\n```html\n<input type=\"text\" id=\"username\" />\n\n<script>\n\n    //兼容各个浏览器的事件监听函数\n    /*\n    ele : 给谁添加事件\n    type: 添加什么事件\n    fn : 事件处理函数\n     */\n    function addEvent(ele, type, fn){\n        if(window.addEventListener) {\n            //火狐浏览器\n            ele.addEventListener(type, fn);\n        }else{\n            //IE浏览器\n            ele.attachEvent('on'+type, fn);\n        }\n    }\n\t\n    //准备两个函数，当做事件处理函数\n    function t1(){\n        alert(1);\n    }\n    function t2(){\n        alert(2);\n    }\n    var input = document.getElementById('username');\n\n    //为input添加两个单击事件\n    addEvent(input, 'click', t1); //addEventListener方法需要的事件名不能带on，事件处理函数t1不能加引号，不能带括号\n    addEvent(input, 'click', t2);\n\n</script>\n```\n\n通过事件监听方法添加的事件，也可以被移除，移除的方法是：**removeEventListener**和**detachEvent**\n\n==注意： **detachEvent**  有些写法多了个 t，如**dettachEvent**，但IE某些版本中会报错。==\n\n16事件监听.html\n\n```javascript\n//移除事件兼容函数\n    function removeEvent(ele, type, fn){\n        if(window.removeEventListener) {\n            ele.removeEventListener(type, fn);\n        }else{\n            ele.detachEvent('on'+type, fn);\n        }\n    }\n\n    removeEvent(input, 'click', t1); //只移除input的click事件，对应的处理函数是t1\n```\n\n\n\n## 4.3、事件中this指向\n\n这节学习事件中，如果出现this，那么this表示什么？\n\n![1532684344930](1532684344930.png)\n\n \n\n## 4.4、常用事件\n\n- 页面事件：\n  - **onload** ：当页面载入完毕（页面中的标签和外部资源）后触发\n- 焦点事件\n  - **onfocus** ：当获取焦点时触发\n  - **onblur** ：当失去焦点时触发\n- 鼠标事件\n  - **onmouseover** ：当鼠标悬浮时触发\n  - **onmouseout** ：当鼠标离开时触发\n- 键盘事件\n  - **onkeypress** ：当键盘按下时触发（如果按住某个键不松开，会一直触发press事件）\n  - **onkeydown** ：当键盘按下时触发\n  - **onkeyup** ：当键盘弹起时触发\n- 其他事件：\n  - **onchange** ：内容改变时会触发，常用于select>option。\n  - **onsubmit** ：表单提交时触发，**这个事件要给form绑定**而不是给提交按钮绑定\n  - **onresize** ： 页面窗口改变大小时会触发\n  - **onscroll** ：滚动条滚动时触发\n  - **onprogress** ：进度事件，用于上传文件的进度\n\n\n\n# 五、==事件对象==（重点）\n\n## 5.1、什么是事件对象\n\n事件被触发以后，系统会生成一个对象，这个对象就是事件对象。\n\n==事件对象中提供了很多属性，这些属性能够表示当前的事件的特点或特征==。\n\n浏览器原生提供一个`Event`对象，所有的事件都是这个对象的实例，或者说继承了`Event.prototype`对象。\n\n> 单词event就是事件的意思，在JavaScript中，它表示事件对象\n\n## 5.2、如何得到事件对象\n\n不同浏览器得到事件对象的方式不同：\n\n- 低版本IE ：**在事件处理函数中**，直接用`window.event;` 就可以得到事件对象;\n- 火狐/谷歌：需要给**事件处理函数加入一个形参**，这个参数就是事件对象。\n\n```html\n<script>\n    //因标签在后面，所以代码应放置在 onload 事件中\n    window.onload = function () {   \n        var input = document.getElementById('username');\n        //给input绑定键盘事件\n        input.onkeyup = function (evt) {\n            //IE : 直接使用 window.event;\n            //火狐: 需要事件处理函数传入一个形参，这个形参就是事件对象\n            \n            var e = window.event||evt;//兼容各个浏览器的事件对象\n            console.log(e.keyCode); //keyCode是一个数字，表示键盘的keyCode值。\n        };\n    };\n</script>\n\n<input type=\"text\" id=\"username\" />\n```\n\n运行代码后，在输入框中输入任何内容，会输出按键对应的keyCode值。\n\n## 5.3、事件对象常用属性\n\n事件对象也是对象，而且是内置的对象，事件对象中默认带有很多属性和方法。需要了解的是，不同的事件，事件对象中的成员有所差异。\n\n下面列举一些事件对象中的常用属性：\n\n==keyCode：表示键盘上的键对应的数值==。\n\nkey：表示按键（是一个实际的符号）\n\naltKey：表示是否按了alt键，按了结果为true，没按结果为false（组合按键的时候，才会有作用）\n\nshiftKey：表示是否按了shift键，按了结果为true，没按结果为false（组合按键的时候，才会有作用）\n\nctrlKey：表示是否按了ctrl键，按了结果为true，没按结果为false（组合按键的时候，才会有作用）\n\npageX: 鼠标距离页面左边的距离\n\npageY: 鼠标距离页面上面的距离\n\nscreenX: 鼠标距离屏幕左边的距离\n\nscreenY: 鼠标距离屏幕上面的距离\n\n\n","categories":["Advanced"]},{"title":"JavaScript 基础知识","url":"%2Fposts%2F2727413451%2F","content":"\n# JavaScript高级\n\n## 一、介绍 (了解)\n\n### 1.1  什么是JavaScript\n\n JavaScript 是一门解释型的、弱类型的、基于原型的编程语言。\n编程语言可以分为两大种：\n\n- 编译型的：先翻译好，再执行。\n- 解释型的：翻译一句，执行一句。\n\n弱类型：数据类型是由值来决定的。\n原型：后面解释\n\nJavaScript被认为是客户端“脚本”，它不常叫“语言”，言外之意是比较简单，但是深入了解之后，你会发现 简单的外表下，蕴藏着丰富的内涵。 \n\n### 1.2  JavaScript 历史\n\n **JavaScript问世**：\n\n上世纪90年代，NetScape(网景)公司研发的NetScape Navigator1.0(浏览器)成为当时最热门的浏览器。\n          ![img](clip_image002.jpg)\n 市场份额一举超过90%。\n          Netscape公司很快发现，Navigator浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。\n\n1995年，Netscape公司雇佣了程序员Brendan Eich（布兰登·艾奇）开发这种网页脚本语言，JavaScript1.0。\n                       ![img](clip_image004.jpg)\n 1996年3月，Navigator 2.0浏览器正式内置了JavaScript脚本语言。\n\n \n\n**“邪恶”的后来者**\n\n因为 JavaScript1.0 如此成功，所以微软·也决定进军浏览器，1996年8月，微软模仿JavaScript开发了一种相近的语言，取名为JScript（JavaScript是Netscape的注册商标，微软不能用），首先内置于IE 3.0。Netscape公司面临丧失浏览器脚本语言的主导权的局面。\n\n**标准的重要**\n\n在微软进入后，有 3 种不同的 JavaScript 版本同时存在：NetscapeNavigator 3.0 中的 JavaScript、IE 中的 JScript 以及 CEnvi 中的 ScriptEase。与 C 和其他编程语言不同的是， JavaScript 并没有一个标准来统一其语法或特性，而这 3 种不同的版本恰恰突出了这个问题。 随着业界担心的增加，这个语言标准化显然已经势在必行。\n\n \n\n**JavaScript标准化**\n\n1996年11月，Netscape公司决定将JavaScript提交给国际标准化组织**ECMA**（European Computer Manufacturers Association欧洲计算机制造商协会），希望JavaScript能够成为国际标准，以此抵抗微软。1997年7月，ECMA组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是==ECMAScript== 1.0版。\n\n 目前最新的**E**CMA**S**cript版本是**ES**6，我们学习的是ES5版本，因为ES6中好多新的内容在 IE11 中都不能使用。\n\n### 1.3  JavaScript组成部分\n\n![img](clip_image005.png)\n **ECMAScript**，核心语法\n **DOM** （Document Object Model）,==文档对象模型==。提供了操作网页内容的一系列工具（api）。\n **BOM** （Browser Object Model）,==浏览器对象模型==。提供了操作浏览器的一系列工具（api）。\n\n### 1.4 JavaScript的应用\n\n① 数据验证（表单验证）\n\n② 网页特效（目前大多数的网页特效都是通过JS编写）\n\n③ 编写网页小游戏\n\n④  服务器端编程，**数据交互**（Ajax、Node.js）\n\n ## 二、语句和表达式（了解）\n\nJavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。\n\n语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句：\n\n```javascript\nvar a = 1 + 3;\n```\n\n这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。\n\n1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。\n\n语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。\n\n凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。一条语句可以包含多个表达式。\n\n> 小提示：可以认为含有等号（=）的是语句，没有等号（=）的是表达式。\n\n语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。\n\n```javascript\nvar a = 1 + 3 ; var b = 'abc';\n```\n\n分号前面可以没有任何内容，JavaScript引擎将其视为空语句。\n\n```javascript\n;;;\n```\n\n上面的代码就表示3个空语句。\n\n\n\n## 三、==变量==（重点）\n\n### 1、命名规则\n\n- 变量必须以字母开头 \n\n- 变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做） \n\n- 变量名称对大小写敏感（y 和 Y 是不同的变量）\n\n- 变量不能使用保留字和关键字（尤其不要使用==this==, ==name==这样的东西）\n\n  ```javascript\n  var $ = 1; //可以，但是不推荐这样用\n  \n  function $(){ //可以，但是不推荐这么用\n      \n  }\n  \n  //不推荐的原因是，jQuery中用$表示jQuery对象，已经把$占用了，如果我们自己声明的变量也叫做$，会和jQuery发生冲突。\n  ```\n\n  \n\n### 2、一条语句，多个变量\n\n在一行中，可以声明多个变量，==注意每个变量之间是逗号==（,）。\n\nconsole.log(); 表示在浏览器的控制台进行输出，console.log()一次性可以输出多个变量，而且变量的数据类型也能够体现。后面的学习中，用console.log() 代替 document.write() 和 alert().\n\n```javascript\nvar a = 1, b = 2, c = 'hello'; //在一行中，使用一个var声明三个变量\nconsole.log(a, b, c); //输出 1 2 hello\n```\n\n![1532483722374](1532483722374.png)\n\n### 3、只声明变量，没有赋初值\n\n```javascript\nvar e;\nconsole.log(e); // underfined\nconsole.log(f); // 报错：ReferenceError: f is not defined\n```\n\n\n\n### 4、重新声明变量\n\n重新声明变量，但是没有给值的话，还使用原来的变量。这点和PHP是一样的。\n\n```javascript\nvar g = 1; //声明变量\nvar g;     //再次声明变量，但是没有给值\nconsole.log(g); // 1\n```\n\n\n\n### 5、变量提升（注意）\n\n变量提升（hoisting）\n\n```javascript\nconsole.log(h);\nvar h = 123;\n//输出结果undefined\n```\n\n实际上JavaScript在解释上面的代码的时候，会有一个变量提升的过程。即将声明变量h的过程提升到代码的最前面，这种情况就叫做变量提升。\n\n上面代码在实际执行时，等同下面的代码：\n\n```javascript\nvar h;\nconsole.log(h);\nh = 123;\n```\n\n变量提升也会发生在函数中，如下代码：\n\n```javascript\nfunction test(){\n    console.log(h);\n    var h = 123;\n}\ntest(); //输出结果 undefined\n```\n\n\n\n## 四、常量\n\nJavaScript中也有常量，使用关键字const进行定义。常量也具有和PHP中常量一样的特点。\n\n```javascript\nconst ABC = 'hello';\nconsole.log(ABC); //输出hello\n```\n\n\n\n## 五、==运算符==（重点）\n\n### 5.1、算数运算符\n\n算数运算符无非就是**加减乘除、取模（余）、递增、递减。**\n\n```javascript\nvar a = 2, b = 5;\nconsole.log(a%b);\n\nvar c = 3, d = 4;\nconsole.log(c++); // 3\nconsole.log(++d); // 5\nconsole.log(c, d); // 4,5\n\nvar e = 3, f = 4;\nvar g = e++; // var g = e; e = e + 1;\nvar h = ++f; // f = f + 1; var h = f;\nconsole.log(g, h); //3, 5\nconsole.log(e, f); //4, 5\n\n```\n\n在累加和加法运算同时存在的时候，要用空格或小括号区分每个+的意思：\n\n```javascript\nconsole.log((a++)+(++b)); //用括号区分\n//或者\nconsole.log(a++ + ++b); //用空格区分\n\nvar a = 2, b = 5;\nconsole.log((a++)+(++b)); // 2 + 6 = 8;\n```\n\n\n\n### 5.2、用于字符串的 “+”\n\nJavaScript中用“+”连接字符串，类似于php中的“点”。\n\n- 如果 “+” 前后都是数值型，那么 “+” 表示加法运算。\n- 如果 “+” 两边有一个为非数值型，那么 “+” 表示字符串连接\n\n```javascript\nconsole.log(1 + 2); // 数值型的 3\nconsole.log(1 + '2'); // 字符串型的 12\nconsole.log('abc' + 2); // 字符串型 abc2\n```\n\n\n\n### 5.3、赋值运算符\n\n赋值运算符是 “=”，意思是将 = 后面的值赋值给等号前面的变量。\n\n在进行判断的时候，一定要注意 “=”、“= =”、“= = =” 的区别。\n\n```javascript\nvar a = 1, b = 2;\nif (a = b) { //一个=表示赋值，意思是将b的值赋值给a，然后判断a是true还是false\n    console.log('相等');\n} else {\n    console.log('不等');\n}\n```\n\n![1532486272490](1532486272490.png)\n\n### 5.4、比较运算符\n\n比较运算符包括：**==、= ==、>=、<=、>、<、!=**\n\n需要注意的是：\n\n​\t== 表示比较两边的值是否相等，而不考虑数据类型；\n\n​\t== =表示比较两边的值是否相等，同时还要考虑数据类型是否相等。\n\n```javascript\nconsole.log(1 == '1'); // true\nconsole.log(1 === '1'); // false\n```\n\n\n\n### 5.5、三元运算符\n\n==三元运算符==也叫做**三目运算符**或**条件运算符**。\n\n**元** 表示参与运算的表达式的个数。\n\n```javascript\nvar a = 1, b = 2;\nvar c = a < b ? 3 : 4;\nconsole.log(c); // 3\n\nvar d = false == 'false' ? 5 : 6;\nconsole.log(d); // 6\n```\n\n\n\n### 5.6、逻辑运算符\n\n逻辑运算符的常规用法，我们就不需要讲解了。下面看一下非常有用的其他使用方法：\n\n```javascript\nvar a = 0, b = 1, c = 2, d = false;\n\nvar e = a&&b; //意思是给e赋值，值肯定是a或者b中的一个。  结果为0，因为a自己就能够决定a&&b的结果为false了。\n    /*if(a && b) {\n        //要判断if的最终结果，先观察a，如果a能够决定最终的结果，则不用看b是什么，则将a赋值给e\n    }*/\nvar f = b&&c; // 2\nvar g = c&&a; // 0\n// && ： 先看左边，左边为true，最终结果是右边的值；左边为false，最终结果直接等于左边的值\n\nvar h = a||b; // 1\nvar j = b||c; // 1\nvar k = a||d; // false\n// || : 先看左边，左边为true，最终结果等于左边的值，左边为false，最终结果直接等于右边\nconsole.log(e, f, g, h, j, k);\n```\n\n\n\n## 六、流程控制\n\n流程控制有三种结构，顺序结构、分支结构和循环结构，关于这三种结构这里就不再多说了。\n\n下面看一个变异的for循环：\n\n```javascript\n    var i=1;\n    for(;;){\n        if(i > 5){\n            break; //跳出循环\n        }\n        console.log(i);\n        i++;\n    }\n```\n\n循环的时候，可以使用break跳出循环，可以使用continue跳过当次循环。\n\n```javascript\n    //a: 表示给循环起一个名字，用于break或者continue。\n    a:for(var i=1; i<=3; i++){\n        b:for(var j=1; j<=3; j++){\n            if(j == 2){\n                break a;\n            }\n            console.log(i + '-' + j);\n        }\n    }\n    /*\n    1-1\n     */\n```\n\n\n\n## 七、==数据类型==（重点）\n\n### 7.1、数据类型介绍\n\nJavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 符号类型的值）\n\n- **number**：数值型，包括整型和浮点型\n- **string**：字符串型\n- **bool**：布尔型\n- **null**：null\n- **undefined**：未定义\n- **object**：对象\n\n通常，我们将数值、字符串、布尔值称为**原始类型**（primitive type）的值，即它们是最基本的数据类型，不能再细分了。而将对象称为合成类型（complex type）的值或**引用类型**，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个**特殊**值。\n\n对象又可以分成三个子类型，即狭义的对象（object）、数组（array）、函数（function），其实，更加广义的讲，原始类型的值（数值、字符串、布尔）也可以看做对象。**一句话，JavaScript中一切皆对象**。\n\n画图说明原始类型和引用类型的区别：\n\n![1532489584864](1532489584864.png)\n\n### 7.2、创建数组\n\n要想得到一个数组，有三种创建方式，分别是：\n\n```javascript\n//方式一（推荐）：\nvar arr1 = []; //空数组\nvar arr2 = [1, 2, 3, 'hello', true]; //创建数组，并为数组添加一些单元\n\n//方式二（推荐）：\nvar arr3 = new Array(); //空数组\nvar arr4 = new Array(1, 2, 3, 'hello', true); //创建数组，并为数组添加一些单元\n//方式三（不推荐）：\nvar arr5 = new Array(3); //表示数组中有3个单元\n\n```\n\n\n\n### 7.3、创建对象\n\n创建一个JavaScript对象有很多种方式，今天先学习一种方式：\n\n```javascript\nvar obj1 = {}; //空对象\n\nvar obj2 = {name:'张三', age:23, sex:'男'}; //创建对象，并添加3个成员属性\n\n//obj3和obj2是一样的，只不过加了换行，使结构更加清晰\nvar obj3 = {\n    name:'张三',\n    age:23,\n    sex:'男'\n}；\n\n//带有成员方法的对象\nvar obj4 = {\n    //添加成员属性\n    name:'张三',\n    age:23,\n    sex:'男',\n    //添加成员方法\n    fn1:function(){\n        console.log(123);\n    },\n    fn2:function(){\n        console.log(this.name); //输出当前对象的name属性\n        this.fn1(); //调用当前对象的其他方法\n    }\n};\nobj4.fn2(); //调用对象的成员方法\n```\n\n\n\n### 7.4、判断数据类型\n\nJavaScript中有一个 `typeof`，用它可以判断一个变量的数据类型，但是它不能区分null、array、object，因为对null、array和object使用 typeof 之后得到的结果都是object。要想区分null、array、object必须借助另一个关键字`instanceof`。\n\n![1532490798842](1532490798842.png)\n\n发现，c（null）、e（数组）、f（对象）得到的结果都是object。\n\n![1532491148663](1532491148663.png)\n\n## 八、==数据类型转换==（重点）\n\n### 8.1、转换成字符串\n\n- 使用字符串方法`toString([进制])`转换，但是null和undefined无法转换。\n- 使用顶层函数`String()`可以将任何数据类型转换成字符串，包括null和undefined。\n- 在其他数据类型和字符串类型进行连接操作时，会自动对其他数据类型使用`String()`强制转换成字符串\n\n```javascript\n    var a = 1, b = 3.14, c = null, d, e = ['apple', 'banana'], f = {name:'zhaowei', age:20};\n\n\t/***************** 使用toString转换 ********************/\n    console.log(a.toString()); // 1\n    console.log(b.toString()); // 3.14\n    //console.log(c.toString()); //null不能被toString方法转换\n    //console.log(d.toString()); //undefined不能被toString方法转换\n    console.log(e.toString()); //apple,banana\n    console.log(f.toString()); //[object Object]\n\n\t/***************** 使用String()转换 ********************/\n\tconsole.log(String(a)); // 1\n    console.log(String(b)); // 3.14\n    console.log(String(c)); // null\n    console.log(String(d)); // undefined\n    console.log(String(e)); //apple,banana\n    console.log(String(f)); //[object Object]\n\n\t/***************** 其他数据类型和字符串相连 ********************/\n\tconsole.log(f + 'hello'); // [object Object]hello\n    console.log(a + 'hello'); // 1hello\n```\n\n### 8.2、转换成数值型\n\n- **parseInt() -- 转换成整型**\n\n  parseInt() 方法首先查看位置 0 处的字符，判断它是否是个有效数字；如果不是，该方法将返回 NaN，不再继续执行其他操作。但如果该字符是有效数字，该方法将查看位置 1 处的字符，进行同样的测试。这一过程将持续到发现非有效数字的字符为止，此时 parseInt() 将把该字符之前的字符串转换成数字。\n\n  例如，如果要把字符串 \"12345red\" 转换成整数，那么 parseInt() 将返回 12345，因为当它检查到字符 r 时，就会停止检测过程。\n\n  字符串中包含的数字字面量会被正确转换为数字，比如 \"0xA\" 会被正确转换为数字10。不过，字符串 \"22.5\" 将被转换成22，因为对于整数来说，小数点是无效字符。\n\n  ```javascript\n  \tvar a = 1, b = 3.14, c = '123', d = '12.3.4', e = '123hello456',f = 'hello123';\n      console.log(parseInt(b)); // 3\n      console.log(parseInt(c)); // 123\n      console.log(parseInt(d)); // 12\n      console.log(parseInt(e)); // 123\n      console.log(parseInt(f)); // not a number = NaN\n  ```\n\n  \n\n- **parseFloat() -- 转换成浮点型**\n\n  道理和转换成整型道理一样，只不过浮点型允许有一个小数点出现。\n\n  ```javascript\n  \tvar a = 1, b = 3.14, c = '123', d = '12.3.4', e = '123hello456',f = 'hello123';\n    \n      console.log(parseFloat(a)); // 1\n      console.log(parseFloat(b)); // 3.14\n      console.log(parseFloat(c)); // 123\n      console.log(parseFloat(d)); // 12.3\n      console.log(parseFloat(e)); // 123\n      console.log(parseFloat(f)); // not a number = NaN\n  ```\n\n  \n\n- **Number() -- 强制转换**\n\n  Number() 函数的强制类型转换与 parseInt() 和 parseFloat() 方法的处理方式相似，**只是它转换的是整个值，而不是部分值**。\n\n  用 Number() 进行强制类型转换，\"1.2.3\" 将返回 NaN，因为整个字符串值不能转换成数字。如果字符串值能被完整地转换，Number() 将判断是调用 parseInt() 方法还是 parseFloat() 方法。\n\n  ![img](clip_image002-1532442906887.jpg)\n\n## 九、==函数==（重点）\n\n### 9.1、function命令定义\n\n```javascript\nfunction  functionName(参数列表){\n    //函数体\n    //return\n}\n\n```\n\n\n\n### 9.2、函数表达式\n\n除了用function命令声明函数，还可以采用**变量赋值**的写法。\n\n```javascript\n\tvar t = function(x, y){\n        console.log(x+y);\n    };\n\n    t(1,2);\n```\n\n\n\n采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。\n\n两种方式声明的函数，优先使用哪个？\n\n不管同名函数的顺序是如何的，==总是优先调用函数表达式(var )的形式定义的函数。==\n\n```javascript\n    function t(x, y){\n        console.log(x - y);\n    }\n\n    var t = function (x, y){\n        console.log(x + y);\n    };\n\n    t(3,1); // 4\n```\n\n\n\n### 9.3、函数预加载\n\n函数也有和“变量提升”类似的效果，叫做函数预加载，也就是说在实际执行时，函数会预先加载。\n\n==一个script代码段中==，函数可以先调用，后声明（**这里的声明指的是传统的function命令声明方式，用表达式的方式不会有预加载**）。\n\n```javascript\n/*************** 函数预加载 ******************/\n    t();\n    function t(){\n        console.log(123);\n    }\n```\n\n\n\n### 9.5、函数参数默认值\n\n定义函数时规定的参数叫做**形参**（形式参数），调用函数时传递给函数的参数叫做**实参**（实际参数）。\n\nES5中，函数的形参不能有默认值。ES6中的函数才允许形参有默认值。目前IE11不支持函数形参有默认值，但是火狐、谷歌、UC支持。\n\n```javascript\n/*********************** 函数参数默认值 *****************************/\n    function t(x, y) {\n        //如果调用函数时，没有传递y的值，则y的值为undefined\n        if(y == undefined){\n            y = 3;\n        }\n        console.log(x + y);\n    }\n    t(2); // 5\n    t(2, 9); // 11\n```\n\n\n\n### 9.6、函数参数不固定\n\n使用**arguments**对象可以获取到函数的所有参数。\n\narguments.length表示参数的个数；\n\narguments[0]表示第一个参数\n\narguments[1]表示第二个参数\n\n…….\n\n![1532504854763](1532504854763.png)\n\n```javascript\n/*********************** 函数参数个数不固定 *****************************/\n    function t(){\n        //功能是将传递进来的所有参数相加\n        //console.log(arguments);\n        var sum = 0;\n        for (var i=0; i<arguments.length; i++){\n            sum += arguments[i];\n        }\n        console.log(sum);\n    }\n\n    //t(1);\n    //t(1,2,3);\n    t(1,2,3,4); // 10\n    //t(1,2,3,4,5......);\n```\n\n\n\n### 9.7、参数传值方式\n\n函数参数如果是**原始类型**的值（数值、字符串、布尔值），传递方式是**按值传递**（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。\n\n函数参数是**复合类型**的值（**数组、对象**），传递方式是**引用传递**（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。\n\n```javascript\n    /*********************** 传值方式 *****************************/\n    var a = 1;\n    var b = ['apple', 'pear'];\n\n    function t(x, y) {\n        x = 2;\n        y.push('banana'); //意思是想y数组中，添加一个单元banana\n    }\n\n    t(a, b);\n\n    console.log(a); // 1\n    console.log(b); // ['apple', 'pear', 'banana']\n```\n\n\n\n### 9.8、自调用模式的函数（立即调用）\n\n```javascript\n    /***************** 函数自调用 *******************/\n\n//    var t = function (x) {\n//        console.log(x);\n//    };\n//    t(2);\n\n    (function (x){\n        console.log(x);\n    })(245);\n\n    !function (x){\n        console.log(x);\n    }(245);\n\n\t~function (x){\n        console.log(x);\n    }(245);\n\n\t+function (x){\n        console.log(x);\n    }(245);\n```\n\n这种方式定义的函数，内部的变量或形参不会污染外部的环境。\n\n### 9.9、递归函数\n\n在函数内部调用函数本身的函数就是递归函数。递归层数不要超过200层\n\n```javascript\n/******************** 递归函数 **************************/\n    function t(x){\n        //加入终止条件\n        if (x > 10){\n            return;\n        }\n        console.log(x++);\n        t(x);\n    }\n    t(1);\n```\n\n\n\n波非那切数列：1  1  2  3  5  8  13  21 ....\n\n**结果为前2个数相加**\n\n要求，定义递归函数，参数是数的位置，要求返回该位置的数字是多少？\n\n```javascript\n\t//波非那切数列：1  1  2  3  5  8  13  21 ....\n    function t(position) {\n        //终止条件\n        if(position==1 || position==2){\n            return 1;\n        }\n        return t(position-1) + t(position-2);\n    }\n    console.log(t(4)); // 3\n    console.log(t(6)); // 8\n    console.log(t(41)); // 165580141\n```\n\n\n\n### 9.10、回调函数\n\n在定义函数时，是可以在括号中定义形参的。\n\n如果一个函数在定义时，设定了一个形参，并希望使用这个函数时传递进来的实参是函数类型的值，那么传递进来的实参函数就叫做==回调函数==。简言之，就是一个函数的参数是另一个函数。\n\n![1532507344947](1532507344947.png)\n\n## 十、执行流程（了解）\n\n### 10.1、全局环境\n\njs在运行时，首先会创建一个全局执行环境，这个全局环境就是定义一个全局对象，页面中所有的内容（不同的script中的内容） 都是这个全局对象的成员，这个全局对象是**window**。\n\n检查的办法是定义一个变量，定义一个函数，然后用window对象来调用它们，看是否能成功，如果成功调用，说明定义的变量和函数确实是window对象的成员。\n\n![1532508474827](1532508474827.png)\n\n### 10.2、执行流程\n\njs在执行的时候，会按照script标签来一个一个的执行，也就是先执行第一个script标签中的内容，然后在执行第二个script标签的内容。\n\n一个script标签中，首先会先\n\n**编译代码**（检查语法、词法是否错误，没有错误就加载到内存中）\n\n**执行代码**（运行或输出结果）。\n\n执行完毕，继续按照相同的方式执行下一个script标签的内容。\n\n![img](clip_image004-1532443887952.jpg)\n\n### 10.3、错误类型\n\n这里所说的错误类型指的是**编译错误和执行错误**。\n\n**编译错误特点**：\n\n​\t语法、词法错误，叫做编译错误。\n\n​\t如果一个script代码段中发生编译错误，则==整个script标签中的内容全部终止执行==，但是==不会影响下一个script代码段==。\n\n![1532509186327](1532509186327.png)\n\n**执行错误特点**：\n\n比如调用未定义的函数。\n\n​\t如果一个script代码段中发生执行错误，==错误之前的代码还能够执行==，错误之后的代码终止执行，但不会影响下一个script代码段。\n\n![1532509222520](1532509222520.png)\n\n### 10.4、错误处理\n\n类似于PHP中的异常处理，但语法稍有不同，使用的也是 **try…catch(e){}**\n\n自然抛出：\n\n![1532509411963](1532509411963.png)\n\n手动抛出：\n\n![1532509552917](1532509552917.png)\n\ntry…catch(e){…}后面可以跟一个**finally**语句，表示无论前面的 try…catch 的执行情况是怎样的，finally都会执行。\n\n```javascript\n    //finally\n    try{\n        //console.log(111);\n        throw new Error('sss');\n    }catch (e){\n        console.log(e.message);\n    } finally {\n        console.log('我总是执行的');\n    }\n```\n\n\n\n## 十一、作用域（链）\n\n### 11.1、作用域分类\n\n全局作用域：范围是整个运行环境\n\n函数作用域：只适用于函数内部，也叫做局部作用域\n\n```javascript\n\tvar a = 1; //全局作用域里的变量\n    \n    function t(){\n        var a = 1; //局部作用域中的变量\n    }\n```\n\n\n\n### 11.2、作用域及作用域链\n\n**案例一**：函数内部可以使用函数外部的变量\n\n```javascript\n\tvar a = 1; //全局作用域里的变量\n    function t(){\n        console.log(a); // 函数内部可以使用函数外部的变量\n    }\n    t(); // 1\n```\n\n\n\n**案例二**：函数内部使用变量的优先级，优先使用函数内部的变量\n\n```javascript\n\tvar a = 1; //全局作用域里的变量\n\n     function t(){\n         var a = 2;\n         console.log(a);\n     }\n     t(); // 2\n```\n\n要注意的是，同一个作用域中会发生变量提升。\n\n```javascript\n\tvar a = 1; //全局作用域里的变量\n\n    function t() {\n        //var a = 2;\n        console.log(a); //因为函数内部也有a，在输出的时候，会发生变量提升，所以输出undefined\n        var a = 3;\n    }\n    t(); // undefined\n```\n\n\n\n**案例三**：函数内部没有用var声明的变量也是全局变量，会影响到函数外部的全局变量的值\n\n```javascript\n\tvar a = 1; //全局作用域里的变量\n\n    function t() {\n        //var a = 2; //局部变量\n        a = 2; //全局变量\n    }\n    t();\n    console.log(a); // 2\n```\n\n\n\n**案例四**：函数内部使用的形参，相当于该函数内部的局部变量\n\n```javascript\n\tvar a = 1; //全局作用域里的变量\n\n    function t(x) {\n        x = 2; //x相当于局部变量\n    }\n    t(a);\n    console.log(a); // 1\n```\n\n\n\n用var和不用var声明变量有什么区别？\n\n①、在函数内部，用var声明的变量是局部变量；没有用var声明的变量是全局变量。\n\n②、没有用var声明的变量可以用delete删除掉，用var声明的变量不能被删除。\n\n![1532510809148](1532510809148.png)\n\n### 11.3、作用域链\n\n```javascript\n\tvar a = 3;\n    function t1() {\n        //var a = 2;\n        function t2() {\n            //var a = 1;\n            console.log(a);\n        }\n        t2();\n    }\n    t1();\n```\n\n作用域链就是一个概念，或者说是一个查询规则。\n\n比如上面的代码，在输出 变量 a的时候，优先使用函数自身中的变量 a，如果没有，则向上一层查找，如果上一层也没有定义 a，则继续向上一层查找，**这样一层一层的查找的方式**，叫做**作用域链**。\n\n \n\n\n\n\n\n\n\n\n\n","categories":["Advanced"]},{"title":"JavaScript 基础知识","url":"%2Fposts%2F2727413452%2F","content":"\n\n# 一、JavaScript简介\n\n## 什么是JavaScript？\n\n从交互的角度，提升用户的体验性！\n\nJavaScript是由网景公司开发的一款基于浏览器、基于面向对象、事件驱动式的网页脚本语言。\n\n**基于浏览器：**JavaScript它是被浏览器来进行解析的。HTML、CSS、JavaScript它们都是被浏览器来进行解析。\n\n**基于面向对象：**在JavaScript中一切皆是对象，对象是由属性与方法来组成。\n\n**事件驱动式：**用户的某些特定的行为，比如鼠标经过、鼠标离开、鼠标点击等等这些行为它会被JavaScript所捕获，JavaScript会给这些行为赋予一些功能代码。\n\n## JavaScript的应用场景\n\n-   **表单验证 **\n\n-   一些网页特效， 比如全选功能、比如图片轮播.........\n\n-   开发一些网页的小游戏 ，比如贪吃蛇...... 别踩白块 HTML5+CSS3+JAVASCRIPT\n\n-   与服务器进行交互， Ajax \\--谷歌于2005年推出的\n\n## JavaScript与Java的关系\n\nJavaScript它是网景公司开发的 livescript\n\nJava是Sun开发的 但是它现在被甲骨文给收购\n\n## 快速入门\n\n![](image2.png)\n\n![](image3.png)\n\n\n\n# 二、JavaScript的书写方式\n\n**嵌入式、外链式、行内式**\n\n\n\n## 嵌入式\n\n将JavaScript代码嵌入到HTML文件的script标签中， 它是通过一对\\<script\\>\\</script\\>标签来嵌入的！\n\n注意：如果H5的文档 type属性可以省略不写！\n\n![](image4.png)\n\n![](image5.png)\n\n在HTML文档中 `script`标签可以出现多次\n\n\n\n## 外链式\n\nJS代码它可以单独的保存为一个以.js为扩展名的文件， 然后通过HTML中的\\<script\\>\\</script\\>的src属性将其引入到当前的HTML文件中！\n\n![](image6.png)\n\n**思考一下：**\n\n因为嵌入式与外链式都是使用的script标签来实现JS代码，会不会产生冲突？\n\n一对script标签 ，既写了JS代码的同时又引入了外部的JS文件\n\n一对script标签 ，实现了嵌入式的同时还实现外链式？会不会产生冲突！\n\n![](image7.png)\n\n![](image8.png)\n\n**一对script标签一次只能实现一种书写方式**\n\n\n\n## 行内式\n\nHTML标签中 有一些**事件属性** 。事件属性都是带有on前缀， 比如鼠标经过、鼠标离开、鼠标单击等等。\n\nonclick\n\nonmouseover\n\nonmouseout\n\n将JS代码书写在HTML标签的事件属性中\n\n\n\n**格式：**\n\n```html\n<标签名 事件属性 = \"JS代码\" >\n```\n\n![](image9.png)\n\n关于**嵌入式与外链式**之间的区别：\n\n-   使用嵌入式书写的JS代码它只能够被当前的HTML文件所使用\n\n-   外部的JS文件可以被多个HTML文件所引入 (推荐使用)\n\n\n\n# 三、注释\n\nJS中的注释有两种方式：**单行注释、多行注释**\n\n## 单行注释\n\n**格式：**\n\n```javascript\n// 注释的内容\n```\n\n## 多行注释 或 块注释\n\n**格式：**\n\n```javascript\n/*\n注释的内容\n*/\n```\n\n![](image10.png)\n\n# 四、JS代码的语法规则\n\n-   JavaScript严格区分大小写\n\n-   JavaScript脚本程序须嵌入在HTML文件中\n\n-   JavaScript脚本程序可以独立保存为一个外部文件， 这个文件是不能自己运行的它必须要依赖于HTML文件\n\n-   JavaScript脚本程序中不能包含HTML标记代码\n\n-   每条语句末尾可以加分号一定是英文下的分号(;)，最好加分号\n\n-   一行写了多条JS语句 这个时候每一条语句就必须要加分号\n\n![](image11.png)\n\n\n\n# 五、三个常用的输出语句\n\n## document.write(\"要输出的内容\")\n\n**作用：**\n\n-   它主要是用来向body标签中输出write()小括号里面的内容\n\n-   document它表示是当前的HTML文档对象\n\n-   write在英文中是\"写\"的意思\n\n-   对象是由属性与方法组成的 。`对象.属性`与`对象.方法 ` ，从视觉上面来区分属性与方法， 属性不带小括号 ，方法带有小括号。\n\n-   write它是一个输出的方法\n\n![](image12.png)\n\n## window.alert(\"要输出的内容\")\n\n**作用：**\n\n-   它主要是用来向当前的浏览器窗口中弹出一个警告提示框\n\n-   window它表示的是当前的浏览器窗口对象 window对象是js中最顶级的对象 ，可以省略不写\n\n-   alert在英文是\"警告\"的意思\n\n\n\n**window对象与document对象之间的区别：**\n\nwindow对象它代表着当前的浏览器窗口对象\n\ndocument对象它代表着当前的HTML文档对象\n\nwindow对象包含document对象\n\n站在window的角度来说document对象是window对象的一个属性\n\n![](image13.png)\n\n## console.log(\"要输出的内容\")\n\n**作用：**\n\n-   向浏览器的调试工具中的\"console\" 选项卡里面输出内容\n\n-   console的英文意思是\"控制台\"\n\n-   log是日志的意思\n\n![](image14.png)\n\n\n\n# 六、变量\n\n## 什么是变量？\n\n**变量**是一种可以变化的量，变量主要是用于存储数据的。我们命令JavaScript去干活的时候，往往需要产生一些数据，需要临时性存放起来，方便取用。我们也可以理解为，变量就像一个购物袋，我们可以用来装苹果、榴莲（当然也可以用来装玫瑰），变量是存放在内存中，内存是临时存储数据的。\n\n**硬盘：**持久性存储\n\n**内存：**临时性存储\n\n## 声明变量(定义变量)\n\n定义变量需要有一个关键字 variable 变量\n\n```javascript\nvar 变量名; //声明变量\n```\n\n![](image15.png)\n\n```javascript\nvar 变量名 = 值;  //定义变量\n```\n\n![](image16.png)\n\n![](image17.png)\n\n## 变量名的命名规则\n\n-   变量名可以是由大小写英文字母、下划线(\\_)、美元符号(\\$)、数字来组合\n\n-   变量名不能以数字开头， 变量名开头只能大小写英文字母或者是下划线或者是美元符号来开头\n\n-   变量名不能使用JavaScript 关键字或者保留字作为变量名。\n\n![](image18.png)\n\n-   如果一个变量名是由多个单词组成的，那么建议使用驼峰法或者下划线连接法\n\n    -   **驼峰法**   ：从第二个单词开始 ，首字母要大写 ，getUserName\n\n    -   **下划线连接法**  ：每一个单词之间要使用下划线来进行连接。 get\\_user\\_name\n\n![](image19.png)\n\n**希望大家在声明变量的时候变量名要做到见名知意。**\n\n\n\n## 给变量名赋值\n\n将等于号右边的值赋值给等于号左边的变量名！\n\n第一种方式：先声明变量然后再来赋值。\n\n![](image20.png)\n\n第二种方式：定义变量\n\n![](image21.png)\n\n## 修改变量的值\n\n声明一个变量已经给其赋了值 ，然后再来修改这个变量的值！\n\n**格式：**\n\n```javascript\n变量名 = \"新值\";  //给变量名重新赋一个值\n```\n\n![](image22.png)\n\n**为什么要使用变量 ?  方便程序员对数据进行管理 **\n\n\n\n# 七、变量的数据类型\n\n## 为什么变量需要数据类型？\n\n变量主要是用于存储数据的，现实生活中的数据有很多种\n\n比如有数值、有字母等等 。那么为了将这些数据进行分门别类，所以就引出了变量的数据类型。\n\n\n\n**变量的数据类型分为：**   ==两大类==、==七小种==\n\n==两大类==：基本数据类型(标量数据类型)、复合数据类型！\n\n* **基本数据类型：**只能存储一个值\n\n* **复合数据类型：**至少存储一个值，可以存储多个值\n\n\n\n\nJavaScript是一种弱类型的语言。 在声明变量的时候不需要指定变量的数据类型。\n强类型的语言，在声明变量的时候一定要先指明这个变量的数据类型是什么 ，并且值也是这个数据类型。\n\n在JS中的变量声明的时候不需要去指定变量的数据类型，但是它也是有数据类型，它的数据类型是由其值来决定！\n\n\n\n## 基本(标量)数据类型\n\nString(字符串型)、Number(数值型)、Boolean(布尔型)、undefined(未定义型)、null(空型)\n\n### String(字符串型)\n\n**什么是字符串型数据类型？**\n\n变量的值加了引号的数据！我们就称之为字符串数据类型！ **引号**：单引号和双引号都可以！不管引号里面是什么 只要是加了引号的数据都称之字符串数据。\n\n![](image23.png)\n\n在JavaScript中有一个内置的函数可以检测变量的数据类型` typeof(要检测的变量名)`\n\n![](image24.png)\n\n**问：**如果在双引号定义的变量中是否还能在出现双引号 ？\n\n要解决上图所示的问题， 就需要使用转义字符！\n\n问：如果在单引号中定义的变量里面是否还能出现单引号？\n\n不能出现单引号，但是可以使用转义字符(\\\\)对单引号进行转义。\n\n![](image25.png)\n\n**一般在工作中：**\n\n-   如果是使用的是双引号定义的变量 ，那么里面就会使用单引号 ，双包单。\n\n-   如果是使用的是单引号定义的变量 ，那么里面就会使用双引号， 单包双。\n\n![](image26.png)\n\n### Number(数值型数据)\n\n**包含：**整数与小数、NaN (Not a Number) 它不是一个数\n\n整数：正整数、负整数、0\n\n小数：正小数、负小数\n\n![](image27.png)\n\n### Boolean(布尔型)\n\n**布尔型它主要是用来表示真与假!**\n\n布尔型数据只有两个值：\n\ntrue(真)和false(假)\n\n\n\n**如何得到布尔型：**\n\n定义一个变量的值为true或者是false 就可以得到布尔型。\n\n**注意：**\n\n布尔型的值是小写的true和false\n\n![](image28.png)\n\n### undefined(未定义型)\n\n**得到未定义的数据类型：**\n\n定义一个变量给其值赋值为 undefined\n\n![](image29.png)\n\n**得到undefined关键字 **\n\n声明变量， 然后直接打印或者使用这个变量， 这个时候就会得到 undefined。\n\n![](image30.png)\n\n### null型\n\n**如何得到null型？**\n\n定义变量的值为null\n\n您也许会问，为什么 typeof ，运算符对于 null 值会返回 \"Object\"。 这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。\n![](image31.png)\n\n\n\n## 复合数据类型\n\n至少存储一个值，可以存储多个值。\n\nObject(对象)、Array(数组)\n\n\n\n# 八、运算符\n\n## 什么是运算符\n\n可以进行运算的符号 比如：+、-、\\*、/\n\n\n\n**运算符可以为分三种：** \n\n一目、二目、三目或 一元、二元、三元\n\n**一目：**指的是运算符的操作数只有一个 比如：i++\n\n**二目：**指的是运算符的操作数有两个 比如：a+b\n\n**三目：**指的是运算符的操作数有三个 `?  :`\n\n\n\n**运算符分为：**\n\n-   算术运算符\n\n-   赋值运算符\n\n-   比较运算符\n\n-   逻辑运算符\n\n-   字符串连接运算符\n\n-   三目运算符\n\n\n\n## 算术运算符\n\n| **符号** | **功能**     |\n| -------- | ------------ |\n| +        | 加法         |\n| -        | 减法         |\n| *        | 乘法         |\n| /        | 除法         |\n| %        | 求余数(取模) |\n| ++       | 自加1运算符  |\n| --       | 自减1运算符  |\n\n---------- --------------\n\n![](image32.png)\n\n![](image33.png)\n\n![](image34.png)\n\n`++`与`--`这两个运算符 一般称之为自操作运算符\n\n`++`与`--`这两个运算符的规则是一样的。\n\n`++`运算符它称之为自加1运算符\n\n`++`运算符它分为前加加和后加加\n\n**前加加：**   `++`符号在变量的前面， 比如：++a;\n\n前加加的运算规则：==先自加1 然后再赋值==\n\n![](image35.png)\n\n**后加加：**`++`符号在变量的后面， 比如：a++;\n\n后加加的运算规则：==先赋值然后再自加1==\n\n![](image36.png)\n\n`--`运算符它称之为自减1运算符\n\n`--`运算符它分为前减减和后减减\n\n**前减减**：`--`符号在变量的前面 ，比如：\\--a;\n\n前减减的运算规则：==先自减1 然后再赋值==\n\n**后减减**：`--`符号在变量的后面 ，比如：a\\--;\n\n后减减的运算规则：==先赋值然后再自减1==\n\n![](image37.png)\n\n**注意：**\n\n-   不管是前加加还是后加加自身都会自加1\n\n-   不管是前减减还是后减减自身都会自减1\n\n## 赋值运算符\n\n![](image38.png)\n\n-   =：将等号右边的值赋值给等号左边的变量\n\n-   +=：将等号左边的变量的值加上等号右边的值然后将其结果赋值给等号左边的变量\n\n-   -=：将等号左边的变量的值减去等号右边的值然后将其结果赋值给等号左边的变量\n\n-   \\*=：将等号左边的变量的值乘以等号右边的值然后将其结果赋值给等号左边的变量\n\n-   /=：将等号左边的变量的值除以等号右边的值然后将其结果赋值给等号左边的变量\n\n-   %=：将等号左边的变量的值与等号右边的值进行求余运算然后将其结果赋值给等号左边的变量\n\n![](image39.png)\n\n![](image40.png)\n\n**我们在使用+= 这些符号的时候的注意事项**\n\n-   += 这些符号的前面没有var关键字\n\n-   += 这些符号必须是紧密相连\n\n\n\n## 字符串连接运算符\n\n**什么是字符串连接？**\n\n使用一定的符号将字符串进行拼接在一起。\n\n![](image41.png)\n\n因为+号它又是算术运算符，又是字符串连接运算符\n\n什么时候它是执行加法运算 ，什么时候是执行字符串连接运算！\n\n-   如果+号两边的变量的数据类型都是数值型的时候， 就会执行加法运算。\n\n-   如果+号两边的有一个变量的数据类型都是字符串类型的时候， 就会执行字符串连接运算。\n\n\n\n**注意：**\n\n变量与字符串要使用+号进行连接\n\n\n\n**工作中：**\n\n\"字符串\"+变量名+\"字符串\"  // 字符串拼接的方法\n\n![](image42.png)\n\n\n\n| **符号** | **功能**   |\n| -------- | ---------- |\n| +        | 字符串连接 |\n| +=       | 字符串连接 |\n\n\n\n![](image43.png)\n\n**需求：使用字符串拼接的方式， 打印出某个人的个人简介， 要求使用无序列表的格式打印 **\n\n![](image44.png)\n\n\n\n## 比较运算符\n\n使用比较运算符会得到boolean类型的值\n\n---------- -----------------------------------\n| **符号** | **功能**                          |\n| -------- | --------------------------------- |\n| >        | 大于                              |\n| <        | 小于                              |\n| >=       | 大于或者等于                      |\n| <=       | 小于等于                          |\n| ==       | 等于  判断==两边的值是否相等      |\n| !=       | 不等于                            |\n| ===      | 全等于 判断数据类型与值是否都相等 |\n| !==      | 不全等                            |\n\n---------- -----------------------------------\n\n**注意：**\n\n比较运算符它最终得到的结果是布尔值：**true和false**\n\n![](image45.png)\n\n\n\n## 三目(三元运算符)\n\n**格式：**\n\n```javascript\n条件表达式 ？条件表达式1 ：条件表达式2;\n```\n\n**说明：**\n\n问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。\n\n**其逻辑为：**\"如果为真执行第一个，否则执行第二个。\"\n\n![](image46.png)\n\n## 逻辑运算符\n\n| **符号** | **说明**      | **功能**                                       |\n| -------- | ------------- | ---------------------------------------------- |\n| &&       | 逻辑与  并且  | &&符号两边的表达式的结果同时为真才为真         |\n| \\|\\|     | 逻辑或   或者 | \\|\\|符号两边的表达式的结果只要有一边为真就为真 |\n| !        | 逻辑非   取反 | 取反操作  将true变为false  将false变为true     |\n\n\n\n![](image47.png)\n\n\n\n# 九、运算符的优先级\n\n为什么会出现运算符的优先级问题？\n\n因为在一个表达式中有可以会出现多个运算符 ，这个时候就要考虑哪一个运算符要进行先运算\n\n有括号就先算括号里面的内容，然后再乘除再加减\n\n\n\n**那么如何去提升运算符的优先级呢？**\n\n加()\n\n\n\n# 十、变量数据类型转换\n\n**什么是数据类型的转换：**\n\n将一种数据类型转换为其它的数据类型！\n\n在JS中变量数据类型的转换分成两种：**自动转换**、**强制转换**！\n\n自动转换是系统自己完成的！我们看不到系统转换的过程！\n\n代码在运行的过程中 ，它会根据上下文的环境进行变量的数据类型的自动转换！\n\n![](image48.png)\n\n**自动转换与强制转换的结果是一样的！**\n\n\n\n## 强制转换\n\n**注意：**强制转换是通过JavaScript中的三个系统函数来完成的。\n\n### 函数：Number(变量名)\n\n作用：将其它的数据类型强制的转换为数值型\n\n在数值型数据中有一个特殊的数据叫NaN(Not a Number)这不是一个数 ，为什么会出现NaN呢？当将其它的变量的数据类型转换为Number的时候， 如果不能直接的转换过来， 就会变成NaN\n\n**注意** \n\n![](image49.png)\n\n---------------------------------- ------------------\n**规则：**\n\n| **数据格式**                              | **转换后的结果** |\n| ----------------------------------------- | ---------------- |\n| “数字”                                    | 数字             |\n| 只要是在字符串中含有非数字的都会转换为NaN | NaN              |\n| “字符数字”                                | NaN              |\n| “字符”                                    | NaN              |\n| “” 和“ ”   空字符串和有空格的字符串       | 0                |\n| true                                      | 1                |\n| false                                     | 0                |\n| null                                      | 0                |\n| undefined                                 | NaN              |\n\n---------------------------------- ------------------\n\n\n\n### 函数：Boolean(变量名)\n\n将其它的数据类型强制的转换为布尔型 (结果：true和false)\n\n| **数据格式**       | **转换后的结果** |\n| ------------------ | ---------------- |\n| null和undefined    | false            |\n| 0和””和NaN         | false            |\n| “0”                | true             |\n| 1                  | true             |\n| “ ” 有空格的字符串 | true             |\n| “有具体内容的”     | true             |\n\n-------------------- ------------------\n\n**总结：**\n\n**将number类型转换为boolean类型， 只有0与NaN是false ，其它的都是true**\n\n**null与undefined 转换为boolean类型 是false **\n\n**将String转换为boolean类型 ，只有空字符串是false ，其它的字符串都是true， 只要是这个字符串里面有内容 ，就是true **\n\n![](image50.png)\n\n\n\n### 函数：String(变量名)\n\n将其它的数据类型强制的转换为字符串型\n\n转换规则是：**在其它的数据类型的外面包裹一个引号 **\n\n![](image51.png)\n\n**注意：**\n\n自动转换与强制转换的结果是一样的。\n\n\n\n# 十、流程控制\n\n**什么是流程控制？**\n\n意指在程序运行时，个别的指令（或是陈述、子程序）求值的顺序。\n\n\n\n**流程控制分为三种结构：**\n\n**顺序结构**、**选择(分支)结构**、**循环结构**\n\n\n\n## 顺序结构\n\n代码从上至下 一行一行进行解析！\n\n![](image52.png)\n\n## 分支结构\n\n虽然有多种选择，但是最终只会选择一个。\n\n**if语句和switch语句**\n\n\n\n==if语句分为三种分支==\n\n### 单分支\n\n**语法：**\n\n```\nif(条件表达式){\n\t要执行的代码块\n}\n```\n\n**结构说明：**\n\n当条件表达式成立时，才会执行代码块。\n\n条件表达式成立指的是：得到布尔类型的值为true 就表示成立。\n\n流程图：\n\n![1539447871060](1539447871060.png)\n\n![](image54.png)\n\n输入对话框\n\n![](image55.png)\n\n在浏览器中弹出一个输入对话框\n\n`window.prompt(Message,defaultValue);`\n\n这个方法有两个参数，这两个参数可以写也可以不写\n\nMessage：表示提示信息\n\ndefaultValue：默认值\n\n如果用户点击了确定按钮会得到一个字符串类型的数据！\n\n如果用户点击了取消按钮会得到 null\n\n![](image56.png)\n\n### 双分支\n\n**语法：**\n\n```\nif(条件表达式){\n\t执行代码块1\n}else{\n\t执行代码块2\n}\n```\n\n**结构说明：**  \n\n如果条件表达式成立的话就执行代码块1，反之如果不成立就执行代码块2\n\n流程图：\n\n![1539447906874](1539447906874.png)\n\n![](image58.png)\n\n### 多分支\n\n多分支也称之为多条件判断\n\n**语法：**\n\n```php\nif(条件表达式1){\n\t\t代码块1\n}else  if(条件表达式2){\n\t代码块2\n} else  if(条件表达式3){\n\t代码块3\n} else  if(条件表达式n){\n\t代码块n\n}else{\n\t默认代码块    \n}\n```\n\n**结构说明：**\n\n-   第一步：先去判断条件表达式1是否成立 ，如果成立就执行代码块1 ，然后就结束if语句 ，如果不成立\n\n-   第二步：判断条件表达式2是否成立， 如果成立就执行代码块2， 然后就结束if语句， 如果不成立\n\n-   第三步：判断条件表达式3是否成立 ，如果成立就执行代码块3 ，然后就结束if语句 ，如果不成立\n\n-   第四步：判断条件表达式n是否成立 ，如果成立就会执行代码块n ，然后就结束if语句 ，如果不成立\n\n-   第五步：前提是有写else语句 ，else语句可以省略不写， 上面的所有的条件表达式都不成立 ，就会执行else语句里面的代码块\n\n流程图：\n\n![1539448074587](1539448074587.png)\n\n![](image60.png)\n\n通过上面的代码我们看出有bug ，要求用户输入的必须是在0\\~100之间来控制，\n\n涉及到if语句的嵌套 ，if语句里面是可以再来嵌套if语句\n\n![](image61.png)\n\n### switch语句\n\n**语法：**\n\n```\nswitch(变量名){\n    case 值1:\n    \t代码块1;\n    \tbreak;\n    case 值2:\n        代码块2\n        break;\n    case 值3:\n        代码块3;\n        break;\n    case 值n:\n        代码块n;\n        break;\n    default:\n    \t默认执行的代码块！\n}\n```\n\n**结构说明：**\n\nswitch语句它是拿小括号中变量的值去与每一个case后面的值进行全等比较 ，如果比较成功(true) 就会执行对应的代码块 ，还要去查找是否有break关键字， 如果有break关键字 ，那么switch语句就会结束 。\n\n但是如果没有break关键字 ，就会先执行下面的代码块， 然后再判断是否有break关键字 ，它要找到break关键字才会结束执行。\n\n如果说变量的值与case中每一个值都不相等 ，那么它就会执行默认的代码块。\n\n流程图：\n\n![1539448304460](1539448304460.png)\n\n![](image63.png)\n\n**关于if语句与switch之间的区别：**\n\n一般if语句用于范围之间的判断\n\nswitch语句一般用于固定值之间的判断\n\n因为SWITCH能够实现的功能， 我们其实完全可以使用IF语句多分支来实现！\n\n\n\n**案例：输出今天星期几？**\n\n**第一步：如何通过JS来获取到系统的时间**![](image64.png)\n\n通过new Date()可以创建一个时间日期对象\n\n**第二步：从时间日期对象中获取一周中的某一天 **\n\n通过时间日期对象.getDay()方法来获取一周中的某一天 。返回值：0\\~6之间的一个整数。 0表示星期天， 6表示星期6 \n\n![](image65.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<script type=\"text/javascript\">\n\t\t//在浏览器打印今天星期几  \n\t\t//1.获取电脑的时间   如何获取：在JS中有一个内置对象  Date() \n\t\tvar myDate = new Date(); //将创建的时间日期对象赋值给变量myDate 这个时候 myDate就是代表这个时间日期对象  对象是由属性与方法 组成 然后我们需要通过myDate这个对象来获取一周中的某一天 \n\t\tvar week = myDate.getDay(); //获取一周中的某一天  返回值：0~6之间的一个整数  0表示星期天  6表示星期六 \n\t\t//通过switch语句来输出今天星期几 \n\t\tvar str = \"今天星期\";\n\t\tswitch(week){\n\t\t\tcase 1:\n\t\t\t\tstr += \"一\";\n\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tstr += \"二\";\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tstr += \"三\";\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tstr += \"四\";\n\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tstr += \"五\";\n\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tstr += \"六\";\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr += \"天\"\n\n\t\t}\n\n\t\tdocument.write(str);\n\t</script>\n</body>\n</html>\n```\n\n\n\n## 循环结构\n\n在满足一定的条件下， 重复执行某些代码！\n\n**for循环**、**while循环**、**do...while循环**\n\n\n\n### for循环\n\n**语法：**\n\n```\nfor(定义变量;条件语句;变量更新){\n\t循环体 //重复做的事情\n}\n```\n\n**结构说明：**\n\n-   第一步：变量初始化 ，定义一个变量并给其赋值 ，它只会执行一次\n\n-   第二步：判断条件表达式是否成立 ，如果成立就执行第三步， 如果不成立就会结束for循环\n\n-   第三步：假设条件表达式成立， 执行循环体\n\n-   第四步：对变量进行更新 ，变量更新完毕以后接下来就会重复第二步\\--第三步\\--第四步\n\n-   一直到条件表达式不成立了 ，然后for循环才会结束\n\n流程图：\n\n![1539448591920](1539448591920.png)\n\n例1：使用for循环来输出10个hello\n\n![](image67.png)\n\n例2：使用for循环来输出1到100之间的数。\n\n![](image68.png)\n\n例3：使用for循环来求1到100之间的和\n\n![](image69.png)\n\n例4：求某一个数的阶乘\n\n![](image70.png)\n\n例5：使用for循环来求1到100之间的偶数的和。\n\n![](image71.png)\n\n例6：恶心的游戏数字7\n\n大家从小到大，都玩儿过的一个庸俗的游戏：\n\n游戏玩儿法就是，大家轮流报数，如果报到能被7整除的数字，或者尾数是7的数字，都算踩地雷了。就应该罚唱歌。\n\n请在控制台输出1\\~60之间的所有\"安全数\"。\n\n比如：\n\n1、2、3、4、5、6、8、9、10、11、12、13、15、16、18、19、20、22、23、24、25、26、29、30......\n\n**思路：**\n\n先应该得到1-60之间所有的数\n\ni%7 != 0 表示不是7的倍数\n\ni%10 !=7 表示个位数不为7\n\n![](image72.png)\n\n例7：使用for循环输出一个9行一列的表格\n\n![](image73.png)\n\n![](image74.png)\n\n例8：使用for循环输出一个1行9列的表格\n\n![](image75.png)\n\n例9：使用for循环输出一个9行9列的表格\n\n![](image76.png)\n\n例10：使用for循环来实现99乘法表\n\n![](image77.png)\n\n\n\n### while循环\n\n**语法：**\n\n```\n定义变量\nwhile(条件表达式){\n    //循环体\n    变量更新\n}\n```\n\n**结构说明：**\n\n当条件表达式成立的时候就执行循环体，反之如果条件表达式不成立就结束while循环！\n\n流程图：\n\n![1539448709167](1539448709167.png)\n\n![](image79.png)\n\n使用while循环打印99乘法表\n![](image80.png)\n\n\n\n###  do\\...while循环\n\n**语法：**\n\n```\ndo{\n\t//循环体\n}while(条件表达式);\n```\n\n**结构说明：**\n\n-   先执行一次循环体，然后再来判断条件表达式是否成立。如果条件表达式成立就继续执行循环体，如果不成立就会结束do while循环。\n\n-   不管条件表达式是否成立，do while循环都会执行一次循环体。\n\n流程图：\n\n![1539448803869](1539448803869.png)\n\n使用do while来求1-100之间数！\n\n![](image82.png)\n\n**什么时候使用for循环什么时候使用while循环?**\n\n答： 不是绝对的\n\n已知循环次数的时候多用for循环\n\n未知循环次数的时候一般用while循环\n\n\n\n**while与do...while之间的区别**\n\nwhile循环是先判断条件表达式再来执行循环体\n\ndo...while先执行一次循环体， 再来判断条件表达式是否成立 。不管条件表达式成不成立， 它先会执行一次循环体 。\n\n\n\n# 十一、循环提前的终止\n\n典型的，当条件表达式不成立了，那么循环体就会终止执行。也可以称之为循环它寿终正寝了。\n\n**循环提前终止**：本来条件表达式是成立了，循环体还可以继续的往下执行，但是我们可以使用一些关键字让其提前终止。\n\n**break**和**continue** 循环终止的关键字 都需要配合 if语句来实现\n\n主要的作用是==为了提升循环的效率== ！\n\n## break\n\n**终止，**当在循环体中遇到了break关键字以后，整个循环语句就会直接结束。不会再执行。\n\n![](image83.png)\n\n## continue\n\n**继续，**它会终止当前循环体，那么继续执行下一次循环体。\n\n![](image84.png)\n\n\n\n# 十二、四个常用的系统函数\n\n## parseInt\n\n**语法：**\n\n```\nparseInt(变量名);\n```\n\n**作用：**从一个变量中提取整数！\n\n**提取规则：**如果变量第一个字符不是数字， 就会返回NaN ，它会遇到非数字就停止提取！\n\n## parseFloat\n\n**语法：**\n\n```\nparseFloat(变量名);\n```\n\n**作用：**从一个字符串提取小数！\n\n**提取规则：**如果字符串第一个字符不是数字 ，就会返回NaN ，它如果遇到除第一个`.`以外的非数字就会停止提取！\n\n![](image85.png)\n\n## isNaN\n\n```\nisNaN(变量名);\n```\n\n如果是NaN就返回true ，如果不是的就是false。\n\n**作用：**先将一个变量的数据类型自动的转换为Number ，如果是NaN就会得到true　；如果是一个数字的话就是得到false。\n\n\n\n## window.prompt\n\n这个方法是属性window对象的方法\n\n```\nwindow.prompt()\n```\n\n这个方法是用来向浏览器中弹出一个用户输入对话框\n\n![](image86.png)\n\n第一个参数：`text`  表示提示信息\n\n第二个参数：`defautlText`  表示输入框的中默认文本 默认值\n\n但是注意：这两个参数都可以省略不写！\n\n\n\n这个方法有两个按钮 ：确定按钮、取消按钮\n\n当用户点击确定按钮时会得到一个String类型的数据\n\n当用户点击取消按钮会得到一个关键字 null\n\n\n\n# 十三、数组\n\n## 什么是数组？\n\n数组是一组数据有序的集合。数组它是属于复合数据类型。至少可以存储一个值。\n\n## 为什么要使用数组？\n\n因为在我们工作中， 有很多数据是有关联的。 我们要表示的时候想把这些数据用一个\"东西\"来存储，这个时候就可以用到数组！\n\n![](image87.png)\n\n## 数组的相关概念\n\n### 数组元素\n\n指数组中的每一个数据！我们就把它们称之为数组元素\n\n### 数组下标(索引)\n\n每一个数组元素都对应着一个数组下标， 数组的下标是从0开始， 第一个数组元素的下标是0，第二个数组元素的下标为1 ，第三个数组元素的下标为2 依此类推！\n\n下标的主要作用就是为了方便找到数组中的元素！\n\n\n\n### 如何访问数组里面的某一个元素\n\n**格式：**\n\n```\n数组变量名[下标]\n```\n\n![](image88.png)\n\n### 数组长度\n\n**数组的长度：**数组中元素的总个数\n\n其实数组的变量名是一个数组对象\n\n\n\n**如何去计算数组的长度：**\n\n`数组变量名.length`\n\n在JS中， 数组对象下面有一个length的属性， 这个属性可以得到数组的长度。\n\n![](image89.png)\n\n**数组的长度与最大下标之间有什么关系 ？** \n\n**最大下标**=数组的长度-1\n\n![](image90.png)\n\n## 定义数组\n\n### 使用\\[\\]来定义数组\n\n第一种方式：先定义一个空数组 ，再往这个空数组中添加数组元素\n\n第二种方式：在定义数组时候直接添加数组元素\n\n![](image91.png)\n\n![](image92.png)\n\n### 使用new关键字和Array()方法来定义数组 \n\n![](image93.png)\n\n第一种方式：创建一个空数组\n\n第二种方式：创建一个数组 ，要指定数组的长度\n\n第三种方式：创建一个数组 ，并指定数组元素\n\n![](image94.png)\n\n**注意：**\n\n在工作中一般都是使用\\[\\]来创建数组， 基本上不会使用new关键字和Array方法来创建。\n\n\n\n# 十四、多维数组\n\nJavaScript它本身是没有多维数组的概念，因为在JavaScript中， 数组元素的数据类型可以是任意数据类型。假设在一个数组中有一些数组元素的的类型还是数组， 这个时候我们就将它称之为多维数组！\n\n## 一维数组\n\n简单来说，一个数组内所有的元素的数据类型的都不是数组类型，就是一维数组。\n\n## 多维数组\n\n超过一维都是可以叫多维，多维数组指的是一个数组中的元素又是一个数组。\n\n![](image95.png)\n\n## 如何访问二维数组的里面的数组元素呢？\n\n**格式：**\n\n```\n数组变量名[一维数组的下标][二维数组的下标];\n```\n\n![](image96.png)\n\n\n\n# 十五、数组的遍历\n\n## 什么是数组的遍历？\n\n操作数组中的每一个数组元素\n\n## 使用for循环来遍历数组\n\n因为数组的下标是连续的，数组的下标是从0开始。\n\n我们也可以得到数组的长度。\n\n**格式：**\n\n```\nfor(var i=0;i<数组的长度;i++){\n\t数组变量名[i]\n}\n```\n\n**注意：条件表达式的写法 **\n\n-   i\\<数组的长度\n\n-   i\\<=数组的长度-1\n\n![](image97.png)\n\n![](image98.png)\n\n求数组中的最大值\n\n![](image99.png)\n\n## 使用for..in语句来遍历数组\n\nfor..in它本身是用来遍历对象的，因为数组也是属于对象的一种，那么也可以使用for..in语句来遍历数组\n\n**格式：**\n\n```\nfor(var 变量名 in数组变量名){\n\t数组变量名[变量名]\n}\n```\n\n**注意：**\n\n一般情况下我们都会使用for循环来遍历数组，因为使用for循环遍历数组非常直观。\n\n![](image100.png)\n\n**案例：使用数组的方式来实现输出今天星期几 **\n\n![](image101.png)\n\n## 遍历二维数组\n\n![](image102.png)\n\n\n\n# 十六、函数\n\n## 什么是函数？\n\n函数是可以被命名的，它是为了解决某些功能的代码段！\n\n**可以被命名：**表示函数是可以有名字的，也是可以没有名字的。\n\n**代码段：**函数体\n\n## 为什么要使用函数？\n\n为了解决代码的重用！\n\n减少代码量。\n\n## 函数的分类\n\n**系统内置函数**和**自定义函数**\n\n\n\n## 定义函数\n\n```\nfunction 函数名([参数列表]){\n\t//函数体\n}\n```\n\n![](image103.png)\n\n**结构说明：**\n\n-   function它是定义函数的关键字 不可以省略。\n\n-   函数名它的命名规则与变量名是一样的\n\n    -   可以使用大小写英文字母、下划线(\\_)、美元符号(\\$)、数字组成\n\n    -   不能使用数字开头\n\n    -   不能使用JS中的关键字和保留字作为函数名\n\n    -   如果函数是由多个单词组成的，那么可以使用下划线连接法和驼峰法\n\n    -   严格区分大小写\n\n-   函数名后面紧跟着一对小括号 这一对小括号不能省略\n\n-   小括号里面可能有参数，我们将其称之为形参\n\n-   小括号后面紧跟着一对大括号 这一对大括号不能省略\n\n-   大括号里面是函数体\n\n> **注意：**函数定义了一定要调用函数才能发挥其作用\n\n## 调用函数\n\n![](image104.png)\n\n**格式：**\n\n```\n函数名([实参列表])\n```\n\n**注意：**在定义函数时如果有形参， 反过来说， 在调用的时候也要有实参 ，但是这个不是绝对的！\n\n-   同名函数后面的会将前面的覆盖\n\n![](image105.png)\n\n-   函数一定是先定义后再调用\n\n![](image106.png)\n\n**什么叫预解析**：在JS中的变量与函数， 会将变量的声明与函数的声明， 提升到当前script标签的最前面！\n\n![](image107.png)\n\n## 函数的参数 \n\n**函数的参数分为两种：**\n\n==形式参数==和==实际参数==\n\n**形式参数：**在定义函数的时候的参数就称之为形式参数，简称\"**形参**\"\n\n在定义函数的时候， 在函数名的后面的小括号里面给的变量名。\n\n**实际参数：**在调用函数的时候的参数就称之为实际参数，简称\"实参\"\n\n![](image108.png)\n\n![](image109.png)\n\n![](image110.png)\n\n在一个函数中，参数的多少是根据功能来定义的！\n\n使用函数来动态的输出M行N 列的表格\n\n![](image111.png)\n\n##  return关键字\n\n一般在函数体里面不会有输出语句，只会有一个return关键字，将我们要输出的内容返回给函数的调用者。\n\n-   return在英文中表示\"返回\"的意思\n\n-   return关键字是在函数体里面使用。\n\n**它在函数体使用有两层含义：**\n\n1.  当函数体里面遇到了return关键字以后，当前的这个函数就不会再往下进行执行了。\n\n![](image112.png)\n\n2.  它会向函数的调用者返回数据 (返回值) \n\n    **格式：** `return 数据;`\n\n**在调用函数时， 可以定义一个变量要接收到这个函数的返回值 **\n\n![](image113.png)\n\n**注意：**\n\n我们在以后的工作中，函数体里面尽量不要有输出语句(document.write alert console.log )，尽量的使用return关键字将数据返回给函数的调用者。\n\n**特别强调：**\n\n-   在一个函数里面，return关键字可以有多个，但是return只会执行一次\n\n-   return关键字它只能返回一个数据，如果需要返回多个数据，我们可以将多个数据使用数组的方式来保存，然后再将数组返回。\n\n![](image114.png)\n\n# 十七、匿名函数\n\n## 什么是匿名函数？\n\n没有名字的函数 称之为匿名函数！ 注意：**匿名函数在JS中使用最多**\n\n\n\n## 匿名函数也是需要调用的\n\n**将匿名函数赋值给变量或者是事件**\n\na)  将匿名函数赋值给变量，然后通过变量名加上小括号来调用匿名函数\n\n![](image115.png)\n\nb)  将匿名函数赋值给事件\n\n将匿名函数赋值给事件 ，那么匿名函数什么时候才会执行？它要等到事件触发了以后， 匿名函数才会执行。\n\n![](image116.png)\n\nc)  匿名函数的自调用 ，匿名函数自己调用自己 ，在一些JavaScript框架中， jQuery 都是匿名函数自调用， 自己使用JS制作框架\n\n![](image117.png)\n\n\n\n# 十八、变量的作用域\n\n## 什么是变量的作用域？\n\n指变量在什么地方可以使用，什么地方不可以使用。\n\n## 变量作用域的分类\n\n变量作用域分为：**全局作用域和局部作用域。**\n\n变量的作用域是通过函数来进行划分的。\n\n在函数外面定义的变量我们将其称为**全局变量**，它的作用域是全局的。\n\n**全局作用域：**变量在函数外面和函数里面都可以使用。\n\n![](image118.png)\n\n在函数里面定义的变量我们将其称为**局部变量**，它的作用域是局部的。\n\n**局部作用域：**变量只能在该函数里面使用，在函数外面不可以使用。\n\n![](image119.png)\n\n**问：**是否能够提升局部变量的作用域呢？将局部变量的作用域提升至全局作用域。\n\n在函数里面定义的变量也能够在函数外面访问到。\n\n只需要将函数里面定义的变量的var关键字给去掉就可以实现将局部变量的作用域提升至全局作用域。\n\n![](image120.png)\n\n但是：并不建议直接就var 关键字给省略，我们建议在函数的外面定义一个同名的全局变量。\n\n定义一个函数， 这个函数的主要功能就是返回三个数的和 这三个数要通过参数传递进去\n\n\n\n# 十九、值传递与引用传递\n\n传递\\--赋值 ，变量与变量之间的赋值操作， 就称为传递！\n\n**注意：**\n\n-   基本数据类型之间的赋值操作都是**值传递**，\n\n-   复合数据类型之间的赋值操作都是**引用传递**。\n\n## 值传递\n\n将一个变量的值赋值给另外一个变量，如果修改其中一个变量的值，不会影响到另外一个变量的值！这两个变量之间是没有任何的联系。\n\n![](image121.png)\n\n![](image122.png)\n\n## 引用传递\n\n将一个变量的内存地址赋值给另外一个变量，如果修改其中一个变量的值，会影响到另外一个变量的值，这两个变量之间是有联系的。\n\n变量名变量值之间的关系！\n\n变量名引用变量值 ，变量值被变量名所引用！\n\n![](image123.png)\n\n![](image124.png)\n\n变量如何在内存中存储！\n\n内存它是分区域：**栈区和堆区 **\n\n**栈区：**空间小，速度快。 主要存储变量名以及值在堆区的地址\n\n**堆区：**空间大，速度慢。 主要存储变量的值\n\n\n\n# 二十、对象\n\n## 什么是对象？\n\n对象是由属性与方法组成。在JavaScript中一切皆是对象！\n\n**对象中的属性**  ：其实就是我们之前学习的变量\n\n**对象中的方法**  ：其实就是我们之前学习的函数\n\n## 对象的分类\n\n==自定义对象==和==内置对象==\n\n## 如何创建自定义对象\n\n1）使用new关键字和Object()方法来创建自定义对象\n\n![](image125.png)\n\n> //this 在英文中表示这个 那个的意思 。没有具体的指向， 它要根据当前的语言环境来指。\n>\n> //表示当前对象 this关键字一般用于方法中 ，它来表示当前对象 ，哪个对象调用当前的方法， this关键字就表示哪个对象。\n\n2）使用{}来创建自定义对象\n\n**格式：**\n\n```\nvar 变量名 = {\n    属性名:值,\n    属性名:值,\n    方法名:匿名函数\n}\n```\n\n![](image126.png)\n\n\n\n## 内置对象分类\n\n-   **String对象**：提供了处理字符串的属性与方法。\n\n-   **Array对象**：提供了一些操作数组的属性与方法\n\n-   **Math对象**：提供了一些操作数学方面属性与方法\n\n-   **Date对象**：提供了一些对时间日期操作的方法\n\n-   **Number对象**：它主要是提供了一个操作数值的方法\n\n-   **Events对象**：提供对JavaScript事件的处理信息。\n\n\n\n### String对象\n\n#### 如何创建String对象\n\n1)  定义的字符串变量名其实就是一个字符串对象。隐式创建\n\n2)  使用new关键字和String()方法来创建。 显示创建\n\n![](image127.png)\n\n#### String对象的属性\n\n| **属性名**          | **功能**                                                     |\n| ------------------- | ------------------------------------------------------------ |\n| StringObject.length | 得到字符串对象的长度    **注意**：这里的长度指的字符的个数！ |\n\n![](image128.png)\n\n\n\n#### String对象的方法\n\n\n| **方法名**                                                   | **功能**                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| StringObject.substr(startIndex,[length])   参数说明：   startIndex：开始下标   length：可缺省的  表示的是要截取的长度 | 截取字符串    从startIndex(开始下标)处开始截取  如果length (长度)没有书写 表示一直截取到字符串的末尾   如果有写则表示截取的长度 |\n| StringObject.split(sep)   参数说明：   sep：指定的分隔符     | 使用指定的分隔符将一个字符串分隔为一个数组                   |\n| StringObject.substring(startIndex,[stop])   参数说明：   startIndex：开始下标   stop：可缺省的  表示的是要结束的下标 | 截取字符串    从startIndex(开始下标)处开始截取  如果stop(长度)没有书写 表示一直截取到字符串的末尾   如果有写则表示截取到结束下标的前一个位置 |\n| StringObject.lastIndexOf(substr) | 查找substr这个字符串或者是字符在StringObject这个对象中最次出现的位置    如果找的到就返回其下标    反之如果没有就返回-1   如果查找的是多个字符  如果找的到就返回第一个字符的下标 |\n| StringObject.indexOf(substr) | 查找substr这个字符串或者是字符在StringObject这个对象中首次出现的位置    如果找的到就返回其下标    反之如果没有就返回-1   如果查找的是多个字符  如果找的到就返回第一个字符的下标 |\n| StringObject.charAt(index) | 返回一个指定下标的字符！   参数说明：   index：指定的下标值！ |\n\n\n\n\n**要访问指定下标的字符有两种方式：**\n\n-   StringObject.charAt(指定的下标)\n\n-   StringObject\\[指定的下标\\] 建议使用\n\n![](image129.png)\n\n\n\n**案例：判断用户名中是否有特殊的符号**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<script type=\"text/javascript\">\n\t\t//判断用户名是否有特殊符号  \n\t\tvar user = \"tia<n#qi\";\n\t\t\n\t\tfunction checkUser(username){\n\t\t\t//判断useranme是否有非法字符  \n\t\t\tvar arr = ['#',\"<\",\">\",\"%\",\"*\"];\n\n\t\t\tfor(var i=0;i<username.length;i++){\n\t\t\t\tfor(var j=0;j<arr.length;j++){\n\t\t\t\t\tif(arr[j] == username[i]){\n\t\t\t\t\t\t//我们会用到return关键字的两层含义：1.中断函数往下执行 2.向函数的调用者返回值 \n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//如果能够执行下一行代码 就表示没有非法字符 \n\t\t\treturn true;\n\n\t\t}\n\n\t//我们应该有一个函数  这个函数就是用来判断用户名是否有非法字符 如果有就输出 用户名中有非法字符  如果没有 就提示用户名合法 \n\t//这个函数有返回值  如果返回true 就表示合法 如果返回false就表示有非法字符 \n\t\n\tvar flag = checkUser(user);// 调用函数得到函数的返回值 \n\n\tif(flag == true){\n\t\tdocument.write(\"用户名合法\");\n\t}else{\n\t\tdocument.write(\"用户名有非法字符 \");\n\t}\n\n\t</script>\n</body>\n</html>\n```\n\n\n\n\nStringObject.substr方法如下图：\n\n![](image130.png)\n\nStringObject.substring\n\n![](image131.png)\n\n获取文件的扩展名\n\n![](image132.png)\n\nStringObject.split()\n\n![](image133.png)\n\n-   获取文件的扩展名， 使用split方法来获取\n\n![](image134.png)\n\n\n\n| **方法名**                                                   | **功能**                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| StringObject.replace(reg,str)   <br />参数说明：   reg：规定了要替换的模式的 RegExp 对象   str：被替换的内容 | 使用str参数里面的内容替换reg的第一次匹配或所有匹配之后得到的内容 |\n\n下图所示：只替换了一个hello\n\n![](image135.png)\n\n下图所示：替换所有的hello\n\n![](image136.png)\n\n\n\n### Array对象\n\n#### 如何创建Array对象\n\n1)  使用\\[\\]来创建\n\n2)  使用new关键字和Array()方法来创建\n\n![](image137.png)\n\n####  Array对象的属性\n\n------------------------ -------------------------------\n| **属性名**             | **功能**                       |\n| ---------------------- | ------------------------------ |\n| **ArrayObject.length** | 返回数组的长度  数组元素的个数 |\n\n------------------------ -------------------------------\n\n![](image138.png)\n\n####  Array对象的方法\n\n----------------------------------------------- -------------------------------------------------------\n| **方法名**                              | **功能**                                              |\n| --------------------------------------- | ----------------------------------------------------- |\n| ArrayObject.push(数组元素1,数组元素2….) | 向数组的末尾添加一个或者多个数组元素 并将新的长度返回 |\n\n----------------------------------------------- -------------------------------------------------------\n\n![](image139.png)\n\n----------------------- ------------------------------\n| **方法名**            | **功能**                     |\n| --------------------- | ---------------------------- |\n| **ArrayObject.pop()** | 删除并返回数组的最后一个元素 |\n\n----------------------- ------------------------------\n\n![](image140.png)\n\n| **方法名**                                                   | **功能**                         |\n| ------------------------------------------------------------ | -------------------------------- |\n| **ArrayObject.join([sep])**   <br />**参数说明：**   sep：表示连接的符号 可缺省的   如果这个参数没有写 则默认使用英文下面的逗号进行连接，如果有写就使用指定的连接符号来进行连接 | 将数组里面的元素合并为一个字符串 |\n\n![](image141.png)\n\nArrayObject.concat(array1,array2\\...\\...)\n\n![](image142.png)\n\n-   `ArrayObject.unshift ` 向数组的开头添加一个或者是多个数组元素\n\n-   `ArrayObject.shift `删除数组中第一个元素\n\n### Date对象\n\n#### 如何创建Date对象\n\n1)  使用new关键字和Date()方法来创建， 带参数 ，获取指定的时间日期对象\n\n2)  使用new关键字和Date()方法来创建 ，不带参数 ，获取系统当前的时间日期对象\n\n![](image143.png)\n\n#### Date对象的方法\n\n| **方法名**                           | **功能**                                                   |\n| ------------------------------------ | ---------------------------------------------------------- |\n| **DateObject.getFullYear()**         | 获取4位数的年份                                            |\n| **DateObject.getMonth()**            | 获取月份 返回值 0~11   0表示1月  11表示12月                |\n| **DateObject.getDate()**             | 返回一个月中的某一天    返回值：1~31                       |\n| **DateObject.getHours()**            | 小时 返回值0~23                                            |\n| **DateObject.   getMinutes()**       | 获取分钟  返回值：0~59                                     |\n| **DateObject.getSeconds()**          | 获取秒数 返回值：0~59                                      |\n| **DateObject.getMilliseconds()**     | 获取毫秒 返回值：0~999                                     |\n| **DateObject.getDay()**              | 获取一周中的某一天  返回值：0~6                            |\n| **DateObject.getTime()**             | 获取时间戳  返回从1970年1月1日 一直到现在的毫秒数！        |\n| **DateObject.** **toLocaleString()** | **根据本地时间把 Date** **对象转换为字符串，并返回结果。** |\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<script type=\"text/javascript\">\n\n\t\t//封闭一个前导0的函数  \n\t\n\t\tfunction zeroFill(m){\n\t\t\t/*if(m<10){\n\t\t\t\treturn '0'+m;\n\t\t\t}else{\n\t\t\t\treturn m;\n\t\t\t}*/\n\t\t\t//如果条件如果为真 就执行:前面  否则就执行:后面\n\t\t\treturn m<10 ? '0'+m : m;\n\t\t}\n\n\t\t//创建时间日期对象\n\t\tvar myDate = new Date(); \n\t\tvar year   = myDate.getFullYear();\n\t\tvar month  = myDate.getMonth();   // 0~11  0表示1月份 11 表示12月\n\t\tvar day    = myDate.getDate(); // 1-31  \n\t\tvar hour   = myDate.getHours(); // 0~23  \n\t\tvar mill   = myDate.getMinutes(); //0~59 \n\t\tvar sec    = myDate.getSeconds(); //0~59\n\t\tvar m      = myDate.getMilliseconds(); //0~999\n\t\tvar week   = myDate.getDay();  //0~6 \n\t\t//将时间日期对象转换为以本地时间方式来显示  字符串格式\n\t\tvar toString = myDate.toLocaleString(); \n\n\t\tvar str = \"<h2>输出当前的时间日期</h2>\";\n\t\t\tstr += \"今年是：\"+year;\n\t\t\tstr += \"<br/>本月是：\"+zeroFill(month +1);\n\t\t\tstr += \"<br/>本日是：\"+zeroFill(day);\n\t\t\tstr += \"<br/>当前小时是：\"+zeroFill(hour);\n\t\t\tstr += \"<br/>当前分钟是：\"+zeroFill(mill);\n\t\t\tstr += \"<br/>当前秒数是：\"+zeroFill(sec);\n\t\t\tstr += \"<br/>当前毫秒数是：\"+m;\n\t\t\tstr += \"<br/>今天星期：\"+week;\n\n\t\t\tvar s = year+\"-\"+month;\n\n\t\t\tdocument.write(str);\n\n\t\t\tdocument.write(\"<hr/>\");\n\t\t\tdocument.write(toString);\n\t\t\tdocument.write(\"<br>\");\n\t\t\t//毫秒时间戳 从1970年1月1日0时0分0秒0毫秒到现在毫秒数\n\t\t\tdocument.write(myDate.getTime());\n\t</script>\n</body>\n</html>\n```\n\n\n\n### Math对象\n\n**注意：**Math对象不需要创建， 直接使用即可！\n\n> Math关键字就是对象名\n\n#### Math对象的属性\n\n------------- ----------\n| **属性名**  | **功能** |\n| ----------- | -------- |\n| **Math.PI** | 求圆周率 |\n\n------------- ----------\n\n![](image144.png)\n\n#### Math对象的方法\n\n----------------- ---------------\n| **方法名**      | **功能**      |\n| --------------- | ------------- |\n| **Math.abs(x)** | 返回x的绝对值 |\n\n----------------- ---------------\n\n![](image145.png)\n\n------------------- ------------------------------------------------\n| **方法名**        | **功能**                                        |\n| ----------------- | ----------------------------------------------- |\n| **Math.ceil(x)**  | 对x进行向上取整  得到一个比当前数要大的最小整数 |\n| **Math.floor(x)** | 对x进行向下取整 得到一个比当前数要小的最大整数  |\n\n------------------- ------------------------------------------------\n\n![](image146.png)\n\n![](image147.png)\n\n-------------------- -----------------\n| **方法名**         | **功能**        |\n| ------------------ | --------------- |\n| **Math. round(x)** | 对x进行四舍五入 |\n\n-------------------- -----------------\n\n![](image148.png)\n\n\n\n| **方法名**     | **功能**                                     |\n| -------------- | -------------------------------------------- |\n| Math. random() | 返回0~1之间的随机数 但是包含0不包含1   [0,1) |\n\n![](image149.png)\n\n![](image150.png)\n\n想要得到10\\~20之间的随机数 或者是20\\~30之间的随机数 或者是40\\~50之间的随机数！\n\n如何通过上面的方法可以得到我们想要的指定区间的随机数！\n\n------------\n\n| **原始值** |            | **0**  | **0.1** | **0.2** | **0.3** | **0.4** | **0.5** | **0.6** | **0.7** | **0.8** | **0.9** |\n| ---------- | ---------- | ------ | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |\n| **10~20**  | ***10+10** | **10** | **11**  | **12**  | **13**  | **14**  | **15**  | **16**  | **17**  | **18**  | **19**  |\n| **20~30**  | ***10+20** | **20** | **21**  | **22**  | **23**  | **24**  | **25**  | **26**  | **27**  | **28**  | **29**  |\n\n公式\tMath.floor(Math.random()\\*(最大值-最小值)+最小值)  包含最小值不包含最大值  \n公式\tMath.floor(Math.random()\\*(最大值-最小值+1)+最小值)  包含最小值包含最大值  \n\n------------\n\n![](image151.png)\n\n\n\n### Nubmer对象\n\nNubmer对象的方法：\n\n`toFixed(n)`\n\n将一个数字进行保留n位小数， 需要进行四舍五入\n\n\n\n# 二十一、BOM对象\n\nJavaScript=ECMAScript+BOM+DOM\n\n## 什么是BOM对象？\n\nBrowser Object Model 浏览器对象模型\n\n## BOM对象的作用\n\nBOM对象它主要为了访问和操作浏览器各个组件提供了一系列的属性与方法！\n\n## BOM的结构图\n\n![](image152.png)\n\n-   **window对象** 它是JavaScript中最顶级的对象，它代表着当前的整个浏览器窗口对象， 其它的对象都是以属性的方式添加在window对象下面！\n    -   比如：document这个对象它就是window对象下面的一个属性，但是它同时也是一个对象。document它相对于window对象来说它就是一个属性 。如果document它相对于write方法来说它就是一个对象\n-   **DOM对象** 文档对象模型。 它是用来操作当前的HTML文档 提供了一些属性与方法。\n-   **document对象** 它代表当前的文档对象\n-   **history对象** 历史对象 。它主要是用来记录浏览器的访问历史记录！**注意：**只有访问过后才会有历史记录。\n-   **location对象** 地址栏对象 。它可以用来获取到当前浏览器上面的地址栏中相关数据。\n-   **navigator对象** 浏览器对象 。它可以获取到浏览器的相关数据。比如浏览器的名称、版本等等\n-   **screen对象** 屏幕对象。 它可以获取到与屏幕相关的数据。比如：屏幕的分辨率\n\n\n\n## BOM对象分类\n\n### window对象\n\n#### window对象的属性\n\n------------------------ ------------------------------------------------------------------\n| **属性**               | **功能**                                                     |\n| ---------------------- | ------------------------------------------------------------ |\n| **window.innerWidth**  | 获取浏览器内部的宽度(不包含浏览器的左右两边边框)             |\n| **window.innerHeight** | 获取浏览器内部的高度(不包含浏览器的菜单栏和地址栏以及上下的边框) |\n| **window.outerWidth**  | 获取整个浏览器的宽度                                         |\n| **window.outerHeight** | 获取整个浏览器的高度                                         |\n\n------------------------ ------------------------------------------------------------------\n\n![](image153.png)\n\n#### window对象的方法\n\n| **方法**                | **功能**                                                     |\n| ----------------------- | ------------------------------------------------------------ |\n| **window.alert()**      | 向浏览器窗口中弹出一个警告提示框                             |\n| **window.prompt()**     | 向浏览器窗口中弹出一个用户输入对话框                         |\n| **window.confirm(str)** | 向浏览器窗口中弹出一个用户确认框    如果点击了确定按钮会返回一个true   如果点击了取消按钮会返回一个false |\n\n![](image154.png)\n\n-------------------- --------------------\n| **方法名**         | **功能**           |\n| ------------------ | ------------------ |\n| **window.close()** | 关闭当前浏览器窗口 |\n\n-------------------- --------------------\n\n![](image155.png)\n\n| **方法名**                                                   | **功能**                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **window.open(url,name,options)**  <br /> **参数说明：**   **url**：要打开窗口的地址   **name**：窗口的名称   **options:**  选项，如下图所示 | 在浏览器中打开一个新窗口  ， 这个方法有一个返回值， 它的返回值是代表当前打开的这个窗口对象。 这个返回值它主要是用来给close()这个方法来使用。 |\n\n![](image156.png)\n\n**注意：**\n\n-   close()这个方法它并不只有window对象才可以调用， 它还可以使用open()方法的返回值来调用\n\n-   谁调用close()方法它就表示将哪一个窗口给关闭\n\n-   如果是window对象来调用close()方法 ，就表示关闭当前浏览器的窗口\n\n-   如果是open()方法的返回值来调用close()方法， 就表示关闭open()方法打开的窗口\n\n![](image157.png)\n\n**延时器 **\n\n| **方法名**                                                   | **功能**                                                   |\n| ------------------------------------------------------------ | ---------------------------------------------------------- |\n| **window.setTimeout(code,MilliSec)**   <br />**参数说明：**   **code**：要执行的代码，代码可以是一个函数   **MilliSec**：时间， 毫秒 | 当指定的时间MilliSec到了以后就执行一次code只会执行一次code |\n\n**需要：**\n\n想实现3秒以后， 才会在浏览器中弹出一个hello\n\n![](image158.png)\n\n案例1：鼠标点击一个按钮 然后5秒以后 ，才会当前的浏览器关闭！\n\n![](image159.png)\n\n案例2：要实现3秒以后 ，将图片隐藏\n\n![](image160.png)\n\n案例3：要求实现每隔3秒钟在浏览器中弹出一个hello\n\n![](image161.png)\n\n\n\n| **方法名**                                                   | **功能**         |\n| ------------------------------------------------------------ | ---------------- |\n| **window.clearTimeout(timer)**   <br />**参数说明：**   timer：要清除的延时器的返回值 | 清除指定的延时器 |\n\n![](image162.png)\n\n**定时器**\n\n| **方法名**                                                   | **功能**                                   |\n| ------------------------------------------------------------ | ------------------------------------------ |\n| **window.setInterval (code,MilliSec)**  <br /> **参数说明：**   **code**：要执行的代码  ，代码可以是一个函数   **MilliSec**：时间，毫秒 | 每隔指定的时间就执行code  ，无限次执行code |\n\n![](image163.png)\n\n案例：使用**setInterval**来实现动态时钟\n\n![](image164.png)\n\n| **方法名**                                                   | **功能**         |\n| ------------------------------------------------------------ | ---------------- |\n| **window.clearInterval   (timer)**   <br />**参数说明：**   **timer**：要清除定时器的返回值 | 清除指定的定时器 |\n\n![](image165.png)\n\n**注意：**\n\n-   什么时候情况下要用到延时器，什么情况下需要用到定时器？\n\n-   只需要执行一次的我们就使用延时器\n\n-   无限次执行的功能我们就定时器\n\n### screen对象\n\n------------------- ----------------\n| **属性名**        | **功能**       |\n| ----------------- | -------------- |\n| **screen.width**  | 获取屏幕的宽度 |\n| **screen.height** | 获取屏幕的高度 |\n\n------------------- ----------------\n\n![](image166.png)\n\n### navigator对象\n\n-------------------------- --------------------\n| **属性名**               | **功能**           |\n| ------------------------ | ------------------ |\n| **navigator.appName**    | 获取到浏览器的名称 |\n| **navigator.appVersion** | 获取到浏览器的版本 |\n\n-------------------------- --------------------\n\n![](image167.png)\n\n### Location对象\n\n这个对象可以获取到地址栏的相关信息\n\nURL：统一资源定位符\n\n![](image168.png)\n\n#### location对象的属性\n\n--------------------------- ---------------------------------------\n| **属性名**                      | **功能**                              |\n| ------------------------------- | ------------------------------------- |\n| **Location.href**    **重定向** | 设置或者获取到浏览器地址栏中的URL地址 |\n\n--------------------------- ---------------------------------------\n\n\n\n#### location对象的方法 \n\n----------------------- ----------------\n| **属性名**            | **功能**       |\n| --------------------- | -------------- |\n| **location.reload()** | 刷新当前浏览器 |\n\n----------------------- ----------------\n\n![](image169.png)\n\n\n\n### history对象\n\n**注意：**只有访问过后才会有历史对象\n\n#### history对象的方法\n\n----------------------- -----------------------------------\n| **方法名**            | **功能**                          |\n| --------------------- | --------------------------------- |\n| **history.back()**    | 加载上一个URL页面   后退          |\n| **history.forward()** | 加载下一个URL页面  前进           |\n| **history.go(n)**     | 加载history列表中的某个具体的页面 |\n\n----------------------- -----------------------------------\n\nhistory.go(1) \\-\\-\\-\\-\\-\\--\\> **history.forward()**\n\nhistory.go(-1) \\-\\-\\-\\-\\-\\--\\> **history.back()**\n\n![](image170.png)\n\n\n\n# 二十二、DOM对象\n\nJS它是一门事件驱动式的语言\n\n## 什么是DOM对象\n\nDocument Object Model 文档对象模型\n\n## DOM对象作用\n\nDOM它主要是为了操作HTML文档提供了一些属性与方法 ！\n\n**JS它主要是HTML文件进行增删改查**\n\n***PHP*它主要是对数据库进行增删改查**\n\n**DOM操作：**\n\n1.  我们要通过JavaScript来操作HTML标签 ，先要找到这个HTML标签对象\n\n2.  我们操作的标签对象， 这个标签里面拥有的属性 ，那么这个标签对象也会同时拥有\n\n\n\n## DOM对象的属性与方法\n\n### DOM的属性\n\n凡是在JS中遇到\"集合\"两字 它就等价于数组 ，它的访问方式与数组一样 ，需要通过下标来访问。\n\n------------------------------ -------------------------------------\n| **属性名**                   | **功能**                            |\n| ---------------------------- | ----------------------------------- |\n| **innerHTML**                | 获取或者设置双边标签里面的内容      |\n| **document.body**            | 获取到body标签对象                  |\n| **document.documentElement** | 获取到根元素   html标签             |\n| **document.forms**           | 获取到所有表单元素 返回是一个集合   |\n| **document.images**          | 获取到所有的图片元素 返回是一个集合 |\n\n------------------------------ -------------------------------------\n\ninnerHTML\n\n![](image171.png)\n\ndocument.body与document.documentElement\n\n![](image172.png)\n\n![](image173.png)\n\ndocument.images\n\ndocument.forms\n\n![](image174.png)\n\n### DOM的方法\n\n| **方法名**                                 | **功能**                                                     |\n| ------------------------------------------ | ------------------------------------------------------------ |\n| document.getElementById(“id的属性值”)      | 通过id的属性值来获取元素 ，它只能获取到一个元素              |\n| document.getElementsByTagName(“标签名”)    | 通过标签名来获取元素 ， 它返回是一个数组集合 。   如果要访问其中的某一个标签对象， 要使用下标来进行访问！ 就算这个数组里面的元素只有一个， 那么也是要使用数组下标的方式来进行访问！ |\n| 祖先对象.getElementsByTagName(“标签名”)    | 后代元素选择器                                               |\n| document.getElementsByName(“name的属性值”) | 通过标签的name属性值来获取元素，  它返回是一个数组 。   如果要访问其中的某一个标签对象 ，要使用下标来进行访问！ 就算这个数组里面的元素只有一个 ，那么也是要使用数组下标的方式来进行访问！   name属性选择器 |\n\n**document.getElementById(\"id的属性值\") ID选择器**\n\n![](image175.png)\n\n**document.getElementsByTagName(\"标签名\")**\n\n![](image176.png)\n\n![](image177.png)\n\n**祖先对象.getElementsByTagName(\"标签名\") 相当于CSS的后代元素选择器**\n\n**先获取到祖先对象，然后再通过这个祖先对象获取其指定的后代元素(标签名)**![](image178.png)\n\n![](image179.png)\n\n**document.getElementsByName(\"name的属性值\") Name属性选择器 **\n\n**在HTML中每一个标签都会有一个NAME属性， 上面的这个方法是表示通过HTML的标签的name属性值来获取元素 ，得到是 数组， 多用于表单 **\n\n![](image180.png)\n\n\n\n## DOM对象操作HTML标签的属性 \n\n**DOM对象对HTML标签的属性操作 htmlDOM**\n\n```\n<标签名 属性=\"值\" >\n```\n\n增删改查\n\n### 增、改 \n\n-   要操作的标签对象.属性名\n\n-   要操作的标签对象.setAttribute(\"属性名\",值)\n\n**增加**\n\n> 要操作的标签对象.属性名\n\n![](image181.png)\n\n> 要操作的标签对象.setAttribute(\"属性名\",属性值)\n\n![](image182.png)\n\n**修改**\n\n![](image183.png)\n\n### 查询\n\n获取到对应的属性的值 ，就称之查询！\n\n**语法：**\n\n-   要操作的标签对象.属性名\n\n-   要操作的标签对象.getAttribute(\"属性名\")\n\n![](image184.png)\n\n### 删除\n\n**语法：**\n\n要操作的标签对象.removeAttribute(\"要移除属性名\")\n![](image185.png)\n\n\n\n**语法：**\n\n-   要操作的标签对象.className\n\n-   要操作的标签对象.setAttribute('class',值)\n\n**特别说明：**\n\n我们使用标签对象.属性名这种方式， 就要将class这个关键字改为className ，如果使用要操作的标签对象.setAttribute()这个方法来设置class属性时， 直接写class就可以了！\n\n![](image186.png)\n\n### DOM对象对style属性操作\n\n它主要是用来操作标签的style的属性 =操作行内样式\n\n```\n<标签名 style=\"CSS样式\" >\n```\n\n**注意：**JavaScript它只能操作标签的行内样式！\n\n\n\n**设置或者修改：**\n\n**语法**\n\n```\n要操作的标签对象.style.css属性 = \"值\"\n```\n\n\n\n点击一个按钮将下面的div进行显示或者隐藏\n\n![](image187.png)\n\n**注意：**\n\n如果CSS属性中有中划线要去掉 ，并且将中划线后面的单词首字母大写 驼峰法\n\n`background-color ==== backgroundColor`\n\n![](image188.png)\n\n\n\n# 二十三、事件\n\n## 什么是事件？\n\n比如当鼠标单击、当鼠标滑过、当鼠标离开 这些行为被称之为事件\n\n## 什么是事件驱动式？\n\njs是一门事件驱动式的脚本语言！\n\n当事件发生时， 会被JS捕获到 ，然后赋予其一些功能代码！\n\n## 事件的绑定方式\n\n事件的绑定方式有二种：**行内绑定**与**动态绑定**\n\n1)  行内绑定事件\n\n> **说明：**所谓的行内绑定事件 是将事件写在HTML标签里面\n>\n> **格式：**\n>\n> \\<标签名 事件名=\"函数名()\" /\\>\n\n![](image189.png)\n\n2)  动态绑定事件\n\n> 说明：是将事件名写在JS代码里面\n>\n> **格式：**\n>\n> 通过JS获取标签对象.事件名 = 事件的处理程序， 事件的处理程序一般是一个匿名函数。\n\n![](image190.png)\n\n## 事件列表\n\n-   onclick 当鼠标单击时\n\n![](image191.png)\n\n-   ondblclick 当鼠标双击时\n\n![](image192.png)\n\n-   onload 当页面加载完成后 \n\n    指body标签里面所有的标签都加载完成以后再来执行js代码。 onload事件要和window对象来绑定， onload还可以写在body标签里面\n\n![](image193.png)\n\n-   onmouseover 当鼠标经过时， 当鼠标悬停\n\n-   onmouseout 当鼠标离开时\n\n![](image194.png)\n\n-   onsubmit 当表单提交时 \n\n    它主要是用来实现表单验证！这个事件要绑定给form标签上面\n\n![](image195.png)\n\n> onsubmit事件它主要是用来阻止表单的默认行为。\n> 表单它本身就会具有提交的功能。如果表单数据不合法就将让表单不提交，如果合法就让其提交。\n>\n> onsubmit事件阻止表单提交分为**行内绑定**与**动态绑定**方式\n> 1.  动态绑定\n>   在表单处理程序\n>    **return false** 表示不允许表单提交\n>    **return true** 表示允许表单提交\n>   ![](image196.png)\n>\n> 2.  行内绑定时\n>    **return false** 表示不允许表单提交\n>\n>    **return true** 表示允许表单提交\n\n\n-   onfocus 当获取焦点时\n\n-   onblur 当失去焦点时\n\n![](image197.png)\n\n-   onchange事件， 当内容发生改变时 ，一般多用于select标签\n\n![](image198.png)\n\n\n\n#  表单验证案例\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n<head>\n\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<form name='form1' onsubmit='return checkForm()' action='index.php'>\n\t\t<table width='600' align='center' >\n\t\t\t<tr>\n\t\t\t\t<td align='right' width='150'>用户名:</td>\n\t\t\t\t<td width='100'><input type='text' name='username' id=\"username\" onfocus='focus_username()' onblur = 'blur_username()'/></td>\n\t\t\t\t<td><span id=\"user_res\"></span></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td align='right' width='100'>密码:</td>\n\t\t\t\t<td width='100'><input type='password' id=\"password\" name='password' onfocus='focus_password()' onblur = 'blur_password()'/></td>\n\t\t\t\t<td><span id=\"pass_res\"></span></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td></td>\n\t\t\t\t<td><input type='submit' value='提交' /></td>\n\t\t\t</tr>\n\t\t</table>\n\t</form>\n\t<script> \n\t\t//当用户名获取焦点时 \n\t\tfunction focus_username(){\n\t\t\t//往id=user_res 写入内容\n\t\t\tdocument.getElementById(\"user_res\").innerHTML = \"<font color='#f00'>请输入用户名</font>\";\n\t\t}\n\n\t\t//当用户名输入框失去焦点时 \n\t\t//1.判断是否输入了用户名  如何判断是否输入了用户名\n\t\t//可以判断这个输入框的value的长度是否等于0  \n\t\t//2.判断其长度  \n\t\t//3.判断有特殊符号\n\t\t//4.用户名合法 \n\t\tfunction blur_username(){\n\t\t\t//获取id=username的标签对象\n\t\t\tvar userObj = document.getElementById(\"username\");\n\t\t\t//2.获取userObj的value属性\n\t\t\tvar userObjValue = userObj.value;\n\t\t\t//3.得到userObjValue这个变量的长度 \n\t\t\tvar userLength = userObjValue.length;\n\t\t\t//接下来就来判断是否输入了用户名 \n\t\t\tif(userLength == 0){\n\t\t\t\tdocument.getElementById(\"user_res\").innerHTML = \"<font color='#f00'>用户名不能为空</font>\";\n\t\t\t\treturn false;\n\t\t\t}else if(userLength < 5 || userLength > 18){\n\t\t\t\t//判断用户名的长度 规定长度必须在5~18位之间\n\t\t\t\tdocument.getElementById(\"user_res\").innerHTML = \"<font color='#f00'>用户名必须在5~18位之间</font>\";\n\t\t\t\treturn false;\n\t\t\t}else if(!checkUser(userObjValue)){\n\t\t\t\t//判断是否有特殊符号 \n\t\t\t\tdocument.getElementById(\"user_res\").innerHTML = \"<font color='#f00'>用户名中特殊符号</font>\";\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tdocument.getElementById(\"user_res\").innerHTML = \"<font color='purple'>用户名合法</font>\";\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n        \n\t\t//判断特殊符号的函数 \n\t\tfunction checkUser(user){\n\t\t\tvar arr = [\"<\",'>',\"%\",\"$\",\"!\",\"#\"];\n\t\t\tvar arrLength = arr.length;\n\t\t\tvar userLength = user.length;\n\t\t\tfor(var i=0;i<userLength;i++){\n\t\t\t\tfor(var j=0;j<arrLength;j++){\n\t\t\t\t\tif(user[i] == arr[j]){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t//当密码框获取焦点时 \n\t\tfunction focus_password(){\n\t\t\t//往id=pass_res 写入内容\n\t\t\tdocument.getElementById(\"pass_res\").innerHTML = \"<font color='#f00'>请输入密码</font>\";\n\t\t}\n\n\t\t//当密码输入框失去焦点时 \n\t\t//1.判断是否输入了密码  \n\t\t \n\t\t//2.判断其长度  \n\t\t//3.密码合法 \n\t\tfunction blur_password(){\n\t\t\t//获取密码输入框这个标签对象 \n\t\t\tvar passObj = document.getElementById(\"password\");\n\t\t\tvar passValue = passObj.value;\n\t\t\tvar passLength = passValue.length;\n\n\t\t\tif(passLength == 0){\n\t\t\t\tdocument.getElementById(\"pass_res\").innerHTML = \"<font color='#f00'>密码不能为空</font>\";\n\t\t\t\treturn false;\n\t\t\t}else if(passLength < 5 || passLength > 18){\n\t\t\t\tdocument.getElementById(\"pass_res\").innerHTML = \"<font color='#f00'>密码必须在5至18位之间</font>\";\t\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tdocument.getElementById(\"pass_res\").innerHTML = \"<font color='purple'>密码合法</font>\";\t\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction checkForm(){\n\t\t\t//得到用户名失去焦点时与密码失去焦点函数的返回值 通过返回值来判断\n\t\t\tvar flag_user = blur_username();\n\t\t\tvar flag_pass = blur_password();\n\t\t\tif(flag_user && flag_pass){\n\t\t\t\talert(\"表单验证通过\");\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\talert(\"表单验证不通过\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t</script>\n</body>\n</html>\n```\n\n\n\n# 全选、反选、取消 案例\n\ndocument.getElementsByName()这个方法多用于复选框中。 一组复选框的name属性值是一样的 ，主要是用来实现全选、反选、取消功能。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t篮球：<input type=\"checkbox\" name=\"hobby\" id=\"\">\n\t篮球：<input type=\"checkbox\" name=\"hobby\" id=\"\">\n\t篮球：<input type=\"checkbox\" name=\"hobby\" id=\"\">\n\t篮球：<input type=\"checkbox\" name=\"hobby\" id=\"\">\n\t篮球：<input type=\"checkbox\" name=\"hobby\" id=\"\">\n\t篮球：<input type=\"checkbox\" name=\"hobby\" id=\"\">\n\t篮球：<input type=\"checkbox\" name=\"hobby\" id=\"\"><br/>\n\t<input type=\"button\" id=\"quanxuan\" value=\"全选\" onclick=\"quanxuan()\">\n\t<input type=\"button\" id=\"quxiao\" value=\"取消\" onclick=\"quxiao()\">\n\t<input type=\"button\" id=\"fanxuan\" value=\"反选\" onclick=\"fanxuan()\">\n\n\t<script type=\"text/javascript\">\n\t\tvar inputsObj = document.getElementsByName(\"hobby\");\n\t\tfunction quanxuan(){\n\t\t\t//当我们点击全选按钮时 要将所有的复选框打上勾 \n\t\t\t//1.先获取到所有的复选框  通过name属性值来获取  \n\t\t\t\n\t\t\t//2.遍历数组  给里面的每个元素打上勾\n\t\t\tfor(var i=0;i<inputsObj.length;i++){\n\t\t\t\tinputsObj[i].checked = true; //表示是被选中 \n\t\t\t}\n\t\t}\n\n\t\tfunction quxiao(){\n\t\t\t//当我们点击全选按钮时 要将所有的复选框打上勾 \n\t\t\t//1.先获取到所有的复选框  通过name属性值来获取  \n\t\t\t//2.遍历数组  给里面的每个元素打上勾\n\t\t\tfor(var i=0;i<inputsObj.length;i++){\n\t\t\t\tinputsObj[i].checked = false; //表示是未选中 \n\t\t\t}\n\t\t}\n\n\t\tfunction fanxuan(){\n\t\t\t//当我们点击全选按钮时 要将所有的复选框打上勾 \n\t\t\t//1.先获取到所有的复选框  通过name属性值来获取  \n\t\t\t//2.遍历数组  给里面的每个元素打上勾\n\t\t\tfor(var i=0;i<inputsObj.length;i++){\n\t\t\t\t//判断是否被选中 \n\t\t\t\t/*if(inputsObj[i].checked){\n\t\t\t\t\tinputsObj[i].checked = false;\n\t\t\t\t}else{\n\t\t\t\t\tinputsObj[i].checked = true;\n\t\t\t\t}*/\n\t\t\t\t//将true变成false 赋值给 inputsObj[i].checked \n\t\t\t\t//将false变成true 赋值给 inputsObj[i].checked\n\t\t\t\t//只有布尔值才可以取反\n\t\t\t\tinputsObj[i].checked = !inputsObj[i].checked;\n\t\t\t}\n\t\t}\n\t</script>\n</body>\n</html>\n```\n\n\n\n","categories":["Basics"]},{"title":"jQuery基础知识","url":"%2Fposts%2F2797510404%2F","content":"\n\n\n# 三、jQuery概述\n\n## 1、什么是jQuery\n\n==**jQuery是一个 js 框架。封装了很多实用的方法，解决了浏览器的兼容问题。**==\n\n\n\n## 2、特点\n\n**write less, do more.** 写的更少，做的更多。\n\n\n\n1．语法简练、语义易懂、学习快速、丰富文档。\n\n2．jQuery 是一个轻量级的脚本，其代码非常小巧。\n\n3．jQuery 支持 CSS1~CSS3 定义的属性和选择器 //document.querySelector('');\n\n4．jQuery 是跨浏览器的，它支持的浏览器包括 IE 6.0+、FF 1.5+、Safari 2.0+和 Opera 9.0+。 \n\n5．能将 JavaScript (行为)脚本与 HTML (结构)源代码完全分离，便于后期编辑和维护。 \n\n6．插件丰富，除了 jQuery 自身带有的一些特效外，可以通过插件实现更多功能\n\n\n\n小结：写的更少，做的更多，强大的选择器，插件丰富。\n\n## 3、网站\n\n官方地址为：http://jquery.com/\n\n下载地址：http://www.jq22.com/jquery-info122   该网站内有很多插件的链接\n\n最新版在线手册手册：http://jquery.cuishifeng.cn/\n\n中文社区：http://jquery.org.cn/\n\n## 4、发展史及版本介绍\n\njQuery 是继 Prototype 之后又一个优秀的 JavaScript 框架，由 John Resig 于 2006 年初创建，目前最新版本为 3.3.1。 \n\njquery版本：\n\n1.0.0  1.0.1  1.0.2  1.1.0  1.1.1  1.1.2  1.2.x  1.2.6  1.3.x  1.4.x  1.5.x  1.6.x  1.7.x\n\n1.8.x  1.9.x  1.10.x  1.11.x  2.x  3.x\n\n**==2.0版本以后，对IE6/7/8支持不好==**。但是市面上这些浏览器基本被淘汰了，所以无差别。\n\n每个jQuery版本都有开发版和产品版，开发版就是带空白和注释的，便于学习；产品版是去掉空白和注释的版本，体积更小，适用于线上。\n\njQuery有一个非常大的**缺点**，就是==不向下兼容==。\n\n## 5、其他类似框架\n\n**Prototype**：与面向对象的原型继承关键字prototype一致，该框架的特点是功能扩展比较容易。\n\n**YUI**：该框架可以实现各种页面布局效果。\n\n**Extjs** : 是目前js框架包里边最为时尚、前沿的。通过该框架包可以实现许多非常绚丽的效果。\n\n该框架可以实现效果之一：页面不同区域进行拖拽效果。由于实现的效果非常“绚丽”、导致其“实用”价值相对略低。\n\n**Mootools**框架，一款短小精悍的框架，完全采用面向对象的思想进行封装，采用很多流行的技术，核心代码只有8kb，是一款非常好用的JS框架。\n\njQuery：使用前期，jquery侧重快速找到页面上各种节点。\n\n后期jquery丰富了事件操作、ajax操作、动画效果、DOM操作等等。jQuery官方也提供了很多比较有效或有针对性的插件比如有jQueryUI、jQuery Mobile插件等。\n\n# 四、快速入门\n\n页面加载完毕，设置页面中的li标签的样式，要求字体颜色为red，背景颜色为#ccffcc。\n\n**jQuery使用的大致流程：**\n\n* 准备工作（html页面和css样式，目录结构）\n* 加载文件（引入css文件、jquery文件，js文件）\n* 功能实现（使用jquery实现所需的js功能）\n\n\n\n\n\n**准备工作：**\n\n![1533437319898](1533437319898.png)\n\n```html\n<body>\n<ul>\n    <li>赵伟</li>\n    <li>赖志丽</li>\n    <li>荔枝味</li>\n    <li>陈贤栋</li>\n</ul>\n\n<script>\n    //页面加载完毕，设置页面中的li标签的样式，要求字体颜色为red，背景颜色为#ccffcc。\n    \n</script>\n</body>\n```\n\n\n\n**加载jquery.js或使用min版的jquery：**\n\n==注：jquery必须在使用它之前加载它，所以通常在首个位置加载js文件==\n\n```html\n<!--在head区引入css和js文件-->\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/editTable.css\" />\n<script src=\"js/jquery-3.3.1.js\"></script>\n<script src=\"js/editTabe.js\"></script>\n```\n\n\n\n![1533435624587](1533435624587.png)\n\n\n\n**jQuery中$()方法：**\n\n```javascript\n// $(); 是jquery中封装的一个方法，参数可以是document、可以是dom对象、可以是css选择器；返回值是jQuery对象\n $(document);  //表示查找整个文档\n $('li');    //表示查找页面中的所有li标签\n```\n\n**jQuery中事件绑定语法：**\n\n```javascript\n//$(document).事件(事件处理函数);\n$(document).ready(function(){\n    //这里表示页面加载完毕，要执行什么。\n});\n```\n\n\n\n**找到li，并设置样式：**\n\n```javascript\n\t$(document).ready(function(){\n        //先找到所有的li\n        //var lis = $('li');\n        //console.log(lis); // 得到一个包括4个li的jQuery对象\n        //lis.css('color', 'red'); //lis虽然表示4个li，但是是一个对象。jQuery有隐式的循环\n        //lis.css('background-color', '#ccffcc'); //jQuery在设置样式的时候，css样式名称原样写即可\n        $('li').css('color', 'red').css('background-color', '#ccffcc');\n    });\n```\n\n----\n\n\n\n# 三、其它\n\n## 1、释放$\n\n释放$，意思是不在使用$符合了。$('li')这种写法就不能用了。\n\n**jQuery为什么要释放$**\n\n有时候，一个页面使用了多个js框架，很多框架都使用$符合当做框架对象的表示。另一个原因，比如自己写了一个名为$的函数，这样的话也会和jQuery中的$冲突，所以要释放$，也就是释放使用$的权利。\n\n**jQuery如何释放$?**\n\n方法一：使用jQuery代替$符号\n\n```javascript\njQuery(document).ready(function(){\n    jQuery('body').css('background-color', 'pink');\n});\n```\n\n方法二：使用jQuery中的noConflict()方法来释放$\n\n```javascript\nvar $2 = jQuery.noConflict();\n//下面就可以使用$2代替原来的$了\n$2(document).ready(function(){\n    console.log(123456);\n});\n```\n\n方法三：使用自调用函数\n\n```javascript\n(function($){\n    //在函数内部，使用的$是形参\n    $(document).ready(function(){\n        $('body').css('background-color', 'blue');\n    });\n})(jQuery);\n```\n\n \n\n## 2、ready和onload的区别\n\nready是jQuery中的方法，规定了页面加载后要执行的函数。\n\nonload是dom中的事件，表示页面加载后要执行的内容。\n\n**区别1**：\n\nready只需要页面中的dom节点加载完毕就可以执行，html标签完全加载完毕就会执行，无关图片是否已经下载。\n\nonload需要整个页面的资源加载完毕才能执行，html标签完全加载完毕，并且图片等页面中的资源也必须加载完毕也能够执行。\n\n**区别2**：\n\n​       一个页面只能执行一个onload事件\n\n​       一个页面可以执行多个ready事件\n\n```javascript\n//下面两个onload事件，后面的会覆盖前面的\nwindow.onload = function () {\n    alert(1);\n};\nwindow.onload = function () {\n    alert(2);\n};\n```\n\n```javascript\n//下面两个ready方法，都可以执行\n$(document).ready(function () {\n    alert(1);\n});\n$(document).ready(function () {\n    alert(2);\n});\n```\n\n## 3、ready方法的简写形式\n\n```javascript\n//下面是ready方法的简写形式\n/*$().ready(function(){\n    alert(123);\n});*/\n\n$(function(){\n    alert(123456);\n});\n```\n\n \n\n## 4、dom对象和jQuery对象的区别\n\n### 1、什么是dom对象，什么是jquery对象？\n\ndom对象就是原生js中使用document.getElement….By….()，得到的对象就是dom对象。\n\njQuery对象指的是使用jQuery方法得到的对象，一般来说就是通过jQuery选择器得到的对象。\n\n```javascript\n//DOM对象\nvar ul = document.getElementsByTagName('ul')[0]; //得到的就是dom对象\n\n//jQuery对象\n$('ul'); //这就是jQuery对象\n```\n\n### 2、dom对象和jQuery对象的区别\n\ndom对象可以使用dom方法，而不能使用jquery方法；\n\njQuery对象可以使用jQuery方法，而不能使用dom中的方法或属性。\n\n```javascript\n//DOM对象\nvar ul = document.getElementsByTagName('ul')[0]; //得到的就是dom对象\n//ul.addClass('a'); //报错，说明dom对象不能调用jQuery方法\n\n\n//jQuery对象\nvar ul2 = $('ul');//这就是jQuery对象\nvar li = document.createElement('li');\nul2.appendChild(li); //报错，说明jQuery对象也不能调用dom方法\n```\n\n### 3、jQuery对象和dom对象互换\n\n①、将jQuery对象转化为dom对象：\n\n方法是给jQuery加==下标==，或用jQuery对象调用==get==方法。\n\n```javascript\n//jQuery对象\nvar ul2 = $('ul');//这就是jQuery对象\nvar li = document.createElement('li');\n//ul2.appendChild(li); //报错，说明jQuery对象也不能调用dom方法\n/************* 下面两种方式都可以将jQuery对象转换为dom对象 ***************/\n//ul2[0].appendChild(li); //加入下标，表示将jQuery对象转换成了DOM对象\nul2.get(0).appendChild(li); //调用get方法，get参数为下标，表示将jQuery对象转换成了DOM对象\n```\n\n②、将dom对象转化为jQuery对象\n\njQuery对象 等于 ==$(==dom对象==)==;\n\n```javascript\n//DOM对象\nvar ul = document.getElementsByTagName('ul')[0]; //得到的就是dom对象\n//ul.addClass('a'); //报错，说明dom对象不能调用jQuery方法\n/*************** 下面用$()处理dom对象，将其转换为jQuery对象 ********************/\n$(ul).addClass('a');\n```\n\n# 四、==jQuery中的事件==（重点）\n\n## 1、普通的事件绑定\n\n普通事件，比如有click、mouseover、change、blur、….\n\n语法：`click([[data],fn]);` \n\n案例一：事件方法没有参数，可用于传递事件\n\n```html\n<form action=\"\">\n    <input type=\"file\" id=\"myfile\" style=\"display: none;\">\n    <input type=\"button\" id=\"btn\" value=\"选择文件\" />\n</form>\n\n<script>\n    $(function(){\n        $('#btn').click(function(){\n            //点击button的时候，触发点击file事件\n            $('#myfile').click();\n        });\n    });\n</script>\n```\n\n案例二：给事件处理函数传入参数，可以通过事件对象的data属性获取到。\n\n![1533523399952](1533523399952.png)\n\n## 2、on具体用法\n\n### 1、可以给未来的元素绑定事件（重点）\n\n低于1.7版本，用live事件可以完成给未来的元素绑定事件。\n\n未来的元素指的是页面加载完毕后没有的元素，后来经过dom操作或ajax异步请求临时加到页面上的元素。\n\n下面案例中，点击页面中的p，点击之后能够在页面中再加入一个p。使用click事件，只能点击页面中开始时已经存在的p；使用on就可以点击页面中所有p。\n\n```html\n<body>\n<script>\n    $(function(){\n        //获取页面中的p元素，点击之后能够在页面中再加入一个p\n        /*$('p').click(function(){\n            var p = $('<p>我是后来的</p>');\n            $('body').append(p);\n        });*/\n        $(document).on('click', 'p', function(){\n            var p = $('<p>我是后来的</p>');\n            $('body').append(p);\n        });\n    });\n\n</script>\n\n<p>我开始就存在</p>\n\n</body>\n```\n\n### 2、可以完成事件委托\n\n下面的例子是将div的单击事件委托给了a。事件委托只能委托个它的子元素。\n\n```html\n<div>\n    <a href=\"#\">点我试试</a>\n</div>\n\n<script>\n    $(function(){\n        //把div的单击事件，委托给a元素。注意的是，只能委托给它的子元素\n        $('div').on('click', 'a', function(){\n            alert(123);\n        });\n    });\n</script>\n```\n\n### 3、可以给一个元素绑定多个事件\n\n```html\n<p>hello world</p>\n\n<script>\n    $(function(){\n        $(document).on('click', 'p', function(){\n            console.log(111);\n        });\n        $(document).on('mouseover', 'p', function(){\n            console.log(222);\n        });\n    });\n</script>\n```\n\n原来不用on的时候，也可以为一个元素绑定多个事件\n\n```javascript\n$('p').click(function () {\n    console.log(222);\n});\n$('p').mouseover(function(){\n    console.log(111);\n});\n```\n\n给on传递对象，也可以，对象的每个元素都是一个事件：\n\n```javascript\n$('p').on({\n    click:function(){\n        console.log(123);\n    },\n    mouseover:function(){\n        console.log(456);\n    }\n});\n```\n\n### 4、可以给一个元素绑定多个相同类型的事件\n\n绑定多个相同事件的时候，可以给事件指定一个人名，表示这个事件是由谁来写的。\n\n```javascript\n\t\t$(document).on('click.zhangsan', 'p', function(){\n            console.log(111);\n        });\n        $(document).on('click.lisi', 'p', function(){\n            console.log(222);\n        });\n```\n\n\n\n## 3、off事件\n\noff在低版本的jQuery中，用unbind来代替。\n\n**off**和on是对应的，它用于取消事件的绑定。\n\n实际开发中，这个东西很有用，有些时候是需要先取消掉一个元素的所有事件，然后在绑定你要绑定的事件，可以解决一些bug。\n\n```html\n<p>123</p>\n\n<script>\n    $(function(){\n        $('p').click(function(){\n            alert(789);\n        });\n        //在绑定新的事件的时候，先取消掉原来的事件\n        $('p').off('click').on({\n            click:function(){\n                console.log('JQK')\n            }\n        });\n    });\n</script>\n```\n\n## 4、one事件\n\n给元素绑定的事件，只执行一次。\n\n```html\n<p>lalsdfa</p>\n\n<script>\n    $(function(){\n        //写法一：\n        /*$('p').one('click', function(){\n            alert(123);\n        });*/\n        \n        //写法二：\n        /*$(document).one('click', 'p', function () {\n            alert(333);\n        });*/\n        \n        //写法三：\n        $('p').one({\n            click:function(){\n                console.log(123);\n            },\n            mouseover:function(){\n                console.log(456);\n            }\n        });\n    })\n\n</script>\n```\n\n\n\n# 五、==jQuery中的效果==\n\n#### 基本\n\n* show([s,[e\\],[fn]])\n* hide([s,[e\\],[fn]])\n* toggle([s\\],[e],[fn])\n\n\n\n#### 滑动\n\n* slideDown([s\\],[e],[fn])\n* slideUp([s,[e\\],[fn]])\n* slideToggle([s\\],[e],[fn])\n\n\n\n#### 淡入淡出\n\n* fadeIn([s\\],[e],[fn])\n* fadeOut([s\\],[e],[fn])\n* fadeTo([[s\\],o,[e],[fn]])\n* fadeToggle([s,[e\\],[fn]])\n\n```html\n<body>\n\n<div style=\"width:200px; height:200px; background-color: #000000;\"></div>\n<input type=\"button\" value=\"淡出\">\n<input type=\"button\" value=\"淡入\">\n<input type=\"button\" value=\"半透明\">\n\n<script>\n    $('input').eq(0).click(function(){\n        $('div').fadeOut(1000);\n    });\n    $('input').eq(1).click(function(){\n        $('div').fadeIn(1000);\n    });\n    $('input').eq(2).click(function(){\n        $('div').fadeTo(1000, 0.5);\n    });\n</script>\n\n</body>\n```\n\n\n\n#### 自定义\n\n* animate(p,[s\\],[e],[fn])\n* stop([c\\],[j])\n* delay(d,q\\]) -- 延迟执行下一个动画\n* finish(queue\\])\n\n```html\n<body>\n<input type=\"button\" value=\"变身\" id=\"btn\">\n<div style=\"width:200px; height:100px; background-color: #000; position: absolute;\"></div>\n\n<script>\n    $(function(){\n        $('#btn').click(function(){\n            /*下面让div通过2秒发生变化，变化完毕提示“变身成功”*/\n            /*$('div').animate({\n                left:'300px',\n                top:'200px',\n                width:'100px',\n                height:'300px'\n            }, 2000, 'swing', function(){alert('变身成功');});*/\n\n            /*下面让div通过2秒变化宽度和高度，然后停顿1秒，然后通过1秒变透明*/\n            $('div').animate({\n                width:'100px',\n                height:'300px',\n            },2000).delay(1000).fadeTo(1000, 0.3);\n        });\n    });\n</script>\n\n</body>\n```\n\n\n\n# 六、==jQuery中的Ajax==（重点）\n\n## 1、$.get方法\n\n专门用于发送get请求的Ajax方法。\n\n语法：\n\n```javascript\n/*\nurl ： 请求的地址\ndata : 发送给服务器的数据（字符串或对象）\nfunction : 用于处理服务器返回的数据\ndataType: 表示服务器返回数据的类型（text、json、xml、html）\n*/\n$.get(url, data, function(e){\n    //形参e表示服务器返回的数据\n}, dataType);\n```\n\n13get.html:\n\n```html\n<body>\n\n<input type=\"button\" value=\"发送\" id=\"btn\" />\n\n<script>\n    $(function(){\n        $('#btn').click(function(){\n            //单击按钮，发送ajax请求\n            $.get('13get.php', {username:'张三', age:20}, function(data){\n                console.log(data);\n            //}, 'text');\n        \t},'json');\n        });\n    });\n</script>\n\n</body>\n```\n\n13get.php:\n\n```php\nfile_put_contents('post.txt', print_r($_GET, true));\n\n//echo '发送过来了'; //返回文本类型的数据\necho json_encode('发送过来了'); //返回json类型的数据\n```\n\n\n\n**注意：对于服务器返回的json类型的数据，无需使用JSON.parse()处理，jQuery已经处理好了**。\n\n## 2、$.post方法\n\n$.post用于发送post请求，使用方式和$.get一模一样。\n\n语法：\n\n```javascript\n/*\nurl ： 请求的地址\ndata : 发送给服务器的数据（字符串或对象）\nfunction : 用于处理服务器返回的数据\ndataType: 表示服务器返回数据的类型（text、json、xml、html）\n*/\n$.post(url, data, function(e){\n    //形参e表示服务器返回的数据\n}, dataType);\n```\n\n\n\n## 3、$.ajax方法\n\n$.ajax()这个方法是综合$.get和$.post的一个方法，另外这个方法可以完整的体现ajax的各种情况。\n\n $.ajax(); 参数要求是一个对象（{}），把请求的各项参数都写到大括号里面。\n\n语法：\n\n```javascript\n$.ajax({\n    type:'get', //可选post\n    url:'xxx.php', //请求的地址\n    data:{name:'zhangsan', age:20}, //表示发送给服务器的数据\n    dataType:'json',//表示服务器返回的数据类型\n    success:function(e){ //用于处理服务器返回的数据，形参就是服务器返回的数据\n        //这里处理服务器返回的数据\n    },\n    async:true //表示异步请求，默认就是true\n});\n```\n\n\n\n## 4、收集表单内容\n\njQuery中封装了一个方法`serialize()` 和 `serializeArray()`，和FormData获取的数据一致，但是不包含文件域的内容。\n\n14serialize.html：\n\n```html\n<body>\n\n<form>\n    用户名：<input type=\"text\" name=\"username\" /><br>\n    密码：<input type=\"password\" name=\"pwd\" /><br>\n    性别：<input type=\"radio\" name=\"sex\" checked value=\"男\">男\n    <input type=\"radio\" name=\"sex\" value=\"女\">女<br>\n    爱好：<input type=\"checkbox\" name=\"hobby[]\" value=\"吃饭\">吃饭\n    <input type=\"checkbox\" name=\"hobby[]\" value=\"睡觉\">睡觉\n    <input type=\"checkbox\" name=\"hobby[]\" value=\"打豆豆\">打豆豆<br>\n    <input type=\"button\" value=\"提交\" id=\"btn\">\n</form>\n\n<script>\n    $(function(){\n        $('#btn').click(function(){\n            //首先找到表单，然后通过表单调用serialize\n            //var data = $('form').serialize();\n            var data = $('form').serializeArray();\n            console.log(data);\n            $.post('14serialize.php', data, function(){\n\n            },'text');\n        });\n    });\n</script>\n</body>\n```\n\n14serialize.php\n\n```php\nfile_put_contents('post.txt', print_r($_POST, true));\n```\n\n\n\n## 5、Ajax提示\n\n数据加载中...\n\najax请求开始和结束分别使用ajaxStart和ajaxStop事件监听。\n\n在14serialize.html中，加入loading.gif图：\n\n```html\n<img src=\"loading.gif\" style=\"display: none;\" />\n```\n\n\n\n在14serialize.html中，修改js代码：\n\n```javascript\n\t$(function(){\n        $('#btn').click(function(){\n            //首先找到表单，然后通过表单调用serialize\n            //var data = $('form').serialize();\n            var data = $('form').serializeArray();\n            console.log(data);\n            $.post('14serialize.php', data, function(){\n\n            },'text');\n        });\n\n        //ajax请求开始，让图片显示\n        $(document).ajaxStart(function(){\n            $('img').show();\n        });\n        //ajax请求结束，让图片隐藏\n        $(document).ajaxStop(function(){\n            $('img').hide();\n        });\n    });\n```\n\n14serialize.php可以sleep(2)。\n\n```php\nfile_put_contents('post.txt', print_r($_POST, true));\nsleep(2);\n```\n\n\n\n----\n\n\n\n# 三、==jQuery文档处理==(重要)\n\n## 3.1、添加节点\n\n1、append：`父节点.append(子节点);` 给父节点追加一个子节点\n\n2、appendTo：`子节点.appendTo(父节点);` 把一个子节点追加到一个父节点中\n\n3、prepend：`父节点.prepend(子节点);` 在一个父节点里开始的位置添加一个子节点\n\n4、after：`兄弟节点.before(兄弟节点);` 在元素后，添加一个兄弟\n\n5、before：`兄弟节点.before(兄弟节点);` 在元素前，添加一个兄弟\n\n01添加节点.html\n\n```html\n<body>\n\n<ul>\n    <li>刘备</li>\n    <li>刘邦</li>\n    <li>刘赢</li>\n</ul>\n\n<script>\n\n    $(function(){\n        //将一个 <li>刘彻</li>  追加到ul里面\n        //$('ul').append('<li>刘彻</li>');\n        $('ul').append($('<li>刘彻</li>'));\n        $('<li>刘德华</li>').appendTo($('ul'));\n\n        //将一个 <li>刘能</li>  追加到ul里面的最前面\n        $('ul').prepend($('<li>刘能</li>'));\n\n        //在ul后面添加一个兄弟 '<p>上面是几个姓刘的哥们</p>'\n        $('ul').after($('<p>上面是几个姓刘的哥们</p>'));\n\n        $('ul').before($('<h1>刘姓贵族</h1>'));\n    });\n</script>\n\n</body>\n```\n\n\n\n## 3.2、修改节点\n\nreplaceWith：`旧节点.replaceWith(新节点);` 用新的节点替换旧的节点（全部替换）\n\n稍微复杂一点的替换：`旧节点.replaceWith(function(){ 返回替换后的结果; })` 用函数处理复杂的替换\n\n02替换节点.html\n\n```html\n<body>\n\n<ul>\n    <li>德玛西亚</li>\n    <li>艾欧尼亚</li>\n    <li>诺克萨斯</li>\n</ul>\n\n<script>\n    $(function(){\n        //将第一个li替换成 '<li>弗雷尔卓德</li>'\n        $('li').eq(0).replaceWith($('<li>弗雷尔卓德</li>'));\n\n        // 使用函数来替换\n        /*$('li').eq(1).replaceWith(function(){\n            return $(this).text('恕瑞玛'); // $(this) 就是查找到的 <li>艾欧尼亚</li>\n        });*/\n\n        //把上面的ul>li, 替换成ol>li\n        $('ul').replaceWith(function(){\n            // $(this) 仍然表示 查找到的节点，即ul\n            return $('<ol></ol>').append($(this).children()); //$(this).children()表示原来ul里面的所有li\n        });\n    });\n</script>\n\n</body>\n```\n\n\n\n## 3.3、包裹节点\n\nwrap：`里面的节点.wrap(包裹的节点);` 将每个查找到的节点**分别**用包裹的节点包裹\n\n![1533694125275](1533694125275.png)\n\nwrapAll：`里面的节点.wrapAll(包裹的节点);` 将查找到的节点用一个包裹的节点包裹，如果查找的节点不在一起，则强制放到一起，**统一包裹**。\n\n![1533694225575](1533694225575.png)\n\n## 3.4、删除节点\n\nremove()：`待删除的节点.remove();` 将选择的节点删除\n\nempty()：`待清空的节点.empty();` 将选择的节点里面的内容清空\n\n```html\n<ul>\n    <li>宋江</li>\n    <li>金莲</li>\n    <li>武大</li>\n</ul>\n\n<script>\n    $(function(){\n        //将ul里面的内容清空\n        $('ul').empty();\n\n        //将ul删除\n        $('ul').remove();\n    });\n</script>\n```\n\n\n\n## 3.5、克隆节点\n\nclone()：`选择的节点.clone();` 将选择的节点（包括里面的内容）克隆\n\nclone(true)：`选择的节点.clone(true);` 将选择的节点克隆，并克隆该节点的事件。\n\n```html\n<button>click</button>\n\n<script>\n    $(function(){\n        //$('button').clone().appendTo($('body'));\n        $('button').click(function () {\n            $(this).clone(true).appendTo($('body'));\n        });\n    });\n</script>\n```\n\n\n\n## 3.6、属性中的prop方法\n\n回顾，DOM中设置元素属性的两种方法。\n\n* input.getAttribute('value');  //使用于input已经存在的属性\n* input.value;  //使用于获取input不存在的属性\n\n```html\n<input type=\"text\" />\n\n<script>\n    //DOM方式\n    var input = document.getElementsByTagName('input')[0];\n    //console.log(input.getAttribute('type'));\n    //console.log(input.type);\n    console.log(input.getAttribute('checked')); //null\n    console.log(input.checked); // false\n</script>\n```\n\n\n\njQuery中的attr和getAttribute()比较像，prop和input.value这种语法比较像。\n\n```html\n<input type=\"text\" />\n\n<script>\n    //DOM方式\n    /*var input = document.getElementsByTagName('input')[0];\n    //console.log(input.getAttribute('type'));\n    //console.log(input.type);\n    console.log(input.getAttribute('checked')); //null\n    console.log(input.checked); // false*/\n\n    $(function () {\n        console.log($('input').attr('checked')); //undefined\n        console.log($('input').prop('checked')); // false\n    });\n</script>\n```\n\n07反选.html代码：\n\n```html\n<button>反选</button>\n<table border=\"1\">\n    <tr>\n        <td>\n            <input type=\"checkbox\" />\n        </td>\n        <td>姓名。。。</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" />\n        </td>\n        <td>姓名。。。</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" />\n        </td>\n        <td>姓名。。。</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" />\n        </td>\n        <td>姓名。。。</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" />\n        </td>\n        <td>姓名。。。</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" />\n        </td>\n        <td>姓名。。。</td>\n    </tr>\n    <tr>\n        <td>\n            <input type=\"checkbox\" />\n        </td>\n        <td>姓名。。。</td>\n    </tr>\n</table>\n```\n\n```javascript\n\t\t$(function(){\n            $('button').click(function(){\n                //$('input[type=\"checkbox\"]').prop('checked', true);\n                $('input[type=\"checkbox\"]').prop('checked', function(i, val){\n                    //console.log(i, val); // i 是每个input的下标，val是checked的值\n                    return !val;\n                });\n            });\n        });\n```\n\n\n\n# 四、jQuery插件编写\n\njquery中可以使用下面两种方式来编写插件。\n\n## 4.1、$.fn.extend();\n\n这种语法，可以一次性写多个插件，需要给extend传递一个对象，对象的每个成员都是一个插件。\n\n```javascript\n$.fn.extend({\n    插件名:function(){\n        //处理函数\n    },\n    插件名:function(){\n        //处理函数\n    }\n});\n```\n\n\n\n08自定义插件.html\n\n```html\n<p>\n    hello world\n</p>\n```\n\n```javascript\n//自定义插件\n$.fn.extend({\n    a:function(){\n        //$(this) 在插件中表示调用插件的元素\n        $(this).css('color', 'red');\n        return $(this);\n    },\n    b:function(style){\n        //$(this) 在插件中表示调用插件的元素\n        $(this).css(style);\n        return $(this);\n    }\n});\n\n//使用自定义的插件\n$(function(){\n    $('p').b({'background-color':'pink', 'font-size':'30px'}).a().hide(15000);\n});\n```\n\n## 4.2、$.fn.插件名 = function(){}\n\n这种语法，只是定义一个插件。\n\n09自定义插件.html\n\n```html\n<p>\n    hello world\n</p>\n```\n\n```javascript\n\t\t//自定义一个插件\n        /*$.fn.hello = function (style) {\n         $(this).css('color', 'red').css(style);\n         return $(this);\n         };*/\n\n        //自定义一个插件\n        /*jQuery.fn.hello = function (style) {\n         $(this).css('color', 'red').css(style);\n         return $(this);\n         };*/\n\n        //自定义一个插件\n        (function($){\n            $.fn.hello = function (style) {\n                $(this).css('color', 'green').css(style);\n                return $(this);\n            };\n        })(jQuery);\n\n\t\t//调用插件\n\t\t$(function () {\n   \t\t \t$('p').hello({'background-color': 'pink'});\n\t\t})\n```\n\n","categories":["js.Jquery"]},{"title":"jQuery案例","url":"%2Fposts%2F2598484047%2F","content":"\n\n# 五、案例：可编辑的表格\n\n## 5.1、先设置html和css\n\n![1533437319898](1533437319898.png)\n\n```html\n<!--在head区引入css和js文件-->\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/editTable.css\" />\n<script src=\"js/jquery-3.3.1.js\"></script>\n<script src=\"js/editTabe.js\"></script>\n```\n\n```html\n<table>\n    <thead>\n    <tr>\n        <th>ID</th>\n        <th>姓名</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>陈贤栋</td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td>赖志丽</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>荔枝味</td>\n    </tr>\n    <tr>\n        <td>4</td>\n        <td>赵伟</td>\n    </tr>\n    <tr>\n        <td>5</td>\n        <td>谢伟杰</td>\n    </tr>\n    <tr>\n        <td>6</td>\n        <td>曾伟宏</td>\n    </tr>\n    </tbody>\n</table>\n```\n\ncss编写：\n\n```css\n*{\n    margin:0;\n    padding:0;\n    border:0 none;\n}\ntable,td,th{\n    border-collapse: collapse; /*合并边框*/\n    border:solid 1px #051c29;\n}\ntable{\n    width:400px;\n    margin:10px auto; /*左右居中对齐*/\n}\nth,td{\n    width:50%;\n    height:26px;\n    line-height: 26px;\n}\n```\n\n效果：\n\n![1533437637525](1533437637525.png)\n\n## 5.2、完成隔行换色\n\n```javascript\n/*页面载入事件*/\n$(document).ready(function(){\n    //隔行换色\n    $('tbody tr:even').css('background-color', '#d4d4d4');\n});\n```\n\n## 5.3、找到包含人名的td，绑定单击事件\n\n```javascript\n/*页面载入事件*/\n$(document).ready(function(){\n    //-----------隔行换色----------//\n    $('tbody tr:even').css('background-color', '#d4d4d4');\n    //-----------隔行换色----------//\n    \n    //----------------------查找姓名列的所有td并绑定单击事件---------------------------//\n    /*\n    // 找到人名的td的第一种方式\n    $('td:odd').click(function(){\n        alert(11);\n    });\n    */\n    // 找到人名的td的第二种方式\n    /*$('tr td:last-child').click(function(){\n        alert(22);\n    });*/\n    // 找到人名的td的第三种方式\n    // '父  子:nth-child(N)'\n    //匹配其父元素下的第N个子或奇偶元素\n    $('tr td:nth-child(2)').click(function(){\n        alert(22);\n    });\n});\n```\n\n## 5.4、创建input并放到td中\n\n```javascript\n/*页面载入事件*/\n$(document).ready(function(){\n    //-----------隔行换色----------//\n    $('tbody tr:even').css('background-color', '#d4d4d4');\n    //-----------隔行换色----------//\n    \n\t//----------------------查找姓名列的所有td并绑定单击事件---------------------------//\n\t//省略内容参考上面代码\n    \n    // 找到人名的td的第三种方式\n    // '父  子:nth-child(N)'\n    //匹配其父元素下的第N个子或奇偶元素\n    $('tr td:nth-child(2)').click(function(){\n        //把点击的td保存成一个变量\n        var td = $(this);  //$(this) 表示点击的那个td，即绑定事件的元素\n        \n        //--------------------细节处理-------------------------//\n        // bug: 再次点击时，td变成空的\n        // 首次点击后，td会被清空，再次点击，则获取的td内容为空\n        // 所以，需要处理点击的逻辑\n        \n        //判断td中是否有一个input了，如果有，就return。\n        /* \n        //方法一\n        if(td.has('input').length > 0){\n            return false;\n        }\n        */\n        /* \n        //方法二\n        if(td.children('input').length > 0){\n            return false;\n        }\n        */\n        //方法三 \n        if(td.find('input').length > 0){\n            return false;\n        }\n        //-----------------------细节处理-----------------------------//\n        \n        //创建input\n        var input = $('<input type=\"text\" />');\n        \n        //获取td中的文本        \n        //text() 用于获取/设置元素里面的文本\n        //类似text()的方法有html()，用于设置或获取元素里面的html内容\n        //类似text()的方法有val()，用于设置或获取表单项的value值\n        var text = td.text();\n\n        //清除td里面的内容\n        td.html(\"\");\n        \n        //设置input的value为td的内容\n        input.val(text);\n        \n        //把input放到td中\n        //td.append(input);\n        input.appendTo(td);\n        \n        //--------------------样式处理-------------------------//\n        //设置input的样式\n        //css()方法，如果只填一个参数，表示获取元素的css\n        //css()方法，如果填两个参数，表示设置元素的css\n        /*\n        var width = td.css('width');\n        input.css('width', width);\n        */\n        input.css('width', td.css('width'));\n        input.css('height', td.css('height'));\n        input.css('background-color', td.css('background-color'));\n        input.css('font', td.css('font'));\n        input.css('outline', '0 none');\n        //--------------------样式处理-------------------------//\n        \n        //--------------------事件处理-------------------------//\n        //让input获取焦点\n        input.focus();\n        //input.select(); //选中内容\n       \n    });\n});\n```\n\n## 5.5、为input绑定事件\n\n```javascript\n\t\t/////////////     在input.focus();这行代码之后 ///////////////////\n\n\t\t//给input绑定失去焦点事件\n        input.blur(function(){\n            //表示取消修改，把text 放到 td 中\n            td.html(text);\n        });\n\n        //给input绑定keyup事件\n        input.keyup(function(e){\n            //获取keyCode\n            //console.log(e.keyCode);\n            //console.log(e.which);\n            if(e.which == 13){\n                //[可选]解决谷歌浏览器bug。谷歌认为按回车的时候，同时触发了失去焦点事件\n                //td.html(\"\"); //清空td里面的input\n                \n                //表示按了回车，表示确定，把input的value值放到td中\n                td.html($(this).val());\n            }\n       //--------------------事件处理-------------------------// \n    });\n\t//----------------------查找姓名列的所有td并绑定单击事件---------------------------//\n});\n```\n\n## 5.6、案例总结\n\n1. 事件绑定：  `$('td:odd').click(function(e){});`\n2. **text()**、**html()**、**val()**三个方法，不填参数表示获取元素的内容或value值。填参数表示设置元素的内容或值。\n3. **css()**方法，填一个参数表示获取元素的样式；填两个参数表示设置元素的样式。\n4. **append()**、**appendTo()**表示追加元素到另一个元素内部。\n\n\n\n# 六、案例：纵向导航菜单\n\n## 6.1、HTML布局和css样式\n\n![1533453258374](1533453258374.png)\n\nhead区引入css和js文件：\n\n```html\n\t<link rel=\"stylesheet\" href=\"css/menu.css\">\n    <script src=\"js/jquery-3.3.1.js\"></script>\n    <script src=\"js/menu.js\"></script>\n```\n\nhtml代码：\n\n```html\n<ul>\n    <li>\n        <a href=\"#\">顶级菜单一</a>\n        <ul>\n            <li>子菜单11</li>\n            <li>子菜单12</li>\n            <li>子菜单13</li>\n        </ul>\n    </li>\n    <li>\n        <a href=\"#\">顶级菜单二</a>\n        <ul>\n            <li>子菜单21</li>\n            <li>子菜单22</li>\n            <li>子菜单23</li>\n        </ul>\n    </li>\n    <li>\n        <a href=\"#\">顶级菜单三</a>\n        <ul>\n            <li>子菜单31</li>\n            <li>子菜单32</li>\n            <li>子菜单33</li>\n        </ul>\n    </li>\n</ul>\n```\n\ncss样式：\n\n```css\n*{\n    margin:0;\n    padding:0;\n    border:0 none;\n}\nul,li{\n    list-style: none; /*去掉li前面的圆点*/\n}\n\n/*顶级菜单*/\na{\n    display: block;\n    width:100px;\n    height:30px;\n    line-height: 30px;\n    text-decoration: none;\n    background-color: #232323;\n    color:white;\n}\n\n/*子菜单*/\nul ul li{\n    width:100px;\n    height:30px;\n    line-height: 30px;\n    text-decoration: none;\n    background-color: #ffccff;\n    color:white;\n}\n\n/*默认子菜单隐藏*/\nul ul{\n    display: none;\n}\n```\n\n## 6.2、js代码\n\njQuery效果：\n\n- 单纯的显示隐藏：\n  - show()\n  - hide()\n  - toggle()\n- 上下滑动式的显示隐藏\n  - slideDown()\n  - slideUp()\n  - slideToggle()\n- 淡入淡出的显示隐藏\n  - fadeIn()\n  - fadeOut()\n  - fadeToggle()\n  - fadeTo(透明度)  -- 将透明度切换到指定的值\n\n```javascript\n//页面加载完毕，执行\n$(document).ready(function(){\n    \n    //找到顶级菜单中的a，然后绑定单击事件\n    $('a').click(function(){\n        \n        //让a的下一个兄弟显示\n        // $(this) 表示你点击的a\n        /*\n       //常规方法\n        if($(this).next('ul').css('display') == 'none'){\n            $(this).next('ul').show(1000);\n        }else{\n            $(this).next('ul').hide(1000);\n        }\n        */\n        \n       //当前对象的下一个元素（ul），显示或隐藏\n        $(this).next('ul').toggle(500); //对角上下滑动\n        // $(this).next('ul').slideToggle(500); //上下滑动\n        // $(this).next('ul').fadeToggle(500); //淡入淡出\n    });\n});\n```\n\n\n\n## 6.3 案例总结\n\n点击菜单(a链接)，让其对应的子菜单区域显示或隐藏\n\n\n\n# 七、案例：横向导航菜单（下拉菜单）\n\n![1533455969563](1533455969563.png)\n\n## 7.1、HTML+css效果\n\nhead区引入css和js文件：\n\n```html\n\t<link rel=\"stylesheet\" href=\"css/menu2.css\">\n    <script src=\"js/jquery-3.3.1.js\"></script>\n    <script src=\"js/menu2.js\"></script>\n```\n\n```html\n<ul id=\"menu2\">\n    <li>\n        <a href=\"#\">顶级菜单一</a>\n        <ul>\n            <li>子菜单11</li>\n            <li>子菜单12</li>\n            <li>子菜单13</li>\n        </ul>\n    </li>\n    <li>\n        <a href=\"#\">顶级菜单二</a>\n        <ul>\n            <li>子菜单21</li>\n            <li>子菜单22</li>\n            <li>子菜单23</li>\n        </ul>\n    </li>\n    <li>\n        <a href=\"#\">顶级菜单三</a>\n        <ul>\n            <li>子菜单31</li>\n            <li>子菜单32</li>\n            <li>子菜单33</li>\n        </ul>\n    </li>\n</ul>\n```\n\ncss代码：\n\n```css\n*{\n    margin:0;\n    padding:0;\n    border:0 none;\n}\nul,li{\n    list-style: none;\n}\n/*顶级菜单*/\na{\n    display: block;\n    width:100px;\n    height:30px;\n    line-height: 30px;\n    background-color: #232323;\n    color:#fff;\n    text-decoration: none;\n}\n#menu2 > li{\n    float:left;\n}\n\n/*子菜单*/\n#menu2 ul li{\n    width:100px;\n    height:30px;\n    line-height: 30px;\n    background-color: #999;\n    color:#fff;\n    text-decoration: none;\n}\n/*默认子菜单隐藏*/\n#menu2 ul{\n    display: none;\n}\n```\n\n## 7.2、实现下拉效果方法一\n\n```javascript\n//页面载入事件\n$(document).ready(function () {\n\n    //在下拉菜单显示后，光标移到子菜单中也不能脱离焦点\n    //所以，事件对象应该是包含顶级菜单的子li，不包括后代li\n\n    //mouseover和mouseout ,在事件对象的子元素中会反复触发事件\n    //解决方案：使用只触发一次的 mouseenter和mouseleave\n    \n    /*\n    //mouseover和mouseout\n    //光标移入事件\n    $('#menuH >li').mouseover(function () {\n\n        $(this).children('ul').slideDown(500);\n    });\n    //光标移出事件\n    $('#menuH >li').mouseout(function () {\n\n        $(this).children('ul').slideUp(500);\n    });\n    */\n\n    //mouseenter和mouseleave\n    //光标移入事件\n    $('#menuH >li').mouseenter(function () {\n\n        $(this).children('ul').slideDown(500);\n    });\n    //光标移出事件\n    $('#menuH >li').mouseleave(function () {\n\n        $(this).children('ul').slideUp(500);\n    });\n    \n\n});\n```\n\n### 7.2.1、mouseover和mouseenter事件对比\n\n这两个事件都是鼠标移入事件，对应的离开事件分别是**mouseout**和**mouseleave**。\n\n**mouseover**事件，鼠标放上去，执行一次事件，当鼠标移入元素的子元素上==会==再次触发该事件。\n\n**mouseenter**事件，鼠标放上去，执行一次事件，当鼠标移入元素的子元素上==不会==再次触发该事件。\n\n```html\n<head>\n    <script src=\"js/jquery-3.3.1.js\"></script>\n    <script>\n        $(document).ready(function(){\n            $('#over').mouseover(function(){\n                var zhi = $(this).children('h1').text();\n                zhi = parseInt(zhi)+1;\n                $(this).children('h1').text(zhi);\n            });\n\n            $('#enter').mouseenter(function(){\n                var zhi = $(this).children('h1').text();\n                zhi = parseInt(zhi)+1;\n                $(this).children('h1').text(zhi);\n            });\n        });\n    </script>\n</head>\n<body>\n\n<div id=\"over\" style=\"background-color: #ccc;\">\n    over\n    <h1 style=\"background-color: blue;\">0</h1>\n</div>\n\n<div id=\"enter\" style=\"background-color: #ffccff\">\n    enter\n    <h1 style=\"background-color: red;\">0</h1>\n</div>\n\n</body>\n```\n\n## 7.3、使用hover事件并加入定时器\n\n\n**解决**：光标快速经过对象时，也会无误的触发对象的事件\n\n\n```javascript\n//页面载入事件\n$(document).ready(function () {\n\n    //在下拉菜单显示后，光标移到子菜单中也不能脱离焦点\n    //所以，事件对象应该是包含顶级菜单的子li，不包括后代li\n\n    //mouseover和mouseout ,在事件对象的子元素中会反复触发事件\n    //解决方案：使用只触发一次的 mouseenter和mouseleave\n    /*\n    // mouseover和mouseout\n    //光标移入事件\n    $('#menuH >li').mouseover(function () {\n\n        $(this).children('ul').slideDown(500);\n    });\n    //光标移出事件\n    $('#menuH >li').mouseout(function () {\n\n        $(this).children('ul').slideUp(500);\n    });\n    */\n\n    /*\n    // mouseenter和mouseleave\n    //光标移入事件\n    $('#menuH >li').mouseenter(function () {\n\n        $(this).children('ul').slideDown(500);\n    });\n    //光标移出事件\n    $('#menuH >li').mouseleave(function () {\n\n        $(this).children('ul').slideUp(500);\n    });\n    */\n\n    /*\n     * hover([over,]out) 事件\n     * 一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法。\n     * over:鼠标移到元素上要触发的函数\n     * out:鼠标移出元素要触发的函数\n     */\n    var st; //定时器\n    $('#menuH >li').hover(\n        function () { //光标移入事件\n\n            //光标快速经过对象时，也会无误的触发对象的事件，\n            //出于实际和安全考虑，需要让光标在对象上停留一定时间才触发事件\n            //所以，设置一个一次性定时器来实现\n            var li=$(this);\n            st=setTimeout(function () {\n                //此位置$(this)不是指向外面的对象，不能直接使用$(this)\n                li.children('ul').slideDown(500);\n            },300);\n\n        },\n        function () { //光标移出事件\n            //清除相应的定时器\n            //如果上面定时器的时间内，触发光标移出事件，就清除。\n            //即上面的定时器里的代码就没执行\n            clearTimeout(st);\n\n            $(this).children('ul').slideUp(500);\n        });\n    \n});\n```\n\n\n\n## 7.4 案例总结\n\n横向菜单，通常不需要点击，而是光标经过。\n\n所以，需要处理，光标移入和光标移出事件。\n\n个别细节需要处理：\n\n* 如事件对象中的子元素会再次触发事件；\n* 光标快速经过时，也会触发事件\n\n\n\n# 八、案例：标签页(选项卡)效果\n\n![1533459228473](1533459228473.png)\n\n## 8.1、html+css布局\n\nhead区引入css和js文件：\n\n```html\n\t<link rel=\"stylesheet\" href=\"css/tab.css\">\n    <script src=\"js/jquery-3.3.1.js\"></script>\n    <script src=\"js/tab.js\"></script>\n```\n\nHTML代码：\n\n```html\n<ul>\n    <li class=\"tab\">军事</li>\n    <li>娱乐</li>\n    <li>体育</li>\n</ul>\n<div class=\"show\">这是军事版块</div>\n<div>这是娱乐版块</div>\n<div>这是体育版块</div>\n```\n\ncss代码：\n\n```css\n*{\n    margin:0;\n    padding:0;\n    border:0 none;\n}\nul,li{\n    list-style: none;\n}\n\nli{\n    float:left;\n    width:50px;\n    height:30px;\n    background-color: #999;\n    color:#fff;\n    line-height: 30px;\n    border:solid 1px #fff;\n}\ndiv{\n    clear: both; /*清除浮动造成的影响*/\n    width:200px;\n    height:120px;\n    background-color: #051c29;\n    color:#fff;\n    display: none;/*隐藏所有的div*/\n}\n/*下面单独设置第一个div和第一个li的样式*/\ndiv.show{\n    display: block;\n}\nli.tab{\n    background-color: #051c29;\n    border: solid 1px #051c29;\n}\n```\n\n## 8.2、js代码\n\n```javascript\n$(document).ready(function(){\n    //找到3个li，绑定单击事件\n    /*$('li').click(function(){\n        //让对应的版块显示(设置当前li的class、设置对应div的class)\n        $('li').removeClass('tab');\n        $(this).addClass('tab');\n    });*/\n    \n    //jQuery核心方法 $.each(); 用于遍历数组或对象的\n    //each() 用法一\n    /*$('li').each(function(i, val){\n        console.log(i, val);\n    });*/\n    \n    //each() 用法二 （用的比较多）\n    /*$.each($('li'), function(i, val){\n        console.log(i, val);\n    });*/\n    /***************************************************************/      \n    //事件对象为选项卡的每个标签li\n    //目的：让对应的版块显示(设置当前li的class、设置对应div的class)\n\n    //遍历标签li\n    // jQuery核心方法 $.each(); --用于遍历数组或对象\n    // i 表示每个li的下标\n    // val 表示每个li，是一个dom对象\n    $.each($('li'), function(i, val){\n        \n        //val是一个dom对象，用$()转换成jQuery对象\n        //每个li单击事件\n        $(val).click(function(){\n            //alert(i); //这里的i仍然表示每个li的下标\n            \n            // eq(n) :表示第n个\n            //$('li').eq(i) 表示点击的li\n            //siblings([expr]) : 同辈元素\n            $('li').eq(i).addClass('tab').siblings().removeClass('tab');\n            $('div').eq(i).addClass('show').siblings().removeClass('show');\n        });\n        \n    });\n    \n});\n```\n\n### 8.2.1、each用法\n\n```javascript\n//用法一：\n$('li').each(function(i, val){\n    // i 表示每个li的下标\n    // val 表示每个li，是一个dom对象\n});\n\n//用法二：常用\n$.each($('li'), function(i, val){\n    // i 表示每个li的下标\n    // val 表示每个li，是一个dom对象\n});\n```\n\n## 8.3 案例总结\n\n**标签页(选项卡)**：为选项卡的每个标签绑定事件，触发事件时，设置标签样式和对应的内容区样式(显示)，其它未触发的标签和内容区样式不同。\n\n\n\n----\n\n\n\n# 七、案例：无刷新分页+可编辑表格\n\n## 1、分页原理\n\n获取province表所有的数据：select * from province;\n\n假设每页显示4条，用 `$pageSize = 4;`表示\n\n用变量 `$p = $_GET['p'] ?? 1;` 表示当前的页码\n\n获取第1页数据的SQL：select * from province limit 0,4;\n\n获取第2页数据的SQL：select * from province limit 4,4;\n\n获取第3页数据的SQL：select * from province limit 8,4;\n\n获取第$p页数据的SQL：select * from province limit ($p-1)*$pageSize , $pageSize;\n\n## 2、先开发一个列表页，带分页\n\n创建list.php:\n\n```html\n<body>\n<h1 align=\"center\">所有的省</h1>\n<table>\n    <thead>\n    <tr>\n        <th width=\"30%\">PID</th>\n        <th width=\"30%\">Pcode</th>\n        <th width=\"40%\">Pname</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td></td>\n        <td></td>\n        <td></td>\n    </tr>\n    </tbody>\n</table>\n<p align=\"center\"></p>\n</body>\n```\n\ncss样式：\n\n```css\n\t\t*{\n            margin:0;\n            padding:0;\n            border:0 none;\n        }\n        table,th,td{\n            border:solid 1px #051c29;\n            border-collapse: collapse;\n        }\n        table{\n            margin:10px auto;\n            width:600px;\n        }\n```\n\n效果：\n\n![1533541699281](1533541699281.png)\n\n在list.php开头的位置，写php代码，获取带分页的数据：\n\n```php\n$pdo = new PDO('mysql:host=localhost;dbname=test;charset=utf8', 'root', '123');\n\n$pageSize = 4; //表示每页显示多少条数据\n$p = $_GET['p'] ?? 1; //表示当前的页码\n\n$sql = \"select * from province limit \" . ($p-1)*$pageSize . \",\" . $pageSize;\n$stmt = $pdo->prepare($sql); //预处理，得到PDOStatement对象\n$stmt->execute();\n$data = $stmt->fetchAll(PDO::FETCH_ASSOC);\n//echo '<pre>';\n//print_r($data);\n```\n\n下面html中，循环tr，显示数据：\n\n```php+html\n<table>\n    <thead>\n    <tr>\n        <th width=\"30%\">PID</th>\n        <th width=\"30%\">Pcode</th>\n        <th width=\"40%\">Pname</th>\n    </tr>\n    </thead>\n    <tbody>\n    <?php\n    foreach($data as $value):\n    ?>\n    <tr>\n        <td><?php echo $value['PID'];?></td>\n        <td><?php echo $value['Pcode'];?></td>\n        <td><?php echo $value['Pname'];?></td>\n    </tr>\n    <?php\n    endforeach;\n    ?>\n    </tbody>\n</table>\n<p align=\"center\"></p>\n```\n\n到此位置，刷新页面，能够看到第一页的数据了：\n\n![1533542166227](1533542166227.png)\n\n下面继续在list.php中，写php，完成页码制作：\n\n```php\n/*************** 下面制作分页样式 **************/\n$page = '';\n//上一页\nif($p <= 1){\n    $page .= \"<a href='javascript:void(0);'>上一页</a>\";\n}else{\n    $page .= \"<a href='?p=\".($p-1).\"'>上一页</a>\";\n}\n\n\n//下一页\n$sql = \"select count(*) from province\";\n$stmt = $pdo->prepare($sql);\n$stmt->execute();\n$count = $stmt->fetchColumn();\n$maxPage = ceil($count/$pageSize); //maxPage 表示总页数\nif($p >= $maxPage){\n    $page .= \"<a href='javascript:void(0);'>下一页</a>\";\n}else{\n    $page .= \"<a href='?p=\".($p+1).\"'>下一页</a>\";\n}\n```\n\n然后在html中，把分页放到p标签中：\n\n```php+html\n<p align=\"center\">\n    <?php echo $page;?>\n</p>\n</body>\n```\n\n## 3、无刷新的分页，获取第1页数据\n\n页面访问html页面即可，php页面用于返回数据，返回给ajax的请求。\n\n![1533543213882](1533543213882.png)\n\n把原list.php中的html代码剪切到list.html中，形成两个文件。\n\n两个页面工作原理是，浏览器访问list.html，list.html中需要的数据通过ajax请求到list.php中去获取。\n\n下一步，在list.html中，当页面加载完毕，向list.php发送ajax请求，请求第1页的数据。\n\n![1533543701617](1533543701617.png)\n\nlist.php，返回浏览器请求的数据：\n\n![1533543755896](1533543755896.png)\n\n当访问list.html的时候，能够通过浏览器工具，查看到返回的内容：\n\n![1533543804858](1533543804858.png)\n\n接下来只需要处理返回的data到页面即可。\n\n```javascript\n//页码加载完毕，请求第1 页的数据\n        $(function(){\n            $.get('list.php',{}, function(data){\n                //console.log(data);\n                //把数据放到tbody中\n                //console.log(data[0]);\n                var trs = '';\n                $.each(data[0], function(i, val){\n                    trs += '<tr><td>'+val.PID+'</td><td>'+val.Pcode+'</td><td>'+val.Pname+'</td></tr>';\n                });\n                $('tbody').html(trs);\n                //把分页样式放到p里面\n                $('p').html(data[1]);\n            }, 'json');\n        });\n```\n\n## 4、获取其他页数据\n\n目前点击下一页，会刷新页面，和目标无刷新的分页不相符。所有把所有超链接的href属性全部写`javascript:void(0);` ，原来的href的值写到page属性上。\n\n修改list.php\n\n```php\n/*************** 下面制作分页样式 **************/\n$page = '';\n//上一页\nif($p <= 1){\n    ///////////////////////////////////////////////////////\n    $page .= \"<a href='javascript:void(0);' page='p=1'>上一页</a>\";\n}else{\n    ///////////////////////////////////////////////////////\n    $page .= \"<a href='javascript:void(0);' page='p=\".($p-1).\"'>上一页</a>\";\n}\n\n\n//下一页\n$sql = \"select count(*) from province\";\n$stmt = $pdo->prepare($sql);\n$stmt->execute();\n$count = $stmt->fetchColumn(); //查询一行中的一列\n$maxPage = ceil($count/$pageSize); //maxPage 表示总页数\nif($p >= $maxPage){\n    ///////////////////////////////////////////////////////\n    $page .= \"<a href='javascript:void(0);' page='p=\".$maxPage.\"'>下一页</a>\";\n}else{\n    ///////////////////////////////////////////////////////\n    $page .= \"<a href='javascript:void(0);' page='p=\".($p+1).\"'>下一页</a>\";\n}\n\n//返回给浏览器的内容有4条数据，和分页样式\necho json_encode([$data, $page]);\n```\n\n![1533546444712](1533546444712.png)\n\n再次发送ajax请求，查看浏览器工具：\n\n![1533545611227](1533545611227.png)\n\n现在，点击页面中的“上一页”和“下一页”确实不会刷新页面，但是不会有新的数据，所以下一步，点击“上一页”和“下一页”的时候，要继续发送ajax请求，请求对应的数据。\n\n```javascript\n//因为a是后来加载到页面中的，所以必须用on来绑定事件\n//给上一页，下一页分别绑定单击事件\n$(document).on('click', 'a', function(){\n    //继续发送ajax请求\n    var param = $(this).attr('page');\n    //console.log(param);\n    $.get('list.php', param, function(data){\n        //console.log(data);\n        //把数据放到tbody中\n        //console.log(data[0]);\n        var trs = '';\n        $.each(data[0], function(i, val){\n            trs += '<tr><td>'+val.PID+'</td><td>'+val.Pcode+'</td><td>'+val.Pname+'</td></tr>';\n        });\n        $('tbody').html(trs);\n        //把分页样式放到p里面\n        $('p').html(data[1]);\n    }, 'json');\n});\n```\n\n## 5、可编辑的表格\n\n可编辑的表格，想要获取tbody中的元素，不可以，因为tbody中的tr和td都是后来加载到页面上的，所以得在ajax处理函数中，才能获取到tbody中的tr或td。\n\n为了方便，封装处理数据的方法：\n\n```javascript\n/************ 封装一个处理ajax返回数据的函数 ***************/\n        function chuli(data){\n            //console.log(data);\n            //把数据放到tbody中\n            //console.log(data[0]);\n            var trs = '';\n            $.each(data[0], function(i, val){\n                trs += '<tr><td>'+val.PID+'</td><td>'+val.Pcode+'</td><td>'+val.Pname+'</td></tr>';\n            });\n            $('tbody').html(trs);\n            //把分页样式放到p里面\n            $('p').html(data[1]);\n        }\n\n        $(function(){\n            /************** 页码加载完毕，请求第1 页的数据 *****************/\n            $.get('list.php',{}, function(data){\n                chuli(data); /////////////////////////////////////修改的位置\n            }, 'json');\n\n\n\n            /***************** 给上一页，下一页分别绑定单击事件 *******************/\n            $(document).on('click', 'a', function(){\n                //继续发送ajax请求\n                var param = $(this).attr('page');\n                //console.log(param);\n                $.get('list.php', param, function(data){\n                    chuli(data); /////////////////////////////////////修改的位置\n                }, 'json');\n            });\n\n        });\n```\n\n下一步，在chuli函数中，做可编辑的表格：\n\n下面是完整的处理方法\n\n```javascript\n/************ 封装一个处理ajax返回数据的函数 ***************/\n        function chuli(data){\n            //console.log(data);\n            //把数据放到tbody中\n            //console.log(data[0]);\n            var trs = '';\n            $.each(data[0], function(i, val){\n                trs += '<tr><td>'+val.PID+'</td><td>'+val.Pcode+'</td><td>'+val.Pname+'</td></tr>';\n            });\n            $('tbody').html(trs);\n            //把分页样式放到p里面\n            $('p').html(data[1]);\n\n\n            //开发可编辑的表格\n            //找到包含Pname的td，绑定单击事件\n            $('tbody tr td:last-child').click(function(){\n                var td = $(this);\n                if(td.children('input').length > 0){\n                    return false;\n                }\n                var text = td.text();\n                td.html(\"\");\n                var input = $('<input type=\"text\" />');\n                input.val(text)\n                        .css('width', td.css('width'))\n                        .css('height', td.css('height'))\n                        .css('background-color', td.css('background-color'))\n                        .css('font', td.css('font'))\n                        .css('outline', '0 none')\n                        .appendTo(td)\n                        .focus();\n\n                input.blur(function(){\n                    td.html(text);\n                }).keyup(function(e){\n                    if(e.which == 13){\n                        td.html(\"\");\n                        var newVal = $(this).val();\n                        td.html(newVal);\n                        //发送ajax到edit.php，修改数据\n                        var pid = td.prev().prev().text();\n                        //var pid = td.parent().children().first().text();\n                        //update province set pname=??? where PID=???\n                        $.get('edit.php', {PID:pid, Pname:newVal}, function(data){\n\n                        }, 'text');\n                    }\n                });\n            });\n        }\n```\n\nedit.php\n\n```php\n$pdo = new PDO('mysql:host=localhost;dbname=test;charset=utf8', 'root', '123');\n\n$pid = $_GET['PID'];\n$pname = $_GET['Pname'];\n\n$sql = \"update province set Pname='$pname' where PID=$pid\";\n$pdo->exec($sql);\n```\n\n修改成功，加入提示：\n\nedit.php返回执行的结果：\n\n```php\n$pdo = new PDO('mysql:host=localhost;dbname=test;charset=utf8', 'root', '123');\n\n$pid = $_GET['PID'];\n$pname = $_GET['Pname'];\n\n$sql = \"update province set Pname='$pname' where PID=$pid\";\nif($pdo->exec($sql)){\n    echo 1;\n}else{\n    echo 0;\n}\n```\n\njs代码，按回车后，给出提示：\n\n引入layer.js\n\n![1533548596813](1533548596813.png)\n\n判断，并提示：\n\n![1533548624468](1533548624468.png)\n\n\n\n----\n\n\n\n# 五、案例：自定义弹出窗口插件\n\n## 5.1、创建demo.html，并写好css\n\n```html\n<body>\n\n<div id=\"left\">\n    <div class=\"title\">左边的标题 <span>×</span></div>\n    <div class=\"content\">\n        这是左边的内容\n    </div>\n</div>\n\n<div id=\"center\">\n    <div class=\"title\">中间的标题 <span>×</span></div>\n    <div class=\"content\">\n        这是中间的内容\n    </div>\n</div>\n\n<div id=\"right\">\n    <div class=\"title\">右边的标题 <span>×</span></div>\n    <div class=\"content\">\n        这是右边的内容\n    </div>\n</div>\n\n</body>\n```\n\n```css\n*{\n    margin:0;\n    padding:0;\n    border:0 none;\n}\n#left, #center, #right {\n    width:200px;\n    height:120px;\n    border:solid 1px #051c29;\n    position:absolute; /*绝对定位*/\n    display: none;\n}\n.title{\n    height:20px;\n    line-height: 20px;\n    background-color: #92B8B1;\n    border-bottom: solid 1px #051c29;\n}\n.title span{\n    float: right;\n    cursor: pointer; /*鼠标放上去显示手型*/\n}\n.title, .content{\n    padding:5px;\n}\n```\n\n## 5.2、创建插件box.js\n\n![1533698726580](1533698726580.png)\n\ndemo.html引入两个js，注意顺序，一定要先引入jquery，然后在引入自己的插件。\n\n![1533698800934](1533698800934.png)\n\n\n\n## 5.3、编写插件\n\n弹出窗口的位置一个有9个，分别是：\n\n![1533711236968](1533711236968.png)\n\n首先使用立即调用模式，编写插件：\n\n```javascript\n//函数立即调用，不会占用$符号\n(function($){\n    //自定义插件，名字为box\n    /**\n     * 插件功能：能够设置元素的left和top值\n     * 插件功能：能够设置元素的显示效果（直接显示、显示后淡出、滑动显示）\n     */\n    /**\n     *\n     * @param position 是一个对象 {zuo:xxx, shang:xxx}\n     * @param xiaoguo 是一个字符串，可选的值有：show, fadeOut, slide， 默认是show\n     */\n    $.fn.box = function(position, xiaoguo){\n        \n    };\n})(jQuery);\n//这种方式的好处是，插件内部可以无限制的使用$，而不会和其他插件冲突。\n```\n\ndemo.html中，调用插件，进行测试：\n\n```html\n<script>\n    //这里写代码，调用插件\n    $(function(){\n        $('#left').box({zuo:'right', shang:'bottom'});\n    });\n</script>\n```\n\n编写插件代码，计算浏览器的宽度、高度、要显示的窗口的宽度、高度、滚动条滚动的距离，获取之后，计算真实的left值和top值，然后设置box的css样式：\n\n```javascript\n//函数立即调用，不会占用$符号\n(function($){\n    //自定义插件，名字为box\n    /**\n     * 插件功能：能够设置元素的left和top值\n     * 插件功能：能够设置元素的显示效果（直接显示、显示后淡出、滑动显示）\n     */\n    /**\n     *\n     * @param position 是一个对象 {zuo:xxx, shang:xxx}\n     * @param xiaoguo 是一个字符串，可选的值有：show, fadeOut, slide， 默认是show\n     */\n    $.fn.box = function(position, xiaoguo){\n        var win = $(window); //用变量表示浏览器窗口\n        var box = $(this); //用box表示当的窗口\n        var left = position.zuo; //用户传递的left\n        var top = position.shang; //用户传递的top\n        var browserWidth = win.width(); //浏览器的宽度\n        var browserHeight = win.height(); //浏览器的高度\n        var boxWidth = box.outerWidth(); //窗口的宽度\n        var boxHeight = box.outerHeight(); //窗口的高度\n        var scrollLeft = win.scrollLeft(); //下边滚动条滚动的距离\n        var scrollTop = win.scrollTop(); //右侧滚动条滚动的距离\n        if(xiaoguo == undefined){\n            //说明用户没有指定xiaoguo\n            xiaoguo = 'show';\n        }\n        //计算真实的left的值和真实的top的值\n        var trueLeft;\n        var trueTop;\n\n        //判断传递进来的left和top，并计算真实的trueLeft和真实的trueTop\n        if(left == 'left'){\n            //trueLeft = 下边滚动条滚动距离;\n            trueLeft = scrollLeft;\n        }else if(left == 'center'){\n            //trueLeft = (浏览器宽度-box宽度)/2 + 下边滚动条滚动距离;\n            trueLeft = (browserWidth - boxWidth)/2 + scrollLeft;\n        }else if(left == 'right'){\n            //trueLeft = 浏览器宽度-box宽度 + 下边滚动条滚动距离;\n            trueLeft = browserWidth - boxWidth + scrollLeft;\n        }\n        if(top == 'top'){\n            //trueTop = 右侧滚动条滚动距离;\n            trueTop = scrollTop;\n        }else if(top == 'center'){\n            //trueTop = (浏览器高度-box高度)/2 + 右侧滚动条滚动距离;\n            trueTop = (browserHeight - boxHeight)/2 + scrollTop;\n        }else if(top == 'bottom'){\n            //trueTop = 浏览器高度-box高度 + 右侧滚动条滚动距离;\n            trueTop = browserHeight - boxHeight + scrollTop;\n        }\n\n        //console.log(trueTop);\n        //设置要显示的窗口的left和top值\n        box.css('left', trueLeft+'px').css('top', trueTop+'px').show();\n        return box;\n    };\n})(jQuery);\n```\n\n## 5.4、加入窗口改变大小事件和滚动事件\n\n当浏览器窗口改变大小和滚动条滚动的时候，重新获取浏览器的宽度，高度，重新获取滚动条滚动的距离，重新计算trueLeft和trueTop的值，最后设置box的css。\n\n整理代码：==下面代码全部在$.fn.box = function(){}函数内部==\n\n第一部分：声明变量\n\n```javascript\nvar win = $(window); //用变量表示浏览器窗口\nvar box = $(this); //用box表示当的窗口\nvar left = position.zuo; //用户传递的left\nvar top = position.shang; //用户传递的top\nvar boxWidth = box.outerWidth(); //窗口的宽度\nvar boxHeight = box.outerHeight(); //窗口的高度\nvar browserWidth; //浏览器的宽度\nvar browserHeight; //浏览器的高度\nvar scrollLeft; //下边滚动条滚动的距离\nvar scrollTop; //右侧滚动条滚动的距离\n//计算真实的left的值和真实的top的值\nvar trueLeft;\nvar trueTop;\n```\n\n第二部分：定义函数\n\n```javascript\n/**\n * 计算浏览器的宽度、高度、计算滚动条的滚动距离\n */\nfunction getInfo(){\n    browserWidth = win.width(); //浏览器的宽度\n    browserHeight = win.height(); //浏览器的高度\n    scrollLeft = win.scrollLeft(); //下边滚动条滚动的距离\n    scrollTop = win.scrollTop(); //右侧滚动条滚动的距离\n}\n\n//判断传递进来的left和top，并计算真实的trueLeft和真实的trueTop\n/**\n * 计算真实的用于css设置的 left值和top值\n */\nfunction getTrue(){\n    if(left == 'left'){\n        //trueLeft = 下边滚动条滚动距离;\n        trueLeft = scrollLeft;\n    }else if(left == 'center'){\n        //trueLeft = (浏览器宽度-box宽度)/2 + 下边滚动条滚动距离;\n        trueLeft = (browserWidth - boxWidth)/2 + scrollLeft;\n    }else if(left == 'right'){\n        //trueLeft = 浏览器宽度-box宽度 + 下边滚动条滚动距离;\n        trueLeft = browserWidth - boxWidth + scrollLeft;\n    }\n    if(top == 'top'){\n        //trueTop = 右侧滚动条滚动距离;\n        trueTop = scrollTop;\n    }else if(top == 'center'){\n        //trueTop = (浏览器高度-box高度)/2 + 右侧滚动条滚动距离;\n        trueTop = (browserHeight - boxHeight)/2 + scrollTop;\n    }else if(top == 'bottom'){\n        //trueTop = 浏览器高度-box高度 + 右侧滚动条滚动距离;\n        trueTop = browserHeight - boxHeight + scrollTop;\n    }\n}\n\n//console.log(trueTop);\n/**\n * 显示窗口\n */\nfunction xianshi(){\n    box.css('left', trueLeft+'px').css('top', trueTop+'px').show();\n}\n```\n\n第三部分：调用函数\n\n```javascript\ngetInfo(); //一定要调用一次\ngetTrue(); //调用一次\nxianshi();\n```\n\n第四部分：浏览器窗口改变大小事件和滚动条滚动事件\n\n```javascript\n//设置浏览器窗口改变大小事件\nwin.resize(function(){\n    getInfo(); //一定要调用一次\n    getTrue(); //调用一次\n    xianshi();\n});\n\n//设置滚动条滚动事件\nwin.scroll(function(){\n    getInfo(); //一定要调用一次\n    getTrue(); //调用一次\n    xianshi();\n});\n\nreturn box;\n```\n\n## 5.5、加入效果\n\n修改demo.html，让其他的窗口也显示\n\n![1533716080829](1533716080829.png)\n\nbox.js，显示的时候，判断效果：\n\n```javascript\n/**\n * 显示窗口\n */\nfunction xianshi(){\n    if(xiaoguo == undefined || xiaoguo == 'show'){\n        box.css('left', trueLeft+'px').css('top', trueTop+'px').show();\n    }else if(xiaoguo == 'fadeOut'){\n        box.css('left', trueLeft+'px').css('top', trueTop+'px').show().delay(1000).fadeOut(1000);\n    }else if(xiaoguo == 'slide'){\n        box.css('top', browserHeight)\n            .css('left', trueLeft)\n            .height(0)\n            .show()\n            .animate({\n                height:boxHeight-2,\n                top:browserHeight-boxHeight\n            },2000)\n            .delay(1000)\n            .fadeOut(1000);\n    }\n}\n```\n\n解决一个bug，已经淡出的窗口，当滚动条滚动的时候，又会显示：\n\n```javascript\n//设置浏览器窗口改变大小事件\nwin.resize(function(){\n    //判断，当浏览器改变大小的时候，让可见的元素显示\n    if(box.is(':hidden')){\n        return false;\n    }\n    getInfo(); //一定要调用一次\n    getTrue(); //调用一次\n    xianshi();\n});\n\n//设置滚动条滚动事件\nwin.scroll(function(){\n    //判断，当滚动条滚动的时候，让可见的元素显示即可\n    if(box.is(':hidden')){\n        return false;\n    }\n    getInfo(); //一定要调用一次\n    getTrue(); //调用一次\n    xianshi();\n});\n```\n\n给关闭按钮添加单击事件：\n\n```javascript\n//添加函数，点击关闭按钮，可以关闭box\nbox.find('span').click(function(){\n    box.hide();\n});\n```\n\n# 六、干货分享\n\n## 6.1、cdn方式加载jQuery\n\n![1533716867581](1533716867581.png)\n\n做项目的时候，直接引入baidu的jquery。\n\n![1533716907674](1533716907674.png)\n\n## 6.2、下载特效\n\n作为PHP程序员，学习JavaScript、ajax、jQuery，==最重要的是ajax，以及简单的事件绑定和dom操作==。\n\n特效类型的东西，可以去网上下载。\n\n## 6.3、扒静态页面工具\n\nTODO\n\n","categories":["js.Jquery"]},{"title":"Nginx","url":"%2Fposts%2F1706463495%2F","content":"\n\n# Nginx简介\n\n## **Lamp(Linux + Apache + MySQL + PHP)架构概述**\n\n**LAMP（Linux- Apache-MySQL-PHP）**网站架构是目前国际流行的Web架构，该架构包括：Linux操作系统，Apache网络服务器，MySQL数据库、PHP。所有组成产品均是开源软件，很多流行的商业应用都是采取这个架构。\n\nLAMP具有通用、跨平台、高性能、低价格的优势，因此LAMP无论是性能、质量还是价格都是企业搭建网站的首选平台。在国内可以说每一个公司都有使用LAMP这种架构，可以说它在国内互联网公司中的占有率基本上达到100%。\n\n \n\n对于大流量、大并发量的网站系统架构来说，除了硬件上使用高性能的服务器、负载均衡、CDN等之外，在软件架构上需要重点关注下面几个环节：使用高性能的操作系统（OS）、高性能的网页服务器（Web Server）、高性能的数据库（Database）、高效率的编程语言等。\n\n \n\n注意：现在的**M**有可能指的是MariaDB，它是MySQL的一个分支。现在的**P**有可能使用Python。\n\n\n\n## **C10K问题**\n\n\n\n目前的我们正处于web2.0的互联网的时代，传统的lamp架构已经很难承载目前的访问流量，同时`C10K`的问题的产生，这个时候我们就不得不使用更加优秀的架构来支撑业务。这个时候，俄国的一个程序猿根据现有的互联网场景、以及结合现在的开发技术和硬件，设计出了一个非常厉害的web服务器软件Nginx，由于Nginx是为了访问量而设计的服务器。在最早的时候Nginx服务器并不支持PHP的，是后来加入了FastCgi才开始支持PHP的。\n\n \n\n**什么是C10K的问题？**\n\n答：在web2.0时代(信息为主，是无法体现价值的转义 web3.0的时候就是目前最火的区块链技术，就是为了价值转移而存在)（以社交类型网站兴起的时候开始计算，51博客、校内）主要是以动态请求为主，静态请求为辅。这个时候由于早先web服务器的设计主要是为了完成静态请求，这个时候对动态请求就显得有点乏力，无法支持大的动态请求。互联网上的一些就开始开发新的web服务器，以来适应新的web2.0时代。\n\n\n\n**当一个web网站的请求的并发数达到10k**（同1s之内大概同时存在1w请求来请求web服务器），这个时候整个网站的架构都要进行重新设计。这个就是著名的C10K问题。并且目前互联网上已经出现**C100K** 甚至**C1000K**的问题的出现。\n\n\n\n## Nginx服务器简介\n\nnginx是一个web服务器；类似Apache软件。这是由俄国人开发的一个软件。其早期开发的这个软件主要是用于邮件代理。后面才转换为web服务，只能做静态的web服务器和`负载均衡器`。\n\n \n\n官网：<http://nginx.org/>\n\n中文社区：<http://www.nginx.cn/>\n\n书籍推荐：《实战nginx》、《决战Nginx》\n\n 张宴-httpsqs队列服务， 是国内最早将Nginx软件引入到新浪。\n\n\n\n**nginx 的使用:**\n\na. 邮件代理服务器，基本不再使用，最早期的功能，后来由于web领域做的更好\n\nb. 静态的web服务器（1u的服务器，大致可以处理的并发数 3-5w之间。apache的并发3-5k左右）\n\nc. 负载均衡器（集群）\n\n \n\n**了解Nginx软件内部的架构处理**\n\n答： Nginx软件启动的时候会启动一个master进程（管理），在启动一个worker进行（主要是提供web服务）。master主进程是不做事的，主要是负责进程的产生和管理，以及配置文件的读取、日志进程管理、缓存进程管理...\n\n \n\nNginx可以这样理解，在内部是一个worker进程处理多个用户的请求，并且在处理请求达到一定的数量之后，会被master进程kill掉，然后在重新的启动一个worker进程（只要是为了防止内存的泄露问题）\n\n \n\n**Nginx好的特性：**\n\na. 支持平滑升级（热部署）：在不关闭服务的情况下可以升级到其他的Nginx版本。（erlang是专门做热部署，一般在游戏领域或者银行领域使用这门语言）\n\nb. 支持动态配置文件的读取（不关闭服务的情况可以重新的加载配置文件）\n\n\n\n## Nginx和Apache\n\n我们需要知道==Nginx的产生并不是为了取代apache软件==，而是为了相互配合，使得网站架构更加的牢固。\n\n###  区别\n\nnginx和apache的软件底层架构不一样。**Nginx的并发性能要比apache好很多**，nginx属于轻量级服务器软件，apache属于重量级软件，nginx在处理静态页的效率要比apache好很多；apache在安全性要比nginx要好，apache在处理动态页面上的效率要比nginx高。\n\n \n\n### 运行模式不同\n\n**php在apache环境下**，运行的是php5模块方式运行的，由于是apache去加载php5模块，所以每次修改了php配置文件需要重启apache；\n\n\n\n**php在nginx模式下**，php运行的时候使用的是**php-fpm**方式进行运行，这个方式会创建**服务**（端口是9000），因此在nginx下修改了php配置文件只需要重启php-fpm服务即可。\n\n\n\n## 常见web服务器分类\n\n1. **apache软件**：一般在Linux下叫做httpd，最先是不使为了提供web服务，是为了解决资源共享的问题，最早使用应该是在军方的信息共享里面。(2.2  2.4版本)。重量级 ，设计成是模块化，但是它的模块不是热插拔的，就是说这么模块必须在编译安装的时候进行选择 ，后期要加，要重新编译。\n\n \n\n2. **nginx**：轻量级的web服务器，`轻内核`的web服务器，众多的其他的特性需要其他的模块进行提供(1. 官方很多模块 2. 第三方模块，互联网上广大开源爱好者，国内的淘宝为其提供很多的模块，并且有部分的模块已经被官方进行收录)。\n\n   【国内前端的力量基本都是在阿里，阿里最先提出大前端，全栈(js 全栈)也是阿里提出来。full stack】\n\n \n\n3. **IIS**：Windows下的一个web服务器，常见的和 sql server 已经和 windows server 一起使用，并且都是图形化配置。\n\n \n\n4. **Lighttpd**：主要是用来提供图片服务，主要是在推广上做的不好。早年豆瓣基本都是使用它。\n\n\n\n5. **tomcat**：Java里面的一个web服务器容器。\n\n\n\n---\n\n## 国内基于Nginx的二次开发\n\n**介绍两个国内基于Nginx做了二次开发的版本：**\n\n1. **tengine**：这个是淘宝基于Nginx做了二次开发，运用到双11 、天猫商城上面进行了检验，产品是非常的优秀。并且在上面增量很多的功能模块，提供了DSO特性。\n\n   http://tengine.taobao.org/\n\n2. **openresty**：这个产品是之前淘宝里面的一个叫做章宜春的大牛基于Nginx做了二次开发，设计出来。在Nginx的基础上面引入 lua 解释器，可以让Nginx在不使用第三方的脚本解释器的情况下，自己就可以完成动态请求。（openresty = nginx + lua）\n\n   1. lua是由一个巴西人开发出来了一门脚本语言，专注于游戏领域的开发。lua是后端语言。\n   2. cocos2d-lua 专门做游戏开发的，还有其它，如，cocos2d-js\\C++\n   3. lua火起来的原因是国内一款《大话2》，其背后的推动着是前网易的 云风（吴云洋）。（国内游戏基本上都认识这个人，天才）\n\n   http://openresty.org/cn/\n\n\n总结：上面的这两个产品在国内使用的更多。成熟的解决方案就更多，文档更加符合国内情况。\n\n\n\n## 哪里在使用这些web服务器？\n\n目前在全球T1000的网站里面，Nginx已经首当其冲。全球市场还是Apache老大哥。\n\n\n\n可以通过抓包分析\n\n1. 豆瓣\n\n   ![img](wpsC837.tmp.jpg)\n\n2. 搜狐\n\n   ![img](wps231A.tmp.jpg)\n\n\n\n后期找工作可以可以尝试去抓包分析网站使用的大致的技术，然后根据该技术有选择性的简历。\n\n\n\n# Nginx安装\n\n1. 使用yum安装\n\n   ```shell\n   # yum install -y nginx\n   ```\n\n2. 使用源码编译（lnmp架构）\n\n### 目录结构\n\n![1536392816584](1536392816584.png)\n\n\n\n### 安装nginx软件\n\n1. 使用ftpd客户端进行上传操作\n\n![1536392952965](1536392952965.png)\n\n2. 把所有的保存copy到/usr/local/src目录下\n\n![img](wpsA365.tmp.jpg) \n\n复制后\n\n![img](wpsA366.tmp.jpg) \n\n3. 由于nginx依赖pcre软件包，所以需要先安装pcre包\n\n   a. 解压\n\n![img](wpsA376.tmp.jpg) \n\n​\tb. 编译和安装一起\n\n![img](wpsA387.tmp.jpg) \n\n注意：pcre包安装的时候不需要指定安装路径 --prefix \n\n \n\n4. 安装nginx软件\n\n   a. 解压nginx安装包\n\n![img](wpsA388.tmp.jpg) \n\n​\tb. 进入后，编译和安装\n\n![img](wpsA389.tmp.jpg) \n\nnginx安装的时候指定了安装的路径(/usr/local/nginx)\n\n \n\n5. 安装后的目录结构\n\n![img](wpsA39A.tmp.jpg) \n\n \n\n6. 启动服务\n\n![img](wpsA39B.tmp.jpg) \n\n \n\n7. 查看服务是否正常启动\n\n进程查看方式\n\n![img](wpsA3AB.tmp.jpg) \n\n端口查看方式\n\n![img](wpsA3AC.tmp.jpg) \n\n\n\n\n\n ### 完成lnmp架构\n\n\n\n安装php的**php-fpm**运行模式。**在php-5.3.28**以后的版本默认里面就存在php-fpm模块，只需要在编译安装php的时候，启用这个模块即可。在编译configure的时候，指定一个选项 **--enable-fpm**\n\n\n\n1. 解压php源码包\n\n![img](wps3C8.tmp.jpg) \n\n \n\n2. 进行目录，编译安装\n\n![img](wps3D9.tmp.jpg) \n\n   收集操作系统的信息（主要是检测操作的位数，编译器是否存在）\n\n![img](wps3DA.tmp.jpg) \n\n3. 编译和安装（主要是把c语言的文件转换机器语言；安装把对应生成的二进制的命令复制到指定的安装目录里面）\n\n![img](wps3EA.tmp.jpg) \n\n​\t 注意：在编译的过程中，可能出现如下的错误\n\n![img](wps3EB.tmp.jpg) \n\n​\t可以使用如下命令进行解决\n\n```shell\n# yum -y install make apr* autoconf automake curl-devel gcc gcc-c++ zlib-devel openssl openssl-devel pcre-devel gd kernel keyutils patch perl kernel-headers compat* mpfr cpp glibc libgomp libstdc++-devel ppl cloog-ppl keyutils-libs-devel libcom_err-devel libsepol-devel libselinux-devel krb5-devel zlib-devel libXpm* freetype libjpeg* libpng* php-common php-gd ncurses* libtool* libxml2 libxml2-devel patch cmake wget vim lrzsz pcre pcre-devel\n```\n\n​\t在执行上面的命令后，需要先清除编译的临时文件，然后在重新编译\n\n```shell\n# make clean\n\n# ./configure --prefix=/usr/local/php --enable-fpm\n\n# make \n\n# make install\n```\n\n\n\n4. **安装后**\n\n![img](wps41E.tmp.jpg) \n\n​\t复制配置文件\n\n![img](wps41F.tmp.jpg) \n\n​\t启动\n\n![img](wps430.tmp.jpg) \n\n \n\n5. 查看服务\n\n![img](wps431.tmp.jpg) \n\n \n\n6. ==整合nginx和PHP==\n\n\t\t使得nginx能够完成动态的请求，修改如下的`nginx.conf`文件\n\n![img](wps441.tmp.jpg) \n\n​\t配置文件内容如下\n\n![img](wps442.tmp.jpg) \n\n​\t如果以后有index.php的文件的请求，则nginx会把请求交给php-fpm处理，php-fpm处理的动态脚本的目录\t是/scripts目录（动态文件夹的目录可以修改）\n\n \n\n7. 增加一个动态请求的目录\n\n![img](wps453.tmp.jpg) \n\n​\t增加一个index.php测试文件（内容phpinfo()函数）\n\n![img](wps454.tmp.jpg) \n\n \n\n8. 重启nginx服务器    `-s` 表示传递一个信号量\n\n![img](wps455.tmp.jpg) \n\n​          `-t` 检测nginx的配置文件语法是否正确\n\n![img](wps466.tmp.jpg) \n\n​\t   查看命令帮助\n\n![img](wps467.tmp.jpg) \n\n \n\n9. 浏览器查看\n\n![img](wps477.tmp.jpg) \n\n10. 通过上面查看发现php没有正确的加载配置文件，需要去php的源码包里面复制一份\n\n![img](wps488.tmp.jpg) \n\n​\t在上面正确复制后，重启**php-fpm**模式\n\n![img](wps499.tmp.jpg) \n\n​\t查看\n\n![img](wps49A.tmp.jpg) \n\n\n\n\n\n# Nginx使用\n\n## Nginx启动错误\n\n![1536549071320](1536549071320.png)\n\n\n\n解决方法：\n\n![1536543104617](1536543104617.png)\n\n\n\n\n\n## Nginx软件的基本使用\n\n在Nginx成功安装后，我们可以在Nginx的安装目录下的`sbin`文件夹里面的nginx来对linux进行管理。\n\n![img](wpsBCA.tmp.jpg) \n\n例如：语法检测   `# ./nginx -t`\n\n![img](wpsBCB.tmp.jpg) \n\n例如：配置文件重新加载   `# ./nginx -s reload`\n\n![img](wpsBDB.tmp.jpg) \n\n \n\n\n\n## Nginx软件的架构体系-【了解】\n\n<http://blog.csdn.net/syhd142/article/details/8440667>\n\n![img](wpsBDC.tmp.jpg) \n\n==记住：**master** 和 **worker**。==\n\nNginx不会对每个连接产生一个新的进程或线程。相反，worker从一个共享的“监听”socket接受新的请求，在每个worker内部执行高效的运行环来处理成千上万的连接。在Nginx内部没有对连接的专门仲裁和分发；这些工作是有操作系统内核来完成的。在启动时，一组初始的监听socket被创建。在处理HTTP请求和响应的时候，worker不断的接受，读取，写入这些socket。  \n\n\n\n由于Nginx对每个连接不会产生一个进程或线程，因此在绝大多数情况下，内存使用率非常保守并且非常的高效。因为没有持续的进程或线程的创建和销毁模式，所以Nginx也非常节省CPU的资源。Nginx所做的工作就是检查网络和存储的状态，初始化新的连接并将其接入运行环，直到异步完成处理时才将该连接释放并将其移除运行环。Nginx对系统调用的谨慎使用和对诸如pool，slab memory分配器接口支持的精准实现，使得Nginx即使在极度恶劣的工作环境中都能够占用较少的CPU资源。  \n\n\n\n由于Nginx会产生多个worker来处理连接，它在多核系统上扩展的很好。一般情况下，一个核心对应一个worker可以充分利用多核架构，并且阻止了线程竞争和锁死。在单线程的worker进程下不会产生资源匮乏，并且资源控制机制是独立的。该模型还允许在物理存储设备上有更多的扩展性，得到更多的磁盘利用率，避免的磁盘I/O阻塞。其结果是，服务器的资源能够被在共享工作平台上的多个worker更有效的利用。  \n\n\n\n**Nginx进程角色**\n\nNginx在内存中运行着多个进程；有一个主进程和几个worker进程。还有一些特殊目的的进程，特别是缓存加载进程和缓存管理进程。在1.x的Nginx版本中，所有的进程都是单线程的。所有的进程基本上都使用内存共享来进行进程间通信。主进程以root用户运行，缓存加载进程、缓存管理和worker进程以低特权用户运行。 \n\n主进程负责执行以下任务：\n\n* 读取并验证配置\n* 创建，绑定并关闭套接字\n* 开始、终止并保持配置中的work进程数目\n* 在线重新配置\n* 在线升级\n* 重新打开日志文件\n* 编译内嵌的Perl脚本 \n\n\n\n# Nginx的虚拟主机的配置\n\n参考文档：<http://tengine.taobao.org/nginx_docs/cn/>\n\n虚拟主机的配置：<http://tengine.taobao.org/nginx_docs/cn/docs/http/request_processing.html>\n\n\n\n## 配置文件的解释\n\n1. 子进程的配置\n\n![img](wpsA687.tmp.jpg) \n\n2. 子进程处理的http请求参数（默认1024即可，不是越大越好）\n\n![img](wpsA688.tmp.jpg) \n\n3. mime.types\n\n![img](wpsA699.tmp.jpg) \n\n4. http 配置：主要是用来做web配置\n\n![img](wpsA69A.tmp.jpg) \n\ngzip压缩\n\n<https://www.cnblogs.com/mitang/p/4477220.html>\n\n \n\nserver配置\n\n![img](wpsA6AA.tmp.jpg) \n\n\n\n## 基于域名的虚拟主机配置\n\n1. 修改server里面的 `server_name`\n\n![img](wpsA6AB.tmp.jpg) \n\n2. 更改hosts文件（Windows下），相当于是dns解释器\n\n![img](wpsA6BC.tmp.jpg) \n\n\n\n## **基于端口的配置**\n\n1. 增加一个server段\n\n![img](wpsA6BD.tmp.jpg) \n\n2. 创建一个虚拟主机的网站根目录（绝对路径）\n\n![img](wpsA6CD.tmp.jpg) \n\n3. 访问\n\n![img](wpsA6CE.tmp.jpg) \n\n# 负载均衡配置\n\n前面学习了Nginx可以为一个静态的web服务器，那么接下我们学习一下它的另外一个功能作为==负载均衡器==。\n\n \n\n之前，一般web架构里面，常见就是一个ln/amp，但是这个单一架构往往能力有限，随着业务的发展，网站越来越受到欢迎，则原先的架构不能支持高并发的访问。所以我们一般会对这个架构做扩展，来支撑高并发。\n\n \n\n**什么是并发？**\n\n答：可以简单的理解就是在1s之内的用户的访问量的总和。一般来说这个最好不要取平均值，一般来说这个最大的峰值。\n\n\n\n**一般常见的扩展的方式有哪些？**\n\n答：常见的扩展方式：\n\n1. 直接升级硬件服务器，也是最简单的，一般被称为**垂直扩展**，**向上扩展**。但是这个容易达到瓶颈。【服务器的硬件配置是很容易达到顶配 16G 32G 64G 128G  工业标准】【硬件升级价格是很贵 】【硬件配置升了一倍，性能不一定能提升】【老板最不喜欢】\n\n \n\n2. **水平扩展**，**向外扩展**。购买普通的pc廉价服务器，搭建集群。\n\n \n\n**什么是集群？**\n\n答：为了完成某一个特定的功能而使用多台服务器搭建的一个架构，被称为集群。\n\n一般在互联网的企业都是做web服务器，一般把它称为**web负载均衡集群**【**LB** load balance 负载平衡】。还有一些其他的集群：**高可用集群**【**HA** high availability】、**高性能集群**【**HP** high perfermance】。\n\n \n\n相关文档：<http://www.tuicool.com/articles/aMVjeeU#_motz_>\n\n \n\n抓包分析：<http://www.51cto.com/>\n\n可以看到该网站的内容是来自于`load-blance`\n\n![img](wpsA871.tmp.jpg) \n\n \n\n由于单台web服务器的能力有限，这个时候可以做水平扩展、向外扩展（scale outer），即 负载均衡集群，增加很多台web服务器提供服务。原先是一个垂直扩展 、向上扩展（scale up）（主要是在单台服务器上不断的增加硬件的配置）。\n\n\n\n## **垂直扩展**\n\n![img](wpsA881.tmp.jpg) \n\n**在单台服务器上增加配置，但是这有问题：**\n\n1. 随着硬件的增加的，效率反倒会在一定的时候出现急剧下降。主要的原因是由于如果存在多个CPU或者其他资源，多个服务进程会不断的争夺操作系统资源。\n\n2. 硬件是存在瓶颈的，也就是说不可能有一个无限配置的主机，也叫作电子行业的摩尔定律。主要是由于先天工业限制，造成电器设备的线宽已经达到瓶颈。\n\n3. 往往硬件的升级和硬件的成本是不满足线性关系的，是一个指数级别的增加。\n\n4. 往往老板最不喜欢花钱的。\n\n\n\n## 水平扩展\n\n![img](wpsA892.tmp.jpg) \n\n**f5报价**【好处：1. 简单 2. 效果特别明显 ，立竿见影】\n\n![img](wpsA893.tmp.jpg) \n\n在水平方向不断的增加主机，提升网站的整体的性能。\n\n\n\n概念：\n\n1. 常见的负载均衡器实现有：软件 nginx 或者 lvs和 硬件 f5（类似交换机 20w） \n\n2. 常见的负载均衡的算法有 `轮询`、`加权`、`ip_hash`\n\n\n\n## 高可用\n\n![img](wpsA8A3.tmp.jpg) \n\n \n\nping IP 包返回，即， 心跳检测\n\n注意：有一个参数是用来衡量这个高可用集群是否高效；**用9的个数**来衡量，如：\n\n \n\n一年内平均无故障的时间/(一年平均无故障的时间+平均恢复应用的时间+维护时间) * 100%\n\n得到的结果肯定是小于1的。（99.8% 或 96.8%）如果能够实现5个9则这个高可用的集群是非常稳固的（意味着一年内故障的时间大概在5分钟左右）（一般国内也就阿里和12306做到了）\n\n**推荐书本：**\n\n《京东技术解密》\n\n《淘宝技术那十年》\n\n \n\n## **具体配置**\n\n1. 画一个拓扑图\n\n![img](wpsA8A4.tmp.jpg) \n\n2. 配置3个虚拟主机 ，\n   1. 端口 81\n\n![img](wpsA8B5.tmp.jpg) \n\n​\t2. 端口 82\n\n![img](wpsA8B6.tmp.jpg) \n\n​\t3. 端口83\n\n![img](wpsA8B7.tmp.jpg) \n\n​\t配置一个80(如果被占用就换个端口)的虚拟主机处理前端的用户请求:\n\n![img](wpsA8C8.tmp.jpg) \n\n​\t\n\n建立虚拟主机的网站根目录\n\n![img](wpsA8C9.tmp.jpg) \n\n \n\n**特别注意：配置Linux下的hosts文件，需要给upstream里面定义的虚拟主机的域名做一个对应的解析**\n\n![img](wpsA8D9.tmp.jpg) \n\n内容：\n\n![img](wpsA8EA.tmp.jpg) \n\n \n\n3. 配置一个upstream，代表的含义：配置能够处理的web服务的负载均衡器\n\n   ==注意==：定义这个**upstream** 指令必须放在http里面的server前面\n\n![img](wpsA8EB.tmp.jpg) \n\n \n\n4. nginx的负载均衡的默认算法是轮询的算法，一个服务器接着一个服务器来。\n\n![img](wpsA8FC.tmp.jpg) \n\n \n\n5. 将nginx的负载均衡算法改为加权方式\n\n![img](wpsA90C.tmp.jpg) \n\n \n\n6. 将nginx的负载均衡算法改为ip_hash;\n\n![img](wpsA90D.tmp.jpg) \n\n \n\n7. 备用服务器的概念\n\n![img](wpsA91E.tmp.jpg) \n\n \n\n8. [参考文档](http://tengine.taobao.org/documentation_cn.html)\n\n\n\n![img](wpsA91F.tmp.jpg) \n\n查看\n\n![img](wpsA92F.tmp.jpg) \n\n地址：<http://tengine.taobao.org/nginx_docs/cn/docs/http/ngx_http_upstream_module.html>\n\n\n\n\n\n# 扩展\n\nlinux是可以做文件查找的，使用find命令\n\n语法：`# find 查找目录  选项（如 名字 修改时间....） 查找文件名称`\n\n```shell\n[root@localhost sbin]# find / -name libpcre.so.1\n```\n\n","categories":["Nginx"]},{"title":"es6简介","url":"%2Fposts%2F3811458831%2F","content":"\n\n\n# es6简介\n\n需求：由于小程序里面的js代码基本都是使用es6的语法规范进行编写，所以我们必须了解一点js的es6标准。\n\n\n\n**我们现在使用的js其实是有三个部分组成：**\n\n1.  **ECMA** ： 是一个组织，该组织是用于指定一系列的语法规范，定义了基本的语法、变量类型。实现的语言：\n    *  javascript\n    *  actionScript（flash动画）\n2.  **BOM**：浏览器对象，js操作浏览器的API的定义 ，如，window.location 、window.history\\....\n3.  **DOM**：文档对象，js操作网页DOM元素的API的定义\n\n\n\n注意：我们知道的后端的 **nodejs** 只实现了 ECMA，它是没有实现BOM和DOM的。\n\n我们现在使用的最多的ECMA的标准是 es5 这个标准（浏览器对该标准基本都支持）。但是随着社会发展，规范也是不断的完善，引入新的特性，慢慢提出了很多的方案，形成比较新的es6标准（该标准是在2015年发布的，所以也叫作 ECMA2015）。\n\n目前来说 ES6正式发布了，但是目前只有一些比较新的浏览器才支持es6里面的新的标准，并且支持度也不是100%。所以在网页开发里面的如果希望使用es6的语法进行开发，则我们还必须要做一点转换，使用es6开发是没有问题，但是在实际上线的时候，我们还需要借助代码转换转换工具把es6标准转换为 es5的标准，以达到在所有的浏览器上都可以运行。\n\n则这样的转换工具一般使用 **babel**。或者是在前端里面专门做自动化构建的工具 **webpack**。\n\n学习资料：\n\n[[http://es6.ruanyifeng.com/]](http://es6.ruanyifeng.com/)\n\n![](image1.png)\n\n新的特性：\n\n最显著\n\n1.  变量的声明（var 但是现在可以使用 let声明； 同时还引入常量的声明）\n\n2.  箭头函数（基本上改写javascript里面匿名函数的写法，同时明确this的指向问题）\n\n3.  引入Class等关键字（基本上改写之前的javascript里面面向的对象的写法，以前javascript面向对象都是基于原型的面向对象）\n\n    ```javascript\n    class People{\n    \n    }\n    \n    class Man extends People{\n    \n    }\n    \n    function People(name, age){\n    \n    // 定义属性 \n    // this 代表的是谁？ 需要区分 ： 函数在哪里被调用， 怎么调用。\n    this.name = name;\n    this.age = age;\n    }\n    ```\n\n    \n\n实际使用：\n\n```javascript\nvar p1 = new People(); // this代表的 p1\n\nPeople(); // 代表是windows全局对象 等价于 window.People();\n```\n\n\n\n**call 和 apply 是做什么的？** \n\n**答：**改变this的指向，如果没有显示传递参数或者null，则指向window\n\n```javascript\nvar obj = {};\nPeople.call(obj); // this代表的obj\nPeople.apply(null); // 不严格的模式下， this代表的 window全局对象\n```\n\n\n\n**如果把一个javascript里面的构造函数当成一个普通函数执行，则会出现什么问题？**\n\n**答：**污染window全局，在全局内引入全局变量。\n\n```javascript\nfunction People(name, age){\n    this.name = name;\n    this.age = age;\n}\n\nPeople(); //相当于如下\n//window.People();\n//window.name = name;\n//window.age = age;\n\nPeople.prototype.say = function(){\n\n}\n```\n\n\n==**注意**==\n\n在我们使用es6的时候，则需要在javascript的**严格模式**下进行执行。\n\n\n\n# let声明\n\n## let 预解析的问题 \n\n在变量声明之前的区域被称为死区，变量是不可以使用的。\n\n![](image2.png)\n\n## let 解决变量重复声明的问题\n\n重复声明会报错\n\n![](image3.png)\n\n## let 块级作用域\n\n![](image4.png)\n\n# const关键字\n\n定义常量\n\n![](image5.png)\n\n换个问题：\n\n![](image6.png)\n\n因为此时常量保存的是对象的地址，而修改时修改的是堆区中对象的值，没有修改其地址。\n\n\n\n# 箭头函数\n\n## 基本语法\n\n![](image7.png)\n\n**在es6里面是很重要的一个特性，在日后的js开发中，基本到处都会使用。**\n\n\n\n## 参数列表\n\n![](image8.png)\n\n多个参数\n\n![](image9.png)\n\n\n\n## 箭头函数的右边部分\n\n![](image10.png)\n\n![](image11.png)\n\n注意：如果在箭头函数里面右侧，只存在一条语句或者一条表达式，则默认内部隐式做了返回(return)\n\n注意：如果只有一条语句，可以写 {} 也可以不写 {} 则不建议写 {} 。\n\n![](image12.png)\n\n在 ｛｝ 中，如果函数没有return，则默认返回undefined\n\n![](image13.png)\n\n函数体存在多条语句，则必须加上 { }\n\n![](image14.png)\n\n\n\n## 箭头函数的 this的指向问题\n\n**理解：**\n\n在es5里面，js里面的this的指向不是在定义的时候确定的，是在代码执行的时候才能确定，动态的。或者这样说，js里面的 this 要看它执行环境。\n\nes5里面的this的指向：\n\n1.  普通函数里面的this指向的window全局\n\n2.  构造函数里面的this在实例化的时候，指向的是实例化出来的对象；补充当对象调用方法的时候，方法内部的this代表的当前对象。\n\n3.  通过 call 和 apply 调用，则指向的是传递过来的第一个参数\n\n4.  定时器里面的this指向的是window全局对象\n\n在 es6 的箭头函数里面，this指向是在定义的时候已经明确了，和在哪里执行无关。 或者这样说，es6箭头函数里面的 this 的指向是看定义时候的环境，不看执行时候的动态环境。对于这句话，不好理解，因为并不清楚什么时候就是定义下来。如何理解?\n\n> 答：在给箭头函数判断 this指向的时候，先看箭头函数是否被包裹在一个函数里面，如果被包裹，则看包裹的函数里面的 this指向谁 ，箭头函数里面的this就指向谁；\n> 如果箭头函数没有被包裹，外层没有函数，则this指向window对象。\n\n\n\n案例一：\n\n![](image15.png)\n\n案例二：\n\n![](image16.png)\n\n案例三：\n\n![](image17.png)\n\n案例四：箭头函数里面的 this在定义的时候已经明确。\n\n![](image18.png)\n\n\n\n# es6注意事项\n\n现在我们编写的es6在现代浏览器下执行是没有什么问题，基本可以执行。\n\n但是如果在低版本的浏览器或者IE下则无法执行。则这个时候我们是需要做**兼容处理**。\n\n1.  babel 转换器进行转换即可。https://www.babeljs.cn/repl\n\n![](image19.png)\n\n注意：一般来说我们没必要手工的自己去使用babel进行转换。一般在前端开发里面都是使用自动化构造工具完成的，如，webpack。\n\n![](image20.png)\n","categories":["js.ES6"]},{"title":"Apache","url":"%2Fposts%2F3588426178%2F","content":"\n\n# Apache\n\n----\n\n\n\n## Apache概要\n\n**apache它是用于提供http服务的 **。   \napache web 服务器软件，通常指的是 ``apache httpd``   \n\n\n**什么是集成环境：**   \n有一些人将apache、mysql、php这三个软件组成到一起 然后开发出一个新的软件！   \n工作一般都是使用集成环境！wamp……..   \n\n\n**为什么我们不使用集成环境？**   \n1、我们不知道集成环境有没有后门 安全性的问题   \n2、我们得知道这三个软件是如何进行组合到一起！   \n\n----\n\n\n\n## 安装Apache\n\nApache本身不用安装，我们只需将其安装为系统服务即可，在Windows中。 \n\n我们需要在自己的电脑上面新建一个文件夹，这个文件夹不建议放置在系统盘，千万注意文件夹的名称不要使用中文特殊符号。  \n\n![](php_11.png)\n\n\n\n安装Apache http服务，在命令行界面输入：\n\n```bash\nhttpd.exe  -k  install\n```\n\n![](php_05.png)\n\n因为上图所示有报错：找到httpd.conf 这个文件上的37行\n\n![](php_06.png)\n\n \n\n我们需要将httpd.conf这个文件中的   ``c:/Apache24``\n\n![](php_07.png)\n\n \n\n替换为apache的实际安装目录\n\n![](php_08.png)\n\n\n\n添加一个**ServerName** \n\n![](php_09.png)\n\n\n\n配置默认显示页面\n\n![](php_15.png)\n\n\n\n检测是否有语法错误 ：使用``httpd.exe  -t ``  \n\n重启Apache ， 在命令行输入(可省略 .exe)： ``httpd -k restart``\n\n![](php_10.png) \n\n\n\n在浏览器访问配置的域名，测试是否成功\n\n![](php_12.png) \n\n----\n\n\n\n## 管理Apache\n\n### 1.   直接以windows服务的方式管理\n\nApache默认的是被安装成了windows系统服务器，所以管理Apache也可以以windows的服务的形式管理：  \n\n**我的电脑---->右键---->管理----->服务与应用程序---->服务**   \n\n![](php_13.png)\n\n或在开始----->运行里面输入：**services.msc**  \n\n \n\n### 2.  可以在cmd下操作Apache\n\n如果说要使用黑窗口来管理Apache的话那么一定要进入到apache的安装目录下面执行httpd.exe这个文件才可以对其进行管理。 \n\n**命令：**    \n``httpd.exe  –k  stop``        **停止服务**   \n``httpd.exe  –k  start``     **开启服务**  \n``httpd.exe  –k  restart``     **重启服务**        \n\n\n\n**注意：**   \n\n凡是修改了Apache配置文件一定要记得重启apache服务！   \n``httpd.exe  –k  restart``    **重启服务**    \n\n检测Apache配置文件的语法错误：   \n``httpd.exe  –t``   \n\n\n\n\n\n**配置环境变量！**  \n\n环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。\n\n环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。\n\n \n\n因为我们经常要操作httpd.exe这个程序  我们就将它配置到环境变量中 。   \n环境变量配置的地方：   \n**我的电脑--->右键-->属性-->高级系统设置-->高级的选项卡->环境变量-->path**   \n\n然后将apache的bin文件夹目录赋值一份，添加到path的最后面。 \n\n----\n\n\n\n## 目录结构\n\n![](php_14.png)\n\n----\n\n\n\n## 配置虚拟主机\n\n### 什么是虚拟主机\n\n**概念**：虚拟主机是指在网络服务器上分出一定的磁盘空间，用户可以租用此部分空间，以供用户放置站点及应用组件，提供必要的数据存放和传输功能。\n\n\n\n### 基于域名的虚拟主机\n\n第一步：我们需要在Apache的配置文件中开启虚拟主机的配置 \nHttpd.conf 在这个文件中 开启虚拟主机的配置文件\n\n![](php_16.png)\n\n\n\n第二步：使用``<VirtualHost  *:80>  </ VirtualHost> `` ，配置一个虚拟主机就是写一对``<VirtualHost>``这对标签 \n\n![](php_17.png)\n\n第三步[可选]：hosts 文件重定向，如果域名是没有配置在DNS服务器的，可用此方法   \n\nhosts文件路径： \nWindows  ``C:\\Windows\\System32\\drivers\\etc\\hosts``   \n\n![](php_18.png)\n\n\n\n### 配置域名(hosts重定向)\n\n``ServerName   域名 ``\n\n![](php_19.png)\n\n\n\n\n\n### 配置域名对应的目录\n\n``DocumentRoot  \"域名所对应的目录\"``\n\n![](php_20.png)\n\n\n\n![](php_21.png)\n\n## 权限配置\n\n\n\n### 目录访问权限\n\n需要使用一对``<Directory  \"给哪一个目录设置权限\"> </Directory>``来配置\n\n**允许用户访问**  ``Require   all   granted``    \n**拒绝用户访问**  ``Require   all   denied``  \n\n![](php_22.png)\n\n\n\n### 指定默认显示页面 \n\n``DirectoryIndex  默认显示的页面``\n\n\n如果在我们当前的网站的根目录中没有默认显示的页面 那么需要如何显示？   \n1） `` Options indexes ``   \n将当前的网站根目录中所有的文件与文件夹以列表的形式展示出来  \n\n2）  ``Options none``  \n拒绝访问  \n\n**注意：**  \n 如果网站已经上线，我们就使用拒绝访问的方式；如果我们在开发中，可以使用以列表的形式显示。\n\n![](php_23.png)\n\n\n\n### 目录访问权限中的“分布式权限”配置\n\n对于某个目录的访问权限，我们在apache中使用Directory来设定，但可能不够方便： \n1，apache配置修改，必须重启apache  \n2，某个站点中的“下级目录”访问权限，不方便单独设置  \n\n这种，可以称为 **集中式权限**；  \n\n**分布式权限**，就是：针对某个网站的任何一个下级目录，都可以单独去设置其访问权限，并且可以不重启apache就生效。  \n\n\n\n**第1步：**   \n在该网站对应目录权限的Directorty配置中添加一条，表示允许覆写：  \n``AllowOverride  all``   \n\n**第2步：**  \n在该目录下的任何子目录中，创建一个特殊的文件（`` .htaccess ``），在该文件中写所需要的“权限内容”（几乎跟Directory中的写法一样）：  \n\n![](php_24.png)\n\n\n\n## 简单的配置示例\n\n```ini\n# 你可以用一个固定的IP地址来代替 * 号，比如说，你可能会希望在一个IP地址上运行一个基于域名的虚拟主机，而在另外一个IP地址上运行一个基于IP的或是另外一套基于域名的虚拟主机。\n# 如果端口不是80 ，还需要在主配置文件配置监听端口(Listen 端口号） \n<VirtualHost *:80>\n\t #文档根目录\n     DocumentRoot \"F:\\Data\\itcast\\WorkSpace\"\n\t #主机名(域名)\n\t ServerName a.myweb.com\n\t #目录权限控制\n\t <Directory \"F:\\Data\\itcast\\WorkSpace\">\n\t\t#是否允许访问 <granted 允许 | denied 拒绝>\n\t\tRequire all granted\n\t\t#默认访问的文件\n\t\tDirectoryIndex index.html index.php\n\t\t#是否允许访问目录结构 <Indexes 索引 | None 无 | All 所有>\n\t\tOptions Indexes\t\t\n\t\t#是否允许覆写 < None 无 | All 所有>\n\t\tAllowOverride all\n\t </Directory>\n</VirtualHost>\n```\n\n\n\n","categories":["Apache.httpd"]},{"title":"Ajax和JSON案例","url":"%2Fposts%2F2669275496%2F","content":"\n\n# 十二、案例：省市县三级联动\n\n## 1、数据表的关系\n\n![1533199284315](1533199284315.png)\n\n省表：``province``\n\n市表：``city``\n\n区县：``areacounty``\n\n对应关系：\n\n​\tprovince表中的==Pcode==字段和city表中的==ProvinceCode==对应\n\n​\tcity表中的==Ccode==和areacounty表中的==CityCode==对应\n\n查询所有的省：`select * from province`\n\n查询广东省下面的市：`select * from city where ProvinceCode=440000` //440000是广东省的Pcode\n\n查询广州市下面的区县：`select * from areacounty where CityCode=440100` //440100是广州市的Ccode\n\n## 2、制作html页面\n\n```html\n<body>\n\n<select id=\"p\">\n    <option value=\"\">--请选择省--</option>\n    <option value=\"\">北京市</option>\n    <option value=\"\">广东省</option>\n    <option value=\"\">广西省</option>\n</select>\n\n<select id=\"c\">\n    <option value=\"\">--请选择市--</option>\n</select>\n\n<select id=\"a\">\n    <option value=\"\">--请选择区县--</option>\n</select>\n</body>\n```\n\n效果：\n\n![1533199930967](1533199930967.png)\n\n## 3、页面加载，先获取所有的省\n\n通过js，发送ajax请求到07city.php，然后获取所有的省。\n\n约定用type区分，此次请求要取什么数据。\n\n\n\n先写`07city.php`，获取所有的省：\n\n```php\n$pdo = new PDO('mysql:host=localhost; dbname=test; charset=utf8', 'root', '123');\n\n// 约定请求会有一个区分取什么数据的参数type， type=p 表示获取省，type=c 表示获取市，type=a 表示获取区县\n$type = $_GET['type'];\nif($type == 'p'){\n    $sql = \"select * from province\";\n    $stmt = $pdo->prepare($sql);\n    $stmt->execute();\n    $data = $stmt->fetchAll(PDO::FETCH_ASSOC);\n    echo json_encode($data); //将获取的数据转换成json，返回给浏览器\n}\n```\n\n## 4、html页面发送ajax请求，把所有的省获取\n\n```html\n<script>\n    //先获取所有的省\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function () {\n        if(xhr.readyState==4 && xhr.status==200){\n            //接收所有的省\n            var str = xhr.responseText;\n            //把str转换成js数组\n            var arr = JSON.parse(str);\n            //console.log(arr);\n            var res = '<option value=\"0\">--请选择省--</option>';\n            for(var i=0; i<arr.length; i++){\n                res += '<option value=\"'+ arr[i].Pcode +'\">'+ arr[i].Pname +'</option>';\n            }\n            document.getElementById('p').innerHTML = res;\n        }\n    };\n    xhr.open('get', '07city.php?type=p');\n    xhr.send(null);\n</script>\n```\n\n效果：\n\n![1533200880147](1533200880147.png)\n\n## 5、当省切换的时候获取对应的市\n\njs代码：\n\n```javascript\n\t/************************ 获取市的代码 *******************************/\n    //当省的内容改变的时候，获取对应的市\n    document.getElementById('p').onchange = function () {\n        xhr.onreadystatechange = function () {\n            if(xhr.readyState==4 && xhr.status==200){\n\t\t\t\t//这里要处理服务器返回的数据\n            }\n        };\n        var Pcode = this.value; //切换的省的Pcode值\n        xhr.open('get', '07city.php?type=c&Pcode='+Pcode);\n        xhr.send(null);\n    };\n```\n\nPHP代码：获取对应的市\n\n```php\n$pdo = new PDO('mysql:host=localhost; dbname=test; charset=utf8', 'root', '123');\n\n// 约定请求会有一个区分取什么数据的参数type， type=p 表示获取省，type=c 表示获取市，type=a 表示获取区县\n$type = $_GET['type'];\nif($type == 'p'){\n    $sql = \"select * from province\";\n    $stmt = $pdo->prepare($sql);\n    $stmt->execute();\n    $data = $stmt->fetchAll(PDO::FETCH_ASSOC);\n    echo json_encode($data); //将获取的数据转换成json，返回给浏览器\n}elseif ($type == 'c'){\n    /**************************** 获取对应的市  *******************************/\n    $sql = \"select * from city where ProvinceCode = ?\";\n    $stmt = $pdo->prepare($sql);\n    $stmt->bindValue(1, $_GET['Pcode']);\n    $stmt->execute();\n    $data = $stmt->fetchAll(2);\n    echo json_encode($data);\n}\n\n```\n\njs处理服务器返回的市的数据：\n\n```javascript\n\t//当省的内容改变的时候，获取对应的市\n    document.getElementById('p').onchange = function () {\n        xhr.onreadystatechange = function () {\n            if(xhr.readyState==4 && xhr.status==200){\n                //复制处理省的代码，修改一下即可\n                var str = xhr.responseText;\n                //把str转换成js数组\n                var arr = JSON.parse(str);\n                //console.log(arr);\n                var res = '<option value=\"0\">--请选择市--</option>';\n                for(var i=0; i<arr.length; i++){\n                    res += '<option value=\"'+ arr[i].Ccode +'\">'+ arr[i].Cname +'</option>';\n                }\n                document.getElementById('c').innerHTML = res;\n            }\n        };\n        var Pcode = this.value; //切换的省的Pcode值\n        xhr.open('get', '07city.php?type=c&Pcode='+Pcode);\n        xhr.send(null);\n    };\n```\n\n## 6、当市切换的时候，获取对应的区县\n\n复制获取市的代码，然后修改：\n\njs代码：\n\n```javascript\ndocument.getElementById('c').onchange = function () {\n        xhr.onreadystatechange = function () {\n            if(xhr.readyState==4 && xhr.status==200){\n                var str = xhr.responseText;\n                //把str转换成js数组\n                var arr = JSON.parse(str);\n                //console.log(arr);\n                var res = '<option value=\"0\">--请选择区县--</option>';\n                for(var i=0; i<arr.length; i++){\n                    res += '<option value=\"'+ arr[i].Acode +'\">'+ arr[i].Aname +'</option>';\n                }\n                document.getElementById('a').innerHTML = res;\n            }\n        };\n        var Ccode = this.value; //切换的市的时候，获取Ccode值\n        xhr.open('get', '07city.php?type=a&Ccode='+Ccode);\n        xhr.send(null);\n    };\n```\n\nPHP代码：\n\n```php\n....\n}elseif ($type == 'a'){\n    $sql = \"select * from areacounty where CityCode = ?\";\n    $stmt = $pdo->prepare($sql);\n    $stmt->bindValue(1, $_GET['Ccode']);\n    $stmt->execute();\n    $data = $stmt->fetchAll(2);\n    echo json_encode($data);\n}\n```\n\n切换省的时候，把区县重置：\n\n![1533202243022](1533202243022.png)\n\n\n\n## 7、细节处理\n\n1. 切换省份时，区县要重置\n2. 省份重置时，市和区县都要重置\n\n   ```javascript\n       //省份对象事件：改变\n       gById('p').onchange = function () {\n   \n           //--------------------细节处理-----------------------//\n           //切换省份时，区县要重置\n           gById('a').innerHTML='<option value=\"0\">--请选择区县--</option>';\n   \n           //省份重置时，市和区县都要重置\n           if (this.value==0){\n               gById('c').innerHTML='<option value=\"0\">--请选择市--</option>';\n               gById('a').innerHTML='<option value=\"0\">--请选择区县--</option>';\n           }\n           //--------------------细节处理-----------------------//\n   ```\n\n\n3. 市重置时，区县需要重置\n   ```javascript\n   \t//市对象事件：改变\n       gById('c').onchange = function () {\n   \n           //--------------------细节处理-----------------------//\n           //市重置时，区县要重置\n           if (this.value==0){\n               gById('a').innerHTML='<option value=\"0\">--请选择区县--</option>';\n           }\n           //--------------------细节处理-----------------------//\n   ```\n\n----\n\n\n\n# 十三、案例：省市县三级联动另一种思路\n\n## 1、对于不经常变换的数据，可以用文件存储\n\n全国的省、市、区县可能很多年都不会发生变化，对于这种数据，就可以不用放到数据库中，直接使用文件存储，效果很好。不但可以加快查询速度，还能减轻数据库服务器的压力。\n\n![1533260844528](1533260844528.png)\n\n## 2、获取省\n\n首先创建`01city.php`，里面读取`0.json`，直接返回读取的json数据。\n\n```php\n//返回所有的省\necho file_get_contents('./city/0.json');\n```\n\n创建`01city.html` ，里面先写html布局\n\n```html\n<select id=\"p\">\n    <option value=\"0\">--请选择省--</option>\n</select>\n\n<select id=\"c\">\n    <option value=\"0\">--请选择市--</option>\n</select>\n\n<select id=\"a\">\n    <option value=\"0\">--请选择区县--</option>\n</select>\n```\n\n然后js封装一个get方法：\n\n```html\n<script>\n    //封装一个get请求\n    /**\n     * @param url 请求的地址\n     * @param fn  回调函数，用fn来处理服务器返回的数据\n     */\n    function get(url, fn){\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function () {\n            if(xhr.readyState==4 && xhr.status==200){\n                fn(xhr.responseText);\n            }\n        };\n        xhr.open('get', url);\n        xhr.send(null);\n    }\n</script>\n```\n\n最后调用get方法，获取所有的省，并处理\n\n```javascript\n/**************************** 首先加载所有的省 *****************************/\n    get('01city.php', function(data){\n        var arr = JSON.parse(data);\n        var res = '<option value=\"0\">--请选择省--</option>';\n        for(var i=0; i<arr.length; i++){\n            res += '<option value=\"'+ arr[i].id +'\">'+ arr[i].cn_name +'</option>';\n        }\n        //把连接好的option放到id为p的select中\n        document.getElementById('p').innerHTML = res;\n    });\n```\n\n整体的图示：\n\n![1533264032807](1533264032807.png)\n\n## 3、获取市\n\n```javascript\n/********************* 获取市，省切换的时候 **************************/\n    document.getElementById('p').onchange = function () {\n        //省切换的时候，重置区县\n        document.getElementById('a').innerHTML = '<option value=\"0\">--请选择区县--</option>';\n        //this.value指的是 option的value值\n        var v = this.value;\n        if(v == 0){ //表示用户点击了 --请选择省--\n            //重置市，区县\n            document.getElementById('c').innerHTML = '<option value=\"0\">--请选择市--</option>';\n            document.getElementById('a').innerHTML = '<option value=\"0\">--请选择区县--</option>';\n            return; //终止函数执行\n        }\n        get('01city.php?filename='+v, function(data){\n            //形参data就是服务器返回的数据\n            var arr = JSON.parse(data);\n            var res = '<option value=\"0\">--请选择市--</option>';\n            for(var i=0; i<arr.length; i++){\n                res += '<option value=\"'+ arr[i].id +'\">'+ arr[i].cn_name +'</option>';\n            }\n            //把连接好的option放到id为c的select中\n            document.getElementById('c').innerHTML = res;\n        });\n    };\n```\n\n`01city.php `获取地址栏的filename，根据filename来获取对应的json文件：\n\n```php\n//获取地址栏的参数 filename\n$filename = $_GET['filename'] ?? 0;\n//返回所有的省\necho file_get_contents('./city/'. $filename .'.json');\n```\n\n\n\n## 4、细节处理\n\n上面的代码已包含。\n\n1. 切换省份时，区县要重置\n\n2. 省份重置时，市和区县都要重置\n\n   ```javascript\n       //省份对象事件：改变\n       document.getElementById('p').onchange = function () {\n   \n           //--------------------细节处理-----------------------//\n           //切换省份时，区县要重置\n           gById('a').innerHTML = '<option value=\"0\">--请选择区县--</option>';\n   \n           //省份重置时，市和区县都要重置\n           if (this.value == 0) {\n               gById('c').innerHTML = '<option value=\"0\">--请选择市--</option>';\n               gById('a').innerHTML = '<option value=\"0\">--请选择区县--</option>';\n               return; //终止函数往下执行\n           }\n           //--------------------细节处理-----------------------//\n   ```\n\n3. 市重置时，区县需要重置\n\n   ```javascript\n       //市对象事件：改变\n       document.getElementById('c').onchange = function () {\n   \n           //--------------------细节处理-----------------------//\n           //市重置时，区县要重置\n           if (this.value == 0) {\n               gById('a').innerHTML = '<option value=\"0\">--请选择区县--</option>';\n               return; //终止函数往下执行\n           }\n           //--------------------细节处理-----------------------//\n   ```\n\n------\n\n\n\n# 案例—Ajax跨域获取天气信息\n\n接口地址1：http://wthrcdn.etouch.cn/weather_mini?citykey=101010100\n\n==Ajax可以直接请求==，推断出对方网站肯定设置 `header('Access-Control-Allow-Origin:*');`。\n\n下面是``08weather.html`` 代码\n\n```html\n<body>\n\n<input type=\"button\" value=\"请求\" id=\"btn\" />\n\n<script>\n    //点击btn的时候，发送ajax请求\n    document.getElementById('btn').onclick = function(){\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function () {\n            if(xhr.readyState==4 && xhr.status==200){\n                //console.log(xhr.responseText);\n                var obj = JSON.parse(xhr.responseText);\n                //console.log(obj);\n                console.log(obj.data.city + ' ' + obj.data.wendu + ' ' + obj.data.ganmao);\n            }\n        };\n        xhr.open('get', 'http://wthrcdn.etouch.cn/weather_mini?citykey=101010100');\n        xhr.send();\n    };\n</script>\n\n</body>\n```\n\n\n\n接口地址2：http://www.weather.com.cn/data/sk/101010100.html\n\n==Ajax不可以直接请求。==\n\n下面是`09weather.html`\n\n```html\n<body>\n<input type=\"button\" value=\"请求\" id=\"btn\" />\n\n<script>\n    //点击btn的时候，发送ajax请求\n    document.getElementById('btn').onclick = function(){\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function () {\n            if(xhr.readyState==4 && xhr.status==200){\n                //console.log(xhr.responseText);\n                var obj = JSON.parse(xhr.responseText);\n                console.log(obj);\n            }\n        };\n        xhr.open('get', '09weather.php');\n        xhr.send();\n    };\n</script>\n</body>\n```\n\n`09weather.php `代码：\n\n```php\necho file_get_contents('http://www.weather.com.cn/data/sk/101010100.html');\n```\n\n\n\n\n\n# 七、案例 – Ajax无刷新分页\n\n## 7.1、分页原理\n\n比如，我的 areacounty 表有3125条数据。要求每页显示10条。那么共有多少页？\n\n$count = 3125;\n\n$pageSize = 10;\n $maxPage = ceil($count / $pageSize);\n\n获取第1页数据的SQL：`select * from areacounty order by AID limit 0,10;`\n\n获取第2页数据的SQL：`select * from areacounty order by AID limit 10,10;`\n\n获取第3页数据的SQL：`select * from areacounty order by AID limit 20,10;`\n\n获取第$p页的数据的SQL：`select * from areacounty order by AID limit ($p-1)*$pageSize, $pageSize;`\n\n## 7.2、传统的分页\n\nTODO\n\n## 7.3、异步请求数据，完成无刷新分页\n\nTODO\n\n","categories":["Ajax"]},{"title":"Ajax高级","url":"%2Fposts%2F738503265%2F","content":"\n# 五、FormData\n\n## 5.1、使用FormData收集表单数据\n\n本节课我们将学习以下内容：\n\n​       ①、使用FormData完成表单数据的收集\n\n​       ②、将收集到的数据通过ajax对象发送给服务器\n\n**FormData**：字母意思就是表单数据，==这是h5中新增的一个内置对象（构造器）==，它可以获取任何类型的表单项的值，比如text/radio/checkbox/file/textarea，适用于获取大量的表单项的值。常用于发送Ajax请求。\n\n\n\n创建`03FormData.html`\n\n```html\n<form name=\"myform\">\n    用户名：<input type=\"text\" name=\"username\"> <br>\n    密　码：<input type=\"password\" name=\"pwd\"> <br>\n    性　别：<input type=\"radio\" name=\"sex\" value=\"男\" checked>男\n          <input type=\"radio\" name=\"sex\" value=\"女\">女 <br>\n    头　像：<input type=\"file\" name=\"picture\" /><br>\n    简　介：<textarea name=\"introduce\" cols=\"30\" rows=\"3\"></textarea><br>\n    <!--提交按钮一定要是button-->\n    <input type=\"button\" value=\"提交\" id=\"btn\" />\n</form>\n```\n\n下面写js，收集表单数据，使用ajax发送到03FormData.php\n\n```html\n<script>\n    //获取button，绑定单击事件\n    document.getElementById('btn').onclick = function () {\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function () {\n\n        };\n        //数据比较多，使用post方式发送\n        xhr.open('post', '03FormData.php');\n        \n        //使用FormData来收集表单数据，\n        //先获取表单，然后实例化FormData，并给FormData传参为表单\n        var form = document.myform; //获取表单\n        var fd = new FormData(form); //fd 就是所有的表单项的内容\n        xhr.send(fd);\n    };\n\n</script>\n```\n\n创建`03FormData.php`，将获取的表单的内容，存放到文件中：\n\n```php\n//接收表单数据，并放到文件中，以便查看\nfile_put_contents('post.txt', print_r($_POST, true)); //print_r()如果第二个参数为true，表示不输出，而是返回数组\n\nfile_put_contents('file.txt', print_r($_FILES, true));\n```\n\n**==总结（注意点）==**：\n\n1. 使用post请求，并使用FormData的时候，**不能**设置请求头 `xhr.setRequestHeader();`\n2. 有文件域，但是不用设置enctype。\n3. 获取表单的内容使用`$_POST`，获取文件域的内容使用`$_FILES`\n4. 收集表单项的值是根据表单项的**name**值获取的。\n\n\n\n## 5.2、使用FormData完成文件上传\n\n本节课我们将学习以下内容：\n\n​       ①、配合FormData，完成文件异步上传工作\n\n使用的文件还是03FormData.html和03FormData.php。\n\n在PHP页面，完成文件的上传即可。\n\n```php\n//接收表单数据，并放到文件中，以便查看\nfile_put_contents('post.txt', print_r($_POST, true)); //print_r()如果第二个参数为true，表示不输出，而是返回数组\n\nfile_put_contents('file.txt', print_r($_FILES, true));\n\n//完成文件上传\n//创建存放目录\n$dir = './Uploads/';\nif(!file_exists($dir)){\n    mkdir($dir, 0777, true); //加入true，表示可以深层目录创建\n}\n//生成一个不重复的文件名\n$name = uniqid(); //time()\n//获取文件的后缀\n$ext = strrchr($_FILES['picture']['name'], '.'); // .jpg\n//echo $name;\n//echo '<br>';\n//echo $ext;\n//move_uploaded_file(临时文件, 目标文件);\nmove_uploaded_file($_FILES['picture']['tmp_name'], $dir.$name.$ext);\n```\n\n\n\n## 5.3、使用FormData上传大文件（上传进度条）\n\n本节课我们将学习以下内容：\n\n​       ①、完成异步上传中，用进度条展示上传进度。\n\n\n\n上传大文件，应该先配置``php.ini``。\n\n**post_max_size**：表示允许post提交的内容的最大值\n\n![1533279318595](1533279318595.png)\n\n**upload_max_filesize**：表示允许提交的附件的最大值。\n\n![1533279363257](1533279363257.png)\n\n**max_execution_time** = 30：最大响应时间\n\n==**重启Apache**==。\n\n\n\n在`03FormData.html`页面中制作上传进度条：\n\n1. 在上传的时候，打印xhr对象\n\n   ![1533279768247](1533279768247.png)\n\n   查看到的结果：\n\n   ![1533279805601](1533279805601.png)\n\n   2. 打印`xhr.upload` \n\n      ![1533279943817](1533279943817.png)\n\n      输出结果：\n\n      ![1533279927449](1533279927449.png)\n\n      3. 给`onprogress` 事件添加处理函数\n\n         ![1533280062394](1533280062394.png)\n\n         查看输出的任意一个事件对象：\n\n         ![1533280180825](1533280180825.png)\n\n         4. 制作进度条\n\n            用 `loaded / total` 表示上传进度。\n\n            先在html中，设置一个进度条，默认隐藏状态。\n\n            ```html\n            <progress id=\"p\" style=\"display: none;\" value=\"0\" max=\"0\"></progress>\n            ```\n\n            当上传的时候，设置进度条的value和max，并让进度条显示：\n\n            ![1533280931981](1533280931981.png)\n\n# 六、==Ajax跨域问题==（重点）\n\nAjax是不允许跨域请求的。\n\n## 6.1、什么是跨域请求\n\n本节课我们将学习以下内容：\n\n​       ①、什么是同源政策。\n\n​       ②、同源政策有哪些限制\n\n​       ③、什么是Ajax跨域请求。\n\n### 6.1.1、什么是同源政策\n\n1995年，同源政策由 Netscape（网景） 公司引入浏览器。目前，所有浏览器都实行这个政策。\n\n最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。==所谓“同源”指的是”三个相同“。==\n\n- **协议相同（http  https）**\n- **域名相同**\n- **端口相同（默认80端口）**\n\n### 6.1.2、同源政策有哪些限制\n\n随着互联网的发展，“同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。\n\n- Cookie无法读取。\n- DOM 无法获得。\n- AJAX 请求无效（可以发送，但浏览器会拒绝接受响应）。\n\n### 6.1.3、什么是Ajax跨域请求\n\n在Ajax请求中，==只要违反了同源政策的请求，都属于跨域请求==。\n\n![img](clip_image040.jpg)\n\n 只要请求的地址的==协议==或==域名==或==端口==和本网站不同，就属于跨域请求。\n\n下面请求了另一个域名下面的一个PHP文件，就叫做跨域请求。\n\n![1533282424397](1533282424397.png)\n\n## 6.2、解决跨域问题\n\n本节课我们将学习以下内容：\n\n​       ①、如何使用**代理**方式解决跨域问题\n\n​       ②、如何使用**jsonp**技术实现跨域请求\n\n​       ③、如何使用**CORS**技术实现跨域\n\n### 6.2.1、使用代理的方式\n\n直接发送Ajax请求到其他域不允许，但是可以先发送Ajax请求到本网站中的一个php文件，然后让这个php文件去访问其他域的内容，那么这个php文件就可以认为是一个代理文件。\n\n![1533282693359](1533282693359.png)\n\n创建04kuayu.html，让其请求本域中的04kuayu.php文件：\n\n```html\n<!--// www.ajax.com-->\n<script>\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function () {\n        if(xhr.readyState==4 && xhr.status==200){\n            console.log(xhr.responseText);\n        }\n    };\n    xhr.open('get', '04kuayu.php');\n    xhr.send();\n</script>\n```\n\n创建04kuayu.php，去访问www.js.com下面的04kuayu.php文件：\n\n```php\n// www.ajax.com\necho file_get_contents('http://www.js.com/04kuayu.php');\n```\n\n让www.js.com下面的04kuayu.php配合测试，加入下面的代码：\n\n```php\n// www.js.com\necho '我是js域名';\n```\n\n\n\n### 6.2.2、使用CORS方式\n\n跨域访问技术CORS（Cross-Origin Resource Sharing ,跨源资源共享 ） \n\n**IE9+才能使用此方式**。\n\n==需要在请求的网站中设置==：Access-Control-Allow-Origin\n\n```php\nheader('Access-Control-Allow-Origin:允许的网站完整域名');\nheader('Access-Control-Allow-Origin:*'); //允许所有网站来请求\n```\n\n\n\n本域中，创建05kuayu.html，直接请求www.js.com/05kuayu.php\n\n```html\n<script>\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function () {\n        if(xhr.readyState==4 && xhr.status==200){\n            console.log(xhr.responseText);\n        }\n    };\n    xhr.open('get', 'http://www.js.com/05kuayu.php');\n    xhr.send();\n</script>\n```\n\n另一个网站：www.js.com/05kuayu.php，设置Access-Control-Allow-Origin\n\n```php\n//www.js.com\n//设置header，允许www.ajax.com这个网站跨域请求\n//header('Access-Control-Allow-Origin:http://www.ajax.com');\n//header('Access-Control-Allow-Origin:*'); //允许所有网站来访问\n\n/************ 下面设置允许多个网站来跨域请求 *************/\n$allow = ['http://www.a.com', 'http://www.ajax.com', 'http://www.b.com'];\n\n//当别人访问这个文件的时候，可以获取到访问者的域名\n$domain = $_SERVER['HTTP_ORIGIN']; //获取的是纯的域名，如http://www.ajax.com\n//$domain = $_SERVER['HTTP_REFERER']; //获取的域名，包括路径和参数http://www.ajax.com/2018-08-03/05kuayu.html\n//echo $domain;\nif(in_array($domain, $allow)){\n\theader('Access-Control-Allow-Origin:'.$domain);\n}\necho '我还是js'; //返回给浏览器\n```\n\n\n\n### 6.2.3、使用jsonp完成跨域请求\n\n**Jsonp(JSON with Padding)** 是 json 的一种\"使用模式\"，通俗的讲，jsonp可以通过html标签中的src属性可以访问另外域的内容，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 \n\n使用script标签的src属性引入的文件会自动执行，只能执行js代码：\n\n![1533284715276](1533284715276.png)\n\n复杂一些：既然可以执行js代码，那么我可以调用一个js函数。\n\n![1533284908730](1533284908730.png)\n\n在复杂一点：给函数传入参数\n\n![1533285162418](1533285162418.png)\n\n刷新页面，能够看到获取的数据。\n\n最后，动态的生成script标签，比如当点击按钮的时候，才创建script标签：\n\nwww.ajax.com/06kuayu.html代码\n\n```html\n<body>\n\n<img src=\"http://www.js.com/1.jpg\" />\n\n<script>\n    function abc(data){\n        console.log(data);\n    }\n</script>\n\n<!--<script src=\"http://www.js.com/06kuayu.php\"></script>-->\n\n<input type=\"button\" value=\"获取数据\" id=\"btn\" />\n<script>\n    //点击按钮，创建script标签，并将其放到body中\n    document.getElementById('btn').onclick = function () {\n        var script = document.createElement('script');\n        script.src = \"http://www.js.com/06kuayu.php\";\n        document.body.appendChild(script);\n    };\n</script>\n</body>\n```\n\nwww.js.com/06kuayu.php 代码：\n\n```php\n//www.js.com\n//echo \"alert(123456);\";\n//echo \"abc();\"; //表示在js端，调用abc函数\n\n$arr = ['apple', 'banana'];\n$json = json_encode($arr);\necho \"abc(\". $json .\");\"; //表示在js端，调用abc函数\n```\n\n关于JSONP技术，补充：\n\nwww.ajax.com/07jsonp.html  和 www.js.com/07jsonp.php \n\n![1533287223815](1533287223815.png)\n\n\n\n","categories":["Ajax"]},{"title":"Ajax和JSON","url":"%2Fposts%2F2279573566%2F","content":"\n\n# 三、概述\n\n手册位置：W3C手册 --  上面的JavaScript  -- 左侧的Ajax\n\n## 1、Ajax历史\n\n1999年，微软在IE5上使用，但是没有被认知。\n\n2005年，谷歌的使用（地图、gmail），使得ajax被全世界所认识，并广泛使用。\n\n## 2、Ajax是什么\n\nAjax中的第一个A是Asynchronous [eɪˈsɪŋkrənəs]\n\n（异步）JavaScript and XML的缩写。可以看出它不是一种技术，而是多种技术的综合体。\n\n其中有JavaScript、有xml、有json、有html、有css、有dom、有**==XMLHttpRequest==**对象等等，而且还必须有一种编程语言与ajax配合才行。\n\n**XMLHttpRequest对象，也叫做Ajax对象**。\n\nAjax的工作也是基于http协议的。\n\n## 3、Ajax能做什么\n\n①、提高用户体验\n\n②、表单实时验证\n\n![img](clip_image002.jpg)\n\n③、百度地图、谷歌地图\n\n④、网页版的聊天室\n\n![1533174381333](1533174381333.png)\n\n⑤、无刷新的分页\n\n# 四、Ajax工作原理\n\n通过ajax向服务器发送请求的时候，实际上是通过浏览器内置的XMLHttpRequest对象来发送的请求，服务器返回数据的时候，也是返回到XMLHttpRequest对象，经过XMLHttpRequest的处理，最后将用户想要的结果输出到浏览器。\n\n![1533175827721](1533175827721.png)\n\n# 五、XMLHttpRequest对象介绍\n\n## 1、创建ajax对象（ajax对象）\n\n所有现代浏览器均支持 **XMLHttpRequest** 对象（==IE5 和 IE6 使用 ActiveXObject==）。\n\n```javascript\n//var xhr = new XMLHttpRequest(); //IE6+\n//var xhr = new ActiveXObject('Microsoft.XMLHTTP'); // IE5 和 IE6\n\n//创建一个兼容各个浏览器的ajax对象\nvar xhr;\nif (window.XMLHttpRequest) {\n    xhr = new XMLHttpRequest(); //IE6+\n} else {\n    xhr = new ActiveXObject('Microsoft.XMLHTTP'); // IE5 和 IE6\n}\n```\n\n\n\n## 2、主要的成员属性：\n\n- **readyState**：表示ajax工作进行到何种状态\n- **onreadystatechange**：事件，表示readyState改变的时候触发的事件\n- **status**：http状态码\n- **responseText**：用来接收返回的文本类型的数据\n- **responseXML**：用来接收返回的是XML格式的数据\n\n## 3、主要的方法\n\n- **open()**：设置（定义）一个请求\n- **send()**：发送设置好的请求\n- **setRequestHeader()**：设置ajax请求头信息\n\n# 六、==使用Ajax的步骤==(重点)\n\n完成验证用户名案例，要求用户名唯一，就是不能有重复。\n\n\n\n## 1、创建两个文件\n\n创建文件，`01chkusername.html` 和 `01chkusername.php` 。\n\n\n\n``01chkusername.html ``：浏览器预览文件。\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"\n          content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n请输入用户名：<input type=\"text\" id=\"username\" />\n\n</body>\n</html>\n```\n\n\n\n``01chkusername.php`` ：检查用户名是否存在的脚本文件。\n\n```php\n//连接数据库，判断用户名是否存在。案例中，就不连接数据库了，假设zhangsan和lisi是存在的\n$arr = ['zhangsan', 'lisi']; //假设这是从数据库查询出来的已经存在的用户\n```\n\n\n\n## 2、绑定事件\n\n给username绑定失去焦点事件，通过事件来操作数据\n\n```html\n<script>\n    //给username绑定失去焦点事件\n    document.getElementById('username').onblur = function () {\n        //获取用户输入的值\n        var u = this.value;\n        \n    };\n</script>\n```\n\n\n\n## 3、设置请求\n\n```html\n<script>\n    //给username绑定失去焦点事件\n    document.getElementById('username').onblur = function () {\n        //获取用户输入的值\n        var u = this.value;\n        //创建Ajax对象\n        var xhr = new XMLHttpRequest();\n        //准备工作（用什么方式，发送到哪里去发送的数据是什么，同步请求还是异步请求）\n        xhr.open('get', '01chkusername.php?user='+u, true);//true 异步 | false 同步\n    };\n</script>\n```\n\n\n\n## 4、发送请求到服务器\n\n```html\n<script>\n    //给username绑定失去焦点事件\n    document.getElementById('username').onblur = function () {\n        //获取用户输入的值\n        var u = this.value;\n        //创建Ajax对象\n        var xhr = new XMLHttpRequest();\n        //准备工作（用什么方式，发送到哪里去发送的数据是什么，同步请求还是异步请求）\n        xhr.open('get', '01chkusername.php?user='+u, true);  //true 异步 | false 同步\n        //发送请求\n        xhr.send();\n    };\n</script>\n```\n\n到这步，可以用浏览器进行检测，看数据是否发送到了服务器：\n\n![1533177261715](1533177261715.png)\n\n## 5、服务器接收请求的参数并判断\n\nphp文件：01chkusername.php\n\n```php\n//连接数据库，判断用户名是否存在。案例中，就不连接数据库了，假设zhangsan和lisi是存在的\n$arr = ['zhangsan', 'lisi']; //假设这是从数据库查询出来的已经存在的用户\n\n//get请求，使用$_GET来获取参数\n$user = $_GET['user'];\n//判断用户是否存在\nif (in_array($user, $arr)) {\n    //说明用户名存在，向浏览器返回\n    echo 1;\n} else {\n    echo 0;\n}\n```\n\n通过浏览器工具，发现服务器确实能够返回对应的值：\n\n![1533177608297](1533177608297.png)\n\n## 6、判断Ajax执行的状态，然后接收服务器返回的数据\n\nreadyState是Ajax对象中的一个属性，它表示ajax执行的状态，它的值有5个，分别表示：\n\nreadyState的四个状态如下：\n\n| 0 (未初始化)   | 对象已建立，但是尚未初始化（尚未调用open方法）               |\n| -------------- | ------------------------------------------------------------ |\n| 1 (初始化)     | 对象已建立，尚未调用send方法，言外之意，open已经调用了       |\n| 2 (发送数据)   | send方法已调用，但是当前的状态及http头未知                   |\n| 3 (数据传送中) | 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误， |\n| ==4 (完成)==   | ==数据接收完毕==,此时可以通过==responseBody==和==responseText==获取完整的回应数据 |\n\n readyState应该配合另一个属性  onreadystatechange 来使用。onreadystatechange也是一个事件。\n\n**下面代码，15行之后是新加的代码，另外html中添加一个span标签**。\n\n```html\n请输入用户名：<input type=\"text\" id=\"username\" /> <span id=\"msg\"></span>\n\n<script>\n    //给username绑定失去焦点事件\n    document.getElementById('username').onblur = function () {\n        //获取用户输入的值\n        var u = this.value;\n        //创建Ajax对象\n        var xhr = new XMLHttpRequest();\n        //准备工作（用什么方式，发送到哪里去发送的数据是什么，同步请求还是异步请求）\n        xhr.open('get', '01chkusername.php?user='+u, true);//true 异步 | false 同步\n        //发送请求\n        xhr.send();\n\n        /*********判断，当readyState等于4的时候，接收服务器返回的数据 ********************/\n        //当readyState属性发生改变的时候，就执行下面的函数，\n        //比如readyState的值从2变化到3的时候，就执行下面的函数，同理，从3变化到4的时候，也会执行\n        xhr.onreadystatechange = function () {\n            //alert(123);\n            if(xhr.readyState == 4) {\n                //接收服务器返回的数据\n                var result = xhr.responseText;\n                //alert(result);\n                if(result == 1){\n                    document.getElementById('msg').innerHTML = '<font color=\"red\">用户名已存在</font>';\n                } else {\n                    document.getElementById('msg').innerHTML = '<font color=\"green\">恭喜，用户名可用</font>';\n                }\n            }\n        };\n\n    };\n</script>\n```\n\n## 7、总结\n\n使用Ajax的步骤：\n\n1. 创建ajax对象\n2. 调用open方法：open(请求方式,  url,  同步或异步);\n3. 调用send方法\n4. 设置onreadystatechange事件，判断readyState\n\n\n\n设置onreadystatechange事件，判断readyState这一步可以放到open之前。\n\n\n\n# 七、其他问题\n\n## 1、编码字符\n\nencodeURI() --- 不能对“:/=&”进行编码\n\n**encodeURIComponent**()  ---  能对“:/===&==”进行编码\n\n![1533180011414](1533180011414.png)\n\nhtml页面对输入的内容进行编码：\n\n![1533180139583](1533180139583.png)\n\nPHP页面对获取的参数进行解码：\n\n![1533180161621](1533180161621.png)\n\n## 2、缓存处理\n\n什么是Ajax缓存原理？\n\nAjax在发送的数据成功后，会把请求的URL和返回的响应结果保存在浏览器缓存内，当下一次调用Ajax发送相同的请求时，它会直接从缓存中把数据取出来，这是为了提高页面的响应速度和用户体验。==当前这两次请求URL完全相同，包括参数。这个时候，浏览器就不会与服务器交互，指的是IE浏览器==。\n\n两次请求的地址完全一致（包括参数），那么**IE就会从缓存中取服务器上一次返回的结果**。而不会从新向服务器发送请求。\n\n\n\n如何解决IE缓存的问题： \n\n1、在ajax发送请求前加上` xhr.setRequestHeader(\"If-Modified-Since\",\"0\"); `//实测可用\n\n![1533180570079](1533180570079.png)\n\n\n\n2、在服务器端加\n\n```php\nheader(\"Cache-Control:no-cache\");\nheader(\"Pragma:no-cache\");\nheader(\"Expires:-1\");\n```\n\n![1533180660810](1533180660810.png)\n\n加入三个header，表示适用于各个浏览器。\n\n\n\n3、在 Ajax 的 URL 参数后加上 `\"?fresh=\" + Math.random(); `，当然这里参数 `fresh` 可以任意取了\n\n![1533180814951](1533180814951.png)\n\n\n\n4、第种方法和第3种类似，在 URL 参数后加上 `\"?timestamp=\" + new Date().getTime();`\n\n![1533180943150](1533180943150.png)\n\n\n\n5、用POST替代GET：不推荐\n\n==以上几种方式，比较推荐第3和第4中方法==。\n\n\n\n## 3、get和post请求\n\n使用POST请求，一定要设置下面的header：\n\n`xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");`\n\n![1533181730505](1533181730505.png)\n\n==使用post请求，PHP页面也使用对应的$_POST接收参数==。\n\najax中的get和post的一些说明：\n\n①、用post请求，不会产生缓存。\n\n②、用post请求的时候，能不能也用get，即post和get请求同时使用。\n\n​      答：能，只不过get请求的参数用$_GET获取，post请求的参数用$_POST获取。\n\n③、用$_REQUEST获取get和post方式提交的参数，如果参数名相同，获取的是谁？\n\n​       答：默认获取的是post的内容，根据`php.ini`配置文件中的配置。\n\n\n\n## 4、同步、异步\n\n==异步请求==，在同一个时间点可以执行多个进程；\n\n==同步请求==，在同一个时间点，只能进行一个操作，其他操作只能等待。\n\n在使用Ajax的时候，大多数都是异步请求，ajax请求什么时候结束，就立即处理ajax，如果ajax请求比较慢，那么继续加载当前页面的其他内容。\n\n![1533192545261](1533192545261.png)\n\n\n\n## 5、请求的url如果出错怎么办\n\n如果请求的url出错，则http状态码就不是200了。所以在获取服务器返回数据的时候，在加入一个条件，只有http状态码等于200的时候，才接收服务器返回的数据。\n\n![1533182159575](1533182159575.png)\n\n\n\n# 八、JSON\n\n## 1、什么是json\n\nw3c手册位置：上面的javascript – 左侧的JSON\n\njson==**本质就是字符串**==，只不过这个字符串的格式比较特殊，格式和JavaScript中的数组和对象的格式一样。\n\n下面定义几个JSON格式的字符串：\n\n①、 ==\"==['apple', 'orange', 'banana']==\"==\n\n②、 ==\"=={name:'zhangsan', age:20}==\"==\n\n```javascript\n//声明两个符合json格式的字符串\n//先写js数组或对象，然后在外面加上引号形成一个字符串，这就是json格式的字符串。\nvar str = \"['apple', 'pear', 'banana']\";\nvar str = \"{name:'zhangsan', age:20}\";\nvar str = \"[{id:1, name:'zhaowei'}, {id:2, name:'荔枝味'}, {id:3, name:'赖志丽'}]\";\n```\n\n\n\n##  2、json有什么用\n\njson在web开发中，它起到的作用和xml和的作用一样。具体来说，json可以当做配置文件，json文件可以存储数据，json可以当做两种编程语言交换数据的媒介。\n\n![1533193705248](1533193705248.png)\n\n## 3、json和PHP进行转换（重要）\n\n**1、把PHP数据转化成json格式**\n\n使用函数 ``json_encode()``\n\n![1533194423187](1533194423187.png)\n\nPHP的索引数组转换成json之后，和JavaScript中的数组一样的格式。\n\nPHP的关联数组和对象转换成json之后，和JavaScript中的对象是一样的格式。\n\n\n\n**2、json数据转化成PHP数据**\n\n使用函数  ``json_decode()``\n\n```php\n$arr1 = ['apple', 'banana'];\n$arr2 = ['one'=>'刘备', 'two'=>'关羽', 'three'=>'张飞'];\n$arr3 = [\n    ['one'=>'刘备', 'two'=>'关羽', 'three'=>'张飞'],\n    ['one'=>'刘邦', 'two'=>'项羽', 'three'=>'虞姬'],\n    ['one'=>'曹操', 'two'=>'孟获', 'three'=>'祝融夫人'],\n];\n$obj = new stdClass(); //空对象\n$obj->name = '赵云';\n$obj->age = 20;\n\n$j1 = json_encode($arr1);\n$j2 = json_encode($arr2);\n$j3 = json_encode($arr3);\n$j4 = json_encode($obj);\n\necho $j1 . '<br>';\necho $j2 . '<br>';\necho $j3 . '<br>';\necho $j4 . '<br>';\necho '<hr /><pre>';\n$a1 = json_decode($j1);\n$a2 = json_decode($j2, true); //加入第2个参数true，表示还转换成原来的数组。不加true，会把关联数组换成对象\n$a3 = json_decode($j3, true);\n$o = json_decode($j4);\nprint_r($a1);\nprint_r($a2);\nprint_r($a3);\nprint_r($o);\n```\n\n\n\n\n\n## 4、json和JavaScript进行转换（重要）\n\n把js数组或对象转换成json，使用 `JSON.stringify();`\n\n把json字符串转换成js数组或对象，可以使用`JSON.parse()`，也可以使用`eval()`\n\n```javascript\nvar arr1 = ['apple', 'banana'];\nvar arr2 = [{id:1, name:'张三'}, {id:2, name:'李四'}];\nvar obj = {name:'张三疯', age:20};\n//下面把js数组或对象转换成json\nvar j1 = JSON.stringify(arr1);\nvar j2 = JSON.stringify(arr2);\nvar o3 = JSON.stringify(obj);\nconsole.log(j1);\nconsole.log(j2);\nconsole.log(o3);\n//把json字符串，转换成js数组或对象\n//eval(\"var a1=\"+j1);\nvar a1 = JSON.parse(j1);\nvar a2 = JSON.parse(j2);\nvar o = JSON.parse(o3);\nconsole.log(a1);\nconsole.log(a2);\nconsole.log(o);\n```\n\n\n\n# 九、==处理服务器返回json格式的数据==(重点)\n\nAjax请求的时候，如果服务器返回json格式的数据，如何处理。\n\n\n\n案例--页面加载完毕，异步请求学生表的数据。\n\n## 1、创建06stu.html\n\n```html\n<body>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" rules=\"all\" width=\"500\" align=\"center\">\n    <thead>\n    <tr>\n        <th>ID</th>\n        <th>姓名</th>\n        <th>性别</th>\n        <th>年龄</th>\n        <th>班级</th>\n    </tr>\n    </thead>\n    <tbody id=\"content\">\n\n    </tbody>\n</table>\n</body>\n```\n\n## 2、发送Ajax请求到06stu.php\n\n```html\n<script>\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function () {\n        if(xhr.readyState==4 && xhr.status==200){\n            //接收服务器返回的数据\n        }\n    };\n    xhr.open('get', '06stu.php');\n    xhr.send(null);\n</script>\n```\n\n## 3、06stu.php连接数据库查询并返回数据\n\n```php\n$pdo = new PDO('mysql:host=localhost; dbname=test; charset=utf8', 'root', '123');\n//$sql = \"select * from stu where id>?\";\n$sql = \"select * from stu\";\n\n$stmt = $pdo->prepare($sql); //预处理SQL，得到返回值PDOStatement对象\n//$stmt->bindValue(1, 5); //绑定第一个问号的值为5\n$stmt->execute();\n//$data = $stmt->fetchAll(2);\n$data = $stmt->fetchAll(PDO::FETCH_ASSOC);\n\n//echo '<pre>';\n//print_r($data);  //检测是否能够查询到数据\n\n//将数据返回给浏览器\necho json_encode($data);\n```\n![1533197397016](1533197397016.png)\n\n\n## 4、js接收json数据并处理\n\n\n```javascript\n\t\n\txhr.onreadystatechange = function () {\n        if(xhr.readyState==4 && xhr.status==200){\n            //接收服务器返回的数据\n            var str = xhr.responseText; //因为json是字符串，所有还用responseText来接收\n            //将JSON格式的字符串转换成js数组\n            var arr = JSON.parse(str);\n            //console.log(arr);\n            var res = '';\n            for(var i=0; i<arr.length; i++){\n                res += '<tr>';\n                for(var x in arr[i]){  // x 代表数组下标，如，id，name\n                    res += '<td>' + arr[i][x] + '</td>';  \n                }\n                res += '</tr>';\n            }\n            //把连接好的数据，放到tbody中\n            document.getElementById('content').innerHTML = res;\n        }\n    };\n```\n\n----\n\n\n\n# 十、==处理服务器返回XML格式数据==(重点)\n\n服务器返回XML格式的数据，需要注意下面三点：\n\n**1、服务器端要指定header('content-type:text/==xml==; charset=utf-8);**\n\n**2、浏览器端接收xml类型的数据用==responseXML==**\n\n**3、浏览器端接收到的数据可以看做是document来使用。**\n\n\n\n创建``02xml.html``，验证用户名：\n\n```html\n<body>\n\n请输入用户名：<input type=\"text\" id=\"username\" />\n\n<script>\n    //输入框失去焦点的时候，发送ajax请求\n    document.getElementById('username').onblur = function () {\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function () {\n            if(xhr.readyState==4 && xhr.status==200){\n                //接收服务器返回的XML格式的数据\n                var res = xhr.responseXML; //注意\n                console.log(res);\n            }\n        };\n        xhr.open('get', '02xml.php?username='+this.value);\n        xhr.send();\n    };\n</script>\n\n</body>\n```\n\n创建``02xml.php``，返回xml格式的数据：\n\n```php\n//指定返回的内容是xml\nheader('content-type:text/xml; charset=utf-8');\n\n//制定一个xml字符串，如果有xml文件，也可以用file_get_contents读取xml文件\n$success = '<msg><result>1</result><content>用户名可用</content></msg>';\n$error = '<msg><result>0</result><content>用户名不可用</content></msg>';\n\n//假设用户名lisi已经存在\nif($_GET['username'] == 'lisi'){\n    echo $error;\n}else{\n    echo $success;\n}\n```\n\n浏览器测试：失去焦点后，看console的输出：\n\n![1533266832968](1533266832968.png)\n\n==得到的返回值res，可以当做document对象来使用==，可以使用类似`document.getElementsByTagName()`来获取标签中的内容：\n\n```javascript\n\t//输入框失去焦点的时候，发送ajax请求\n    document.getElementById('username').onblur = function () {\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function () {\n            if(xhr.readyState==4 && xhr.status==200){\n                //接收服务器返回的XML格式的数据\n                var res = xhr.responseXML; //注意,res用法和document用法一样\n                //console.log(res);\n                /*\n                //从返回值中获取msg标签\n                var msg = res.getElementsByTagName('msg')[0];\n                //从msg标签中，获取content标签\n                var content = msg.getElementsByTagName('content')[0];\n                //根据content查找它的子节点\n                var text = content.childNodes[0];\n                console.log(text.nodeValue);\n                */\n                var content = res.getElementsByTagName('content')[0];\n                console.log(content.innerHTML);\n            }\n        };\n        xhr.open('get', '02xml.php?username='+this.value);\n        xhr.send();\n    };\n```\n\n\n\n# 十一、Ajax代码模版参考\n\n```javascript\n//[可选]绑定事件\ndocument.getElementById('p').onchange = function () {\n    \n    //实例化Ajax对象\n    var xhr = new XMLHttpRequest();\n    //设置Ajax对象的状态改变事件\n    xhr.onreadystatechange = function () {  //书写在此位置，可获取readyState的所有状态码\n        //判断Ajax对象的状态码和请求的状态码\n        if(xhr.readyState==4 && xhr.status==200){\n            //接收返回的完整数据并处理\n        }\n    };\n    xhr.open('get', '07city.php?type=c&Pcode=1001'); //设置请求信息\n    xhr.send();  //发送请求\n    \n};\n```\n\n\n\n","categories":["Ajax"]},{"title":"vagrant技术","url":"%2Fposts%2F1535111454%2F","content":"\n---\ntypora-root-url: vagrant\ntypora-copy-images-to: vagrant\n---\n\n# vagrant技术\n\n## ①-常见问题描述\n\n在项目交互部署的时候（往往开发和部署不是同一个团队做的，开发有专门的开发人员；部署一般都是运维部署），经常听到 “在我的电脑明明是好好的，为什么在你的电脑就不可以使用了呢? 是不是你的环境没有装好？”\n\n\n\n之前我们一般是使用wamp环境在本地开发（习惯在windows下做开发），开发测试通过后，然后使用ftp、xshell等一定的工具把我们项目代码上传到线上服务器lamp环境上，这个时候一般会出现一些问题。例如Linux下和window下环境不一致，为了防止这种情况，一般我们都已在本地搭建一些lamp环境，但是这个lamp一般我们是使用本地的虚拟机软件（VMware、VirtualBox）搭建出来。\n\n但是通过这些虚拟机软件搭建环境的时候，我们需要手工的去创建一个虚拟电脑，然后在虚拟电脑上进行环境搭建，但是这个过程往往是枯燥耗费时间的，甚至有的时候还安装不成功。\n\n\n\n基于上面常出现的这两种情况，有人就提出了一个可行性的方案：\n\n通过一定的软件来帮我们去管理我们的虚拟机软件，然后通过该工具直接的管理虚拟机软件。让虚拟机软件去执行对应的操作。例如我们需要按照一个操作，只需要使用该工具给虚拟机软件发送一个如下的命令：\n\n```\n> vagrant  box  add  CentOs65_x64  url\n> vagrant  up \n```\n\n这用的工具就是我们今天学习的**vagrant**工具。\n\n**vagrant 是一个软件，专门帮我们管理虚拟机、或者操作系统镜像的，可以保证环境的一致。**\n\n后期还会学习一个docker的技术来实现环境的一致。\n\n\n\n \n\n## ②-什么是vagrant工具？\n\n网站：<https://www.vagrantup.com/>\n\n![img](wps12BE.tmp.jpg)\n\n \n\n \n\n**Vagrant**是一个软件，可以自动化虚拟机的安装和配置流程。如果需要用Linux环境进行开发或学习，使用虚拟机无疑是最方便的选择。而Vagrant更进一步，可以让你通过编写一个`Vagrantfile`文件来控制虚拟机的启动、虚拟机网络环境的配置、虚拟机与主机间的文件共享。\n\n这意味着，当你需要在多台机器间同步开发进度时，只需要同步Vagrantfile文件，就可以**保证各台机器拥有一致的开发环境**。另外，即便对于计算机小白用户，Vagrant也是一个利器。以前我们为了学习一门语言，必须先手动安装这门语言的编译环境。这期间的各种痛苦想必各位深有体会。有了Vagrant后，我们可以下载别人写好的`Vagrantfile`，然后运行`vagrant up`，vagrant就会自动下载虚拟机镜像，自动加载镜像并配置虚拟机，然后给我们一个即开即用的学习环境。\n\n \n\n## ③-vagrant的依赖环境\n\n\n\n由于vagrant是管理虚拟机软件的，那么自然需要==虚拟机==程序和==操作系统镜像==。前者常用的选择有**VirtualBox**和**VMWare**，后者则包括Ubuntu、FreeBSD、window7等等。Vagrant称前者为**provider**（提供商），称后者为**box**（安装的镜像文件，只是这个镜像文件可以理解成是已经做好的一个操作系统，不需要我们在手工的去安装，拿过来直接可以使用）。原则上，我们可以自由搭配provider和box，但由于VirtualBox开源且免费，Vagrant将其作为默认的provider。所以，一般会先安装VirtualBox，再安装Vagrant。\n\n### 软件安装\n\n1. 先安装virtualBox（4.3版本） ，全程下一步即可。\n\n![1538187060443](1538187060443.png) \n\n\n\n\n\n2. 在安装vagrant（最新的），全程下一步即可。\n\n![1538179806838](1538179806838.png)\n\n \n\n### 注意网卡禁用\n\n如果之前我们的电脑安装过VMware这个软件，这个软件安装之后需要在我们自己电脑上虚拟出来一些网卡，则我们为了防止可能影响我们的virtualbox，则我们先把VMware这些网卡全部禁用。\n\n![1538187172549](1538187172549.png)\n\n\n\n### 成功安装\n\n1. virtualbox安装后，可以点击该软件，显示如下\n\n![img](wps12D1.tmp.jpg) \n\n上面的这个软件就是一个虚拟机软件，我们可以使用它去创建很多的虚拟电脑，然后在虚拟电脑上面进行操作系统的安装，但是这个过程是很繁琐的，也是耗费时间的，没有任何的意义。完全没有必要自己尝试去装操作系统，或者说在安装之后，在该操作系统上面去搭建属于自己的开发环境，一般来说我们可以在安装完成该软件之后，在安装一个vagrant的软件帮我们去管理上面的虚拟机软件，然后通过vagrant去下载我们需要的操作系统，并且把操作系统直接导入上面的虚拟机里面去，而不需要自己去安装操作系统，搭建环境。\n\n\n\n2. vagrant安装之后的测试命令，查看一下版本即可。\n\n![img](wps12D2.tmp.jpg) \n\n如果使用 `vagrant -v` 可以查看到版本信息，代表vagrant安装是没有问题的\n\n \n\n### Linux环境模拟\n\n注意：由于vagrant最好是使用Linux的`cli`环境，所以最好装一个Linux的环境模拟，如 `git` 或 `cmder`\n\n![img](wps12E3.tmp.jpg) \n\n安装成功后，鼠标右键即可看到如下\n\n![img](wps12E4.tmp.jpg) \n\n点击后，出现如下的界面\n\n![img](wps12F4.tmp.jpg) \n\n \n\n## ④-基本使用\n\n### box选择\n\n一般我们会从网上下载某个虚拟机的安装镜像到本地，文件名为`***.iso`，然后使用VirtualBox加载镜像并安装操作系统到虚拟机中，期间可能涉及到网卡、USB等虚拟硬件的配置。之后就可以正常的使用这个虚拟的系统了。\n\n这一过程基本类似于使用安装盘在一台真实的电脑上安装系统。但Vagrant使用的镜像并不是待安装的系统镜像，而是从虚拟机中导出的、对已经安装配置好的操作系统的快照，以`.box`作为扩展名。\n\n这类似于Windows中完整的系统备份所产生的镜像文件。`.box`文件不过是个压缩文件包，里面除了基础数据的镜像外，还包括一些开发环境。我们当然可以从最原始的安装镜像开始，一步步制作自己的`.box`镜像。但这一过程比较麻烦，也可以使用Vagrant官网提供了许多制作好的box文件。选择时注意box与provider的对应关系。\n\n网站：https://app.vagrantup.com/boxes/search\n\n\n\n本次课程使用自己下载的盒子进行操作\n\n![1538189780340](1538189780340.png)\n\n \n\n==注意：在导入的时候需要使用非中文的文件夹==\n\n\n\n![1538187287539](1538187287539.png)\n\n\n\n### 盒子添加-add\n\n**我们介绍如何添加box文件到Vagrant的box管理系统中呢？**\n\n \n\n1. 切换到盒子的目录，执行如下命令\n\n   ```\n   vagrant box add    盒子名称  盒子的绝对目录\n   ```\n\n   `盒子名称` ： 可自定义\n\n   `盒子的绝对目录`  ： 需要使用正斜线\n\n   **示例**\n\n   ```\n   >  vagrant box add centos64 C:/workspace/centos64/centos65_x64.box\n   ```\n\n   ![1538187404455](1538187404455.png)\n\n\n\n### 初始化盒子-init和启动盒子-up\n\n```\n> vagrant init centos64\n\n> vagrant up\n```\n\n执行 `vagrant init centos64 `命令的时候，这里的centos64是上面使用 `vagrant box add` 添加盒子时候指定的名称。\n\n\n![1538187707232](1538187707232.png)\n\n \n\n### vagrantfile的基本配置\n\n1. 配置用户信息\n\n![1538189548360](1538189548360.png)\n\n\n\n2. 配置一下公共的网络 ， 和我们的自己的电脑(宿主机) 处于同一个网络。\n\n![1538189533091](1538189533091.png)\n\n\n\n3. 让vagrant重新读取配置文件\n\n```\n> vagrant reload\n```\n\n![1538189479973](1538189479973.png)\n\n\n\n\n\n### 虚拟机连接工具-SSH\n\n![1538189371457](1538189371457.png)\n\n\n\n### 远程登录\n\n使用git模拟环境进行远程登录\n\nssh命令登录\n\n ```\n > ssh root@127.0.0.1 -p 2222\n ```\n\n会提示输入加密的密钥，点击确定，同时root的密码为admin88\n\n\n\n#### vagrant ssh快速登录\n\n当我们在导入盒子的目录下，执行如下的命令的时候，可以不输入任何端口和用户名以及IP的情况下，快速登录到linux操作系统\n\n```\n> vagrant ssh\n```\n\n执行这个命令的时候，去尝试读取VagrantFile文件里面的\n\n```\nconfig.ssh.username\nconfig.ssh.password\n```\n\n\n\n### 退出登录\n\n如果大家要退出执行，在linux下执行exit即可。\n\n![1538190875110](1538190875110.png)\n\n\n\n### 关闭虚拟机-halt\n\n切换到盒子安装目录，执行如下命令\n\n```\n> vagrant halt\n```\n\n ![1538191013605](1538191013605.png)\n\n\n\n### 盒子卸载-destroy\n\n进入盒子导入的目录，执行如下命令\n\n```\n> vagrant destroy\n```\n\n\n\n### 盒子导出\n\n```\n> vagrant package --base  centos65_default_1538191254489_16849  --out   C:/workspace/mycentos65.box\n```\n\n![1538191932374](1538191932374.png)\n\n\n\n\n\n## 参考阅读\n\n[**laravel开发的homestead环境搭建**](https://laravelacademy.org/post/9530.html) \n\n\n\n\n\n","categories":["Vagrant"]},{"title":"XML 案例","url":"%2Fposts%2F3698054443%2F","content":"\n\n## 八、小案例--获取天气信息\n\n下面是一个天气信息的接口：\n请求地址： http://v.juhe.cn/weather/index\n请求参数： cityname=%E5%8C%97%E4%BA%AC&dtype=xml&format=&key=810c3b2c488bc37d5f521196d8799a72\n请求方式： GET\n\n广州的天气接口：\n\nhttp://v.juhe.cn/weather/index?cityname=%E5%B9%BF%E5%B7%9E&dtype=xml&format=&key=810c3b2c488bc37d5f521196d8799a72\n\n我们已经知道，通过该接口，可以获取到XML格式的天气信息，所以解析该XML后就能够拿到我们想要的天气信息了，并可以把天气信息应用到你的网站中。\n\n代码--输出今天的天气状况：\n\n```php\n//判断：如果本地的天气文件不存在或者weather.xml30秒没有更新，则从新从远程获取一次\nif(!file_exists('./weather.xml') || filemtime('./weather.xml') + 30 < time()) {\n    $url = 'http://v.juhe.cn/weather/index?cityname=%E5%B9%BF%E5%B7%9E&dtype=xml&format=&key=810c3b2c488bc37d5f521196d8799a72';\n    $str = file_get_contents($url);\n    //把得到的字符串放到本地文件中\n    file_put_contents('./weather.xml', $str);\n    //echo 1111;  //测试\n}\n\n//直接读取本地文件\n$xml = simplexml_load_file('./weather.xml');\n\n//echo '<Pre>';\n//print_r($xml);\n\n//\necho '今天的温度是：' . $xml->result->today->temperature;\necho '<br>';\necho '今天' . $xml->result->today->weather;\n```\n\n\n\n\n\n## 十、案例--电子词典\n\n### 10.1、界面设计\n\n查询的时候，使用get方式提交到当前页面，所以表单的action和method都不需要写。\n\n```html\n<h1>查询</h1>\n    <form>\n        <input type=\"text\" name=\"search\">\n        <select name=\"type\">\n            <option value=\"en\">英文</option>\n            <option value=\"cn\">中文</option>\n        </select>\n        <input type=\"submit\" value=\"查询\">\n    </form>\n    <br>\n    <p>查询结果：<span>xxx</span></p>\n```\n\n\n\n### 10.2、词库设计\n\n创建16dict.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<dict>\n    <word>\n        <en>bag</en>\n        <cn>包</cn>\n    </word>\n    <word>\n        <en>desk</en>\n        <cn>桌</cn>\n    </word>\n    <word>\n        <en>position</en>\n        <cn>位置</cn>\n    </word>\n</dict>\n```\n\n### 10.3、基本的查询实现\n\n```php\n<?php\n//获取搜索的单词\n//获取词的类型（中文、英文）\n$search = $_GET['search'];\n$type = $_GET['type'];\n\n//加载xml词库\n$xml = simplexml_load_file('16dict.xml');\n//根据查询的内容，找到包含查询内容的词\n$word = $xml->xpath('//word[en = \"bag\"]'); \n//根据查询的词，找到中文\n$result = $word[0]->cn;\n//echo \"<pre>\";\n//print_r($word);\n?>\n```\n\n```php+HTML\n<p>查询结果：<span><?php echo $result;?></span></p>\n```\n\n### 10.4、解决bug\n\n```php+HTML\n<?php\n$result = ''; //给result一个默认值\n$default_value = ''; //搜索框的默认值\n$default_selected = 'en'; //下拉框默认值\n\nif(isset($_GET['search']) && $_GET['search'] != '') {\n    \n    $search = $default_value = $_GET['search']; //获取搜索的单词\n    $type = $default_selected =  $_GET['type']; //获取词的类型（中文、英文）\n\n    $xml = simplexml_load_file('16dict.xml');  //加载xml词库\n    $word = $xml->xpath(\"//word[$type = '$search']\"); //根据查询的内容，找到包含查询内容的词\n\n    //echo \"<pre>\";\n    //print_r($word); //数组\n    \n    //根据数组是否为空进行判断\n    if($word){ //不为空时\n        //根据查询的词，找到中文\n        $result = $type=='en' ? $word[0]->cn : $word[0]->en;\n    } else { //为空时\n        $result = '查无结果';\n    }\n}\n?>\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"\n          content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>电子词典</title>\n</head>\n<body>\n    <h1>查询</h1>\n    <form>\n        <input type=\"text\" name=\"search\" value=\"<?php echo $default_value;?>\">\n        <select name=\"type\">\n            <option value=\"en\" <?php if($default_selected=='en') echo \"selected\";?>>英文</option>\n            <option value=\"cn\" <?php if($default_selected=='cn') echo \"selected\";?>>中文</option>\n        </select>\n        <input type=\"submit\" value=\"查询\">\n    </form>\n    <br>\n    <p>查询结果：<span><?php echo $result;?></span></p>\n</body>\n</html>\n```\n\n\n\n","categories":["XML"]},{"title":"XML 基础知识","url":"%2Fposts%2F2727003801%2F","content":"\n\n\n# XML\n\n## 一、简介（了解）\n\n### 1.1、历史\n\n<u>**GML**    通用标记语言</u>\n\n1969年，IBM公司的一些砖家为了解决不同系统中文档格式的问题而开发的一种文档描述语言。\n\n<u>**SGML**   标准通用标记语言</u>\n\n1986年，ANSI组织对GML进行整理并升级为SGML。但是SGML是一种非常严谨的文档描述语言，其结构非常复杂（标准手册就有500多页），难以理解和学习，进而影响其推广与应用。\n\n<u>**HTML**   超文本标记语言（W3C）</u>\n\n1993年，HTML继承了SGML的许多重要的特点，比如结构化、实现独立和可描述性，但是同时它也存在很多缺陷：比如它只能使用固定的有限的标记，而且它只侧重于对内容的显示。\n\n<u>**XML**  可扩展标记语言</u>\n\n==1998==年，随着Web上数据的增多，这些HTML存在的缺点就变的不可被忽略。为了解决这些问题， W3C组织又基于SGML语言开发一款新的标记语言，并称之为XML。是xml1.0。**到目前为止，xml的版本还是1.0**。\n\n> w3c从98年就发布了XML1.0版本，到现在还是1.0版本，说明了什么？\n>\n> 并不是说明XML不好，反之，说明XML语法上没有缺陷，不需要升级。\n\n\n\n### 1.2、概念\n\nXML（e**X**tensible **M**arkup **L**anguage）叫做 **可扩展标记语言**\n\n从语法上来说，它和HTML非常像，都是使用标签语言，比如  `<table></table>` ，不同的是XML可以自己定义标签，比如 `<name></name>` 。\n\n从意义上来说，它和HTML完全不一样，HTML用于展示数据，而XML用于==存储==或者==传输==数据。\n\n> 有关XML和HTML的区别，在学习完XML语法之后，再来详细的比较。\n\n\n\n## 二、==XML语法==（重点）\n\n### 2.1、文档声明\n\n一个完整的xml文档必须有一个文档声明。文档声明中要注明XML版本和XML文档的编码。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n```\n\n\n\n### 2.2、树结构\n\nXML 文档必须包含 ==**根元素**==。该元素是所有其他元素的父元素。\n\nXML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。\n\n所有元素均可拥有子元素：\n\n![1532025359169](1532025359169.png)\n\n根据上图，编写XML代码：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n\t<book category=\"修仙\">\n    \t<title>斗破苍穹</title>\n        <author>天蚕土豆</author>\n        <year>2010</year>\n        <price>39.9</price>\n    </book>\n</bookstore>\n```\n\n如上代码，我们就描述了一本书，按照这个规律，我们还可以添加更多的书：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n    <!--第1本书-->\n\t<book category=\"修仙\">\n    \t<title>斗破苍穹</title>\n        <author>天蚕土豆</author>\n        <year>2010</year>\n        <price>39.9</price>\n    </book>\n    <!--第2本书-->\n    <book category=\"文学\">\n    \t<title>西游记</title>\n        <author>吴承恩</author>\n        <year>1560</year>\n        <price>68.54</price>\n    </book>\n</bookstore>\n```\n\n用浏览器打开这个XML文档，能够看到表示书籍的树状结构而不报错，就表示你的XML语法没有问题。\n\n> PS：XML的注释和HTML一样。\n>\n> 这部分总结起来就一句话：==XML有且仅有一个根元素==。\n\n\n\n### 2.3、标签都必须闭合\n\n在 HTML，经常会看到没有关闭标签的元素：\n\n```html\n<p>This is a paragraph\n<p>This is another paragraph\n<input type=\"text\">\n<img src=\"./111.jpg\">\n```\n\n在 XML 中，省略关闭标签是非法的。所有元素都 **必须** 有关闭标签：\n\n```xml\n<p>This is a paragraph</p>\n<p>This is another paragraph</p>\n<input type=\"text\" />\n<img src=\"./111.jpg\" />\n```\n\n==无论是双标记还是单标记，XML标签都必须闭合。==\n\n注释：您也许已经注意到 XML 声明没有关闭标签。这不是错误。声明不属于XML本身的组成部分。它不是 XML 元素，也不需要关闭标签。\n\n> 元素命名尽量不要用`first-name`、`first.name`、`first:name`的形式。\n\n\n\n### 2.4、XML 标签对大小写敏感\n\nXML 标签对大小写敏感。在 XML 中，标签 `<Letter>` 与标签 `<letter>` 是不同的。\n\n==必须使用相同的大小写来编写打开标签和关闭标签==：\n\n```xml\n<Message>这是  错误  的。</message>\n\n<message>这是  正确  的。</message> \n```\n\n注释：打开标签和关闭标签通常被称为开始标签和结束标签。不论您喜欢哪种术语，它们的概念都是相同的。\n\n\n\n### 2.5、XML 必须正确地嵌套\n\n在 HTML 中，常会看到没有正确嵌套的元素：\n\n```xml\n<b><i>hello</b></i>\n```\n\n==在 XML 中，所有元素都 **必须** 彼此正确地嵌套==：\n\n```xml\n<b><i>This text is bold and italic</i></b>\n```\n\n\n\n### 2.6、XML 的属性值须加引号\n\n与 HTML 类似，XML 也可拥有属性（名称/值的对）。\n\n==在 XML 中，XML 的属性值比须加引号（单或双引号都可）==。\n\n```xml\n<note date=\"08/08/2008\">\n<to>George</to>\n<from>John</from>\n</note> \n```\n\n在第一个文档中的错误是，note 元素中的 date 属性没有加引号。\n\n> 一个标签如果有属性，则必须给属性值\n>\n> 一个标签不能存在同名属性\n\n\n\n### 2.7、实体引用\n\n在 XML 中，一些字符拥有特殊的意义。\n\n如果你把字符 \"<\" 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n\n这样会产生 XML 错误：\n\n```xml\n<message> 3<5 </message>\n```\n\n为了避免这个错误，请用*实体引用*来代替 \"<\" 字符：\n\n```xml\n<message>if salary &lt; 1000 then</message> \n```\n\n在 XML 中，有 5 个预定义的实体引用：\n\n| &lt ;   | <    | 小于   |\n| ------- | ---- | ------ |\n| &gt ;   | >    | 大于   |\n| &amp ;  | &    | 和号   |\n| &apos ; | '    | 单引号 |\n| &quot ; | \"    | 引号   |\n\n注释：在 XML 中，==只有字符 \"<\" 和 \"&\" 确实是非法的==。大于号是合法的，但是用实体引用来代替它是一个好习惯。\n\n\n\n### 2.8、CDATA\n\n术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。\n\n在 XML 元素中，\"<\" 和 \"&\" 是非法的。\n\n\"<\" 会产生错误，因为解析器会把该字符解释为新元素的开始。\n\n\"&\" 也会产生错误，因为解析器会把该字符解释为字符实体的开始。\n\n某些文本，比如 JavaScript 代码，包含大量 \"<\" 或 \"&\" 字符。为了避免错误，可以将脚本代码定义为 CDATA。\n\nCDATA 部分中的所有内容都会被解析器忽略。\n\nCDATA 部分由 **`<![CDATA[这里写内容]]>`** 结束：\n\n```xml\n<script>\n<![CDATA[\nfunction matchwo(a,b)\n{\nif (a < b && a < 0) then\n  {\n  return 1;\n  }\nelse\n  {\n  return 0;\n  }\n}\n]]>\n</script>\n```\n\n在上面的例子中，解析器会忽略 CDATA 部分中的所有内容。\n\n> CDATA 部分不能包含字符串 \"]]>\"。也不允许嵌套的 CDATA 部分。\n\n> 标记 CDATA 部分结尾的 \"]]>\" 不能包含空格或折行。\n\n\n\n## 三、XML和HTML的区别（了解）\n\n|        HTML        |         XML          |\n| :----------------: | :------------------: |\n|   意义：展示数据   | 意义：存储并传输数据 |\n|   标签有限且固定   |      标签可扩展      |\n|    标签可不闭合    |     标签必须闭合     |\n| 属性值可以不用引号 |   属性值必须有引号   |\n\n总体来说，HTML和XML设计的初衷就不一样，另一方面XML语法上比较严格。\n\n\n\n## 四、XML的用途（理解）\n\n### 4.1、存储数据\n\n前面说到用xml表示一些书籍，其实这就是用xml存储数据信息。\n\n练习，用xml存储全班的学生，要求包括全班所有学生，每个学生要有id、姓名、性别、身高、体重、出生年月日、爱好。可以试着写一下。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!--有一个根节点-->\n<students>\n    <stu id=\"1\" name=\"赵伟\" age=\"37\" />\n    <stu>\n        <id>2</id>\n        <name>周国权</name>\n        <age>100</age>\n    </stu>\n    <stu>\n        <id>3</id>\n        <name>宋顺杰</name>\n        <age>120</age>\n    </stu>\n    <stu>\n        <id>4</id>\n        <name>巫妖王</name>\n        <age>20</age>\n    </stu>\n</students>\n```\n\n\n\n练习，设计一个xml文档，存储一本中英词典的信息。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<dict>\n    <word>\n        <en>bag</en>\n        <cn>包</cn>\n    </word>\n    <word>\n        <en>desk</en>\n        <cn>桌</cn>\n    </word>\n    <word>\n        <en>position</en>\n        <cn>位置</cn>\n    </word>\n</dict>\n```\n\n\n\n> 这里的xml就充当了小型数据库。\n\n### 4.2、传输数据时，数据的载体\n\n有些项目是跨语言的，比如PHP从数据库取出一组数据，要发送给Android，这个时候就需要将数据转换成双方都能识别的语言，然后再进行数据的交互，此时就可以使用xml当做数据的载体了。\n\n再比如，有些网站提供各种接口，比如天气信息接口，那么我们的网站中如何使用别人提供的天气信息呢？很简单，提供者将数据转换为xml格式的数据，然后我们去获取，获取之后自行解析使用即可。\n\n下面是一个天气信息的接口：\n请求地址： http://v.juhe.cn/weather/index\n请求参数： cityname=%E5%8C%97%E4%BA%AC&dtype=xml&format=&key=810c3b2c488bc37d5f521196d8799a72\n请求方式： GET\n\n### 4.3、其他\n\n作为配置文件：比如飞秋的配置文件就是xml格式的\n\n其他领域使用：比如化学领域可以使用xml表示化学式。\n\n\n\n## 五、操作XML（理解）\n\n### 5.1、何为操作XML\n\n一句话，就是对XML进行==增删改查==操作。\n\n在操作XML的时候，我们把 <u>整个XML文档</u>、<u>文档中的标签</u>、<u>标签的属性</u>、<u>标签中的文本</u> 都叫做==节点==。\n\n- 查询：先读取XML，然后按要求读取XML节点的内容\n- 添加：按要求添加XML节点，最后保存\n- 修改：按要求修改XML节点，最后保存\n- 删除：按要求删除XML节点，最后保存\n\n![1532352371653](1532352371653.png)\n\n\n\n### 5.2、谁来操作XML\n\n这里的操作可不是用记事本打开XML，然后对其操作。而是用编程语言来对其进行操作。大多数的编程语言都可对XML进行操作，有的编程语言在操作XML的时候还有很多不同的方式。\n\n![1532351790124](1532351790124.png)\n\n\n\n==PHP方面，我们主要学习的是用PHP的**simpleXML**来操作XML，因为这种方式操作XML非常简单易学==。\n\nJavaScript方面，我们将在后面的JavaScript高级课程中讲解DOM操作。\n\n\n\n### 5.3、为什么要操作XML\n\n很简单，如果有一个xml文档是软件的配置文件，那么我们是不是要读取这个xml，有时候还要对配置进行修改、添加或者删除操作？在比如有一个接口提供了XML格式的信息，而我们刚好要用这些信息，我们是不是要读取这个xml并整理其包含的信息？答案都是肯定的。所以操作XML是必要的。\n\n\n\n### 5.4、simpleXML工作原理\n\n① 开辟内存空间 \n\n② 载入XML文件到内存形成DOM树结构\n\n③ 生成SimpleXMLElement对象\n\n![img](clip_image002.jpg)\n\n实际上是调用函数库中的一个函数 `simplexml_load_file()` 或 `simplexml_load_string()`将 XML 文档或XML字符串加载到内存并得到 `SimpleXMLElement`对象，然后调用 `SimpleXMLElement`对象中的方法对XML进行操作。\n\nSimpleXMLElement对象方法一览（具体查看手册）：\n\n![1532353577345](1532353577345.png)\n\n\n\n## 六、==操作XML元素节点==（重点）\n\n使用的xml文档是01.xml\n\n### 6.1、获取元素节点的内容\n\n当调用 `simplexml_load_file()` 函数之后，会得到一个simpleXMLElement对象，该对象包含了XML文档的所有内容，我们通过遍历该对象可以得到不同元素节点的内容。\n\n代码--获取XML中第一本书的名字：\n\n```php\n//调用simplexml_load_file()函数，加载xml文档到内存，得到simpleXMLElement对象\n$xml = simplexml_load_file('01.xml');\n//$str = \"<book><name>sdf</name></book>\";\n//调用simplexml_load_string()函数，加载xml字符串，得到simpleXMLElement对象\n//$xml = simplexml_load_string($str);\n//echo \"<pre>\";\n//print_r($xml);\n//获取第1本书的名字\necho $xml->book[0]->name;\n```\n\n代码-- ==遍历==获取XML中所有书的名字：\n\n```php\n//调用simplexml_load_file()函数，加载xml文档到内存，得到simpleXMLElement对象\n$xml = simplexml_load_file('01.xml');\n//$str = \"<book><name>sdf</name></book>\";\n//调用simplexml_load_string()函数，加载xml字符串，得到simpleXMLElement对象\n//$xml = simplexml_load_string($str);\n//echo \"<pre>\";\n//print_r($xml);\n//获取第1本书的名字\n//echo $xml->book[0]->name;\n//遍历把所有的书打印出来\nforeach ($xml->book as $value){\n    echo $value->name . '<br>';\n}\n```\n\n\n\n### 6.2、添加元素节点\n\n步骤：\n\n1. 得到simpleXMLELement对象；\n2. 找到父级节点，为其添加子节点（addChild）；\n3. 保存\n\n代码--添加一本新书：\n\n```php\n$xml = simplexml_load_file('01.xml'); //得到simpleXMLElement对象，它表示文档中的根节点\n\n//表示在根节点中添加book节点，谁调用addChild，就是给谁添加子节点\n//addChild的返回值仍然是simpleXMLElement对象\n$book = $xml->addChild('book');\n\n//在book中，添加name\n$book->addChild('name', '西厢记');\n//继续添加作者、发布时间、价格\n$book->addChild('author', '赵伟');\n$book->addChild('year', 2015);\n$book->addChild('price', 65);\n\n//保存\n//$xml->saveXML('02.xml'); //给定参数，表示保存到哪里；未给定参数，则只会保存在内存中\n$xml->asXML('02.xml'); //和saveXML一样\n```\n\n\n\n### 6.3、修改元素节点的内容\n\n步骤：\n\n1. 找到要进行修改的元素节点；\n2. 对其内容(文本节点)进行从新赋值；\n3. 最后保存。\n\n代码--修改第一本书的价格：\n\n```php\n$xml = simplexml_load_file('01.xml');\n//echo '<pre>';\n//print_r($xml);\n$xml->book[0]->price = 2.5;\n//保存\n$xml->saveXML('02.xml');\n```\n\n\n\n### 6.4、删除元素节点\n\n步骤：\n\n1. 找到要进行删除的元素节点；\n2. 对其使用 `unset()` 进行删除；\n3. 最后保存。\n\n代码--删除第一本书的出版时间：\n\n```php\n$xml = simplexml_load_file('01.xml');\n//echo '<pre>';\n//print_r($xml);\nunset($xml->book[0]->year);\n//保存\n$xml->saveXML('02.xml');\n```\n\n\n\n## 七、==操作XML属性节点==（重点）\n\n### 7.1、获取元素的属性节点\n\n步骤：\n\n1. 因为属性属于元素，所以先找到元素节点\n2. 通过 `attributes()`获取到该元素的所有属性（注意，调用attributes()方法得到的返回值仍然是对象）\n3. [获取元素的某个属性]\n\n代码--获取第一个book节点的所有属性：\n\n```php\n$xml = simplexml_load_file('01.xml'); //返回simpleXMLElement对象\n\n//echo '<pre>';\n//print_r($xml);\n//先找到第一个book节点\n$book = $xml->book[0];\n//调用attributes()方法，可以得到book节点的所有属性\n$attrs = $book->attributes();\n\necho '<pre>';\nprint_r($attrs);\n```\n\n代码--获取第一个book节点的category属性：\n\n```php\n$xml = simplexml_load_file('01.xml'); //返回simpleXMLElement对象\n//echo '<pre>';\n//print_r($xml);\n//先找到第一个book节点\n$book = $xml->book[0];\n//调用attributes()方法，可以得到book节点的所有属性\n$attrs = $book->attributes();\n\n//echo '<pre>';\n//print_r($attrs);\n//获取book的category属性\necho $attrs->category; //注：是属性，所以用 ->\necho $attrs->id;\n```\n\n\n\n### 7.2、为元素添加属性\n\n步骤：\n\n1. 找到元素节点\n2. 通过 `addAttribute()`为元素添加属性\n3. 保存\n\n代码--为第一个book节点添加download属性：\n\n```php\n$xml = simplexml_load_file('01.xml');\n//先找到第一个book节点\n$book = $xml->book[0];\n//调用addAttribute()方法为book添加属性\n$book->addAttribute('download', 20);\n//保存\n$xml->asXML('02.xml');\n```\n\n\n\n### 7.3、修改元素的属性\n\n步骤：\n\n1. 找到元素节点\n2. 采用从新赋值的方法，修改元素节点的属性的值\n3. 保存\n\n代码--修改第一个book节点的category属性值：\n\n```php\n$xml = simplexml_load_file('01.xml');\n//先找元素\n$book = $xml->book[0];\n//找book的category属性，然后修改\n$book->attributes()->category = '玄幻';\n//保存\n$xml->asXML('02.xml');\n```\n\n\n\n### 7.4、删除元素的属性\n\n步骤：\n\n1. 找到元素节点\n2. 找到元素节点的属性\n3. 使用 `unset()`对其进行卸载\n4. 保存\n\n代码--删除第一个book节点的category属性：\n\n```php\n$xml = simplexml_load_file('01.xml');\n//先找元素\n$book = $xml->book[0];\n//找book的category属性，然后修改\nunset($book->attributes()->category);\n//保存\n$xml->asXML('02.xml');\n```\n\n\n\n\n\n## 九、Xpath查询（会用几个常用语法）\n\n### 9.1、什么是Xpath\n\n官方给的解释是：XPath 使用路径表达式在 XML 文档中进行导航\n\n•     XPath 包含一个标准函数库\n\n•     XPath 是 XSLT 中的主要元素\n\n•     XPath 是一个 W3C 标准\n\n简言之，**XPath** **是一种用来在内存中导航整个 XML** **树的语言**。Xpath有它自己的一套字符串形式的语法，我们按照语法可以简化很多复杂的查询。\n\nXPath 的设计初衷是作为一种面向 XSLT 和 XPointer 的语言。XPath 1.0 在 1999 年成为了一种 W3C 标准。较新的 XPath 2.0 已于 2007 获得规范的状态。\n\n==**PHP目前只支持XPath1.0**==，所以在使用Xpath的时候，有些Xpath语法PHP并不支持或者支持的不好，而且PHP的版本不同，得到的结果也不同。\n\nXpath在很多语言中（PHP、Java、.NET以及Javascript），都可以广泛使用。\n\n\n\n### 9.2、Xpath使用方法\n\n在得到SimpleXMLElement对象之后，该对象中有一个xpath方法，xpath方法的参数就是一个符合Xpath语法的字符串，根据这个字符串的不同，我们可以得到不同的查询结果。\n\n示例：\n\n```php\n$xml = simplexml_load_file('01.xml');\n$result = $xml->xpath('//book'); //查询所有的book节点\n//...\n```\n\n\n\n### 9.3、选取节点\n\nXpath语法：\n\n1. `/` 选择根节点\n2. `//` 选择任意节点。实测PHP支持不好，如果根节点是第1节点，则`//`支持第2节点，如案例中的book节点\n3. `|` 或者的意思，表示选取若干节点\n\n使用示例代码：\n\n```php\n$xml = simplexml_load_file('01.xml');\n\n//从根节点一层一层查询，下面三种方式都可用\n$data = $xml->xpath('/bookstore'); \n$data = $xml->xpath('/bookstore/book');\n$data = $xml->xpath('/bookstore/book/name');\n\necho '<pre>';\nprint_r($data);\n\n//从任意一层节点开始查询\n$data = $xml->xpath('//book');\n$data = $xml->xpath('//name'); //7版本可以，5.4版本不可以\n$data = $xml->xpath('//book/name'); //7版本可以，5.4版本不可以\n\necho '<pre>';\nprint_r($data);\n\n//查询多个不同的节点\n//查询所有的name和所有的price节点\n$data = $xml->xpath('//name | //price');\n```\n\n\n\n### 9.4、方括号筛选\n\n方括号（[]）表示对已经查询到的节点的**筛选**。可以**根据节点的位置进行筛选**、也可以**根据子节点筛选**、还能**根据属性进行筛选**。比如查询到了所有的book节点，通过[]可以对book节点进行进一步的筛选。\n\n1. **根据位置筛选**\n   - `//book[1]` ：查询第一个book节点\n   - `//book[last()]` ：查询最后一个节点\n   - `//book[last()-1]` ：查询倒数第2个节点\n   - `//book[position()<3]` ：查询前两个节点\n\n示例代码：\n\n```php\n$xml = simplexml_load_file('01.xml');\n\n$data = $xml->xpath('//book[1]');\n$data = $xml->xpath('//book[last()]');\n$data = $xml->xpath('//book[last()-1]');\n$data = $xml->xpath('//book[position() < 3]');\n\necho '<pre>';\nprint_r($data);\n```\n\n\n\n2. **根据子节点筛选**\n   - `//book[year]` ：查询book节点，但只查询含有year子节点的book\n   - `//book[year<2000]` ：查询book节点，但要求book含有子节点year，并且year的值要小于2000\n   - `//book[contains(year, 0)]` ：（**模糊查询**）查询book节点，要求book含有子节点year，并且year中要包含数字0\n\n示例代码：\n\n```php\n$xml = simplexml_load_file('01.xml');\n\n$data = $xml->xpath('//book[year]');\n$data = $xml->xpath('//book[year<2010]');\n$data = $xml->xpath('//book[contains(year, 1)]'); //1是数字不用加引号，如果是字符串则需要加引号\n\necho '<pre>';\nprint_r($data);\n```\n\n\n\n### 9.5、@根据属性筛选\n\n在Xpath语法中，带`@`的都表示元素的属性。\n\n- `//book[@category]` ：查询book节点，但只获取带有category属性的节点\n- `//book[@id>2]` ：查询book节点，但只获取id属性值小于3的book\n\n示例代码：\n\n```php\n$data = $xml->xpath('//book[@category]'); //查询带有category属性的book\n$data = $xml->xpath('//book[@id>2]');\n```\n\n\n\n### 9.6、逻辑查询\n\n在查询的时候，查询条件中可以有`and`或者`or`来进行逻辑查询，比如：\n\n`//book[@id and year]` ：查询book节点，要求book节点必须含有id属性，并且book必须有子节点year\n\n> 这个例子通过@将属性和子节点区分开了，带有@的都表示属性，不带@的就表示子节点。\n\n代码：\n\n```php\n$data = $xml->xpath('//book[@id>1 and @id<4]');\n$data = $xml->xpath('//book[@category and year]'); //查询带有category属性，并且包含year子元素的book\n$word = $xml->xpath(\"//word[$type = '$search']\"); //根据查询的内容，找到=查询内容的词\n```\n\n\n\n## 十一、DOM方式操作XML\n\n使用PHP中的DOM系列**内置对象（类）**，对XML进行查询。\n\n```php\n<?php\n//通过PHP的dom类查询所有的name\n$doc = new DOMDocument('1.0', 'UTF-8');\n//echo '<pre>';\n//print_r($doc);\n\n//先加载XML文档\n$doc->load('01.xml'); //通过load方法，将xml加载到内存了\n\n//获取节点\n$nodes = $doc->getElementsByTagName('name');\n//echo '<pre>';\n//print_r($nodes); //数组\n\n/*\n//输出节点某个项的值\n$name1 = $nodes->item(0);  \n//echo '<pre>';\n//print_r($name1); //数组\n\necho $name1->nodeValue;\n*/\n\n//遍历获取的节点数组，输出节点所有项的值\nfor($i=0; $i<$nodes->length; $i++) {\n    echo $nodes->item($i)->nodeValue . '<br>';\n}\n\n```\n\n\n\n## 十二、总结\n\n1. **XML的语法**\n   1. 有且只有一个根节点\n   2. 标签必须闭合\n   3. 属性必须有值，值必须有引号\n   4. < 和 & 必须转换成实体，大段的特殊符号使用CDATA\n2. **操作XML的元素（文本）节点**\n   1. **获取节点** ： $xml = simplexml_load_file();  **$xml->book[0]->name** \n   2. **添加节点** ： $book = $xml->**addChild**('book'); $book->**addChild**('name', '书名');\n   3. **修改节点** ： $xml->book[0]->name = '新的名字';  $xml->asXML();\n   4. **删除节点** ： **unset**($xml->book[0]->name);  $xml->asXML();\n3. **操作属性节点**（==必须先找到元素，比如第一个book元素$book==）\n   1. **获取属性** ：$attrs = $book->attributes();  $attrs->category;\n   2. **添加属性**：$book->**addAttribute**(属性名，属性值);\n   3. **修改属性**：$attrs = $book->attributes();  $attrs->category = '新的值';\n   4. **删除属性**：$attrs = $book->attributes();  **unset**($attrs->category);\n4. ==**Xpath**==\n   1.  `/` 表示从根节点查询\n   2. `//` 表示从任意节点开始查询\n   3. `[ ]` 里面表示对查询的节点进行筛选\n      * [year < 2000] 表示包含子节点year并且他的值小于2000\n      * [@id < 3] 表示查询到的节点要有id属性并且id的值要小于3\n   4. `last()` 表示最后一个\n   5. `position()` 表示节点的位置\n   6. `contains()` 表示**模糊查询**","categories":["XML"]},{"title":"mongodb案例","url":"%2Fposts%2F3990249883%2F","content":"\n\n# mongoDB\n\n# 案例：Mongodb实现短网址\n\n## **简介**\n\n将一个非常长的URL地址转换为一个比较短的URL地址。主要为了用户的一个体验，因为短的信息美观一些。同时也可以达到隐藏url地址信息，有的时候我们可以不希望用户直接看到url里面包含的信息，或者有的时候出于某些操作可能根不希望别人看到。\n\n \n\n一般在微博里面最常见。有的时候手机的短信也可以收到类似的url地址。\n\n \n\n体验地址：\n\n<http://dwz.wailian.work/>\n\n \n\n效果：\n\n![img](wps81FE.tmp.jpg) \n\n \n\n \n\n实现技术点：\n\n1. 用户先输入一个长的网址，然后发送ajax请求去后台生成短的网址\n2. 到时候后台会保存一个 短网址 和 长网址 的对应关系 【使用mongodb进行映射关系数据的存储】\n3. 当用户利用短网址去访问的时候，短网址的服务器先判断短网址是否在本地的数据库里面存在，如果存在则取出后使用php的header(‘location:长URL’, 302)函数做一个跳转即可完成。【302：临时重定向】\n\n \n\n## 新浪微博短网址api使用\n\n现在如果实际是自己的公司要做这样的分享网址的业务，那么我们自己该如何处理呢？\n\n答：\n\n1. 自己是否存在短的域名\n2. 使用第三方的API进行生成【短网址最先从新浪的微博演变过来的，因为微博在设计的时候，只能发送140个文字】\n\n![img](wps8210.tmp.jpg) \n\n\n\n\n\n微信开发平台现在也支持短网址的操作。 \n\napi文档：<http://open.weibo.com/wiki/Short_url/shorten>\n\n 一款开源的PHP程序，让你可以轻松建立属于自己的短网址生成系统 【https://c7sky.com/yourls.html】\n\n\n\n已知新浪有提供类似的API。\n\n1. 成为新浪的开发者【身份证信息】\n2. 创建应用（获取到appkey）\n\n![img](wps8220.tmp.jpg) \n\nappkey： **752547878**\n\n \n\n3. 根据文档进行接口调用，提供了两种方式的url请求\n\n![img](wps8231.tmp.jpg) \n\na) xml格式数据\n\nhttp://api.t.sina.com.cn/short_url/shorten.xml?source=752547878&url_long=http://open.weibo.com/wiki/Short_url/shorten\n\nb) json格式的数据\n\nhttp://api.t.sina.com.cn/short_url/shorten.json?source=752547878&url_long=http://open.weibo.com/wiki/Short_url/shorten\n\n![img](wps8232.tmp.jpg) \n\n \n\n\n\n## **用户自定义开发思路分析**\n\n \n\n通过上面的操作，我们可以使用别人提供的API进行短网址的生成，但是我们现在处于学习，我们可以自己去实现一个短网址的转换项目。自己在本地定义一个域名(hosts文件里面定义即可 例如：b.cn)\n\n\n\n思路：\n\n1. 短网址必须唯一，一 一对应。可以参考MySQL的主键ID，即可以自增，也可以唯一\n2. 网址必须短，但是需要存储的信息多。这个时候可以使用进制实现，进制可以实现使用较少的位数来保存更多的信息。\n3. 短网址尽量乱，无规律。防止发现规律后批量请求。\n\n\n\n统一现在规定短网址的位数在6位，查看一下不同进制下可以保存的所有的短网址的信息：\n\n\t二进制 111111    2^6\n\t八进制 777777   8^6\n\t十六进制 FFFFFF F   16^6\n\t六十二进制 62^6  \n\n![img](wps8243.tmp.jpg) \n\n使用6位的62进制最多可以表示出500多亿种状态。\n\n\n\n![img](wps8244.tmp.jpg) \n\n**使用62进制在处理的时候，不能体现出规律性**。则我们需要设计出一个自己的码表。之前我们使用的16进制，可以使用 0-9 A-F 来表示10进制的 0-15 这个16个数，则现在我们的62进制，则也需要使用62个字符来表示我们10进制的0-61。\n\n**去哪里找出62个字符进行替代？**\n\n0-9：十个阿拉伯数字\n\na-z：26个字符\n\nA-Z：26个字符\n\n----\n\n正好为 62 个字符，所以我们可以使用上面的 字符行为一个码表。\n\n| 序号 | 62进制 | 10进制 |\n| ---- | ------ | ------ |\n| 1    | 0      | 0      |\n| 2    | 1      | 1      |\n| 3    | 2      | 2      |\n| 4    | 3      | 3      |\n| 6    | 5      | 5      |\n| 7    | 6      | 6      |\n| 8    | 7      | 7      |\n| 9    | 8      | 8      |\n| 10   | 9      | 9      |\n| 11   | a      | 10     |\n| 12   | b      | 11     |\n| 13   | c      | 12     |\n| ...  | ....   | ...    |\n| 60   | Y      | 60     |\n| 61   | Z      | 61     |\n\n62进制：ZY\n\n10进制为：61*62^1 + 60 * 62^0\n\n\n\n**问题：为什么要使用62进制来设计短网址了吗？**\n\n答：进制大，短表示更多的可能性。\n\n \n\n## **主键id和进制代码实现**\n\n==代码实现的思路：==\n\n* **首先 生成一个唯一的数字，然后把这个唯一的数字转换为62进制。**\n\n   mongodb里面提供一个**全局计算器**，可以帮我们生成唯一的整数，理解成mysql里面的自增型的主键id。用户输入的一个长的url地址应该对应一个唯一的短的url地址。\n\n   实现：\n\n   <http://www.runoob.com/mongodb/mongodb-autoincrement-sequence.html>\n\n![img](wps8254.tmp.jpg) \n\n演示：\n\n1. 创建一个集合，集合里面存在两个字段\n\n```\n> use short\n\n> db.counter.findAndModify({query:{'_id': 1} , update:{'$inc': {'value': 1}}});\n\n{ \"_id\" : 1, \"value\" : 10 }\n```\n\n实现每调用一次，先获取对应的自增id 然后把对应的值自增一下。然后将自增的id转化为对应的短网址。\n\n \n\n2. 变短的62进制和域名的前缀进行拼接\n\n  定义码表 \n\n![1536910478920](1536910478920.png)\n\n转换函数\n\n![1536910497867](1536910497867.png)\n\n\n\n## **代码实现**\n\n### **前台效果**\n\n1. 创建一个 输入长网址转换为短网址的页面\n\n![img](wps829A.tmp.jpg) \n\n效果\n\n![1536911578689](1536911578689.png)\n\n \n\n2. 完成页面的ajax提交事件\n\n![1536913844373](1536913844373.png)\n\n3. 复制按钮\n\n   a) 复制静态资源到z.cn目录\n\n![1536913886975](1536913886975.png)\n\n​\tb) 在index.html页面修改短网址框的val值 和 点击复制按钮的ID，并引入插件包\n\n![1536913914046](1536913914046.png)\n\n引入插件并定义复制函数\n\n![1536913938083](1536913938083.png)\n\n \n\n在完成ajax请求后进行复制函数调用\n\n![1536913976415](1536913976415.png)\n\n\n\n### **后台处理**\n\n1. 在function.php定义好进制转换函数\n\n ![1536914096593](1536914096593.png)\n\n在后台op.php生成短网址和长网址的映射关系\n\n![1536914020696](1536914020696.png)\n\n\n\n2. 如果存在则直接返回\n\n![1536914034810](1536914034810.png)\n\n \n\n3. 不存在则生成\n\n![1536914056393](1536914056393.png)\n\n\n\n### 短网址访问\n\n1. 定义伪静态规则，开启Apache的rewrite模块\n\n![img](wps82F2.tmp.jpg) \n\n \n\n2. 开启虚拟主机的重写\n\n![img](wps8303.tmp.jpg) \n\n \n\n3. 在网站根目录创建.htaccess文件\n\n![img](wps8304.tmp.jpg) \n\n \n\n内容如下：\n\n![1536915532909](1536915532909.png)\n\n\n\n5. 在b.cn/s目录创建一个index.php完成跳转\n\n![1536915512675](1536915512675.png)\n\n \n\n\n\n ","categories":["NoSQL.Mongodb"]},{"title":"mongodb","url":"%2Fposts%2F4026166152%2F","content":"\n\n# mongoDB\n\n**mongodb**，也叫作文档型的数据库，一般来说对于我们PHP，这个数据库的使用量还是偏少一点，一般来说我们使用的更多的是memcache和Redis。mongodb一般还是配合前端的javascript工程师和nodejs工程师进行开发使用，一般都将这个数据库做数据存储的仓库。我们PHP后端一般还是习惯用mysql作为数据存储的仓库，一般来说我们PHP程序员习惯使用mongodb存储一些日志信息，例如我们的网站里面做发送短信的业务，用来记录发送了哪些短信。\n\n \n\n## **简介**\n\n**mongoDB**  被称为文档型数据库，当然也叫Nosql数据库。\n\n**Nosql数据库：**\n\n1.  没有表的概念，没有行和列的概念，即没有二维表\n\n2. 没有sql查询，一般都是自己有相关的查询api，例如mongodb就是使用的javascript的api进行数据的处理，所以对于javascript工程师来说，掌握mongodb是很轻松。\n\n\n\n\n**关系型数据库：**\n\n* 由行和列构成的一张二维表被称为实体。实体和实体之间的关系，被称为E_R模型，则就是关系型数据库的理论基础。\n\n| id   | username | password | email                                     | address      | gender | classid |\n| ---- | -------- | -------- | ----------------------------------------- | ------------ | ------ | ------- |\n| 1    | caoyang  | admin88  | [gogery@173.com](mailto:gogery@173.com)   | shanghaishi  | m      | 3       |\n| 2    | andy     | admin88  | [caoyang@173.com](mailto:caoyang@173.com) | guangzhoushi | m      | 4       |\n\n \n\n其他的表\n\n| classid | class_name | class_markup  | class_address |      |\n| ------- | ---------- | ------------- | ------------- | ---- |\n| 3       | php23      | PHP最牛的班级 | 312           | .... |\n| 4       | java       | Java还可以吧  | 213           | .... |\n\n \n\n所以，现在的nosql数据库并不适合做关系很复杂的业务，不好去做连表类型的业务。nosql更多就是一个数据的仓库，不适合做连表业务。\n\n\n\n**如果我们希望非关系型数据库去处理这种关系型的业务，该如何处理？**\n\n答：通过==增加冗余的信息==来保证数据的完整性。如果使用非关系型数据库到时候会导致数据量非常大。冗余数据的增加带来的弊端就是磁盘要使用更多，好处也是显而易见，查询更加的便捷，一条查询把所有的数据全部搞定，不需要进行连表业务。\n\n\n\n注意：由于mongodb的特性（底层使用json格式的数据进行存储，如果我们严格的规定了json的key=>value对，则看起来想一个行和列构成的二维结构），很像一个关系型的数据库（设计字段），所以有的人尝试把它当成关系型数据库进行使用，然后存在了很多的数据，但是它毕竟不是关系型数据库，所以后期如果需要把mongodb转存到关系型数据库里面，发现实际不可行的。一般这时候都是 mysql + mongodb 一起配合，千万不要mongodb使用在前。\n\n\n\n**mongodb被为文档型数据库**\n\n可以这样理解：文档型的数据库存储的数据格式就是经过特殊处理的json格式的数据，存储的载体是文档，专业术语叫做Bson。\n\n\n\n简单的理解，Bson比原先的json多了一些数据类型，或者说是数据类型的格式更加的规范，严苛，例如存储的浮点数的精度更加的高。\n\n \n\n**特点：**\n\nmongodb内部使用**js解释引擎**来实现数据的分析  **。现在还是使用的和chrome浏览器相同的引擎，是现在javascript最厉害的引擎，v8引擎 和我们Nodejs内部的js引擎是一样**。\n\n在插入的时候，将数据转换成二进制的Bson来存储；在查询的时候，将数据Bson转换成json对象返回。\n\n \n\n\n\n现在出了v8引擎，还有其他的很多的引擎，trident、xxmonkey。\n\n<https://liulanmi.com/browser>\n\n<http://www.paopaoche.net/soft/77495.html>\n\n\n\n**mongodb与传统关系型数据（MySQL）有什么区别？**\n\n| 名称    | 库     | 表                | 行                          | 操作                                     |\n| ------- | ------ | ----------------- | --------------------------- | ---------------------------------------- |\n| mongodb | 数据库 | collection (集合) | document 文档json格式的数据 | js面向对象  `db.users.find()`            |\n| mysql   | 数据库 | 表                | 记录                        | sql操作`select * from user where id > 1` |\n\n \n\nmysql:\n\n| id   | username | password | email      |\n| ---- | -------- | -------- | ---------- |\n| 12   | caoyang  | admin88  | a2@sina.cn |\n| 13   | caoyang  | admin88  |            |\n\n \n\n可以使用一个bson来描述上面的信息\n\n```bson\n[\n\n    {\n\n        “id”:12,\n\n        “username”:”caoyang”,\n\n        “password”:”admin88”,\n\n        “classInfo”:{\n\n            \"id\" : 1\n\n            \"class_name\": \"itphp30\",\n\n            \"start_time\" : 1231231\n\n        }\t\n\n    }，\n\n    {\n\n        “id”:22,\n\n        “username”:”adny”,\n\n        “password”:”admin88”,\n\n        “email”:”a2@sian.cn”，\n\n        “classInfo”:{\n\n            \"id\" : 1\n\n            \"class_name\": \"itphp30\",\n\n            \"start_time\" : 1231231\n\n        }\n\n    }\n\n]\n```\n\n\n\n**扩展：**\n\n什么是**GeoJson**？topjson?\n\n答：GeoJson 翻译过来是 地理信息的json格式数据。和普通的json的格式稍有一定区别。\n\n普通json格式的数据的如下：\n\n```\n{\n\n“id”:22,\n\n“username”:”adny”,\n\n“password”:”admin88”,\n\n\n```\n\n但是GeoJson里面的key-value的key是受到==严格==的限制的，只能使用固定好的key。\n\n![img](wps7F5B.tmp.jpg) \n\n网站：\n\n<http://echarts.baidu.com/demo.html#map-china-dataRange>\n\n<http://echarts.baidu.com/echarts2/doc/example/map20.html>\n\n \n\n<http://www.osgeo.cn/info/270ce>\n\n<https://blog.csdn.net/lzhlzz/article/details/41347929>\n\n \n\n可能做图表。\n\n<http://echarts.baidu.com>\n\n \n\n\n\n## 安装\n\n\n\n1. 下载对应的稳定版源代码，并放置到（/usr/local/src目录下）\n\n   官网：[www.mongodb.org](http://www.mongodb.org)\n\n   中文手册：<http://www.runoob.com/mongodb/mongodb-tutorial.html>\n\n   中文社区：<http://www.mongoing.com/>\n\n   阿里云的mongodb的镜像：<https://mirrors.aliyun.com/mongodb/>\n\n \n\n![img](wps7F5C.tmp.jpg) \n\n\n\n2. 上传、解压文件（/usr/local/src**/**）\n\n![img](wps7F6C.tmp.jpg) \n\n​\t解压安装包\n\n![img](wps7F7D.tmp.jpg) \n\n​\t然后将mongodb源码移动到上级目录下\n\n![img](wps7F7E.tmp.jpg) \n\n \n\n3. 为mongodb创建一个==符号链接==\n\n![img](wps7F8F.tmp.jpg) \n\n \n\n4. 查看一下bin目录的命令\n\n![img](wps7F9F.tmp.jpg) \n\n \n\n5. 我们通过常看README文件或者帮助命令\n\n![img](wps7FA0.tmp.jpg) \n\n​\t查看帮助\n\n![img](wps7FB1.tmp.jpg) \n\n \n\n6. 启动服务：\n\n   a. 创建db文件夹，保存mongodb运行时候的数据库信息\n\n![img](wps7FC2.tmp.jpg) \n\n​\tb. 启动服务\n\n![img](wps7FD2.tmp.jpg) \n\n参数的解释：\n\n`--dbpath`: 表示是数据库保存的目录\n\n`--logpath`: 表示是日志文件log.txt\n\n`--fork`: 表示该服务在后台运行\n\n \n\n7. 停止，关闭mongodb，使用kill 命令，不要使用pkill。\n\n![img](wps7FE4.tmp.jpg) \n\n8. 连接服务端，使用mongo客户端进行连接。\n\n![img](wps7FF4.tmp.jpg) \n\n9. 简单的使用：只需要遵循js语法，基本都可以使用。能使用的只是ECMAScript定义的函数\n\n![img](wps8005.tmp.jpg) \n\n \n\n\n\n# ==mongoDB使用==（重要）\n\n\n\n## **入门命令**\n\n学习文档：\n\n<http://www.runoob.com/mongodb/mongodb-create-database.html>\n\n\n\n1. `show dbs`  查看所有的数据库\n\n```\n> show dbs;\nlocal  0.078GB\nphp31  0.078GB\ntest   0.078GB\n> \n```\n\n\n\n2. `use databaseName`  选库\n\n    MongoDB可以隐式的创建，直接`use databaseNAME `可以创建一个数据库\n\n```\n> use php32;\nswitched to db php32\n> \n> \n\n> use php33;\nswitched to db php33\n> \n```\n\n\n\n3. 查看当前数据库下的集合\n   * `show tables` 查看当前库下的数据表\n   * `show collections `也可以查看\n\n```\n> use php33;\nswitched to db php33\n> show tables;\n\n> show collections;\n```\n\n\n\n## 库操作\n\n### 创建数据库\n\nmongoDB的库是隐式创建，当use 一个不存在的库的时候，然后在该库下创建collection后即可创建数据库。\n\n```\n> use php32;\nswitched to db php32\n```\n\n**注意：** \n\na. 使用use 选择一个数据库，这个数据库可以不存在，当在这个数据库下创建集合的时候，则对应的数据库创建成功，使用 `show dbs` 进行查看当前系统所有的数据库时，才能显示当前库。\n\n```\n> db.createCollection(\"students\");\n\n> show dbs;\nlocal  0.078GB\nphp31  0.078GB\nphp32  0.078GB\ntest   0.078GB\n```\n\n 注意：`db.createCollection(\"students\"); ` 中 db表示当前切换的数据库 php32， createCollection表示在当前数据库创建一个集合，集合的名称为 students ，当创建该集合后，则可以使用 `show dbs` 查看系统所有的数据库信息，也可以使用 `show tables` 查看当前数据库下的集合信息。\n\n```\n> show tables;\nstudents\nsystem.indexes\n> \n```\n\n其中的students 表示我们刚才创建的集合，system.indexes是系统内部维护的集合。\n\n\n\n### 创建表\n\n1. 显式创建\n\n```\n> db.createCollection(\"order\")\n{ \"ok\" : 1 }\n```\n\n\n\n2. 隐式创建\n\n```\n> db.myClass.insert({\"name\":\"phpLearn\", \"classInfo\": \"PHP学习\"});\nWriteResult({ \"nInserted\" : 1 })\n\n```\n\n这里的myClass是用户自定义的集合名称，当不存在的集合里在插入数据的时候，隐式的创建该集合\n\n\n\n**集合查看** \n\n* `show tables `查看当前数据库下的表\n* `show collections `也可以查看当前数据库下的表\n\n```\n> show tables;\nmyClass\norder\nstudents\nsystem.indexes\n\n> show collections;\nmyClass\norder\nstudents\nsystem.indexes\n> \n```\n\nshow tables 和 show collections 完全等价。\n\n\n\n### **删除表**\n\n`db.collectionName.drop() `删除表\n\n```\n> db.students.drop();\ntrue\n> \n```\n\n这里的students表示的是集合名称，用户可以换成自己要删除的集合名称。\n\n\n\n### **删除数据库**\n\n```\n> db.dropDatabase();\n{ \"dropped\" : \"php32\", \"ok\" : 1 }\n> \n```\n\n\n\n\n\n## 数据操作\n\n### **基本增删改查命令**\n\n1. `find() `查看\n\n```\n> use php31;\nswitched to db php31\n\n> show tables;\nstuendts\nsystem.indexes\n\n> db.stuendts.find();\n{ \"_id\" : ObjectId(\"5b9b1a93aa27e2cddc7d7a2f\"), \"name\" : \"LILY\" }\n{ \"_id\" : ObjectId(\"5b9b1ad2aa27e2cddc7d7a31\"), \"name\" : \"MY\", \"age\" : 46 }\n{ \"_id\" : ObjectId(\"5b9b1ad2aa27e2cddc7d7a32\"), \"name\" : \"iju\", \"age\" : 45 }\n{ \"_id\" : ObjectId(\"5b9b23bdaa27e2cddc7d7a34\"), \"name\" : \"andy\", \"age\" : 12, \"address\" : \"shenzhenshi\", \"money\" : 300000 }\n```\n\ndb表示的是当前数据库 php31\n\nstudents表示当前数据库下的集合，用户可以换成自己的集合名称\n\nfind表示查看所有的记录信息\n\n上面的的：`db.stuendts.find(); `类似下面的SQL语句：\n\n> select * from collectionName;\n\n\n\n**备注：**可以在find方法后面在使用`pretty()`方法，将取出的数据以一个优雅的格式显示。\n\n```\n> db.stuendts.find().pretty();\n{ \"_id\" : ObjectId(\"5b9b1a93aa27e2cddc7d7a2f\"), \"name\" : \"LILY\" }\n{ \"_id\" : ObjectId(\"5b9b1ad2aa27e2cddc7d7a31\"), \"name\" : \"MY\", \"age\" : 46 }\n{ \"_id\" : ObjectId(\"5b9b1ad2aa27e2cddc7d7a32\"), \"name\" : \"iju\", \"age\" : 45 }\n{\n\t\"_id\" : ObjectId(\"5b9b23bdaa27e2cddc7d7a34\"),\n\t\"name\" : \"andy\",\n\t\"age\" : 12,\n\t\"address\" : \"shenzhenshi\",\n\t\"money\" : 300000\n}\n\n```\n\n\n\n### **增加数据 insert**\n\n```\n> db.collectionName.isnert(document);\n```\n\n注意：document可以是一个js对象，表示是单条记录插入; 也可以是一个数组，数组里面的每个元素又是一个js对象，表示是多条记录插入。\n\n例如：\n\n单条记录\n\n```\n> db.collectionName.insert({_id:5, age:18, name:’asion’});\n```\n\n多条记录\n\n```\n> db.collectionName.insert(\n\t[\n\t\t{date:'2014-12-12', study:'mongodb'},\n\t\t{_id:9, gender:'male', name:'caoyang'}\n\t]\n)\n```\n\n\n\n### **删除数据 remove**\n\n一般来说我们做删除的时候，肯定要设置删除的条件。\n\n```\n> db.collectionName.remove(查询表达式,  选项);\n\n\n```\n\n`选项`  是指  {justOne:true/false}, 是否只删一行，默认为false\n\n等同于\n\n>  delete  from tableName where id > 1 limit 1; \n\n**注意**\n\n1: 查询表达式依然是个json对象\n\n2: 查询表达式匹配的集合，将被删掉\n\n3: 如果不写查询表达式，tables中的所有文档将被删掉\n\n \n\n例1: 删除students表中 sn属性值为’001’的数据\n\n```\n>  db.students.remove({sn:'001'});\n```\n\n例2: 删除students表中gender属性为m的文档，只删除1行\n\n```\n> db.students.remove({gender:'m'},{justOne:true});\n```\n\n\n\n### **修改数据 update**\n\n```\n# db.collectionName.update(查询表达式, 新值)\n```\n\n等同于\n\n> udpate collectionName  set name = ‘asion’ where id = 1;\n\n \n\n例如: 现在需要将name为asion的文档的用户名改为caoyang\n\n```\n# db.news.update({name:'asion'},{name:'caoyang'});\n```\n\n结果: 文档中的其他列不见了，改后只有_id和name列数据\n\n注意-->**新值直接替换了旧值，而不是修改，将我们设置的值做了一个全部的替换**\n\n所以，如果是想修改数据的**某列**，可以用**$set**关键字\n\n```\n# db.collectionName.update({name:'asion'}, { $set:{name:'caoyang'} })\n```\n\n$set：表示当前的操作是一个更新，而不是替换。\n\n\n\n### **查询数据 find、 findOne**\n\nfind和findOne都是用来做数据查询的，但是find是显示所有的数据，findOne是查询单条数据的。同时在查询的时候，可以指定==查询的条件==和==显示的字段==信息。\n\n```\n> db.collection.find(查询表达式, 显示的列);\n\n> db.collections.find(查询表达式, {列1: 0,  列2:0});\n```\n\n\n\n例1:查询students所有数据\n\n```\n> db.stuendts.find()\n{ \"_id\" : ObjectId(\"5b9b1a93aa27e2cddc7d7a2f\"), \"name\" : \"LILY\" }\n{ \"_id\" : ObjectId(\"5b9b1ad2aa27e2cddc7d7a31\"), \"name\" : \"MY\", \"age\" : 46 }\n{ \"_id\" : ObjectId(\"5b9b1ad2aa27e2cddc7d7a32\"), \"name\" : \"iju\", \"age\" : 45 }\n{ \"_id\" : ObjectId(\"5b9b23bdaa27e2cddc7d7a34\"), \"name\" : \"andy\", \"age\" : 12, \"address\" : \"shenzhenshi\", \"money\" : 300000 }\n> \n```\n\n\n\n例2: db.students.find({},{name:1})\n\n{} 表示取出所有\n\n查询所有文档数据，但是只显示name列数据 (_id属性默认总是查出来)\n\n```\n> db.stuendts.find({}, {\"name\":1});\n{ \"_id\" : ObjectId(\"5b9b1a93aa27e2cddc7d7a2f\"), \"name\" : \"LILY\" }\n{ \"_id\" : ObjectId(\"5b9b1ad2aa27e2cddc7d7a31\"), \"name\" : \"MY\" }\n{ \"_id\" : ObjectId(\"5b9b1ad2aa27e2cddc7d7a32\"), \"name\" : \"iju\" }\n{ \"_id\" : ObjectId(\"5b9b23bdaa27e2cddc7d7a34\"), \"name\" : \"andy\" }\n```\n\n\n\n例3: 查看所有文档指定字段。\n\n查询所有文档数据，但是只显示name列信息，且不显示_id列信息\n\n```\n> db.stuendts.find({}, {\"name\":1, \"_id\": 0});\n{ \"name\" : \"LILY\" }\n{ \"name\" : \"MY\" }\n{ \"name\" : \"iju\" }\n{ \"name\" : \"andy\" }\n```\n\n\n\n例4: 查看单条记录信息\n\n查询所有name值为andy的数据，但是只显示name这列信息，并且只获取一条文档。\n\n```\n> db.stuendts.findOne({\"name\": \"andy\"}, {\"name\": 1, \"_id\": 0});\n{ \"name\" : \"andy\" }\n\n```\n\n\n\n在查询的时候，除了 = 是否还存在其他的查询运算符，例如 > >= < ..... \n\n参考<http://www.runoob.com/mongodb/mongodb-operators.html>\n\n \n\n\n\n# ==Mongodb高级查询技巧-单一条件==\n\n文档：<http://www.runoob.com/mongodb/mongodb-operators.html>\n\n \n\n一般的业务还是查询比较多，写的相当来说少一些。\n\n![img](wps8107.tmp.jpg) \n\n \n\n## 大于查询\n\n`# db.collectionName.find({\"查询字段的名称\" : {操作符 : 查询值} })`\n\n例如：查询用户的年龄大于 20的用户的用户名和年龄信息\n\n```\n> db.stuendts.find({\"age\": {\"$gt\": 12}}, {\"name\": 1, \"age\": 1, \"_id\":0});\n{ \"name\" : \"MY\", \"age\" : 46 }\n{ \"name\" : \"iju\", \"age\" : 45 }\n```\n\n等同于\n\n> select name, age from students where age > 12;\n\n\n\n## 小于查询\n\n```\n> db.stuendts.find({\"age\": {\"$lt\": 45}});\n{ \"_id\" : ObjectId(\"5b9b23bdaa27e2cddc7d7a34\"), \"name\" : \"andy\", \"age\" : 12, \"address\" : \"shenzhenshi\", \"money\" : 300000 }\n```\n\n等同于\n\n> select * from students where age < 45;\n\n\n\n## 小于等于查询\n\n```\n> db.stuendts.find({\"age\": {\"$lte\": 45}});\n\n{ \"_id\" : ObjectId(\"5b9b1ad2aa27e2cddc7d7a32\"), \"name\" : \"iju\", \"age\" : 45 }\n{ \"_id\" : ObjectId(\"5b9b23bdaa27e2cddc7d7a34\"), \"name\" : \"andy\", \"age\" : 12, \"address\" : \"shenzhenshi\", \"money\" : 300000 }\n```\n\n等同于\n\n> select * from students where age <= 45;\n\n\n\n# ==Mongodb高级查询技巧-多条件处理==\n\n## mongodb的and操作\n\n![img](wps812B.tmp.jpg) \n\n`db.collectionName.find({key1: value1, 'key2': value2});`\n\n![img](wps813B.tmp.jpg) \n\n\n\n## mongodb的or操作\n\n![img](wps813C.tmp.jpg) \n\n \n\n![img](wps813D.tmp.jpg) \n\n \n\n## mongodb的and和or\n\n![img](wps814E.tmp.jpg) \n\n例如数据库里面存在用户的信息，获取用户的年龄是成年，同时籍贯为湖北或者湖南的。\n\n`age >= 18 and ( jiguan = '湖北' or jiguan='湖南' )`\n\n ( age>= 18 and jiguan='湖南' ) or (age>=18 and jigaun='湖北') 更符合人类的阅读\n\n<http://www.runoob.com/mongodb/mongodb-query.html>\n\n \n\n\n\n# ==php操作mongoDB==\n\n一般是用php作为客户端来操作mongodb，对我们php程序员来说很少使用CLI。\n\n \n\n## **windows下安装**\n\n1. 下载源码\n\n   下载地址：<http://pecl.php.net/package/mongo>\n\n \n\n2. 点击对应的【dll：dynamic link library 动态链接 ，window用来操作mongodb的扩展文件】\n\n![img](wps814F.tmp.jpg) \n\n \n\n3. 选择合适的php版本，这个时候需要注意的是，选择版本的时候，存在php线程和非线程安全的选择。\n\n![img](wps8160.tmp.jpg) \n\n**线程安全信息如何查看？**\n\n​\t答：使用phpinfo函数，进行查看如下信息\n\n![img](wps8170.tmp.jpg) \n\n​\t含义：\n\n![img](wps8171.tmp.jpg) \n\n \n\n4. 复制上面压缩包里面的两个文件到php的ext目录\n\n![img](wps8182.tmp.jpg) \n\n![img](wps8183.tmp.jpg) \n\n \n\n5. 修改php.ini文件，phpinfo查看配置文件所在路径\n\n   ![img](wps8184.tmp.jpg) \n\n![img](wps8194.tmp.jpg) \n\n\n\n6. 必须重启，建立一个phpinfo() ，见到如下信息，表示成功\n\n![img](wps81A5.tmp.jpg) \n\n \n\n\n\n## Linux下安装-php5.3\n\n可视化操作mongodb的客户端（Redis也存在这种可视化的客户端）\n\n<https://blog.csdn.net/zhengalen/article/details/51464513>\n\n<https://www.cnblogs.com/shiweida/p/7692468.html>\n\n<https://www.cnblogs.com/aimu/p/7047671.html>\n\n \n\n1. 上传扩展包到 /usr/local/src\n\n![img](wps81B7.tmp.jpg) \n\n \n\n​\t解压【注意：这个是一个zip包，不需要进行tar方法解压，使用 unzip解压即可】\n\n![img](wps81B8.tmp.jpg) \n\n​\t注意：如果zip命令无法使用，则使用如下的命令进行安装\n\n`> yum install -y unzip zip`\n\n \n\n2. 执行phpize命令\n\n![img](wps81C8.tmp.jpg) \n\n​\t执行上面的操作后，利用生成的configure文件，收集操作系统和php-config命令的信息\n\n![img](wps81C9.tmp.jpg) \n\n3. 执行`make && make install `\n\n![img](wps81DA.tmp.jpg) \n\n4. 执行上面的操作后，会在如下的目录生成一个.so文件\n\n![img](wps81DB.tmp.jpg) \n\n5. 修改php.ini\n\n![img](wps81DC.tmp.jpg) \n\n6. 在test.php里面使用 phpinfo函数测试\n\n![img](wps81ED.tmp.jpg) \n\n \n\n7. 创建测试文件\n\n   下面的这个语法是：php5.3里面的 pdo链接方式 dsn: data source name\n\n![img](wps81EE.tmp.jpg) \n\n \n\n\n\n# 扩展\n\n## **mongodb的权限验证机制**\n\n<http://blog.csdn.net/lk10207160511/article/details/50281883>\n\n\n\n\n\n# 案例：Mongodb实现短网址\n\n## **简介**\n\n将一个非常长的URL地址转换为一个比较短的URL地址。主要为了用户的一个体验，因为短的信息美观一些。同时也可以达到隐藏url地址信息，有的时候我们可以不希望用户直接看到url里面包含的信息，或者有的时候出于某些操作可能根不希望别人看到。\n\n \n\n一般在微博里面最常见。有的时候手机的短信也可以收到类似的url地址。\n\n \n\n体验地址：\n\n<http://dwz.wailian.work/>\n\n \n\n效果：\n\n![img](wps81FE.tmp.jpg) \n\n \n\n \n\n实现技术点：\n\n1. 用户先输入一个长的网址，然后发送ajax请求去后台生成短的网址\n2. 到时候后台会保存一个 短网址 和 长网址 的对应关系 【使用mongodb进行映射关系数据的存储】\n3. 当用户利用短网址去访问的时候，短网址的服务器先判断短网址是否在本地的数据库里面存在，如果存在则取出后使用php的header(‘location:长URL’, 302)函数做一个跳转即可完成。【302：临时重定向】\n\n \n\n## 新浪微博短网址api使用\n\n现在如果实际是自己的公司要做这样的分享网址的业务，那么我们自己该如何处理呢？\n\n答：\n\n1. 自己是否存在短的域名\n2. 使用第三方的API进行生成【短网址最先从新浪的微博演变过来的，因为微博在设计的时候，只能发送140个文字】\n\n![img](wps8210.tmp.jpg) \n\n\n\n\n\n微信开发平台现在也支持短网址的操作。 \n\napi文档：<http://open.weibo.com/wiki/Short_url/shorten>\n\n 一款开源的PHP程序，让你可以轻松建立属于自己的短网址生成系统 【https://c7sky.com/yourls.html】\n\n\n\n已知新浪有提供类似的API。\n\n1. 成为新浪的开发者【身份证信息】\n2. 创建应用（获取到appkey）\n\n![img](wps8220.tmp.jpg) \n\nappkey： **752547878**\n\n \n\n3. 根据文档进行接口调用，提供了两种方式的url请求\n\n![img](wps8231.tmp.jpg) \n\na) xml格式数据\n\nhttp://api.t.sina.com.cn/short_url/shorten.xml?source=752547878&url_long=http://open.weibo.com/wiki/Short_url/shorten\n\nb) json格式的数据\n\nhttp://api.t.sina.com.cn/short_url/shorten.json?source=752547878&url_long=http://open.weibo.com/wiki/Short_url/shorten\n\n![img](wps8232.tmp.jpg) \n\n \n\n\n\n## **用户自定义开发思路分析**\n\n \n\n通过上面的操作，我们可以使用别人提供的API进行短网址的生成，但是我们现在处于学习，我们可以自己去实现一个短网址的转换项目。自己在本地定义一个域名(hosts文件里面定义即可 例如：b.cn)\n\n\n\n思路：\n\n1. 短网址必须唯一，一 一对应。可以参考MySQL的主键ID，即可以自增，也可以唯一\n2. 网址必须短，但是需要存储的信息多。这个时候可以使用进制实现，进制可以实现使用较少的位数来保存更多的信息。\n3. 短网址尽量乱，无规律。防止发现规律后批量请求。\n\n\n\n统一现在规定短网址的位数在6位，查看一下不同进制下可以保存的所有的短网址的信息：\n\n\t二进制 111111    2^6\n\t八进制 777777   8^6\n\t十六进制 FFFFFF F   16^6\n\t六十二进制 62^6  \n\n![img](wps8243.tmp.jpg) \n\n使用6位的62进制最多可以表示出500多亿种状态。\n\n\n\n![img](wps8244.tmp.jpg) \n\n**使用62进制在处理的时候，不能体现出规律性**。则我们需要设计出一个自己的码表。之前我们使用的16进制，可以使用 0-9 A-F 来表示10进制的 0-15 这个16个数，则现在我们的62进制，则也需要使用62个字符来表示我们10进制的0-61。\n\n**去哪里找出62个字符进行替代？**\n\n0-9：十个阿拉伯数字\n\na-z：26个字符\n\nA-Z：26个字符\n\n----\n\n正好为 62 个字符，所以我们可以使用上面的 字符行为一个码表。\n\n| 序号 | 62进制 | 10进制 |\n| ---- | ------ | ------ |\n| 1    | 0      | 0      |\n| 2    | 1      | 1      |\n| 3    | 2      | 2      |\n| 4    | 3      | 3      |\n| 6    | 5      | 5      |\n| 7    | 6      | 6      |\n| 8    | 7      | 7      |\n| 9    | 8      | 8      |\n| 10   | 9      | 9      |\n| 11   | a      | 10     |\n| 12   | b      | 11     |\n| 13   | c      | 12     |\n| ...  | ....   | ...    |\n| 60   | Y      | 60     |\n| 61   | Z      | 61     |\n\n62进制：ZY\n\n10进制为：61*62^1 + 60 * 62^0\n\n\n\n**问题：为什么要使用62进制来设计短网址了吗？**\n\n答：进制大，短表示更多的可能性。\n\n \n\n## **主键id和进制代码实现**\n\n==代码实现的思路：==\n\n* **首先 生成一个唯一的数字，然后把这个唯一的数字转换为62进制。**\n\n   mongodb里面提供一个**全局计算器**，可以帮我们生成唯一的整数，理解成mysql里面的自增型的主键id。用户输入的一个长的url地址应该对应一个唯一的短的url地址。\n\n   实现：\n\n   <http://www.runoob.com/mongodb/mongodb-autoincrement-sequence.html>\n\n![img](wps8254.tmp.jpg) \n\n演示：\n\n1. 创建一个集合，集合里面存在两个字段\n\n```\n> use short\n\n> db.counter.findAndModify({query:{'_id': 1} , update:{'$inc': {'value': 1}}});\n\n{ \"_id\" : 1, \"value\" : 10 }\n```\n\n实现每调用一次，先获取对应的自增id 然后把对应的值自增一下。然后将自增的id转化为对应的短网址。\n\n \n\n2. 变短的62进制和域名的前缀进行拼接\n\n  定义码表 \n\n![1536910478920](1536910478920.png)\n\n转换函数\n\n![1536910497867](1536910497867.png)\n\n\n\n## **代码实现**\n\n### **前台效果**\n\n1. 创建一个 输入长网址转换为短网址的页面\n\n![img](wps829A.tmp.jpg) \n\n效果\n\n![1536911578689](1536911578689.png)\n\n \n\n2. 完成页面的ajax提交事件\n\n![1536913844373](1536913844373.png)\n\n3. 复制按钮\n\n   a) 复制静态资源到z.cn目录\n\n![1536913886975](1536913886975.png)\n\n​\tb) 在index.html页面修改短网址框的val值 和 点击复制按钮的ID，并引入插件包\n\n![1536913914046](1536913914046.png)\n\n引入插件并定义复制函数\n\n![1536913938083](1536913938083.png)\n\n \n\n在完成ajax请求后进行复制函数调用\n\n![1536913976415](1536913976415.png)\n\n\n\n### **后台处理**\n\n1. 在function.php定义好进制转换函数\n\n ![1536914096593](1536914096593.png)\n\n在后台op.php生成短网址和长网址的映射关系\n\n![1536914020696](1536914020696.png)\n\n\n\n2. 如果存在则直接返回\n\n![1536914034810](1536914034810.png)\n\n \n\n3. 不存在则生成\n\n![1536914056393](1536914056393.png)\n\n\n\n### 短网址访问\n\n1. 定义伪静态规则，开启Apache的rewrite模块\n\n![img](wps82F2.tmp.jpg) \n\n \n\n2. 开启虚拟主机的重写\n\n![img](wps8303.tmp.jpg) \n\n \n\n3. 在网站根目录创建.htaccess文件\n\n![img](wps8304.tmp.jpg) \n\n \n\n内容如下：\n\n![1536915532909](1536915532909.png)\n\n\n\n5. 在b.cn/s目录创建一个index.php完成跳转\n\n![1536915512675](1536915512675.png)\n\n \n\n\n\n ","categories":["NoSQL.Mongodb"]},{"title":"Redis案例_使用PHP实现消息队列","url":"%2Fposts%2F3783825305%2F","content":"\n\n# 案例-使用PHP实现消息队列\n\n## 简介\n\n思路：实际就是操作链表数据类型的队列\n\n \n\n使用php代码实现医院的模拟医生就诊叫号流程：\n\n1、挂号（把病人的信息加入消息队列）\n\n2、医生叫号（把病人的信息在消息队列中弹出，病人看完后医生停止就诊）\n\n\n\n## 实操\n\n1、编写挂号的代码如下\n\n![img](wps973A.tmp.jpg) \n\n​\t测试结果如下所示:\n\n![img](wps973B.tmp.jpg) \n\n \n\n2、医生叫号，病人排队进入诊室，就把队列中依次弹出\n\n![img](wps973C.tmp.jpg) \n\n \n\n​\t测试结果如下:\n\n![img](wps974D.tmp.jpg) \n\n​\t继续刷新页面，医生实际中是点击了一个按钮\n\n![img](wps974E.tmp.jpg) \n\n​\t如果医生看完了所有的病人，那么就应该显示当前当前停止就诊了\n\n![img](wps975E.tmp.jpg) ","categories":["NoSQL.Redis"]},{"title":"NoSql之Redis数据库","url":"%2Fposts%2F3355790013%2F","content":"\n\n# NoSql之Redis数据库\n\n 之前学习了memcache，一个缓存系统，在实际的使用中，Redis也是一个不错的nosql数据库（因为它的存储的value类型很多，并且功能也会memcache多很多）\n\n\n\n## Redis简介\n\n**Redis**是**Remote Dictionary Server**(远程数据服务)的缩写，它是NoSql中一款非常出色的产品，由意大利人 antirez(Salvatore Sanfilippo) 开发的一款`内存高速缓存数据库`同时支持`持久化`设置。该软件使用C语言编写，它的存储格式也是key-value然而它支持丰富的数据结构，具体一共有==5==种数据类型。\n\n1. **String**（字符串类型）\n\n2. **list**（链表）\n\n3. **hash**（哈希表类型 映射  map）\n\n4. **set**（无序的集合: 1. 无序性 2. 唯一性 3. 确定性）  \n\n5. **sorted set**(有序集合、orderset、缩写为zset)（1. 有序性，存在一个排序的法则（数字 0-9   字母表 a-z   I II III xI.... ） 2. 唯一性 3. 确定性）\n\n\n\n\n**==注意==**：上面我们说的value的数据类型，其实在底层都是一个字符串，只是这些字符串满足一种认为的特定格式，所有才有了这么多数据类型。\n\n\n\n而且redis通过简单的配置把数据从内存保存到硬盘当中进行持久保存。Redis为高并发而生，是NoSql中的佼佼者。后起的nosql都是为了解决互联网上的高并发的问题。\n\n \n\n## **常见的nosql产品**\n\n![img](wps93F3.tmp.jpg) \n\n网站：<http://www.nosql-database.org/>\n\n\n\n## 常见nosql的比较\n\n注意：key-value 底层的保存都是使用hash结构，特点就是时间复杂度为o(1)：随着数量的增加，在100w条里面查询一条记录和在1000w里面的时间数量级是一样的。\n\n![img](wps9403.tmp.jpg) \n\n\n\n## Redis和Memcache\n\n**memcache**不支持数据持久化，软件运行和安装都较小。Memcache是纯内存存储的数据库，单个key的value值只能保存1M的数据，默认最大的内存存储量是64M（`-m` 选项），Memcache具有分布式的算法功能（取模）。\n\n \n\n**redis** 支持==数据持久化==和==内存存储==两种方式，软件运行比memcache大一点，可以设置缓存时间，redis集群是一个主从模式的，主服务器可用来读写，从服务器只能用来读。redis没有内置的分布式算法功能。Redis单个key的value可以存储的最大空间为**1G**，而总存储容量可以视硬盘的大小而定。\n\n \n\n在PHP的官方当中Memcache具有Memcache类和Memcached类。而Redis(纯个人开发的产品)没有PHP官方的支持，**Redis的PHP扩展是其开发作者编写的**。\n\n\n\n# ==Redis的安装和使用==\n\n## Redis的安装操作系统和端口说明\n\nredis是一款开源产品，主要开发平台为linux，所以原生的代码在linux下运行是最好的。\n\nredis作者不愿意开发windows版本下的redis。微软技术小组，在redis源码的基础上，进行了开发windows版的redis，主要提供给ASP.NET使用，所以你也可以安装windows版本的redis程序。在本阶段当中，我们主要学习redis在Linux下的应用为主。\n\n \n\n**Redis**默认使用的是`6379`端口，对一些众所周知的服务的端口一般我们不建议修改。\n\n1. http 80\n2. https 443\n3. memcache 11211\n4. redis 6379\n5. mysql 3306\n6. smtp 25\n7. ipop3  110 (先发后收，从小到大)\n8. sshd  22\n9. ftpd  20、21\n10. mongodb xxx\n11. sphinx xxx\n\n\n\n6379端口由来：redis作者为了追求一个女星，专门写了一个redis之后把端口命名为她的名字merz(九格宫键盘)。\n\n<http://www.zhihu.com/question/20084750>\n\n![img](wps9404.tmp.jpg) \n\n![1536802433436](1536802433436.png) \n\n\n\n## **Windows下安装**\n\n1. 复制软件\n\n![img](wps9415.tmp.jpg) \n\n \n\n2. 在cmd里面启动服务（需要超级管理员的身份启动）\n\n![img](wps9416.tmp.jpg) \n\n \n\n3. redis目录结构\n\n![img](wps9426.tmp.jpg) \n\n \n\n4. 启动redis服务\n\n![img](wps9427.tmp.jpg) \n\n​\t如果要终止，则使用 `ctrl + c`即可。\n\n \n\n## **Linux下Redis安装**\n\n这个需要做源码的编译，下去可以百度一下 yum的安装，就是输入一条命令的事。\n\n \n\n1. 上传源代码\n\n![img](wps9438.tmp.jpg) \n\n \n\n2. 解压redis的源码包\n\n![img](wps9439.tmp.jpg) \n\n \n\n3. 进入解压后的目录，然后进行`make`（redis安装不需要configure的过程）\n\n![img](wps943A.tmp.jpg) \n\n \n\n4. 指定安装路径，进行安装` make   PREFIX=/usr/local/redis    install` （PREFIX必须大写）\n\n![img](wps944B.tmp.jpg) \n\n \n\n6. 建立redis的配置文件目录和配置文件的副本\n\n![img](wps944C.tmp.jpg) \n\n \n\n7. 成功安装后的目录结构\n\n![img](wps945C.tmp.jpg) \n\n \n\n## linux下redis服务的启动\n\n \n\n1. 修改Redis的配置文件，将daemon改为yes\n\n![img](wps945D.tmp.jpg) \n\n![img](wps946E.tmp.jpg) \n\n \n\n2. 启动服务（跟随配置文件）\n\n![img](wps946F.tmp.jpg) \n\n \n\n3. 使用客户端操作\n\n![img](wps9470.tmp.jpg) \n\n​\t注意：如果要终止则按`ctrl+c`\n\n \n\n4. 关闭，在命令行输入` shutdown`\n\n![img](wps9481.tmp.jpg) \n\n5. 如果停止不了，则采取杀死进程的方式\n\n![img](wps9482.tmp.jpg) \n\n \n\n\n\n# ==Redis的数据类型==（重要）\n\n需要注意：Redis是一个c/s的架构，在使用之前，必须确保服务器端是开启的，同时Redis也是一个key-value型的nosql的数据库。并且其value值的类型有如下的几种：\n\n![img](wps9492.tmp.jpg) \n\n \n\n## string类型\n\n1. **set**  设置值\n\n   语法：`set   key  value`\n\n![img](wps9493.tmp.jpg) \n\n \n\n2. **get** 获取值\n\n![img](wps94A4.tmp.jpg) \n\n \n\n3. **incr** 自增，默认自增1 $i++，注意：value的值必须是整数，还有如果key不存在则从0开始\n\n![img](wps94A5.tmp.jpg) \n\n![img](wps94B5.tmp.jpg) \n\n![img](wps94B6.tmp.jpg) \n\n \n\n4. **decr** 自减 默认是-1 $i--，值的类型必须是整数；如果key不存在默认是0\n\n![img](wps94C7.tmp.jpg) \n\n​\t注意：可以使用tab键进行命令的补齐，也可以使用上下键来执行之前的命令。\n\n \n\n5. **incrby** 指定自增的数字（步长）\n\n![img](wps94C8.tmp.jpg) \n\n \n\n6. **decrby** 指定自减的数字\n\n![img](wps94D9.tmp.jpg) \n\n \n\n一般来说是有key-value数据库最重要的就是key的设计。\n\n\n\n==**如何设计redis下的key？**==\n\n例如在mysql里面设计一张user表：\n\n| id   | name  | password | email          | sex  |\n| ---- | ----- | -------- | -------------- | ---- |\n| 1    | asion | admin88  | gogery@163.com | m    |\n| 4    | ruby  | admin    | ruby@sina.com  | f    |\n\n注意：memcache的可以直接md5编码一下即可。 md5(key) ==> value\n\n\n\n如果要把上面的user表转换成redis里面的key-value来保存，该如何设计key？\n\n答：分如下几部\n\n1.  把mysql里面的==表名称==换成redis里面key的前缀   **user:**\n\n2. ​ 把mysql里面的表的==主键字段名称==换成后缀的第二个字符 **user： :id:**\n\n3.  把对应记录的主键id==记录==换成key的第三个部分 **user：:id:: 1:**\n\n4.  把mysql里面==其他所需的字段名==换成key的第四个部分 **user：:id::1:name** \n\n\n**保存邮箱的key：user：:id::1:email**\n\n \n\n对应上面mysql表里面的数据，该这样保持在redis里面：\n\n![img](wps94DA.tmp.jpg) \n\n取出数据：\n\n![img](wps94EA.tmp.jpg) \n\n取id为1的用户名\n\n![img](wps94EB.tmp.jpg) \n\n\n\n## hash类型\n\n**redis里面value的hash类型完全和php里面的关联数组一样**。 和js里面的对象也是一样。\n\n```\n//php\n$arrray = ['name'=>'caoyang', 'age'=>12]; \n\n//js \nvar json = {'name':'caoyang', 'age':12}\n```\n\n \n\n1. **hset** 设置hash的单个值\n\n![img](wps94EC.tmp.jpg) \n\n2. **hget** 获取某个值\n\n![img](wps94FD.tmp.jpg) \n\n3. **hmset** 设置hash的多个值\n\n![img](wps94FE.tmp.jpg) \n\n4. **hgetall**  获取整个key的hash值\n\n![img](wps950F.tmp.jpg) \n\n\n\n## **link链表类型**（队列栈）\n\n![img](wps9510.tmp.jpg) \n\n链表 可以从头部或者是尾部都可以存放数据\n\n \n\n1. **lpush** 向链表的头部【左侧】压入数据    **L 的小写**\n\n![img](wps9520.tmp.jpg) \n\n2. **rpush** 向链表的尾部【右侧】压入数据\n\n![img](wps9521.tmp.jpg) \n\n \n\n实际使用：后台统计一下最近登录的10个用户\n\n` select * from user order by logintime desc limit 10;`\n\n换成redis的链表来实现的话，只需要设置一个链表，然后往链表的左侧压入10个username即可；如果10个满了，在链表右侧弹出一个值即可。\n\n![img](wps9532.tmp.jpg) \n\n \n\n3. **lrange** 获取链表里面所有的元素\n\n![img](wps9533.tmp.jpg) \n\n4. **lpop** 删除链表里面头部的第一个元素，并返回该元素\n\n![img](wps9534.tmp.jpg) \n\n5. **rpop**删除链表里面尾部的最后一个元素，并返回该元素\n\n![img](wps9544.tmp.jpg) \n\n \n\n## **set类型**\n\n集合分为两类：\n\n* 无序集合\n\n* 有序集合\n\n\n\n\n一般来说我们口头上说的集合基本都是指的是**无序**即可。\n\n \n\n集合：\n\n 无序性， 元素的位置没有讲究\n\n 唯一性， 里面的元素不能重复\n\n 确定性， 元素的个数是确定的\n\n \n\n交集：A∩B   === B∩A\n\n并集：A∪B  === B∪A\n\n差集：A-B  !===  B - A\n\n差集定义：A-B 元素在A存在但是在B里面不存在。B-A元素在B里面存在，但是不在A存在\n\n![img](wps9545.tmp.jpg) \n\n \n\n1. **sadd** 向集合里面添加元素，并查看\n\n![img](wps9556.tmp.jpg) \n\n​\t案例 ：来完成集合的交集、并集、差集\n\n![img](wps9557.tmp.jpg) \n\n​\t使用的场合，如豆瓣里面的==书签系统==。\n\n![img](wps9568.tmp.jpg) \n\n \n\n集合实际使用的场合主要是==好友推荐，共同好友==。可能认识的人。\n\n \n\n## orderset类型\n\norderset是set的一个升级版本【也叫作sortset】，意大利文叫zset，在set的基础上增加了一个顺序属性（权值1 2 3），这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。有序列表值完成的是集合元素排序的功能。\n\n \n\n有序集合里面的元素是有序的，并且也是唯一的，也是确定的。\n\n![img](wps95C1.tmp.jpg) \n\n1. **zadd** 添加有序集合\n\n![img](wps95C2.tmp.jpg) \n\n \n\n2. **zrange** 获取有序集合里面的元素\n\n![img](wps95C3.tmp.jpg) \n\n \n\n3. `zrange  key 0 -1 WITHSCORES`  获取权值\n\n![img](wps95D3.tmp.jpg) \n\n \n\n实际应用场景：==最近最活跃的的前10个用户==。\n\n最活跃：在有序集合里面权重最大。\n\n如果现在这个场景使用mysql实现\n\n| id   | name  | passwd  | lgtime  | lgnumber |\n| ---- | ----- | ------- | ------- | -------- |\n| 1    | asion | admin88 | 1234223 | 1        |\n| 4    | bill  | admin88 | 53214   | 8        |\n\n \n\n主要用户每登录一次，这个lgnumber 字段的次数就要+1；到时候可以统计登录次数最多的10个用户\n\n` select * from user order by lgnumber desc limit 10;`\n\n\n\n# ==php操作Redis==（重要）\n\n通过上面的基本命令可以操作Redis后，一般来说我们都是编程语言进行操作，所以我们需要开启PHP操作Redis的扩展。\n\n![img](wps95D4.tmp.jpg) \n\n http://www.runoob.com/redis/redis-tutorial.html\n\n\n\n## **Windows下实现**\n\n1. window下php操作redis扩展，前往该网站，搜索自己需要的PHP扩展\n\n   下载地址：https://pecl.php.net/package/redis/2.2.7/windows\n\n![img](wps95E5.tmp.jpg) \n\n \n\n2. 选择合适的版本【注意：这里需要根据phpinfo函数的信息进行选择】\n\n![img](wps95E6.tmp.jpg) \n\n \n\n3. 点击上面的 【dll】链接后，选择合适的版本\n\n![img](wps95F7.tmp.jpg) \n\n \n\n4. phpinfo函数的信息\n\n![img](wps95F8.tmp.jpg) \n\n![img](wps95F9.tmp.jpg) \n\n​\t   到pecl网站下载合适的版本\n\n![img](wps9609.tmp.jpg) \n\n \n\n5. 复制合适的扩展文件到php的ext目录\n\n![img](wps960A.tmp.jpg) \n\n \n\n6. 修改php.ini文件，如果不存在则增加，存在则去除前面的分号\n\n![img](wps961B.tmp.jpg) \n\n\n\n7. 重启集成开发环境\n\n![img](wps961C.tmp.jpg) \n\n \n\n8. 浏览器访问\n\n![img](wps962D.tmp.jpg) \n\n\n\n## Windows下简单操作\n\n1. 在网站根目录编写如下代码\n\n![img](wps962E.tmp.jpg) \n\n \n\n2. 浏览器访问即可\n\n![img](wps962F.tmp.jpg) \n\n3. php操作redis手册\n\n![img](wps963F.tmp.jpg) \n\n\n\n## **linux-开启PHP操作Redis的扩展** \n\n==**装扩展的的步骤**==\n\n1. 下载对应的扩展源码（https://pecl.php.net/package/redis/2.2.7/windows）\n\n2. 上传到 `/usr/local/src`\n\n3. 解压` tar -zxvf `扩展包 `.tar.gz`\n\n4. `cd `到解压目录\n\n5. 执行一个 `/usr/local/php/bin/phpize` 执行这个生成一个 configure 文件（收集操作系统信息）\n\n6. `./configure --with-php-config=/usr/local/php/bin/php-config `  ，收集操作系统信息，\n\n7. 使用  `make && make install`  生成一个  扩展`.so `文件\n\n8. 修改php.ini，加上  extension=  上一步 扩展.so  文件\n\n9. 重启 php-fpm \n\n10. 使用 phpinfo() 函数查看\n\n    \n\n  ​    \n\n1. 上传源码包，并复制到`/usr/local/src`目录\n\n![img](wps9640.tmp.jpg) \n\n \n\n2. 解压，并进入解压后的目录，并使用/usr/local/php/bin/phpize 生成文件\n\n![img](wps9651.tmp.jpg) \n\n \n\n3. 使用`./configure --with-php-config=/usr/local/php/bin/php-config`来收集操作系统信息\n\n![img](wps9652.tmp.jpg) \n\n \n\n4. 编译和安装\n\n![img](wps9662.tmp.jpg) \n\n​\t注意使用的编译和安装后会生产一个目录，目录下有一个NAME.so文件\n\n![img](wps9663.tmp.jpg) \n\n \n\n5. 修改php.ini文件\n\n![img](wps9664.tmp.jpg) \n\n​\t增加如下内容\n\n![img](wps9675.tmp.jpg) \n\n6. 重启Apache，并添加一个index.php测试文件\n\n![img](wps9676.tmp.jpg) \n\n \n\n7. 浏览器访问这个测试文件\n\n![img](wps9687.tmp.jpg) \n\n \n\n8. 在网站根目录编写如下代码\n\n![img](wps9688.tmp.jpg) \n\n \n\n8. 浏览器访问\n\n![img](wps9698.tmp.jpg) \n\n\n\n\n\n# redis的一些小命令\n\n1.` keys * `看所有的key【*  通配符，表示任意的字符】\n\n![img](wps9699.tmp.jpg) \n\n \n\n2. `del 删除key`（成功返回1 不成功返回0）\n\n![img](wps969A.tmp.jpg) \n\n \n\n3.` exists `检测key是否存在（存在返回1 不存在返回0）\n\n![img](wps96AB.tmp.jpg) \n\n \n\n4. `type` 查看value的类型\n\n![img](wps96AC.tmp.jpg) \n\n \n\n5. `flushdb `清空当前数据库所有的key，只在测试的时候使用，==线上千万不要使用==。\n\n![img](wps96BD.tmp.jpg) \n\n\n\n**注意：**\n\nRedis下是存在数据库的概念，默认是存在**16**个数据库，每个数据库下我们可以保存属于自己的key-value的值。flushdb只是清空当前数据库的key。如果要清空所有的使用`flushall`。\n\n\n\nRedis里面的 数据库可以认为是 key的一个集合。\n\n \n\n6. `select Number`   切换数据库。redis默认是有16个数据库（下标从0开始），但是这个不怎么使用。\n\n![img](wps96BE.tmp.jpg) \n\n \n\n7. `flushall `清除所有数据库的key，千万==慎用==\n\n![img](wps96BF.tmp.jpg) \n\n \n\n8. `dbsize` 查看当前数据库的key的个数\n\n![img](wps96CF.tmp.jpg) \n\n \n\n\n\n# redis安全认证\n\n在默认的情况下redis不需要任何密码就可以登录，为了设置客户端连接后进行任何其他操作前需要使用的密码，我们使用Redis的安全认证，然而这个安全认证的密码是明文的。\n\n注意：memcache是没有权限机制，Redis是存在密码操作。后面的mongodb里面定义类似一套rbac（基于角色的权限管理）的机制。\n\n \n\n1. 开启\n\n![img](wps96D0.tmp.jpg) \n\n![img](wps96E1.tmp.jpg) \n\n​\t重启redis的服务即可\n\n![img](wps96E2.tmp.jpg) \n\n \n\n2. 登录测试\n\n![img](wps96F2.tmp.jpg) \n\n​\t解决：\n\n![img](wps96F3.tmp.jpg) \n\n​\t还一种方案在登录的时候加参数` -a admin88`\n\n![img](wps96F4.tmp.jpg) \n\n \n\n# ==redis的持久化==（重要）\n\n## 简介\n\n注意：我们在使用Redis的时候，Redis里面的存储的数据是保存在内存里面，但是Redis提供了持久化的机制，可以将内存里面的数据持久保存在硬盘。\n\n我们在使用数据的时候，其实是操作的内存，但是通过一定方式将内存的数据保存在磁盘。如果要实现持久化，则**有两种方式可以实现：**\n\n1. 基于==快照==的方式，将内存的数据直接一次性的快照到磁盘上面，相对对系统的开销很大。\n2. 基于==文件追加==的方式，定期把内存里面的数据追加到一个文本文件里面。\n\n\n\n在redis当中，redis开发设计两种持久化的模式，如下：\n\n \n\nRedis的快照模式，默认安装完成就会自动开启的持久化模式，可以通过查看redis命令的目录下的的快照文件dump.rdb。\n\n`vim /etc/redis/redis.conf`\n\n![img](wps9705.tmp.jpg) \n\n \n\ndump.rdb文件就是redis的快照文件，它保存了redis所有的数据信息和记录，如果当网站数据量变大，该文件也会随之增大，操作效率很低。因此我们有必要去把该模式改为 `aof 持久化模式`【append of file文件追加模式】。\n\n \n\nRedis中的Aof模式：Redis的aof文件有点类似mysql的**binlog**日志【读写分离的时候】，该文件把用户的操作记录包括查询的过程全部记录，当服务器出现问题的时候，那么redis会将数据从内存中保存到aof文件当中，当服务器重新运行时那么aof就会根据操作的记录把数据重新还原到Redis的内存当中过去，以却保数据的完整性。我们作为应用者，只需要了解aof的持久化模式是记录用户的操作而非实时数据记录就可以了，然后我们需要知道如何开启aof持久化模式。\n\n \n\n==快照模式和aof模式是完全互斥的。==\n\n \n\n如果aof的模式一旦启动，那么快照就会失效，redis就会把所有的数据缓存到内存当中，如果你发生重启，停止，关闭服务器等行为，那么aof文件就会把内存中数据同步到硬盘中。\n\n## 快照模式\n\n1. 开启\n\n![img](wps9706.tmp.jpg) \n\n`save 900 1 `表示的含义：如果在900s或者900s以上有1次对key的操作则把内存数据持久化到磁盘上\n\n`save  300 10` 表示的含义：如果在300s或者300s以上有10次对key的操作则把内存数据持久化到磁盘上\n\n`save 60 10000 `表示的含义：如果在60s或者60s以上有10000次对key的操作则把内存数据持久化到磁盘上\n\n \n\n如果忘记了，则查看即可\n\n![img](wps9717.tmp.jpg) \n\n2. 测试 \n\n   可以使用  `bgsave background save`快速的把内存数据持久化到磁盘上。\n\n![img](wps9718.tmp.jpg) \n\n \n\n## aof 模式\n\naof【append fo file】，和快照是互斥。\n\n \n\n1. 修改 `/etc/redis/redis.conf`配置文件\n\n![img](wps9728.tmp.jpg) \n\n \n\n2. 设置持久化数据的频率\n\n![img](wps9729.tmp.jpg) \n\n \n\n**appendfsync always** 的选项表示redis的命令每一次只要运行那么就会马上写入aof操作文件当中，该选项是最没有效率的，然后它却是最具备操作记录完整性的。\n\n**appendfsync everysec **的选项是redis比较==折中==的选项，表示每一秒中只要有操作那么就会进行操作记录，但是如果在某一秒当中redis发生故障，那么这一秒的数据操作记录将有可能发生丢失的情况，存在一定的风险，然而这个配置的性能比较适合中，所以建议使用，因为redis一秒中内可以写81000次/s所以虽然存在一定的风险，但只要不要把一些非常重要的敏感数据至于redis当中，那么就不需要过分担心这个问题。\n\n**appendfsync no** 该配置的效率完全依赖您当前所在使用的操作系统和计算机的性能，即，系统空闲时才写入。如果操作系统稳定，计算机的性能强大，那么这一项是最有效率的，反而就是最差，所以一般最好不要设置该项。\n\n \n\n","categories":["NoSQL.Redis"]},{"title":"SVN","url":"%2Fposts%2F3963543486%2F","content":"\n\n\n# 一、SVN概述\n\n## 1、传统团队合作开发项目的流程\n\n传统的团队合作开发项目流程如下：\n\n![](image1.png)\n\n**问题：上面团队开发的流程会产生哪些痛点？**\n\n1.  **代码冲突问题。**因为多个组员可能修改同一个文件，造成同一个文件相同行代码进行整合的时候会产生冲突。\n\n2.  **代码找回(丢失)问题。**某个组员误删了文件或误删了某段代码，找不回来了。\n\n采用svn版本控制工具就可以很好的解决上面问题。\n\n团队采用svn方式开发项目的流程图解：\n\n![](image2.png)\n\n## 2、SVN介绍\n\n**SVN**全名Subversion，即**版本控制系统**（主要可以追溯以前的代码版本）,Subversion是一个通用的系统,可用来管理任何类型的文件,其中主要文件是程序源码,它将数据放置在一个中央仓库(repository)中,这个仓库很像一个普通的文件服务器,不过它会记住文件的每一次变动,这样就可以找回之前的所写的任何的一个代码版本。\n\n**相关的版本控制软件：**\n\n-   **CSV**：全称-Concurrent Versions System,与后面提到的SVN是同一个厂家，不过是svn的前身,现已被svn替代。\n\n-   **VSS**：全称-Visual Source Safe,此工具是Microsoft提供的，是使用的相当普遍的工具之一，做net开发使用较多。\n\n-   **SVN**：全称-Subversion现在国内企业使用的主流的版本控制系统。\n\n-   **git**（分支）：也可以对代码进行版本控制，它开始主要是用于管理linux内核的,由李纳斯发明，企业使用量和svn相当。\n\n国外代码托管（同性交友网站）网站：[https://github.com/](https://github.com/)\n\n国内代码托管网站（码云）：[https://gitee.com/](https://gitee.com/)\n\ncoding(码市): [https://coding.net/](https://coding.net/)\n\n----\n\n\n\n# 二、==svn软件的安装==\n\n==svn是c（client）/s(server)软件的架构，有服务端和客户端。==\n\n服务端下载地址: [[https://www.visualsvn.com/visualsvn/download/]](https://www.visualsvn.com/visualsvn/download/)\n\n客户端下载地址： [[https://tortoisesvn.net/downloads.html]](https://tortoisesvn.net/downloads.html)\n\n软件在课件中：\n\n![](image3.png)\n\n## 1、安装服务端\n\n![](image4.png)\n\n提示：如果VisualSVN安装不上可以安装Subversion版本的。\n\n安装VisualSVN服务端步骤：\n\n1、双击安装程序，点击next下一步\n\n![](image5.png)\n\n2.  接受软件的相关协议，点击next。\n\n![](image6.png)\n\n3、选择勾选最后一项，配置svn服务端的相关的命令到系统的环境变量，点击next下一步\n\n![](image7.png)\n\n4.  选择标准版Standard Edition。\n\n![](image8.png)\n\n5.  选择一个安装目录，这里以安装到D:\\\\svn\\\\server为例\n\n![](image9.png)\n\n6、点击finish完成\n\n![](image10.png)\n\n7、查看安装的svn服务端环境变量是否生效，直接在cmd窗口中出输入svn命令，若出现以下提示说明已生效。\n\n![](image11.png)\n\n\n\n如果安装的时候勾选了环境变量，但是依然没有出现以上提示，有以下两种解决办法：\n\n①重启电脑\n\n②(推荐)点击环境变量path选项，直接点击确定即可，不需要修改，这样可以立即生效\n\n![](image12.png)\n\n再次关闭黑窗口重新打开，输入svn命令进行测试即可。\n\n![](image13.png)\n\n## 2、安装客户端\n\n安装客户端的时候，先检查自己电脑系统的位数，选择对应系统位数安装即可。\n\n查看系统位数：计算机\\--\\>右键属性\n\n![](image14.png)\n\n**安装TortoiseSVN步骤：**\n\n1、双击安装程序，点击next下一步\n\n![](image15.png)\n\n2、接受软件的相关协议，点击next。\n\n![](image16.png)\n\n3、选择选项command line client tools-Will be installed on local hard driver\n\n![](image17.png)\n\n4、点击第一个选项TortoiseSVN，配置安装的目录，目录可自定义，这里以安装到D:\\\\svn\\\\client\\\\中为例，点击next。\n\n![](image18.png)\n\n注：路径尽量不要包含特殊字符和中文。\n\n5、安装完成，点击finish.。\n\n![](image19.png)\n\n6、测试是否安装成功，在桌面鼠标右键，多出以下两个选项说明安装成功：\n\n![](image20.png)\n\n7、如需要汉化可安装系统对应位数的汉化包即可：\n\n![](image21.png)\n\n安装一路next即可，会自动找到上面svn客户端的安装位置：\n\n切换中文步骤：TortoiseSVN\\--\\>Settings\\--\\>General\\--\\>Language\n\n![](image22.png)\n\n![](image23.png)\n\n变成中文效果：\n\n![](image24.png)\n\n---\n\n\n\n# 三、==部署单仓库==\n\n==注意:在svn服务器中，我们把存放代码的地方称之为 \"仓库\"。==\n\n## 1、部署单仓库的步骤\n\n在svn中创建仓库的步骤总共有三步：\n\n**步骤1**：建立项目目录 。如：`D:/app/blog`\n\n![](image25.png)\n\n**步骤2**：把项目目录变为仓库。 命令为：` svnadmin create D:/app/blog`（项目目录绝对路径）\n\n![](image26.png)\n\n**步骤3**：开启监管仓库目录的服务。命令为：`svnserve -d -r D:/app/blog`\n\n> 选项说明\n>\n> -d：作为后台服务运行。\n>\n> -r：监管的目录。\n\n![](image27.png)\n\n**注**：上面黑窗口正在监管仓库服务，不要关闭，否则导致后面连接不上。\n\n## 2、svn中的三大指令的使用\n\n-   **checkout** ：检出指令，用于首次与svn服务器建立连接，获取代码到本地目录（第二次以后直接使用update更新指令获取代码。）\n\n-   **commit**：提交本地代码到svn服务器\n\n-   **update**：把svn服务器上面的最新代码更新下来\n\n三大指令使用图解：\n\n![](image28.png)\n\n\n\n**注意：**\n\n以后去公司上班，公司基本早就已经部署好svn服务端了，我们开发者只需要在自己的电脑中安装svn客户端即可，公司的相关人员会告诉我们svn仓库地址，且会给我们分配一个账号和密码进行连接svn服务器，然后checkout检出代码在本地进行开发。写完代码后使用commit进行提交。第二天使用update更新指令下载最新代码进行开发。\n\n## 3、连接svn服务器\n\n**步骤1**：如在我们桌面中，建立一个项目检出目录myblog，用于存放检出的代码：\n\n![](image29.png)\n\n==**检出和版本库浏览器的区别：**==\n\n**检出(checkout)**：是把仓库所有的代码都检出到本地目录。\n\n**版本库浏览器**：它可以浏览仓库中有哪些文件，有选择性的检出指定文件。\n\n**步骤2**：输入我们svn服务器的地址，指定一个检出代码的本地目录\n\n![](image30.png)\n\n检出成功之后，会在本地检出目录多出一个`.svn`的隐藏文件夹，==重要此文件夹下存储着和服务端仓库直接的关联信息，更改信息等，不能随意改动。==同时版本为0， 说明是一个新建立的仓库，之间没有任何的commit提交。\n\n![](image31.png)\n\n## 4、上传代码到svn仓库中\n\n**步骤1**：在检出的目录中，建立一些测试文件或目录，鼠标右键选择**commit**提交指令\n\n![](image32.png)\n\n**步骤2**：【重要】填写提交的备注，主要是用于后面代码的版本回退（代码找回）\n\n![](image33.png)\n\n提交确定之后，提示无权限提交，\n\n![](image34.png)\n\n因为默认新创建的仓库，只能更新或检出，但是不能commit提交,后面需要修改此仓库的配置文件，进行权限配置。\n\n## 5、单仓库的权限配置(添加用户名和密码)\n\n==权限可以细分两种：==\n\n1.  **匿名用户提交**（不需要用户名和密码也可以提交，但是不安全，个人测试使用较多）\n\n2.  【重点】**允许授权用户提交**（需要用户名和密码，安全一点，企业中使用都是需要密码账号的）\n\n\n\n每个仓库的conf目录中，都会有以下三个配置文件：\n\n![](image35.png)\n\n`svnserve.conf` ：当前仓库的核心配置文件，可以开启某些文件的功能\n\n`passwd`：给当前仓库的增加用户名和密码\n\n`authz`：给当前仓库的用户设置一些权限1\n\n> 权限\n> w：write可更新可提交\n>\n> r：read 可更新不可提交\n>\n\n**提示**：后面学的linux中还有一种权限为x,代表可执行。\n\n\n\n### 5.1、匿名用户提交\n\n设置匿名用户访问，仅需修改`svnserve.conf`配置文件即可，把其中`anno-access = read`前面\n\n的\\#号给去掉，且把read改为write，如下：\n\n![](image36.png)\n\n==注：最前面要顶格写，即不要留空格。只要保存配置文件会立刻生效，不需要重新监管仓库服务。==\n\n再次进行commit提交测试：成功了，提示版本1，说明此仓库成功提交过1次。\n\n![](image37.png)\n\n尝试对检出目录的index.php文件进行如下修改测试：\n\n![](image38.png)\n\n再次进行提交；\n\n![](image39.png)\n\n\n\n### 5.2、授权用户的权限配置【重点】\n\n即，需要用户名和密码才可以进行代码的操作\n\n修改仓库**conf**目录中的三个配置文件：`svnserve.conf`、`passwd`、`authz`\n\n\n\n**步骤1**：修改svnserve.conf配置文件，开启passwd和authz文件的功能\n\n![](image40.png)\n\n配置解释：\n\n19行：设置为none，代表匿名用户无访问权限。\n\n20行：设置为write，允许授权用户可更新也可提交。\n\n27行：代表开启passwd配置文件。\n\n36行：代表开启authz配置文件。\n\n\n\n**步骤2**，修改passwd文件，给当前仓库增加一些用户名和密码\n\n![](image41.png)\n\n**格式**： `用户名 = 密码`（密码明文）\n\n**提醒**：==以后在Linux中修改含有敏感的词汇，如密码，需要给这类文件设置严格的访问权限。这样更加安全。==\n\n\n\n**步骤3**：修改authz文件，给当前仓库的用户名分配一些权限（rw）\n\n![](image42.png)\n\n设置组：\n\n```\nphp_group = dashen\ncainiao_group = cainiao\n```\n\n\n\n==注：权限有**r**但未有**w**，表示只能更新代码到本地但不能提交。且目录后面不可以加斜杠/。==\n\n**控制权限形式：**\n\n`[/目录/子目录/子子孙孙目录/....]`\n\n`[/] `对此单仓库的所有文件进行权限控制\n\n`[/core]` 对此单仓库的core目录下面的文件进行权限控制，可覆盖根目录配置。\n\n再次进行commit提交，若出现一个输入密码的弹窗，说明配置授权用户访问成功：\n\n![](image43.png)\n\n注意：如果没有**w**权限，提交的时候会提示`Access Denies`权限拒绝。\n\n----\n\n\n\n# 四、svn常见文件状态图标说明\n\n## 1、图标异常的解决办法【了解】\n\n-   win7解决办法：\n\n底部启动任务管理器\\--\\>进程\\--\\>找到进程名explorer.exe\\--\\>鼠标右键结束，然后再找到文件选项新建刚才结束的进程explorer.exe,如下图所示：\n\n![](image44.png)\n\n-   win8，win10解决办法：\n\n修改如下注册表：按住win+r,输入regedit\n\n![](image45.png)\n\n需要修改注册表中的某些选项，参考下面的图片：\n\n![](image46.png)\n\n找到对应的注册表的值（Tortoise打头的），在前面加多空格，空格越多优先级越高：\n\n![](image47.png)\n\n最后在底部任务栏管理器选中window资源管理器\\--\\>鼠标右键重新启动即可,再去看检出目录就可以看到图标了。\n\n这个svn图标不是特别重要，没有出现也没有关系，只是为了可以看到文件的状态，因为提交代码的时候，在文件变更列表中也是可以看看。\n\n## 2、常见图标的认识\n\n-   **常规(同步)**图标：\n\n![](image48.png)\n\n出现此图标，说明此文件中的内容与svn服务器中对应文件内容一样。\n\n\n\n-   **修改**图标：\n\n![](image49.png)\n\n当我们对本地的某个文件进行修改，导致与svn服务器上面的对应的文件的内容不一致就会出现此图标。\n\n\n\n-   **无版本控制**图标\n\n![](image50.png)\n\n说明此文件没有与svn服务器建立关联，说明没有被仓库管理过\n\n\n\n-   **忽略**图标\n\n![](image51.png)\n\n当我们有些文件不想提交到svn服务器或者没有必要提交，我们可以把这些文件设置为忽略即可，那么提交的时候这些文件就不会出现在提交的文件变更列表中。\n\n**忽略一般有两种：**\n\n忽略一个具体的文件：1.jpg\n\n忽略某一类的文件：\\*.jpg\n\n具体操作：选中要忽略的文件鼠标右键\\--\\>TortoiseSVN\\--\\>增加到忽略列表。如下：\n\n![](image52.png)\n\n其中带**recursively**是递归的意思，多用于忽略目录中及其子目录中的所有的文件。\n\n-   **冲突**的图标\n\n![](image53.png)\n\n尤其是团队开发的时候，多个开发人员对同一个文件的相同行代码都进行了修改，那么后者提交的会覆盖前者提交的，但是svn不会进行覆盖，会提示我们解决冲突，把具有冲突的文件更新下来就是上面的黄色图标。\n\n----\n\n\n\n# 五、svn代码冲突的解决【重点】\n\n**说明**：尤其是团队开发的时候，多个开发人员对同一个文件的相同行代码都进行了修改，那么后者提交的会覆盖前者提交的，但是svn不会覆盖，会提示我们解决冲突。\n\n下面就来演示造成冲突的场景以及怎么解决\n\n## 1、造成冲突的场景\n\n这里以dashen用户和cainiao用户对blog仓库的index.php的文件进行操作。\n\n首先，他们两者都要把代码给更新下来，此时，两者的代码应该是完全一致的：\n\n![](image54.png)\n\n先是cainiao用户对index.php文件进行修改：修改6-10行,并成功commit提交。\n\n![](image55.png)\n\n成功提交之后，即svn仓库中index.php的文件的最新内容是cainiao用户提交的。\n\n随后dashen用户同样也对index.php文件进行修改6-9行。\n\n![](image56.png)\n\n现在dashen用户commit提交代码出现如下的冲突提示：\n\n![](image57.png)\n\n出现上面的提示，说明提交的文件的内容与svn仓库中的index.php文件内容有冲突部分。\n\n**产生冲突的原因：**\n\ncainiao用户：修改6-10行\n\ndashen用户：修改6-9行\n\n其中6-9都被两者修改过，导致仓库无法知道使用哪部分代码，所以后者提交失败，报冲突。\n\n## 2、解决冲突\n\n**步骤1**：鼠标选中有冲突的文件，鼠标右键选择更新，\n\n![](image58.png)\n\n![](image59.png)\n\n可见，更新下来会多出三个**辅助文件**：\n\n**文件名(黄色标识)** ：把服务器上面最新文件内容与即将提交的冲突内容进行一个融合。\n\n**文件名.mine**  ： 当前用户即将要提交的文件内容。\n\n**文件名.r(前一版本)**：所有用户提交之前，即文件冲突之前，仓库上最新的文件内容。\n\n**文件名.r(后一版本)**：仓库上最新的文件内容。\n\n\n\n==解决办法：==\n\n把三个辅助文件都给删除，修改含有黄色感叹号的文件，进行代码整合修改，再次进行提交即可。\n\n\n\n**注：整合冲突代码的时候，千万不要覆盖人家代码，合并之前需要程序员之间彼此商量一下。**\n\n----\n\n\n\n# 六、==svn中的版本回退==【重点】\n\n使用到版本回退的场景：\n\n-   一般由于不小心误删文件或某段代码，并且提交了，这时候就可以通过svn提供的更新至版本来找回。\n\n**步骤1**：选中要回退的文件，`更新至版本`\n\n![](image60.png)\n\n在通过之前提交的日志来找回：\n\n![](image61.png)\n\n找到之前提交的日志信息，点击确定，即可回到之前的代码版本。\n\n![](image62.png)\n\n注：\n\n1、检出目录，鼠标右键点击更新是更新最新的版本，如果需要回退到指定的版本，需要通过更新至版本来实现。\n\n2、如要要查看某个文件的版本，右键选中此文件更新至版本即可，可以查看当前文件所有的版本变化。\n\n3、若点击空白处，可以查看当前项目所有代码的版本\n\n\n\n以后上班，下班之前先commit提交代码。早上上班，开启电脑，先update更新最新代码版本，需要在最新的代码基础上进行开发。\n\n----\n\n\n\n# 七、==部署多仓库==\n\n因为一个公司会有多个项目同时进行，比如有java项目，android项目、php项目。其实也就对应着多个仓库，那么不同的开发人员其对应的svn仓库的连接地址也不同。\n\n\n\n**==实现步骤：==**\n\n**步骤1**：如在app目录中建立多个项目文件夹（android、java）\n\n![](image63.png)\n\n**步骤2**：把上面的android和java目录变为项目仓库。\n\n![](image64.png)\n\n注：blog已经是仓库了，不要重复创建。\n\n**步骤3**：监管所有仓库的==父目录==（`D:/app`）,这样才可以访问到其中的某个仓库项目代码\n\n![](image65.png)\n\n\n\n\n\n**==怎么访问多仓库中的某个项目仓库代码？==**\n\n**答**：访问形式：` svn://ip/仓库名/目录/子孙目录/....`\n\n如访问blog仓库，地址为：`svn://127.0.0.1/blog/`\n\n如访问java仓库，地址为： `svn://127.0.0.1/java/`\n\n如访问android仓库，地址为： `svn://127.0.0.1/android/`\n\n如访问其中blog仓库项目：\n\n![](image66.png)\n\n\n\n**==怎么访问单仓库中的某个仓库代码？==**\n\n答：访问形式： `svn://ip/目录`\n\n注： svn://127.0.0.1 这种url访问形式只能对单仓库有效，多仓库的访问后面需加仓库名。\n\n----\n\n\n\n\n# 八、==多仓库的权限设置==\n\n由于这里有三个仓库，这里以其中一个仓库`blog`为例，进行权限设置。\n\n还是修改三个文件：**svnserve.conf** 、**passwd**、**authz**\n\nsvnserve.conf配置和passwd配置和之前单仓库配置一样，不用变。\n\n仅需要改变authz配置文件即可：\n\n![](image67.png)\n\n**单仓库和多仓库的authz权限文件配置区别：**\n\n单仓库：\\[/目录/子目录/子孙目录/\\.....\\]\n\n多仓库：\\[==当前仓库名==:/目录/子目录/子孙目录/\\.....\\]\n\n----\n\n\n\n# 九、SVN其他功能\n\n## 1、清除用户名和密码\n\n做法：鼠标右键TortoiseSVN\\--\\>Settings\\--\\>已保存数据\\--\\>清除全部\\--\\>确定\n\n![](image68.png)\n\n## 2、export导出指令\n\nexport指令：相当于拷贝项目,导出的代码不会含有隐藏文件.svn，即不受svn版本控制\n\n![](image69.png)\n\n导出来如下所示：\n\n![](image70.png)\n\n## 3、更改svn服务器地址\n\n做法：TortoiseSVN\\--\\>重新定位\\--\\>输入新的仓库地址即可\n\n![](image71.png)\n\n重新输入新的仓库地址即可：\n\n![](image72.png)\n\n----\n\n\n\n# 十、==svn监管服务注册成window系统服务==\n\n## 1、创建SVN监管仓库服务\n\n快捷键win+r，输入cmd，以**管理员**的方式执行以下命令:\n\n```bash\nsc create SVNService binpath= \\\"D:\\svn\\server\\bin\\svnserve.exe --service -r D:\\app\\\" start= auto\n```\n\n\n\n特别注意:\n\n`binpath=`后面有个空格， `start=`后面有个空格（只能有一个空格），其中`SVNService` 是服务的名称，此服务名称可以自己自定义，只要不和系统其它服务名重名即可。\n\n![](image73.png)\n\n![](image74.png)\n\n注册成功之后会在系统服务面板中出现对应。\n\n\n\n查看：底部任务栏启动任务管理器\\--\\>服务\\--\\>找到所注册的服务\n\n![](image75.png)\n\n设置为服务自动启动：服务名右键属性\n\n![](image76.png)\n\n![](image77.png)\n\n==注：如果是以之前黑窗口的形式监管服务，就不可以在使用window服务的形式进行监管。==\n\n## 2、服务相关控制指令\n\n关闭、开启、重启服务:\n\nnet stop\\|start\\|restart 服务名 （如开启svn服务：`net start SVNService`）\n\n![](image78.png)\n\n删除服务:\n\nsc delete 服务名 （如删除svn服务：`sc delete SVNService`）\n\n![](image79.png)\n\n## 3、cmd命令的批处理\n\n我们可以把之前在cmd中写的命令直接写在后缀名为bat的文件中，然后以管理员方式运行bat文件就相当于在cmd命令行中运行命令是一样的，这样操作起来更加方便。\n\n![](image80.png)\n\n如其中关闭svn服务的批处理文件`stop_svn.bat`的内容如下：\n\n![](image81.png)\n\n开启svn服务，`start_svn.bat`内容如下：\n\n![](image82.png)\n\n----\n\n\n\n# 十一、==svn中的钩子程序==\n\n## 1、钩子介绍\n\n抽象介绍：所谓钩子就是与一些版本库事件触发的程序，例如新修订版本的创建，或是未版本化属性的修改。每个钩子都会被告知足够多的信息，包括那是什么事件，所操作的对象，和触发事件的用户名。通过钩子的输出或返回状态，钩子程序能让工作继续、停止或是以某种方式挂起。\n\n说的简单点，我们可以利用钩子在提交前或者是提交后做一些操作。如:\n\n-   利用**提交前的钩子**让用户在提交代码前强制用户必须填写备注信息(了解)。\n\n-   利用**提交后的钩子**把svn仓库代码实时同步到网站web目录（重点掌握，开发中使用较多）\n\n前钩子和后钩子触发的顺序图解：\n\n![](image83.png)\n\n\n\n==钩子的种类：==\n\n每个仓库目录中都会有个**hooks**目录，其中包含了所有的钩子模板代码。\n\n其中使用最多的有两个钩子：提交前的钩子、提交后的钩子（重点，开发中使用较多）\n\n![](image84.png)\n\n## 2、钩子实战\n\n### 2.1、后钩子实时同步仓库代码到web站点【重点】\n\n-   利用**提交后的钩子(post-commit)**把svn仓库代码实时同步到网站web目录\n\n图解如下：\n\nweb站点  `D:\\local.com\\blog`\n\n**步骤1**：==先确保web站点目录与相应的仓库要建立关联，只要含有其仓库的.svn隐藏文件夹即可==。在web站点目录检出就有了\n\n**步骤2**：把blog仓库中的hooks的`post-commit.tmpl`复制一份在当前目录，并改名为`post-commit.bat`\n\n![](image85.png)\n\npost-commit.bat内容为：\n\n```cmd\nSET SVN=\"D:\\svn\\sever\\bin\\svn.exe\"\nSET DIR=\"D:\\local.com\\blog\"\nSVN update %DIR% --username  dashen --password dashen123\n```\n\n注意：要确保设置的用户有写入的权限。\n\n效果：\n\n![](image86.png)\n\n\n### 2.2、前钩子强制用户填写提交时备注信息【了解】\n\n-   利用**提交前的钩子**让用户在提交代码前强制用户必须填写备注信息。\n\n第一步：打开blog仓库的hooks目录，把`pre-commit.tmpl`文件复制一份在当前目录，改名为`pre-commit.bat`,\n\n![](image87.png)\n\npre-commit.bat内容如下：\n\n```cmd\n@echo off\n::\n:: Stops commits that have empty log messages.\n:: 停止提交当记录信息为空时\n::\n\n@echo off\n\nset svnlook=\"D:\\svn\\server\\bin\\svnlook.exe\"\nsetlocal\n\n:: Subversion sends through the path to the repository and transaction id\n::\nset REPOS=%1\nset TXN=%2\n\n:: Check for an empty log messages\n::\n%svnlook% log %REPOS% -t %TXN% | findstr ....... > null\nif %errorlevel% gtr 0 (goto err) else exit 0 \n\n:err\necho. 1>&2\necho Your commit has been blocked because you didn't give any log message 1>&2\nexit 1\n```\n\n\n\n![](image88.png)\n\n注：如需要中文提示，为防止乱码需要把`pre-commit.bat`文件的编码改为**ANSI**。英文提示则不需要\n\n\n\n# 总结\n\n-   创建单仓库（3个步骤）：\n\n\t1.  创建项目目录（`D:/app/blog`）\n\n\t2.  把项目目录变为仓库 `svnadmin create D:/app/blog`\n\n\t3.  监管仓库服务  `svnserve -d -r D:/app/blog`\n\n* 访问单仓库项目：`svn://ip/目录`\n* 单仓库的权限配置（`authz`）：\n\n```\n[groups]\nphp_group = dashen\ncainiao_group=cainiao \n\n[/]\n@php_group = rw\n@cainiao_group = rw\n* =\n\n[/core]\n@php_group = rw\n@cainiao_group = rw\nadmin = rw\n* =\n```\n\n----\n\n-   创建多仓库（3个步骤）：\n\n    1.创建项目目录（`D:/app/blog` 、`D:/app/java`）\n\n    2.把项目目录都变为仓库\n\n    ```\n    svnadmin create D:/app/blog\n    svnadmin create D:/app/java\n    ```\n\n    3.监管仓库服务  `svnserve -d -r D:/app`\n\n-   访问多仓库项目：`svn://ip/仓库名/目录`\n\n-   多仓库的权限配置（`authz`）：\n    ```\n    [blog:/]\n    @php_group = rw\n    @cainiao_group = rw\n    admin = rw\n    * =\n    \n    [blog:/core]\n    @php_group = rw\n    @cainiao_group = rw\n    admin = rw\n    * =\n    ```\n\n----\n\n\n-   **版本回退**\n\n    鼠标右键-\\>tortoiseSvn-\\>更新至版本\\--\\>点击显示日志-\\>通过对应的日志信息，回退到指定的版本\n\n-   **解决冲突**\n\n\t1.  先把具有冲突的文件拉取（`update`）\n\n\t2.  把三个辅助文件删掉，修改含有黄色感叹号的文件，进行代码整合。再次进行提交\n\n----\n\n\n","categories":["svn"]},{"title":"NoSQL之Memcache","url":"%2Fposts%2F402189821%2F","content":"\n\n# NoSql\n\n## PHP+MySql的存储缺点\n\n在大部分的PHP的网站开发当中，我们往往采用的数据存储方式是**php+mysql**，因此就会产生如下图所示的请求方式：\n\n![img](wps2B64.tmp.jpg) \n\n以上的架构对一般对于访问量不大的网站没有任何问题，例如：个人博客网站，小公司的企业网站。然而当网站的数据量和访问量增大之后，即使您的MySql数据库做了非常完美的优化手段，这个架构的请求方式是不会有任何改变的。也就是说，该架构所有的读写操作都是实时发生的，就算你设定了读写分离其实也是把这一切的工作依然是实时的，全部由MySql数据库来承受。所以这种请求方式的架构是有瓶颈的，虽然说理论上你还可以部署更多的数据库读写分离来减轻压力，就算是实时的请求也能扛得过去，但依然存在一个问题，更多的数据库部署意味要添加更多的服务器，这个成本其实是很高的，所以网站优化的另外一个思维就是在当前服务器中减轻数据库的压力，减轻访问(连接)的次数,而并不是不断通过添加服务器来解决。\n\n \n\n**原理：**在我们PHP去和数据库进行交互的时候，减少对数据库的操作、因为数据库需要进行磁盘IO的操作，磁盘IO往往是很慢的（磁盘、硬盘访问的速度本身就很慢）。为了提升速度，一般来说我们会在PHP前往数据库获取数据之前，先去一个缓存系统（一般是一个内存缓存系统，内存的访问速度非常的块，最快的应该是CPU里面的一级缓存、比一级缓存更快的就是CPU寄存器 0 或 1 按位来说）里面获取数据，如果缓存系统里面的数据存在并且没有失效的情况，则可以直接返回。如果不存在或者是存在已经失效，则会去mysql数据库里面进行获取，成功获取后，不但要返回给客户端，还需要在缓存里面缓存一份，下一次请求到达的时候，直接可以从缓存里面获取。对于这种缓存系统叫做**旁路式缓存系统**。\n\n \n\n## **大型网站的优化方向**\n\n1、增加服务器，设置读写分离（架构：更多做数据的备份）\n\n2、增加cpu、高速的IO读写硬盘等硬件和网络带宽\n\n3、在MySql层面做各项优化，如:索引优化，分表等\n\n4、使用反向代理和负载均衡技术\n\n5、聘请可靠的开发技术团队和优秀的运维团队\n\n6、使用NoSql作为缓存中间层\n\n7、CDN进行部署\n\n8、web服务器参数调优\n\n9、......\n\n \n\n \n\n## NoSql的含义\n\n**NoSQL ,（Not Only SQL）**，泛指`非关系型数据库`, 它是由一次叫“反Sql运动”的社区讨论而诞生的体系。这个运动的发起最早源自于社区网站 LiveJournal的开发团队，它们的初衷是为了用于减少数据库连接数，减轻数据库的工作压力，但发展至今有着其他不同的应用领域，因此NoSQL处于一种所谓百家争鸣的，各执一词的时期。但我们作为NoSql的学习者和应用者，我们不需要关心和纠结这些NoSql的争论，也不需要参与到这些争论当中。\n\n \n\n为了更好的理解nosql，则我们需要理解SQL。\n\n1. 数据库的概念\n2. 数据表（行和列构成一个二维结构：表，并且表一般就是现实生活中的一个实体，并且表和表之间是存在关系，也就是实体和实体关系）\n3. 表中数据一般使用SQL（结构化的查询语句）操作（curd、grant、desc）\n\n \n\n**只要不是关系型数据库里面的东西，都可以叫做nosql数据库。**\n\n\n\n**关系型数据库：**\n\n表的关系：（在描述表关系的时候，我们需要知道我们到底是站在哪一张表的角度去看待关系）\n\n==1：1==  用户表  身份证表，一般会在我们看待表关系的表的上增加一个额外的字段来保存对其唯一的表的主键id。\n\n==1：N==  用户表  相册表，最通用的解决方法，就是增加一个附加表，在附加表里面N里面增加一个字段，表示对1表的主键的id引用。（常见的处理方式有三种：1. 在用户表里面水平方向扩充五个字段，每个表示一张图片 2. 只是在1表里面扩充一个字段，设置的类型为 text，在这个字段里面一般保存所有的图片的信息 [ [url=> '1.jpg','uid'  => 12 ], ['url' => '23.jpg', 'uid' => 12....], []  ]  3. 附加表）\n\n==M：N== 网站里面的标签云 ，一般设计一个中间表，中间表里面存在两个字段，第一个字段就是关联M表里面的主键id，第二字段关联N表里面的主键id。（注意：中间不需要设计主键id）\n\n\n\n**设计主键ID的目的**：主要是为了数据的唯一性，带来的其他的作用可以实现快速的查找。主键id也是一种索引结构，既然是索引结构，就适合做数据的查找。\n\n\n\n**关联:** 三范式(记住：在设计表的时候，并不是只有三范，还是5范式....只能借助一些软件)\n\n==范式1==：原子性，字段不可拆分，就是字段是最小字段，不要纠结，因为mysql天生支持1范。\n\n==范式2==：为了保证数据唯一性，引入主键id（主键索引），unique key（唯一索引）【1. 主键只能存在一个，可以让多个字段形成一个复合主键，唯一索引可以存在多个  2. 主键，不允许出现重复，不允许出现null  3. 唯一，不能出现重复，但是可以允许出现null，但是null不能重复】\n\n==范式3==：不能存在冗余，而引入关联。（拆成最小表：只保存用户的最最基本信息 id uname）\n\n| id   | uname  | address_id |\n| ---- | ------ | ---------- |\n| 1    | andy   | 1          |\n| 2    | mark   | 2          |\n| 3    | liyang | 1          |\n\n \n\n| id   | address_name             |\n| ---- | ------------------------ |\n| 1    | 广州市天河区珠吉新路58号 |\n| 2    | 深圳市罗湖区翠竹路78号   |\n| 3    | xxx路                    |\n\n下去：反3范（反的是第三个）表里面要存在冗余信息。\n\n需求：网页要显示出当前这个已经有多少张照片了？\n\n| id   | uname  | imgs_count |\n| ---- | ------ | ---------- |\n| 1    | andy   | 2          |\n| 2    | mark0  | 0          |\n| 3    | liyang | 1          |\n\n`select count(*) from xiangce where uid = 1;`\n\n| id   | img_url              | uid  | add_time  |\n| ---- | -------------------- | ---- | --------- |\n| 1    | imgs/12312.jpg       | 1    | 123213123 |\n| 2    | imgs/12321321.jpg    | 1    | 12312312  |\n| 3    | imgs/12312122312.jpg | 3    | 12312312  |\n\nhttps://www.cnblogs.com/xwdreamer/archive/2012/05/17/2506039.html\n\n\n\n### NoSql的共同特点和优势\n\n* NoSQL 通常是以**key-value**形式存储的（如:Memcache、Redis、Mongodb） \n\n* 不支持SQL语句\n\n* 没有表结构\n\n* 配置简单 \n\n* 灵活、高效的操作与数据模型（key-value存储，一般叫做hash表）\n\n* 低廉的学习成本\n\n* 能很好地作为MySql的中间层\n\n* 能很好地支持PHP\n\n\n\n\n### **NoSql的共同的缺点**\n\n* 没有统一的标准 \n\n* 安全性极差（memcache没有权限系统 内网）\n\n* 没有正式的官方支持 \n\n* 各种产品还不算成熟\n\n* 权威支持的产品价格很高\n\n\n\n\n### **NoSql的产品分类**\n\n网站：<http://www.nosql-database.org/>\n\n* redis \n\n* mongodb\n\n* memcache\n\n* Aliyun MQ\n\n* HBASE\n\n* .....\n\n\n\n\n**问题：为什么搜索不到memcache？**\n\n答：一般的人认为memcache是一个缓存系统，算不上一个数据库。 \n\n\n\n**问题：memcacheDB是什么？**\n\n答：memcache出现的历史是非常的早，在出现之后，只是作为一个缓存系统出现，**不支持持久化的操作**（断电丢失数据）。国内的新浪最先使用的memcache，新浪业务需要做一些持久化的操作，则他们对memcache高可用（数据持久化），这个新的产品 memcacheDB，对于现在来说，实际意义不大，如果真的需要缓存系统做持久化建议使用Redis。\n\n\n\n# Memcache技术\n\n## memcache简介\n\n官网：<http://memcache.org/>\n\nmemcache是一个内存缓存系统。意思是memcache里面的数据全部是保存在内存里面的，速度上比硬盘快了很多很多。\n\n \n\n**常见存储介质速度：**\n\n硬盘最慢、内存其次、一级缓存快、二级缓存更快、cpu（寄存器，电脑里面最快最小的存储单元，只能存储简单的0和1状态）。\n\n \n\n**为什么要使用memcache做数据的缓存？**\n\n答：主要的原因是这样的，由于目前是出于web2.0的时代，这个数据量现在已经非常大，原先的系统架构已经不再能够支持现在的访问。所以才引入这些缓存系统来响应更大的并发。\n\n \n\n## Memcache的优点\n\n1、纯内存的缓存机制，因此它是所有NoSql产品当中最简单也是速度最快,但是同时也是功能最弱的 \n\n2、内置分布式(集群)算法，使得开发者不需要自己去实现\n\n3、它能把单项数据缓存的过期时间设置为30天，也能使得单项数据常驻内存当中\n\n4、完美支持PHP的调用\n\n \n\n## Memcache的缺点\n\n1、由于memcache使用**telnet**协议进行传输，没有数据加密的功能，安全性很差，通常只适用于内网。\n\n2、Memcache最大的内存存储空间（吞吐量）只有**64M**，如果64M的内存一旦爆满，Memcache会指定重启，并释放当前所有的内存，在内存数据就是无情的丢失也不会保留。（`-m `选项指定内存的大小）\n\n3、memcache单个的value值最大为**1M**(string)\n\n4、由于Memcache把数据置于内存中，所以服务器进行维护或者重启，那么数据就会丢（本身就是缓存，是允许数据进行丢失，丢失了之后重新缓存一份即可。和存储不一样，真正保证数据不能丢失）\n\n5、数据零散，无法遍历，管理数据完整性非常一般\n\n \n\n## **memcache和mysql对比**\n\n**什么是nosql数据库？**\n\n答：1. nosql数据库不使用sql语句作为查询 ；2. 没有严格的表结构的概念，一般来说都是使用key-value的hash表把数据保存在内存里面\n\n| key     | value       |\n| ------- | ----------- |\n| name    | caoyang     |\n| age     | 12          |\n| address | shanghaishi |\n\n \n\n**注意：**\n\n1. hash表（hash函数）有一个好处：时间复杂度为O(1)：理论上来当使用hash表保存数据的时候，不会随着数据量的增加使得查询的速度变慢，响应的时间基本不变。\n\n   即：理论上10w条记录里面检索1条满足记录的时间和 从 1000w里面检测1条时间基本差不多。\n\n2. hash的弊端：数据是随机分在某一个内存的区域里面。\n\n3. 最大的弊端就是hash碰撞：理论上来说多个key对应同一个值，是绝对存在的，但是发生的概念很低，可以使用更多的优秀的hash函数（md5 sha1 sha256 crc32...）来尽可能的避免。\n\n\n\nhash使用的场景：下载软件的时候需要使用 hash做检验。（hash严格意义上不是加密）\n\n例如我们常见的md5(是一个hash函数)：可以把任何大小的文件转换为一个固定长度的字符串（ 32位的16进制字符 ，128为二进制的字符）\n\n1Byte = 8bits\n\n1 0x = 4bits\n\n2 0x = 8bits\n\n2 0x = 1Byte\n\n32 0x  = 16Byte\n\n\n\n**PHP业务很少做位的操作？**\n\n答：签到业务\n\n\n\n## memcache是一个c/s架构软件\n\nmemcache是一个c/s架构的软件，需要安装server端来提供相应的服务；然后使用相应的客户端，命令行**telnet**、**php语言**去操作服务器端。\n\n\n\n**PHP + Memcache + MySql的架构图**\n\n![img](wps2B89.tmp.png) \n\n当前方式是客户端（用户浏览器）发起请求，这时这种架构的请求方式，我们称为非实时请求，那么每一次的请求必须通过中间的缓存层面进行，如果缓存中有数据，那么数据库就不会做出任何的响应，如果没有缓存的数据，数据库只会响应一次，并把响应的结果放到内存中等待用户下一次的请求。\n\n\n\n# window下memcache安装\n\n注意：这个一般在本地开发的时候使用，但是线上环境一般都是在linux下运行的。\n\n \n\n## **一次性使用**\n\n1. 复制memcahe软件包里面的exe文件到一个非中文的目录下\n\n![img](wps2B8A.tmp.jpg) \n\n \n\n2. 需要使用管理员的身份启动cmd窗口\n\n   如果是window7则使用如下方式打开cmd窗口\n\n![img](wps2B9A.tmp.jpg) \n\n如果windows10则推荐使用`power shell`（使用快捷方式 windows键 + x键）\n\n![img](wps2B9B.tmp.jpg) \n\n \n\n3. 进入对应软件的目录，查看帮助\n\n![img](wps2BAC.tmp.jpg) \n\n \n\n**参数解释：**\n\n`-p`参数  表示监听的端口， 默认是 11211端口\n\n`-m`参数  表示分配给memcache的内存大小\n\n`-d` 参数  表示可以把memcache加入到window系统服务，然后可以使用命令启动或者是重启\n\n![img](wps2BAD.tmp.jpg) \n\n`-vvv`参数 打印启动的信息\n\n`-f `增长因子\n\n![img](wps2BBD.tmp.jpg) \n\n \n\n4. 一次性启动：默认是占据这个终端窗口的\n\n![img](wps2BBE.tmp.jpg) \n\n如果需要终止服务，只需要按一下`ctrl+c`\n\n \n\n \n\n## **安装成window系统服务**\n\n1. 在启动memcache.exe的时候加上` -d install`即可安装为服务\n\n![img](wps2BBF.tmp.jpg) \n\n \n\n2. 当成为一个系统服务后可以在服务列表里面进行服务的管理\n\n![img](wps2BD0.tmp.jpg) \n\n查看具体的服务信息\n\n![img](wps2BD1.tmp.jpg) \n\n \n\n3. 点击【属性】后\n\n![img](wps2BE2.tmp.jpg) \n\n \n\n4 . 如果要卸载window下的memcache服务，则可以使用 `-d uninstall`命令\n\n![img](wps2BE3.tmp.jpg) \n\n \n\n## Memcache客户端管理（使用Telnet、PHP）\n\n1. memcache可以使用Telnet这个命令来管理服务器端。（注意：前提是memcache已经启动）\n\n`> telnet localhost 11211 `  {表示的含义是去请求本机的11211的服务}\n\n![img](wps2BF3.tmp.jpg) \n\n**解决：**在程序里面安装Telnet命令即可，操作如下：先打开控制面板\n\n![img](wps2BF4.tmp.jpg) \n\n点击【程序】\n\n![img](wps2C05.tmp.jpg) \n\n【打开或关闭windows功能】\n\n![img](wps2C06.tmp.jpg) \n\n【Telnet客户端】\n\n![img](wps2C17.tmp.jpg) \n\n \n\n2. 连接远程memcache服务器\n\n![img](wps2C18.tmp.jpg) \n\n输入上面的命令后回车，然后按一下`ctrl+]`之后，在回车\n\n![img](wps2C28.tmp.jpg) \n\n \n\n3. 输入如下命令测试：\n\n![img](wps2C29.tmp.jpg) \n\n \n\n4. 退出终端：输入`quit`即可\n\n![img](wps2C3A.tmp.jpg) \n\n \n\n \n\n## xshell提供的强大的功能\n\n由于windows自带的telnet提供的功能不能进行字符的删除，则我们可以使用xshell提供的telnet功能。\n\n![img](wps2C3B.tmp.jpg) \n\n \n\n \n\n# ==Memcache下的常见命令==（重要）\n\n注意：memcache需要使用客户端进行链接的，前提是memcache服务必须启动。\n\n![img](wps2C4B.tmp.jpg) \n\n确保服务是正常启动的。\n\n![img](wps2C4C.tmp.jpg) \n\n使用客户端telnet链接\n\n`> telnet    memcache的主机的IP地址       端口`\n\n \n\n测试是否连接成功（`stats`查看memcache的状态）\n\n![img](wps2C5D.tmp.jpg) \n\n \n\n## add命令-添加key\n\n该命令用来添加key，同时指定是否进行压缩以及缓存时间。\n\n**语法：**\n\n`> add KEY FLAGE EXPIRES Bytes`\n\n**KEY** : 表示需要存储的key\n\n**FLAGE**：表示是否对存储的数据进行压缩，0表示不压缩， 1表示压缩；但是不建议压缩（压缩需要操作系统消耗一定的资源），拿空间换时间。\n\n**EXPIRES**:  表示value值失效的时间，单位是s。如果设置为0，表示不过期，但是memcache里面存在一个最大的保留时间为30天。\n\n还得注意一件事，当memcache本身的存储不够用的情况下，会优先剔除这些长期没有使用的的数据信息，以腾出新的空间供其他的数据缓存。（LRU算法：最近最少使用原则，最近一段时间内，最少被使用的数据，在剔除的时候会被优先剔除）\n\n**Bytes**：表示存储value值的字节数（在命令行是需要手工指定，并且在存储的时候，需要严格的对应，但是如果使用的PHP作为客户端操作，就不用担心这个）\n\n\n\n使用如下：\n\n![img](wps2C5E.tmp.jpg) \n\n\n\n## get命令-获取key的值\n\n该命令主要用来获取指定key的value值\n\n`> get KEY`\n\n![img](wps2C6F.tmp.jpg) \n\n\n\n## set命令-给key设置值\n\n**使用set命令的时候，如果key不存在，则创建一个key，如果存在这个key，则做替换操作。**\n\n \n\n**为什么会出现set?**\n\n这是因为我们使用add做添加的时候，如果某个key在缓存系统里面存在，使用add的时候，会报错的。则就出现一个set，如果不存在，则添加，如果存在则替换\n\n![img](wps2C70.tmp.jpg) \n\n\n\n## delete命令-删除对应的key\n\n该命令删除指定key的值\n\n![img](wps2C71.tmp.jpg) \n\n删除一个不存在的key\n\n![img](wps2C81.tmp.jpg) \n\n\n\n## stats命令-查看memcache服务的状态\n\n（status）\n\n**该命令用来查看memcache服务器的状态**\n\n使用如下：\n\n![img](wps2C82.tmp.jpg) \n\n常见参数解释\n\n\n\n![img](wps2C94.tmp.jpg) \n\n`flush_all`命令-清空memcache里面所有的数据，==实际生产环境慎用==(会产生，雪崩效应)\n\n![img](wps2CA5.tmp.jpg) \n\n\n\n## incr 自增命令\n\n**一般在统计文章的浏览量**\n\n需要注意：`incr `默认只能做+1的自增，类似$i++\n\n使用如下：\n\n![img](wps2CA6.tmp.jpg) \n\n\n\n## decr 自减命令\n\n需要注意：`decr `默认只能做-1的自减，类似$i--\n\n使用如下：\n\n![img](wps2CB6.tmp.jpg) \n\n \n\n\n\n# ==PHP操作memcache==（重要）\n\n## 简介\n\n一般来说，Telnet只是用来调试memcache的基本命令的使用，但是在实际开发过程中，一般我们是通过PHP的扩展去操作memcache的，则这个时候我们需要开启PHP操作memcache的扩展。\n\n扩展下载地址：http://pecl.php.net/\n\n>\n\n## memcache类和memcached类的区别\n\n如果我们打开http://www.php.net/manual/zh/搜索`memcache`关键字会出现以下情况的信息，如图所示:\n\n![img](wps2CC7.tmp.jpg) \n\n![img](wps2CC8.tmp.jpg) \n\n在PHP手册里面提供了**memcache**和**memcached**两个扩展类来操作memcache服务器。本质上来说memcache和memcached是的功能是一样的。\n\n \n\nmemcache类支持**php5.3 - php5.6**的单服务器和多服务器的操作。但多服务器的操作在Linux操作系统中兼容性会出现bug。\n\n \n\n为了在Linux中很好地兼容多服务器的操作，php官方推出了一个叫memcached的类，该类只能运行在Linux操作系统当中，支持Linux的单服务器和多服务器操作。如果你使用Linux操作系统作为服务器必须使用Memcached类。同时Memcached类是基于一个叫libmemcached的库，这个库是用C语言开发的在Linux当中运行的效率最高。\n\n1. windows 下使用memcache这个类，memcached这个类是无法在windows下使用。\n2. linux下可以使用 memcache这个类，也可以使用memcached这个类，但是建议使用 memcached 这个类\n\n\n\n## Windows下安装memcache扩展\n\n由于我们现在使用的是windows下的memcache，则我们需要使用memcache扩展类。\n\n \n\n1. 下载PHP操作memcache的扩展类\n\n   <http://pecl.php.net/package/memcache>\n\n \n\n2. 利用phpinfo查看PHP环境信息，选择合适的dll扩展文件，主要是查看PHP版本，平台架构，是否线程安全，以及vs版本\n\n![img](wps2CD8.tmp.jpg) \n\n \n\n3. 将上面的扩展文件复制到php的ext目录\n\n![img](wps2CD9.tmp.jpg) \n\n \n\n4. 修改php.ini文件，增加`extension=php_memcache.dll`信息\n\n![img](wps2CEA.tmp.jpg) \n\n \n\n5. 使用`phpinfo()`测试，如果出现如下信息，表示安装成功\n\n![img](wps2CEB.tmp.jpg) \n\n \n\n \n\n## Memcache存储PHP各种数据类型\n\n在我们使用memcache的时候进行数据缓存的时候，一般会缓存的PHP数据类型如下：\n\n1. **基本数据类型**：字符串、整数、布尔值....\n2. **复合数据类型**：数组（序列化的json格式的字符串）、一般对象很少存储\n\n但是需要注意的是，在memcache的底层其value值都是string类型的，至于我们缓存的PHP里面的数组，在memcache内部会进行序列化后保存起来。\n\n \n\n**操作步骤**\n\n1. 使用PHP扩展（memcache后），则可以使用memcache的类\n\n   ```php\n   $memcache = new Memcache();\n   ```\n\n2. 使用这个memecache对象去链接memcache服务器\n\n   ```php\n   $memcache->connect('127.0.0.1', 11211);\n   ```\n\n3. 使用相关的方法来操作数据\n\n   ```php\n   $memcache->set( key, value, isZip, expires ) ; // 建议set\n   ```\n\n4. 使用相关的方法来关闭连接\n\n   ```php\n   $memcache->close();\n   ```\n\n   \n\n## php中的基本数据类型缓存\n\n![img](wps2CFC.tmp.jpg) \n\n \n\n \n\n## php中的复合数据类型缓存\n\n![img](wps2CFD.tmp.jpg) \n\n**注意：**  在我们存储复合数据类型的时候，memcache的底层会给我们做序列化操作。这个行为对程序员来说是完全透明的。\n\n \n\n# ==Memcache实现session共享==（重要）\n\n## 简介\n\nsession是用来跨脚本共享数据的，保存在服务器端，并且需要依赖cookie，保存一个session_id，所以一般说session是基于cookie。\n\n \n\nsession的存储介质可以是：文件、mysql(需要重写session相关的函数)、memcache。实际项目中使用文件还是偏多，但是如果项目达到一定的并发数之后基本都是使用memcache来保存。\n\n参考阅读\n\nhttps://blog.csdn.net/xinxinji/article/details/50523629\n\n\n\n一般一个网站变大之后，为了提升网站的能力，一般都会做负载均衡。如果使用了负载均衡的则会出现session丢失的问题。\n\n可以使用memcache来保存session数据，使得所有的session全部保存在memcache服务器里面。其他的web服务器也是去同一个memcache服务器里面获取数据。被称为**session共享**。\n\n\n\n一般对于负载均衡集群还可以使用linux下的NFS文件共享服务来解决session文件丢失的问题。\n\n \n\n## **配置session共享**\n\n1. 配置web服务器实现session共享\n\n   a. 修改php.ini文件的三处，表示现在使用memcache来保存session数据\n\n![img](wps2D0D.tmp.jpg) \n\n​\tb. 把session数据保存在哪台memcache上面\n\n![img](wps2D0E.tmp.jpg) \n\n​\tc. 开启php操作memcache的扩展，先把对应的dll文件复制到php的ext目录\n\n![img](wps2D0F.tmp.jpg) \n\n![img](wps2D20.tmp.jpg) \n\n \n\n​\t\t注意：通过`phpinfo()`里面的信息，选择对应的php_memcache.dll 版本。\n\n![img](wps2D21.tmp.jpg) \n\n![img](wps2D32.tmp.jpg) \n\n \n\n \n\n2. 重启Apache，使用phpinfo函数进行测试，见到如下信息则成功。\n\n   现在可使用memcache保存session数据\n\n![img](wps2D33.tmp.jpg) \n\n​\tmemcache扩展成功开启\n\n![img](wps2D43.tmp.jpg) \n\n3. 测试使用\n\n   需要注意：使用memcache保存session后，memcache服务器必须启动\n\n![img](wps2D44.tmp.jpg) \n\n​\t设置session数据\n\n![img](wps2D55.tmp.jpg) \n\n​\t获取session里面的数据\n\n![img](wps2D56.tmp.jpg) \n\n \n\n**注意：** 当用户的session数据保存在memcache里面之后，是拿什么作为session数据存储的**key**呢？\n\n​\t答：使用服务器给客户端分配的**session_id**做的key。\n\n \n\n# memcache分布式缓存系统\n\n上面讲解的memcache都是==单台==memcache的使用。\n\n\n\n概图：\n\n![img](wps2D66.tmp.jpg) \n\n \n\n**什么是memcache分布式缓存系统？**\n\n答：由于单台memcache的能力有限，例如内存空间大小有限，有的时候为了存储更多的数据，就是多台memcache来存储数据。而多台memcache组成的架构就被称为**分布式缓存系统**（**集群缓存系统**）。\n\n \n\n测试：只需要在程序里面，配置一下多台memcache的ip地址和端口，memcache内部会存在一个算法，把key存储在对应的memcache服务器上。\n\n \n\n代码：\n\n1. 使用分布式存储数据（内部使用分布的策略的就是使用的取模，内置策略）\n\n![img](wps2D67.tmp.jpg) \n\n \n\n2. 获取分布式数据\n\n![img](wps2D68.tmp.jpg) \n\n \n\n**总结**：在使用上只需要配置一下memcache分布式的ip和端口，然后把数据丢给memcache即可，我们不用关心数据是存在哪台memcache服务器上。当我们获取数据的时候，也需要配置一下memcache分布式的IP和端口，告诉它一个key，memcache会自己去找对应存储数据的memcache服务器把值获取出来。\n\n \n\n\n\n# memcache内存分配机制\n\n由于memcache是一个内存缓存系统，本身需要内存来保存数据，这就牵涉到内存的申请释放的问题。在memcache设计之初是不断申请和释放。但是这样设计导致一个问题：叫做**内存碎片化**。（备注：电脑的磁盘也存在碎片化的概念），同时还会使得管理上非常的麻烦，需要不断的找操作系统申请内存，释放内存，这无疑是一个很大的开销。\n\n![img](wps2D79.tmp.jpg) \n\n了解：**什么是内存碎片化？**\n\n![img](wps2D7A.tmp.jpg) \n\n内存碎片化永远存在，但是可以使用优秀的算法尽可能的减少内存碎片化。内存的频繁的申请和释放也是需要消耗资源。\n\n \n\n所以memcache为了解决上面的问题，使用了一种较为优秀的处理方法。叫做**内存的预先分配机制**。\n\n \n\n1. 启动memcache的时候使用`-m` 指定分配的内存大小\n\n   ![img](wps2D8B.tmp.jpg) \n\n \n\n2. 预先分配机制\n\n![img](wps2D8C.tmp.jpg) \n\n**注意一下几点：**\n\na. **chunk** 小块memcache存储数据最小的单元\n\nb. 1M里面所有的小的chunk组成一个**slab class**\n\nc. 相邻的chunk之间的比值是固定的，被称为增长因子` -f \t`，根据实际的业务数据大小做处理\n\nd. memcache里面最大的value可以是1M\n\n\n\n备注：最小的chunk是需要源码编译才可以修改\n\n问题：如果真的有value值大小是超过1M，则这个时候不是memcache，使用Redis即可，Redis最大单个value值可以存储1G。\n\n \n\n3. 总结：\n\n   a. 内存预先分配机制（内存碎片化和内存管理）\n\n\t\tb. LRU算法（为了更好的使用空间，需要注意chunk在不够用的情况下，才会这样）\n\t\t\n\t\tc. 惰性删除机制（memcache本身不监控数据是否过期，当下一次重新获取数据的时候，才会去查看数据是否有效，如果有效则返回，否则清除。）\n\n**LRU算法**：被称为最近最少使用原则的算法，当memcache的一个slab里面的chunk不够使用的情况下（存储满了，数据在有效期）当有新的满足chunk的数据过来的情况下，memcache会优先把slab里面最近一段时间内，最不活跃的数据先剔除掉，腾出空间，给新的数据使用。 \n\n![img](wps2D9C.tmp.jpg) \n\n \n\n\n\n# ==linux下源码编译安装memcache==\n\n**如何给PHP装扩展？**不仅限于讲的memcache，后面还有其他的Redis、mongodb.....\n\n\n\n## 简介\n\n一般来说，实际生成环境memcache服务都是安装在linux服务下的，同时在linux下的PHP如果要操作memcache服务器，一般来说，我们都是使用的**memcached**这个扩展类。\n\n \n\n## 源码准备\n\nlibevent-2.0.20-stable.tar.gz\n\nmemcached-1.4.15.tar.gz\n\n 或\n\nlibmemcached-1.0.14.tar.gz \n\nmemcached-2.1.0.tgz\n\n![img](wps2D9D.tmp.jpg) \n\n \n\n由于memcache的底层需要一个libevent库，所以必须先安装该库后，再源码编译安装memcache（存在严格的顺序的问题），并且需要在安装的时候指定该库的位置。\n\nlibevent下载地址：<http://libevent.org/>\n\n \n\n同时，在linux下一般来说，我们都是为PHP安装**memcached**这个扩展类来操作memcache的，但是由于该扩展库底层需要依赖libmemcached库，所以我们需要先安装这库，再安装memcached这个扩展类。\n\n \n\n## memcache安装\n\n1. 上传源码到` /usr/local/src` 目录下，对libevent，解压，并安装\n\n![1536655654383](1536655654383.png)\n\n```shell\n# cd /usr/local/src\n\n# tar -zxvf libevent-2.0.20-stable.tar.gz\n\n# cd libevent-2.0.20-stable\n\n# ./configure --prefix=/usr/local/libevent && make && make install\n```\n\n3， 编译安装memcached\n\n```shell\n# tar -zxvf memcached-1.4.20.tar.gz\n\n# cd memcached-1.4.20 \n\n# ./configure --prefix=/usr/local/memcache  --with-libevent=/usr/local/libevent && make && make install\n```\n\n\n\n## linux下安装php的扩展memcache\n\n1. 上传源码到 `/usr/local/src` 目录，编译安装libmemcached库\n\n![1536655672202](1536655672202.png)\n\n```shell\n# cd /usr/local/src \n\n# tar zxf libmemcached-1.0.14.tar.gz\n\n# cd libmemcached-1.0.14\n\n# ./configure --prefix=/usr/local/libmemcached --with-memcached && make && make install\n```\n\n\n\n注意，如果安装过程中，出现如下的错误，则按照如下的方式进行解决\n\n![img](wps2DAF.tmp.jpg) \n\n解决：\n\n```shell\n# yum install -y gcc44 gcc44-c++ libstdc++44-devel\n\n# export CC=/usr/bin/gcc44\n\n# export CXX=/usr/bin/g++44\n\n# make cache\n\n然后重新执行\n # ./configure --prefix=/usr/local/libmemcached --with-memcached && make && make install\n```\n\n2. 编译安装PHP操作memcache的扩展\n\n```shell\n# cd /usr/local/src\n\n# tar -zxvf memcached-2.1.0.tgz\n\n# cd memcached-2.1.0\n\n# /usr/local/php/bin/phpize\n\n# ./configure --with-php-config=/usr/local/php/bin/php-config --with-libmemcached-dir=/usr/local/libmemcached  && make && make install \n```\n\n3. 成功安装后，则会提示出一个文件夹，该文件夹下会存在一个**memcached.so**文件，这个时候修改php.ini的配置文件，增加一行\n\n```shell\n# vim /usr/local/php/lib/php.ini\n\nextension=\"/usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/memcached.so\"\n\n```\n\n4. 使用`phpinfo()`函数进行测试，如果在出现如下界面，表示扩展安装成功\n\n![img](wps2DB0.tmp.jpg) \n\n \n\n \n\n\n\n## **Memcache设置缓存时间的问题**\n\n文档：<http://php.net/manual/zh/memcached.expiration.php>\n\n![img](wps2DC1.tmp.jpg) \n\n \n\n**如何在memcache里面为指定的key设置缓存有效期呢？**\n\n`> set('name', 'asion', isZIp，缓存时间)`\n\n1. 缓存时间：使用s秒数，但是不能超过 86400*30 s，也就是30天的秒数。\n2. 设置时间戳，但是该方式只在linux下可以使用，在window下并不能生效。\n\n \n\n**如何在memcache里面设置一个超过30天缓存时间的数据，例如设置为31天？**\n\n答：使用时间戳，`time() + 86400 * 31`；需要注意如果我们不给memcache的value设置有效期，则memcache默认只能保持30天有效期；但是如果我们需要手工的设置一个数据的有效期超过30天，则只能使用时间戳的方式设置。同时需要注意，该方法在Windows下并不支持，需要在linux下才可以。\n\n \n\n \n\n## memcache高可用\n\n（==本身就是缓存系统==）\n\n**memcache是否支持高可用？**\n\n答：支持。\n\n但是不建议memcache做高可用。memcache本身的数据是保持在内存里面，如果断电或者宕机、服务器挂了则数据会丢失，由于memcache本身就是做缓存的，数据是允许丢失的，下一次重新生成一份缓存即可。\n\n \n\n这里高可用的意思就是memcache里面的数据是否可以在宕机或者突然终止的情况下，数据还要存在。\n\n \n\n**备注**\n\n1. 机房一般来说断电是没有影响的，就是即使机房断电，是完全不影响服务器的使用。\n2. 机房没那么容易断电。\n3. 但是最好不要做数据丢失。丢失多，一瞬间mysql的压力会暴增。mysql扛不起的情况下出现宕机。\n   1. 由于缓存系统出现问题，导致mysql的压力变大，出现宕机，这种情况被称为memcache的==**雪崩现象**==，\n   2. 出现宕机后，一般mysql都有重启的机制，重启后缓存系统会重建，重建部分之后，mysql还是有可能宕机，重启，缓存在重建一部分.....随着时间推移，缓存系统重新的建立，趋于稳定.....。\n\n \n\n**有以下两种方案实现：**\n\n1. 典故：主要是sina公司发现memcache本身不支持高可用，单独为其开发了一个高可用的插件（MemcacheDB）定期的把memcache内存里面的数据同步的写到磁盘上面。\n\n![img](wps2DC2.tmp.jpg) \n\n​\t备注：该产品产生的原因是因为当时没有可以把内存里面的数据同步写入到磁盘的产品。则新浪自主开发了该产品。但是后面出现redis可以把内存里面的数据写入到磁盘，所以该产品基本不使用了。后面使用redis做数据缓存和持久化存储。\n\n \n\n2. **repcached**产品也可以实现。\n\nhttp://www.07net01.com/program/524088.html\n\n![img](wps2DD2.tmp.jpg) \n\n \n\n## memcache阅读资料\n\n<http://kimi.it/category/memcache/>\n\n\n\n## memcache实际使用\n\n1. 缓存网站里面的局部数据\n\n![img](wps2DE4.tmp.jpg) \n\n \n\n2. 访问频率限制功能  如，[点赞 1天之内点赞1次] \n\n![img](wps2DF4.tmp.jpg) \n\n例如：同一个手机号码一分钟之内只能发送1次短信验证（有效期60s）；一天只能只能拥有3次发送短信的机会(有效期)[时间点： 1. 到今天23:59:59末点时间戳  、   2. 设置 今日末点23:59:59 - 当前时间 =  s数 ]。\n\n\n\n3. 文章浏览数统计\n\n![img](wps2DF5.tmp.jpg) \n\n对于文章浏览数没必要实时的写入数据库，我们可以将文章的浏览器数先写入到memcache缓存中，然后在夜晚通过定时任务将对应的浏览器写入到数据库中，做持久化操作。\n\n\n\n4. 热门软件下载排行榜\n\n![img](wps2E06.tmp.jpg) \n\n一般这些数据也不是实时的，一般来说都是统计前一天的下载量，所以我们可以将对应软件下载排行数据缓存一天，到下一天后进行重新缓存。\n\n\n\n## memadmin图形化界面\n\n\n\n网站：<http://www.junopen.com/memadmin/>\n\n \n\n**MemAdmin**是一款可视化的Memcached管理与监控工具，使用PHP开发，体积小，操作简单。\n\n**主要功能：**\n\n· 服务器参数监控：STATS、SETTINGS、ITEMS、SLABS、SIZES实时刷新\n\n· 服务器性能监控：GET、DELETE、INCR、DECR、CAS等常用操作命中率实时监控\n\n· 支持数据遍历，方便对存储内容进行监视\n\n· 支持条件查询，筛选出满足条件的KEY或VALUE\n\n· 数组、JSON等序列化字符反序列显示\n\n· 兼容memcache协议的其他服务，如Tokyo Tyrant (遍历功能除外)\n\n· 支持服务器连接池，多服务器管理切换方便简洁\n\n\n\n# http状态码-502\n\n![1536658468283](1536658468283.png)\n\n PHP的应用服务器挂了，也就是**php-fpm**不可以使用了。\n\n ","categories":["NoSQL.Memcache"]},{"title":"mysql","url":"%2Fposts%2F2501908538%2F","content":"\n\n# MySQL数据库\n\n\n\n----\n\n**数据库**：永久性保存数据的仓库。\n\n\n\nMysql称为**关系型数据库** \n\n**非关系型**： 是将数据存在在内存中   \n**关系型**：是将数据存储硬盘中\n\n\n\n何谓关系型（关系模型），即利用关系(二维表)，去描述实体信息。    \n与 实体之间有联系 的数据库架构就是 **关系型数据**！\n\n \n\n**关系**：二维表\n\n行，记录，一行就是一条记录。   \n列，字段，一列就是一个字段。\n\nSQL：结构化查询语言，操作关系型数据库的语言！SQL是一门编程语言并且它是**强类型**的编程的语言。\n\n**学生表**\n\n| **学号**   | **姓名** | **年龄** | **教室表中所属ID** |\n| ---------- | -------- | -------- | ------------------ |\n| Itcast1001 | 王小明   | 38       | 1                  |\n| Itcast1002 | 王宝强   | 20       | 2                  |\n| Itcast1003 | 梅超风   | 30       | 3                  |\n\n \n\n**教室表**\n\n| ID   | 教室号 | 所属班级   |\n| ---- | ------ | ---------- |\n| 1    | 305    | PHP25期    |\n| 2    | 210    | PHP24期    |\n| 3    | 311    | JavaEE48期 |\n\n----\n\n\n\n## 安装Mysql\n\nmysql的安装分为两部分：**安装**与**配置**     \n版本不同，界面可能有些不同\n\n### 安装\n\n![img](clip_image001.png) \n\n![img](clip_image001-1529568600124.png) \n\n![img](clip_image001-1529568622911.png) \n\n![img](clip_image001-1529568642067.png) \n\n\n\n### 配置\n\n1）  安装完后进行配置界面\n\n \n\n2）  选择“详细配置”选项\n\n![img](clip_image001-1529568922307.png)\n\n \n\n3）  选择“开发者机器”\n\n![img](clip_image002.png)\n\n4）  选择“多功能数据库”\n\n![img](clip_image003.png)\n\n \n\n5）  选择“手动设置连接数”\n\n![img](clip_image004.png)\n\n \n\n6）  允许防火墙通过\n\n![img](clip_image005.png)\n\n \n\n7）  设置默认字符集\n\n![img](clip_image006.png)\n\n \n\n8）  设置开机自启动\n\n![img](clip_image007.png)\n\n \n\n \n\n9）  设置root用户的密码\n\n![img](clip_image008.png)\n\n \n\n10）              选择执行\n\n![img](clip_image009.png)\n\n\n\n----\n\n\n\n## 连接Mysql数据库 \n\nMySQL是基于C/S架构的。   \n客户端/服务器端架构 ，   一对一模式 \n\n\n\n安装mysql时，自动携带一个命令行的客户端 mysql Client。   \n利用该客户端，向服务器发送指令，然后等待执行结果即可！\n\n![](mysql_client.png)\n\n\n\n操作mysql，就一定：通过操作mysql客户端，向mysql服务器发出指令，从而完成操作！\n\n![](procedure.png)\n\n\n\n\n\n### 通过cmd命令行窗口管理Mysql服务\n\n\n\n启动mysql服务器\n\n```bash\nnet start mysql \n```\n\n停止mysql服务器 \n\n```bash\nnet stop mysql \n```\n\n注： mysql 为安装 的服务名，有些新版本为 mysql80，按实际修改。前提为mysql要已安装已添加到环境变量中。\n\n\n\n### 通过Window的服务来管理Mysql服务 \n\n![](win_service_manage.png)\n\n\n\n### 使用命令行窗口来作为Mysql客户端\n\n先在键盘上面按下：**win**+**R**  然后输入 **cmd** ，回车键打开命令行窗口\n\n```bash\nmysql.exe   -h(主机名)  -P(端口号)  -u(用户名)  -p(密码)\n```\n\n本地主机可以省略 -h(主机名) \n\n![](cmd_mysql_client.png)\n\n----\n\n","categories":["Mysql"]},{"title":"MySQL 字符集","url":"%2Fposts%2F2831383651%2F","content":"\n\n# MySQL 字符集\n\n----\n\n想在数据表中插入汉字 发现插入不了\n\n\n\n**字符集**  \n描述 可见到的图形，在存储和传输时 使用的编码 称之为字符集！\n\n指的是：   \n图形 与 编码 之间的对应关系！\n\n \n\n字 => 11100101 11100001 00010100\n\n----\n\n\n\n## 数据存储的编码\n\n数据是存储在服务器端的！究竟是以哪种编码保存的，怎么决定？   \n数据是最终要映射（保存）到字段的层面上！因此决定数据的编码，也是最终由字段来决定！\n\n \n\n* 在MSQL配置文件中 有字符编码设置的 \n* 在创建数据库也可以指定字符编码 \n* 在创建表也可以指定字符编码 \n* 在定义字段的时候也可以指定其字符编码 \n\n \n\n**确定数据的存储编码是由以下的方案完成的**：\n\n1. 先看 字段的编码！如果存在则确定完毕！\n2. 如果字段没有设置编码，查看表的编码，如果有，则确定数据编码！\n3. 如果表没有编码，查看库的编码，如果有，则确定数据编码！\n4. 如果库也没有编码，则有服务器程序确定！\n\n\n\n典型的编码：**gbk，utf8**\n\n----\n\n\n\n## 客户端操作，查询的编码\n\n![](client_charset_show.png)\n\n在客户端与 服务器端交互时，存在两个重要的编码：\n\n1. 客户端发送数据的编码\n2. 客户端接收到服务器数据编码！\n\n \n\n可以通过 **show variables like ‘character_set_%’** 展示以 **character_set**开头变量，其中就有上面的两个值：\n\n![](show_var_char.png)\n\n \n\n \n\n在往Mysql服务器写入汉字的时候 报错：  \n\n可使用 **set** **变量名 =** **变量值**\n\n\n\n打开 黑窗口：   \n\n第一步，选择数据库    \n第二步，设置字符编码   \n\n \n\n```bash\nset names gbk|utf8\n```\n\n就是一个快捷操作，将上面三个配置同时更改成目标编码！ \n设置gbk或utf8 ，不包含竖线 |\n\n \n\n**注意**：set names gbk|utf8 取决于，客户端所能接受的编码！\n\n![](mysql_liucheng.png)\n\n\n\n----\n\n\n\n# MySQL 校对集(collate)\n\n指的是 **字符之间的比较关系**！\n\na B c\n\nor？\n\nB a c\n\n可以被 校对集改变：\n\n利用 **show collation;** 查看到所有的校对集！\n\n![](1536906389_image1.png)\n\n校对集，依赖于**字符集**！\n\n校对集，指的是，在某个字符集下，字符的排序关系应该是什么，称之为校对集！\n\n![](1536906389_image2.png)\n\n![](1536906389_image3.png)\n\n![](1536906389_image4.png)\n\n典型的后缀：\n\n`_bin `二进制编码层面直接比较：\n\n`_ci `忽略大小写（大小写不敏感）比较\n\n`_cs` 大小写敏感比较","categories":["Mysql"]},{"title":"MySQL 字段约束","url":"%2Fposts%2F1492550196%2F","content":"\n\n# MySQL 字段约束\n\n----\n\n## 非空值约束\n\nmysql的**NULL**不是数据，也不是类型！只是标识字段属性！ \n用于说明某个字段，是否可以为null  \n\n是：NULL，而不是：‘NULL’\n\n属性： \n``null``   表示可以为空，默认  \n``not null``  表示不能为空  \n如果，在添加数据时 ，没有指定值，也可能会是NULL！  \n\n![](mysql_key_01.png)\n\n----\n\n\n\n## 默认值约束\n\n**Default**：默认值 \n\n当字段被设计的时候，如果允许默认条件下，用户不进行数据的插入，那么就可以使用事先准备好的数据来填充：通常填充的是NULL 。\n\n```mysql\ncreate table my_table(\nname varchar(20) default '小米'\n);\n```\n\n----\n\n\n\n## 主键约束\n\n**主键**，可以唯一标识记录的字段，是表中一列或多列的组合。主键约束要求主键列的数据**唯一**，且**不能为空**。\\\\\\\n\n主键分为：**单字段主键**  和 多字段联合的**复合主键**\n\n一个表，只能有一个主键！ \n典型的，在创建表时，主动增加一个 非实体的自然属性，充当主键，采用整型，运算速度快！\n\n**关键字**： ``primary key``\n\n\n\n#### 单字段主键\n\n在定义列的同时指定主键，语法：  \n``字段名  数据类型   primary key [默认值]``  \n\n\n在定义完所有列之后指定主键，语法： \n``[constraint <约束名>] primary key [字段名]``\n\n```mysql\n-- 在定义列的同时指定主键\ncreate table my_table(\nid  int(10) primary key,\nname varchar(20)\n);\n\n-- 在定义完所有列之后指定主键\ncreate table my_table(\nid int(10),\nname varchar(20),\nprimary key (id)\n);\n```\n\n\n\n#### 复合主键\n\n复合主键，语法： \n\n``primary key [字段1,字段2,...字段n]``\n\n```mysql\n-- 复合主键\ncreate table my_table(\nid int(10),\nname varchar(20),\nprimary key (id,name)\n);\n```\n\n![](mysql_key_02.png)\n\n### 管理主键\n\n\n```mysql\n-- 添加主键\nalter table  表名 add primary key(字段列表);\n\n-- 删除主键\nalter table  表名 drop primary key;\n```\n\n\n\n----\n\n\n\n## 唯一值约束\n\n**唯一值约束**，要求该列的值唯一，允许为空，且只能一个空值。   \n唯一值约束可以确保列中不出现重复值。\n\n**关键字**： ``unique``\n\n\n\n在定义列的同时指定唯一，语法：  \n``字段名  数据类型 unique   ``  \n\n在定义完所有列之后指定唯一，语法： \n``[constraint <约束名>] unique (字段名)``\n\n```mysql\n-- 在定义列的同时指定唯一\ncreate table my_table(\nname varchar(20) unique\n);\n\n-- 在定义完所有列之后指定唯一\ncreate table my_table(\nid int(10),\nname varchar(20),\nunique (name)\n);\n```\n\n### 管理唯一\n\n```mysql\n-- 删除唯一\n-- 索引的名字，可以通过 show create table 看到！\nalter table 表名 drop  index  索引名称;\n\n-- 增加唯一\n-- 建议索引名字使用反引号(~按键)包裹\nalter table 表名 add unique  key 索引名字 (字段列表);\n-- 或\nalter table 表名 add unique  index  索引名字 (字段列表);\n\n```\n\n----\n\n\n\n## 外键约束\n\n**外键**，用来在两个表的数据之间建立链接，可以是一列或多列，可以不是本表的主键，但对应另一表的主键。一个表可以有多个外键。\n\n\n\n如，一个实体A的某个字段，刚好指向或者引用到另外一个实体B的主键，那么实体A的这个字段就是外键！ 所以，简单来说，外键就是外面的主键，就是指向其他表的主键的那个字段！\n\n\n\n**作用**：外键主要是保持数据的一致性、完整性。\n\n\n\n**主表(父表)**：对于两个具有关联关系的表而言，关联字段中``主键``所在的表是主表。 \n**从表(子表)**：对于两个具有关联关系的表而言，关联字段中``外键``所在的表是从表。  \n\n\n\n**关键字**： ``foreign key``\n\n\n\n在定义列的同时指定外键，语法：  \n``[constraint `外键名`] foreign key  [`索引名`] (外键字段列表)  references 主表(主键字段);   ``  \n\n在创建表后增加外键，语法： \n``Alter  table 从表 add [constraint `外键名`] foreign key  [`索引名`]  (外键字段列表) references 主表(主键);``\n\n```mysql\n-- 在定义列的同时指定外键\ncreate table my_table(\nid int,\nc_id int,\nconstraint `stu_fy` foreign key (c_id) references my_class(id)\n);\n\n-- 在创建表后增加外键\nalter table my_table add constraint `stu_fy` foreign key (c_id) references my_class(id);\n```\n\n创建外键后会自动增加一个普通索引，可以指定普通索引的名称，也可以让系统分配 。\n\n![](foreignkey01.png)\n\n\n\n### **删除外键**\n\n外键不允许修改，只能先删除后增加  \n基本语法：``alter table 子表 drop  foreign key 外键名字;`` \n外键名字可以通过 ``show create table table_name ``查看  \n\n注意： \n\n**外键不能删除产生的普通索引，只会删除外键自己**\n\n```mysql\nalter table my_table drop foreign key `stu_fy`;\n```\n\n### 约束模式\n\n可以在创建外键的时候，对外键约束进行选择性的操作。\n\n \n\n基本语法： \n``Alter table 从表 add [constraint `外键名`] foreign key  [`索引名`]  (外键字段列表) references 主表(主键)  on 约束模式;``\n\n**约束模式**有三种：\n\n1. **district**：严格模式，默认的，不允许操作\n2. **cascade**：级联模式，一起操作，主表变化，从表数据跟着变化\n3.  **set null**：置空模式，主表变化（删除），从表对应记录设置为空：前提是从表中对应的外键字段允许为空\n\n \n\n外键约束主要约束的**对象**是主表操作：从表就是不能插入主表不存在的数据\n\n \n\n通常在进行约束时候的时候，需要指定操作：**update**和**delete**\n\n常用的约束模式： ``on update cascade``, ``on delete set null``，更新级联，删除置空\n\n![](foreignkey02.png)\n\n\n\n### 注意事项\n\n1. 外键约束，只能在 当前的 mysql的的 **innodb** 表类型（引擎）下才会生效！\n2. 外键字段需要保证与关联的主表的主键**字段类型完全一致**\n3. 因为外键有非常强大的数据约束作用，而且可能导致数据在后台变化的不可控。导致程序在进行设计开发逻辑的时候，没有办法去很好的把握数据（业务），所以外键比较少使用。 因为我们是站在PHP的层面去操作Mysql数据库  所以外键使用的概率非常小。\n\n----\n\n\n\n## 自动增长\n\n**自动增长**，可以从1开始，逐一递增的数值 。\n\n**关键字**： ``auto_increment``\n\n\n\n一张表只可有一个字段使用 ``auto_increment`` 约束，且该字段必须为主键。\n\n\n\n典型的，从1 开始，没有负数，可以采用 无符号 **unsigned**整型！   \n**注意**： unsigned，不是列属性，是类型的一部分！（包括zerofill）因此位置上与类型在一起！\n\n\n\n语法： \n\n``字段名  数据类型  auto_increment``\n\n```mysql\ncreate table my_table(\nid int(11) primary key auto_increment\n);\n```\n\n----\n\n\n\n## 字段注释\n\n**字段注释**，主要是用于给字段进行注释，方便自己和他人阅读字段的含义。\n\n关键字： ``comment``\n\n```mysql\ncreate table my_table(\nid int(11),\nname varchar(23) not null  comment '用户名'\n);\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Mysql"]},{"title":"MySQL 数据类型","url":"%2Fposts%2F3832727553%2F","content":"\n\n# MySQL 数据类型\n\n----\n\nMySQL 支持多种据类型，主要有 数值类型、日期/时间类型 和 字符串类型。\n\n 数值类型：包括整数类型(**tinyint** ， **smallint**  ， **mediumint** ， **int**  / **intege** ， **bigint**)，浮点类型(**float** ， **double**)，定点类型(**decimal**)。\n\n日期时间类型： 包括 **year**  ， **time** ， **date** ， **datetime**  和 **timestamp**。 \n\n字符串类型： 分为 文本字符串(**char** ， **varchar** ，  **text**，**enum** ，**set** ) 和 二进制字符串(**binary** ，**varbinary** ，**blob**)包括 等。\n\n----\n\n\n\n## 数值类型\n\n数值类型主要用来存储数字，Mysql提供多种数值类型，不同的类型提供不同的取值范围，可以存储的值范围越大，其所需的存储空间越大。\n\n### 整数类型\n\n![](mysql_datatype_01.png)\n\n![](mysql_datatype_02.png)\n\n```mysql\ncreate table my_table (\nid    int(10),\n...\n...\n);\n```\n\n``int(10)``  10 表示显示宽度，并非是限制存储个数。\n\n\n\n**注意**： 宽度只用于显示，并不能限制取值范围和占用空间。如果宽度不够，则采用前导零补齐！此时需要 额外的属性 ``zerofill`` 来设置！如果超过设置的宽度，不会报错。\n\n```mysql\n-- 前导零补齐\ncreate table my_table (\nid  int(10) zerofill\n);\n```\n\n\n\nmysql的整型，有php整型不具备的概念：  \n\n**有符号** \n默认，表示有正数和负数。 \n\n**无符号**  \n只能表示正数或0。那么最大的正数会很大！ \n可通过 整型的 **unsigned**选项设置其无符号  \n\n```mysql\n-- 设置无符号\ncreate table my_table(\nid int unsigned\n);\n```\n\n\n\nmysql中，没有 布尔型！\n但是 存在 boolean这个关键字，表示 tinyint(1)  \n典型的，0表示假，1表示真！\n\n```mysql\ncreate table my_table(\nsex tinyint(1)\n);\n```\n\n\n\n### 浮点类型和定点类型\n\nMysql使用浮点数和定点数来表示小数。 \n浮点类型：单精度浮点类型(float) 和 双精度浮点类型(double)。 \ndouble 比 float 精度更高，小数位更多。\n\n![](mysql_datatype_03.png)\n\n![1529831736044](mysql_datatype_04.png)\n\n```\nfloat(M,D)\ndouble(M,D)\ndecimal(M,D)\nM：所有的有效位数，也表示显示宽度\nD：其中的小数位数\n以上两个值，决定一个浮点数的有效范围！\n\n典型的浮点数\nfloat(10, 2);\n99999999.99\n```\n\n**注意**，浮点数，近似值，不是精确值！如果一个数，很大，接近最大值，可能出错！\n\n```mysql\ncreate table my_table(\nm  float(10,2)\n);\n```\n\n\n\n关于小数：\n\n1. 支持 科学计数法7e3 \n2. 同样支持 unsigned，无符号\n3. 同样支持 zerofill\n\n\n\n无论是浮点还是定点，如果超出了精度范围(M)，则会四舍五入。\n对精度要求比较高时(如 货币，科学数据等) 使用定点类型比较好。\n浮点类型在减法和比较运算时也容易出错，应尽量避免。\n\n----\n\n\n\n## 日期时间类型\n\n![1529835602621](mysql_datatype_05.png)\n\n\n\n### date\n\n**日期类型：**系统使用3个字节来存储数据，对应的格式为：YYYY-mm-dd，能表示的范围是从1000-01-01 到9999-12-12，初始值为0000-00-00\n\n\n\n### time\n\n**时间类型：**能够表示某个指定的时间，但是系统同样是提供3个字节来存储，对应的格式为：HH:ii:ss，但是mysql中的time类型能够表示时间范围要大的多，能表示从-838:59:59~838:59:59，在mysql中具体的用处是用来描述时间段。\n\n\n\n### datetime\n\n**日期时间类型：**就是将前面的date和time合并起来，表示的时间，使用8个字节存储数据，格式为YYYY-mm-dd HH:ii:ss，能表示的区间1000-01-01 00:00:00 到9999-12-12 23:59:59，其可以为0值：0000-00-00 00:00:00\n\ndatetime插入年份时 可以选择2位数或者是4位数的年份\n\ndatetime进行两位数插入的时候，有一个区间划分，零界点为69和70：当输入69以下，那么系统时间为20+数字，如果是70以上，那配系统时间为19+数字\n\n**建议插入4位数的年份！！！**\n\n \n\n### timestamp\n\n**时间戳类型：**mysql中的时间戳类型只是表示从1970年1月1日开始，但是其格式依然是：YYYY-mm-dd HH:ii:ss\n\n### year\n\n**年类型：**占用一个字节来保存，能表示1900\\~2155年，但是year有两种数据插入方式：0\\~99和四位数的具体年\n\nyear进行两位数插入的时候，有一个区间划分，零界点为69和70：当输入69以下，那么系统时间为20+数字，如果是70以上，那配系统时间为19+数字\n\n**建议插入4位数的年份！！！**\n\n\n\n**注意**：因为在PHP中有强大的date()与strtotime() time()函数  所以站在PHP的角度这个日期时间类型用的不多 \n\n----\n\n\n\n## 字符串类型\n\n![](mysql_datatype_06.png)\n\n\n### char\n\n格式：\n\n``字段名 char(L)``  ：L表示最大的字符数（不是字节数）  \n\n最基本（定长）的字符串类型！  \n用于保存，长度固定的内容！\n速度快，但是保存变长数据，会浪费空间！\n\n\n\n\n### varchar\n\n格式：\n\n``字段名 varchar(L)``  ：L表示最大的字符数 （不是字节数）  \n可变长度的字符串！  \n用于保存长度可变的数据！  \n保存变长数据时，节省空间，但处理起来麻烦些！  \n\n\n``char(L)，varchar(L)``  \nL,表示每个数据的最大长度！单位是 字符数（不是字节数）\n\n \n\n**L的值不是多大都可以的，有最大值**：\n\n1. mysql一条记录最大不能超过65535个字节！（字段的长度加起来，不能超过这个值）\n2. 长度单位是字符数，与编码是相关的！\n3. 由于varchar是变长，需要记录下真实的数据到底有多长！每个varchar类型的数据，还需要额外的1个或2个字节保存真实数据的长度！（取决于真实数据的长度）\n4. 整条记录，还需要1个字节来保存那些字段为null\n\n\n\n 采用单字节编码测试下：  \n``Latin1``   \n测试发现只有一个字段，而且是单字节字符集，还是不能是65535  \n\n为什么是 65532呢，少了三个字节?  \n因为 varchar 类型还需要额外的1个或2个字节保存真实数据的长度。整条记录，还需要1个字节来保存那些字段为null。\n\n![](mysql_datatype_07.png)\n\n![](mysql_datatype_08.png)\n\n\n\n**但是，在使用时，varchar 超过255就选择 text来保存！**\n\n \n\n### text\n\n文本，不限长度的字符串！   \n该字段，不需要指定长度，而且也不会算入到记录的总长度内！   \n比如：文章管理系统  有会文章  可以选择使用text这个字符串类型来存储 \n\n```mysql\ncreate table my_table(\nt text\n);\n```\n\n\n\n\n### 怎么选择？\n\n定长，**char**   \n变长较短（255）个字符之内，**varchar**   \n变长，较长，**text**\n\n\n\n \n\n### enum\n\n枚举，enum，单选   \n需要在定义枚举类型时，列出哪些是可能的！ 如： \n\n```\nenum(‘男’,’女’,’保密’);\n```\n在处理时，类似 字符串型进行操作！\n\n \n\n意义在于：\n1.  限定值的可能性！\n2.  速度快，比普通的字符串速度快！\n\n枚举型 是利用 整数进行管理的，速度比字符串快！ 每个值，都是一个整数标识，从第一个选项开始为1， 逐一递增！\n\n**站在mySQL的角度 建议使用enum来存储类似于单选的这种数据  ，但是站在PHP的角度来说 建议不要使用**\n\n\n\n### set\n\n集合，set，复选  \n类似于 enum枚举，在定义时，也需要指定其已有值！ \n\n**集合**：是一种将多个数据选项可以同时保存的数据类型，本质是将指定的项按照对应的二进制位来进行控制：1表示该选项被选中，0表示该选项没有被选中。\n\n\n**注意：**站在 mysql的角度，尽量多用 枚举和集合！ \n但是站在php操作mysql的角度，尽量少用！（兼容性差）\n\n![](mysql_datatype_09.png)\n\n\n\n----\n\n\n\n","categories":["Mysql"]},{"title":"SQL编程--触发器(trigger)","url":"%2Fposts%2F3965222648%2F","content":"\n\n# SQL编程--触发器(trigger)\n\n**场景：**\n\n**日志系统**，记录对学生表有哪些操作！\n\n解决的问题：\n\n1.  得到每条学生记录被修改的时机，才能发出记录日志的动作！\n\n2.  执行某段操作，需要得到当前处理的记录的信息！\n\n触发器：一种编程设计！类似js的基于事件编程的程序设计的理念！可以在某个表的每条记录上，设置一个事件，从而对该表上的某些操作，加以监听！一旦所监听的行为出现，则会执行相应的代码。\n\n```\n记录\t\t\t\t =button\n\n（修改，删除，增加）  =onclick\n\n执行操作 \t\t\t=alert('Hello');\n```\n\n以上的所有行为，都是采用 sql 完成的\n\n## 语法\n\n### 创建触发器\n\ncreate trigger 触发器名字 触发条件，监听的内容，触发后执行的操作\n\n```sql\nCREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt\n```\n\n其中，触发条件，是由 事件的时机，与事件的内容 组成\n\n时机：之前before，和之后after！\n\n事件：增加insert，删除delete，修改update\n\n因此，一共只有六种事件：\n\n`before insert`   `before delete`   `before update`\n\n`after insert` `after delete`   `after update`\n\n监听的主体是由表中的记录发出的\n\n`on table_name for each row`\n\n执行的操作，就是一段 sql的集合！\n\n![](1536906389_image15.png) \n\n![](1536906389_image16.png) \n\n\n\n### 删除触发器\n\n`drop trigger trigger_name`\n\n\n\n### 查看触发器的创建语法\n\n`show create trigger trigger_name`\n\n\n\n## 在触发程序中得到当前触发的记录信息\n\n有，两个！\n\nnew（新的），old（旧的）\n\nnew，和old，都表示触发程序的记录！\n\nnew：新的记录。old：旧的记录！\n\n取决于当前操作（intser，update，delete）去使用其中某个：\n\n**insert**，增加记录，没有旧记录，只有new关键字可以使用\n\n**delete**，删除记录，没有新纪录，只有old可用！\n\n**update**，更新，既有新纪录，也有旧记录，更新前是旧记录，而更新后是新纪录！因此可以 new和 old\n\n![](1536906389_image17.png)\n\n![](1536906389_image18.png)\n\n**更新日志：**\n\n记录更新日志，要求是，只对某部分同学完成更新日志！\n\n**只记录**，身高超过175学生的更新记录！记录学生id和修改前的身高与之后的身高\n\n需要额外的增加条件判断！\n\n**逻辑分支语句：**\n\n```php\nif 条件 then\n\n语句体\n\nelse if 条件 then\n\n语句体\n\n....\n\nelse\n\n语句体\n\nend if;\n```\n\n\n\n**sql语句的结束符问题**\n\n可以修改 最外层的语句结束符达到目的！\n\n`delimiter $$`\n\n将语句结束修改成 \\$\\$\n\n记住用完后要再修改回来！\n\n![](1536906389_image19.png) \n\n如果 触发程序由多条语句组成块。此时就需要使用\n\nbegin\n\nend 将语句块包裹！\n\n最终显示的代码\n\n![](1536906389_image20.png) \n\n\n\n# SQL编程--存储函数\n\n一：SQL也是一门程序设计语言！可以用其编程！\n\n二：基本常规的编程要素：\n\n* 变量，运算符，表达式，流程控制，函数\n\n\n\n## 变量\n\n典型的，字段名就是变量名，字段就是变量！\n\n特殊的变量，例如系统内置变量（character\\_set\\_xxx, autocommit）\n\n**变量的典型操作：**\n\n*  赋值\n* 取得值\n\n\n\n### 用户自定义变量\n\n用户自定义变量需要使用 @作为变量名的前缀，用于区分是否是系统内置变量！\n\nset 语句 可以完成对变量的设置！\n\n```sql\nset 变量名=变量值;\n```\n\n![](1536906389_image21.png) \n\n怎么取得？\n\n采用select 语句即可！\n\n`select 变量名`\n\n![](1536906389_image22.png) \n\n\n\n## SQL编程的的实现\n\n一共有三种编程方式：\n\n触发器，存储函数（自定义函数），存储过程\n\n## 函数\n\n### 内置函数\n\n对于mysql来讲，有内置函数！\n\n\n\n**rand()**,生成随机数的函数，得到0-1之间的随机数\n\n![](1536906389_image23.png)\n\n典型的为了得到某个范围内的随机数，需要\\* N倍：\n\n需要配合上 取整使用，达到取得随机整数的目的：\n\n**floor()** 向下取整：\n\n![](1536906389_image24.png)\n\n**substring(字符串，位置，长度) **   ，截取字符串函数\n\n![](1536906389_image25.png)\n\n注意，从1开始的下标! 而且是以为字符为单位：\n\n![](1536906389_image26.png)\n\n**char\\_length()**字符数量\n\n![](1536906389_image27.png)\n\n**length()**字节长度\n\n![](1536906389_image28.png)\n\n**concat()** 连接字符串\n\n![](1536906389_image29.png)\n\n### 自定义函数\n\n**函数的要素：**\n\n函数名，函数体（返回值），函数参数\n\n**函数的基本使用：**\n\n声明，调用\n\n\n\n#### 声明\n\n![](1536906389_image30.png)\n\n注意多条语句，修改结束符\n\n创建一个打招呼的函数\n\n![](1536906389_image31.png)\n\n#### 调用\n\n类似于系统函数即可！\n\n`select 函数名`\n\n![](1536906389_image32.png)\n\n注意，函数是存储在某个数据库内，因此与库是相关的！\n\n![](1536906389_image33.png)\n\n#### 参数\n\n**注意，**参数也是需要有类型之分\n\n而且，不用使用@。原因是函数内的变量是不用区分的！参数是一个局部变量！\n\n![](1536906389_image34.png)\n\n![](1536906389_image35.png)\n\n\n\n#### 函数局部变量与函数外全局变量的作用域问题\n\n作用域是重叠的！在函数内，可以访问到函数外所定义的全局变量！\n\n![](1536906389_image36.png)\n\n#### 局部变量\n\n在 函数内的变量！\n\n此时在函数内，使用 关键字 **declare** 来声明局部变量（js中类似var的作用）！\n\n![](1536906389_image37.png)\n\n#### 流程控制\n\n**分支**\n\n```sql\nif 条件 then\n\n语句\n\nelse if 条件 then\n\n语句\n\nelse\n\n语句\n\nend if;\n```\n\n\n\n**循环**\n\n```php\nwhile 条件 do\n\n循环体\n\nend while;\n```\n\n**示例：**求1-N之和：\n\n![](1536906389_image38.png)\n\n![](1536906389_image39.png)\n\n练习：拼凑随机的名字！\n\ngetName(2\\|3\\|4)\n\n参数为名字的长度，而返回值为名字！\n\n业务逻辑：\n\n取得姓，在某个集合内获取的！\n\n再取的名字（根据字数，取得的数量不同）。\n\n![](1536906389_image40.png)\n\n\n\n# SQL编程--存储过程\n\n## 存储过程(procedure)\n\n与函数类型，都是一个功能模块的代码！\n\n相对于函数，函数，倾向于某个功能点。\n\n而 存储过程，倾向于某个业务逻辑的整体实现！\n\n**功能点**：自由得到用户名，函数\n\n\n\n**业务逻辑**：向 select\\_student 表内，插入1W条测试数据！，过程\n\n### 语法\n\n函数：`create function`\n\n过程：`create procedure`\n\n**创建**\n\n```\ncreate procedure 过程名 (参数列表)\n\nbegin\n\n过程体，执行代码的集合\n\nend\n```\n\n**注意没有返回值**\n\n![](1536906389_image41.png) \n\n调用\n\n不能直接调用！需要使用 **call** 关键字 调用 存储过程：\n\n![](1536906389_image42.png)\n\n过程，是一个独立的业务逻辑，不能出现在表达式内。\n\n\n\n## 存储过程的参数\n\n功能类似函数的参数，也是在运行时传递数据。\n\n但是，参数是分成 **三种** 类型：\n\n### 输入，in\n\n调用过程时，给过程传递数据，就是输入参数\n\n![](1536906389_image43.png)\n\n使用过程来得到某个数的阶乘！\n\n![](1536906389_image44.png)\n\n### 输出，out\n\n调用过程之后，可以利用该参数，将数据传递出来！\n\n![](1536906389_image45.png)\n\n![](1536906389_image46.png)\n\n### 输入输出，inout\n\n同时完成 输入 和 输出功能。既可以输入数据，也可以输出数据！\n\n利用：**in**，**out**，**inout**来声明参数，最像 php中 引用传递！\n\n![](1536906389_image47.png)\n\n![](1536906389_image48.png)\n\n![](1536906389_image49.png)\n\n\n\n**典型，**可以利用过程，增加测试数据：\n\nselect\\_student这个表中写入1W\n\n**案例**：往某个表中写入1W条数据\n\n1W条学生数据！\n\n![](1536906389_image50.png)\n","categories":["Mysql"]},{"title":"MySQL 视图","url":"%2Fposts%2F932476632%2F","content":"\n\n## MySQL 视图\n\n**视图，view**\n\n视图，是一张表，但是虚拟表！\n\n是通过 一条 查询语句 得到一个张虚拟表！\n\n因此，认为视图，就是 select语句的结果！\n\n\n\n## 创建视图\n\n视图的本质是SQL指令（select语句）\n\n基本语法：`create view 视图名字 as select指令;` //可以是单表数据，也可以是连接查询，联合查询或者子查询\n\n![](view1.png)\n\n查看视图结构：视图本身是虚拟表，所以关于表的一些操作都适用于视图\n\n比如有一个用户是超级管理员 我们可以给其看到所有的数据\n\n普通用户我只想给其一个查看 学生姓名 、学生的所在班级\n\n![](view2.png)\n\n\n\n## 使用视图\n\n视图是一张虚拟表：可以直接把视图当做\"表\"操作，但是视图本身没有数据，是临时执行select语句得到对应的结果。视图主要用户查询操作。\n\n基本语法：`select 字段列表 from 视图名字 [字句];`\n\n\n\n## 修改视图\n\n修改视图：本质是修改视图对应的查询语句\n\n基本语法：`alter view 视图名字 as 新select指令;`\n\n\n\n## 删除视图\n\n基本语法：`drop view 视图名字;`\n\n![](view3.png)\n\n\n\n## 视图算法(执行方式)\n\n**算法(algorithm)**\n\n**场景**\n\n取得每个班级最高的学生信息\n\n先将my\\_student 表中的记录按照money字段进行降序排序 然后将其作为一个view表\n\n![](view4.png)\n\n然后再对v\\_stu\\_select 这个view表按照c\\_id进行分组 想取得组内的第一条记录：但是发现在结果不对\n\n![](view5.png)\n\n视图 其实一共有三种执行方式：\n\nmerge，合并\n\ntemptable，临时表\n\nundefined，未定义，就是默认的，mysql自己决定算法（从 merge，和temptable内选择）！\n\n![](view6.png)\n\n1、 merge算法是先合并后执行：group by是在order by之前执行，所以视图1是先合并后再执行，从而先执行的group by后执行order by，导致数据错误。\n\n2、 temptable算法是先执行视图：拿到的数据就是排序好的数据，然后再执行外部select，进行group by，拿到的分组第一条一定是满足要求的。\n\n注意：视图在使用过程中，如果出现了视图本身与外部select语句都有子句的情况下，要考虑是否选择temptable算法（系统倾向于使用merge）\n\n\n\n","categories":["Mysql"]},{"title":"表的设计范式","url":"%2Fposts%2F2613340531%2F","content":"\n\n# 关系（二维表）的设计规范，范式\n\n范式，**NF**，Normal Format，就是指对表的结构的要求！\n\n目的：\n\n1. 规范结构！\n2. 减少数据冗余！\n\n \n\n## 第一范式，1NF，字段原子性\n\n要求字段不能再分，要求字段的原子性\n\n原子：组成物质的最小单位，不可以再进行分割\n\n![](table_NF_01.png)\n\n----\n\n\n\n## 第二范式，2NF，非部分依赖\n\n**增加唯一主键即可！ID**\n\n \n\n范式的要求，是逐渐递增！\n\n在 满足 了 第一范式的前提下，不能出现部分依赖！\n\n \n\n**部分依赖指的是**：普通字段 对 主键 是完全依赖的，而不应该是依赖主键的一部分！\n\n依赖：可以通过那个 字段去决定另一个字段\n\n \n\n因此，出现主键部分依赖的前提是，出现 复合主键！\n\n![](table_NF_02.png)\n\n![](table_NF_03.png)\n\n \n\n消灭复合主键即可！增加一个唯一字段的主键即可。增加一个与业务逻辑毫无关系的，唯一的ID主键，\n``int unsigned primary key auto_increment``\n\n \n\n----\n\n\n\n## 第三范式，3NF，非依赖传递  反第三范式|逆第三范式\n\n在满足第二范式的前提下，取消 传递依赖，就是第三范式！\n\n \n\n**传递依赖：**如果 字段B对字段A有依赖，而字段C对字段B存在依赖。则出现了传递依赖！\n\n\n\n联表查询   效率就会很低   反第三范式\n\n![](table_NF_04.png)\n\n \n\n ","categories":["Mysql"]},{"title":"表关系","url":"%2Fposts%2F2063222971%2F","content":"\n\n# 表关系\n\n----\n\n\n\n表关系：表与表之间（实体）有什么样的关系，每种关系应该如何设计表结构。\n\n----\n\n## 一对一\n\n1：1\n\n一对一：一张表中的一条记录与另外一张表中最多有一条明确的关系：通常，此设计方案保证两张表中使用同样的主键即可\n\n \n\n**学生表**\n\n| 学生ID（PRI） | 姓名 | 年龄 | 性别 | 籍贯 | 婚否 | 住址 |\n| ------------- | ---- | ---- | ---- | ---- | ---- | ---- |\n|               |      |      |      |      |      |      |\n\n \n\n表的使用过程中：常用的信息会经常去查询，而不常用的信息会偶尔才会用到。\n\n \n\n解决方案：将两张表拆分，常见的放一张表，不常见的放一张表\n\n \n\n常用表\n\n| 学生ID（PRI） | 姓名 | 年龄 | 性别 |\n| ------------- | ---- | ---- | ---- |\n|               |      |      |      |\n\n \n\n不常用表\n\n| 学生ID（PRI） | 籍贯 | 婚否 | 住址 |\n| ------------- | ---- | ---- | ---- |\n|               |      |      |      |\n\n \n\n----\n\n## 一对多\n\n1：N  或者 N：1 \n\n一对多，通常也叫作多对一的关系。通常一对多的关系设计的方案，在“多”关系的表中去维护一个字段，这个字段是“一”关系的主键。\n\n \n\n``班级表  学生表  ``\n\n![](table_relation_01.png)\n\n![](table_relation_02.png) \n\n一对多或者是多对一 应该是多的这一个表中 要新建一个字段来保存另外一端的所属ID 字段\n\n----\n\n## 多对多\n\n \n\n多对多：一张表中的一条记录在另外一张表中可以匹配到多条记录，反过来也一样。\n\n\n多对多的关系如果按照多对一的关系维护：就会出现一个字段中有多个其他表的主键，在访问的时候就会带来不便。\n\n \n\n``班级表  讲师表`` \n\n![](table_relation_03.png)\n\n\n既然通过两张表自己增加字段解决不了问题，那么就通过第三张表来解决。\n\n \n\n![](table_relation_04.png)\n\n\n**多对多解决方案；**增加一个中间表，让中间表与对应的其他表形成两个多对一的关系：多对一的解决方案是在“多”表中增加“一”表对应的主键字段。\n\n\n\n\n\n\n\n","categories":["Mysql"]},{"title":"MySQL 管理","url":"%2Fposts%2F1044743360%2F","content":"\n\n# MySQL 管理\n\n----\n\n## 数据的备份\n\n属于**DCL**：数据控制语言！control \n\n**备份**：就是将已有的数据复制一份，存放到其他的存储单元！\n\n常见的有：**文本备份**，**数据备份**和**sql备份**\n\n\n\n\n### 文本备份\n\n文本备份是最简单的，复制——粘贴！   \n一般认为，只适合**Myisam**存储引擎的表！   \n因为Myisam引擎的表它会将表分为**三**个部分来进行存储    \n\n文本备份的缺点：   \n每次都需要备份整个全部文件，非常浪费磁盘空间！\n\n![](mysql_manage_01.png)\n\n\n\n\n### 数据备份\n\n就是只备份一张表的数据部分！\n\n采用这种备份方式，如果误删了表的全部记录，还可以还原（也就是误使用delete语句），但是如果将整个表都删除了（误使用drop），不能还原！\n\n#### 备份语法\n\n``select  *|字段列表  into  outfile 文件地址  from 表名; ``\n\n```mysql\nselect * into outfile 'd:/stu.sql' from stu;\n```\n\n![](mysql_manage_02.png)\n\n\n\n#### 还原语法\n\n``load data infile 文件路径  into  table 表名[字段列表];``\n\n```mysql\nload data infile 'd:/stu.sql' into table stu;\n```\n\n----\n\n\n### 数据的导出工具 mysqldump\n\n将表的结构和数据通过sql语句的形式进行备份！\n\nmysql中有一个专门用来sql备份的客户端 ``mysqldump.exe``！ 位于bin目录下，不需要登录即可使用。在命令行窗口使用。\n\n#### 备份语法\n\n1 备份库\n\n```cmd\n## 备份一个库\nmysqldump  –hPup  -B  需要备份的数据库 > 指定的文件中 \n# -h 主机名，本地可省略\n# -P 端口，可省略\n# -u 用户名\n# -p 密码\n# >  输出重定向\n\n##示例\nmysqldump -u root -p -B studb > d:/studb.sql \n```\n\n2  备份表 \n```cmd\n## 一次备份一个表\nmysqldump  –hPup   数据库 表名 > 指定的文件中  \n\n## 一次备份多个表\n# 表名之间是使用空格分隔\nmysqldump  –hPup   数据库  表名1  表名2  表名n > 指定的文件中  \n\n# -h 主机名，本地可省略\n# -P 端口，可省略\n# -u 用户名\n# -p 密码\n# >  输出重定向\n\n## 示例\nmysqldump -u root -p -B studb stu1 > d:/studb.sql \nmysqldump -u root -p -B studb stu1  stu2 > d:/studb.sql \n```\n\n\n#### 还原语法\n\n```mysql\n## 导入到指定库中\nmysql  –hPup 数据库名 < 备份路径\n# -h 主机名，本地可省略\n# -P 端口，可省略\n# -u 用户名\n# -p 密码\n# <  输入重定向\n\n## source 还原备份(需要登录mysql)\n#  可以在mysql客户端登陆后，使用 source 指令，来强制执行一个文件内的sql语句！\n#  使用source这个命令导入文件时，文件名不需要加引号 \nsource 备份路径;\n\n\n##示例\nmysql -u root -p  studb < d:/studb.sql \n\nsource d:/studb.sql \n```\n\n----\n\n\n\n## 用户和权限管理\n\n**用户权限管理**：在不同的项目中给不同的角色（开发者）不同的操作权限，为了保证数据库数据的安全。\n\n \n\n通常，一个用户的密码不会长期不变，所以需要经常性的变更数据库用户密码来确保用户本身安全（mysql客户端用户）\n\n \n\n### 用户管理\n\nMysql需要客户端进行连接认证才能进行服务器操作：需要用户信息。Mysql中所有的用户信息都是保存在mysql数据库下的``user``表中。\n\n![](mysql_manage_03.png)\n\n\n![1530181955777](mysql_manage_04.png)\n\n默认的，在安装Mysql的时候，如果不选择创建匿名用户，那么意味着所有的用户只有一个：root超级用户 \n\n\n在mysql中，对用户管理中，是由对应的**Host**和**User**共同组成**复合主键**来区分用户。   \n``User``：代表用户名。    \n``Host``：代表允许访问数据库的客户端（IP或者主机地址）。如果host使用%代表所有的用户（客户端）都可以访问。   \n\n\n\n#### 创建用户\n\n基本语法：\n```mysql\n-- 使用 create user 语句创建用户\ncreate user 'username' identified by '明文密码';\n-- 或\ncreate user 'username'@'host' identified by '明文密码';\n\n-- -------------------------------------------------------------------------------\n-- 使用 grant 语句创建用户\n-- TODO \n\n\n-- -------------------------------------------------------------------------------\n-- 直接操作mysql数据表(不推荐)\n-- 必须拥有对mysql.user表的insert权限\n-- TODO:有些版本可能某些字段不同\n-- insert into mysql.user(Host,User,Password,[privilegelist]) \n-- values('host','username',password('pwd'),privilegevaluelist);\n\n```\n**用户** ： 可以是 ``'用户名'`` 或``'用户名'@'主机地址'``     \n**主机地址**：  省略时默认为`` %``  ，即所有主机可访问此账户。   \n``privilegelist``  权限字段   \n``password()``  加密密码   \n``privilegevaluelist`` 对应的权限的值\n\n\n\n示例：\n\n```mysql\n-- create user 语句创建localhost主机才可用的用户\ncreate user 'bb'@'localhost' identified by '123456';\n\n-- create user 语句创建任何主机都可用的用户\n create user 'aa' identified by '1111';\n \n```\n\n\n\n\n\n#### 删除用户\n\n基本语法：\n\n```mysql\n-- 使用 drop user 语句删除用户(推荐)\ndrop user 'username'@'host'; \n-- 或\ndrop user 'username'[,'username2',...]; \n\n-- -------------------------------------------------------------------------------\n-- 使用 delete 语句删除用户\ndelete from mysql.user where host='host' and user='username';\n```\n\n示例：\n\n```mysql\n-- 使用 drop user 语句删除用户\ndrop user 'bb'@'localhost';\n-- 或\ndrop user 'aa';\n\n-- 使用 delete 语句删除用户\ndelete from mysql.user where host='localhost' and user='bb';\n```\n\n\n\n\n\n#### 修改密码\n\nMysql中提供了多种修改的方式：基本上都必须使用对应提供的一个系统函数：``password()``，需要靠该函数对密码进行加密处理。 \n\n\n\n##### 普通用户修改密码\n\n普通用户登录后，通过``set``语句设置自己的密码。\n\n```mysql\nset password = password('new_password');\n-- TODO ： 某些版本可能无法使用 password(),改用如下\nset password = 'new_password';\n```\n\n``'new_password'``  新密码\n\n\n\n##### root用户修改普通用户密码\n\n```mysql\n-- 使用 set 语句修改\nset password for 'username'@'host' = password('new_password');\nset password for 'username' = password('new_password');\n\n-- 使用 set 语句修改  无法使用password()时，改用如下(推荐)\nset password for 'username'@'host' = 'new_password';\nset password for 'username' = 'new_password';\n\n-- -------------------------------------------------------------------------------\n-- 使用 update 语句修改(不推荐)\n-- TODO:有些版本可能某些字段不同\n-- update mysql.user set Password=password('new_password')\n-- where User='username' and Host='host';\n\n-- -------------------------------------------------------------------------------\n-- 使用 grant 语句修改\n-- 使用 grant usage 语句(*.*)指定某个账户密码而不影响其权限\n-- grant usage on *.* to 'username'@'host' identified by 'new_password';\n-- grant usage on *.* to 'username' identified by 'new_password';\n```\n\n\n\n##### root用户修改root的密码\n\n```mysql\n-- 使用 set 语句修改\nset password = password('new_password');\n-- TODO ： 某些版本可能无法使用 password(),改用如下\nset password = 'new_password';\n\n-- -------------------------------------------------------------------------------\n-- 使用 mysqladmin 命令在命令行中指定新密码\n\n\n-- -------------------------------------------------------------------------------\n-- 修改 mysql.user 表\n\n```\n\n\n\n#### root 密码丢失的解决方案\n\n如果忘记了root用户密码，就需要去找回或者重置root用户密码\n\n\n1  **使用 --skip-grant-tables 选项启动mysql服务**\n\n首先，停止mysql服务 。   \n\n**启动服务器但是跳过权限**，当前启动的服务器没有权限概念：非常危险，任何客户端，不需要任何用户信息都可以直接登录，而且是**root**权限。\n\nWindows 中，如果mysql目录添加到环境变量中，可直接使用 ``mysqld``或``mysqld-nt``来启动服务，否则，在bin目录使用如下命令：\n```mysql\n-- mysqld 命令\nmysqld --skip-grant-tables\n\n-- mysqld-nt 命令\nmysqld-nt --skip-grant-tables\n```\n\nLinux 中，使用``mysqld_safe``或使用 ``/etc/init.d/mysql``命令来启动服务\n```mysql\n-- mysqld_safe 命令\nmysqld_safe --skip-grant-tables user=mysql\n\n-- /etc/init.d/mysql 命令\n/etc/init.d/mysql start-mysqld --skip-grant-tables\n```\n启动mysql服务后，就可以用root用户登录了\n\n\n2 **使用root登录，重置密码**\n```mysql\n-- widows:无需密码登录root\nmysql -u root\n```\n登录成功后，可修改root的密码，参考 **root修改root的密码** 章节。\n\n\n3 **加载权限表**\n\n修改密码后，必须用如下语句加载权限表，新的密码才能生效，同时mysql服务器开始权限验证。\n\n```mysql\nflush privileges;\n```\n\n之后，将``mysqld --skip-grant-tables``的窗口关闭，即可使用新密码来登录mysql。\n\n \n\n### 权限管理\n\n在mysql中将权限管理分为三类：\n\n1、  数据权限：增删改查（select|update|delete|insert）   \n2、  结构权限：结构操作（create|drop）   \n3、  管理权限：权限管理（create user|grant|revoke）：通常只给管理员如此权限   \n\n\n\n#### 授予权限：grant\n\n将权限分配给指定的用户\n\n基本语法：``grant 权限列表 on 库名.表名 to 用户;``   \n**权限列表**：使用逗号分隔，但是可以使用``all privileges``代表全部权限   \n**数据库.表名**：可以是单表(``数据库名字.表名``)，可以是具体某个数据库(``数据库.*`` )，也可以整库（``*.*``）\n\n![img](mysql_manage_05.png)\n\n\n\n#### 取消权限：revoke\n\n权限回收：将权限从用户手中收回\n\n基本语法：``revoke  权限列表 on  库名.表名  from '用户名' [@主机地址];``\n\n![](mysql_manage_06.png)\n\n\n\n#### 刷新权限：flush\n\nFlush：刷新，将当前对用户的权限操作，进行一个刷新，将操作的具体内容同步到对应的表中。\n\n基本语法：``flush privileges;``\n\n\n\n\n\n\n\n","categories":["Mysql"]},{"title":"MySql  数据库操作","url":"%2Fposts%2F4146397750%2F","content":"\n\n# MySql  数据库操作\n\n----\n\n\n\n## 概述\n\n\n\n**SQL (Structured Query Language)**，结构化查询语言，是数据库系统的通用语言。\n\n\n**数据查询语言(Data Query Language, DQL)** \n只查询数据，不改变数据库中的数据，命令动词有 Select\n\n\n**数据定义语言(Data Definition Language,DDL)** \n创建、修改或删除数据库中的各种对象，包括表、视图、索引等。命令动词有  Create   Drop  Alter\n\n\n**数据操纵语言(Data Manipulation Language,DML)**  \n对数据库中的数据的插入、删除、修改等，命令动词有 insert   update  delete  \n\n\n**数据控制语言(Data Control Language,DCL)**  \n权限管理、控制事务、对数据库进行监视等，命令动词有  grant  revoke\n\n----\n\n\n\n## 库操作\n\n### 创建数据库\n\n```mysql\ncreate database 库名  [库选项];\n```\n库选项，指字符集的设置，可选。\n\n![](mysql_character_collation.png)\n\n\n每个库，会对应一个数据目录，存放在当前mysql配置的数据库目录内。\n\n![](mysql_datadir.png)\n\n\n\n**数据库名的问题**\n\n**大小写**，取决于mysql服务器所在的操作系统！（**建议是**，认为区分大小写） \n**特殊名称，关键字，特殊字符等**，默认是不可以的！ \n\n但是，可以使用 反引号(~按键) 将 名称 包裹起来，告知服务器，此处一个名字，而不是特殊操作！ \n中文等都可以作为标识符（库名），同样需要反引号！（多字节字符，还需要注意字符集的问题）\n\n\n\n### 查看数据库\n\n```mysql\n-- 查看已存在的所有库，复数(s)\nshow databases;\n\n-- 查看数据库的定义语句\nshow create database 库名;\n```\n**模糊查询**\n```mysql\nshow databases  like '模式';\n```\n\n**like** 关键字 用于过滤多个数据库，通常与通配符一起使用。\n\n\n``% `` 匹配任意字符的任意次数（包括0次）的组合  \n``_`` 匹配任意一个字符 \n\n![](show_databases_like.png)\n\n\n\n### 修改数据库\n\n```mysql\n-- 修改数据库选项\nalter database 库名 [库选项];\n```\n库选项，指字符集的设置，可选。\n\n![1529673315095](alter_database.png)\n\n\n\n### 删除数据库\n\n```mysql\n-- 删除数据库\ndrop database 库名;\n```\n删除数据库后那么对应的存放数据库的的文件夹也同样被删除！\n\n----\n\n\n\n## 表操作\n### 创建表\n```mysql\n-- 在创建表之前一定要选择指定的数据库：\nuse 库名;\n```\n```mysql\n-- 创建表\ncreate table 表名 (\n字段的定义,\n字段的定义\n) [表选项];\n```\n\n其中表名，一定先要确定数据库！因此一个典型的表名是由两部分组成：\n\n``所在库.表名``\n\ntest.itcast       test库内itcast表  \nitcast.stu         itcast库内的stu表\n\n\n\n但是我们可以使用``use``设置默认数据库，如果不指定则使用默认数据库（即当前数据库）\n在使用 表名 但是没有指明其所在数据库时，默认数据库才会起作用！\n\n**字段**才是最终的数据的载体（与变量的概念是类似的，都是保存数据的），SQL的是强类型，字段的类型是固定的，提前定义好的！\n\n因此，在定义字段时，至少要字段名 和 字段类型！\n\n两种最基本的mysql数据类型（**int**， **varchar,varchar**必须指定最大长度，单位：字符。int可以省略长度）\n\n\n\n**表选项部分**   \n典型的常用的表选项有： \n字符集，表引擎(**myisam**   **innodb** )\n\n```mysql\ncreate table my_table(\nname varchar(20),\nage int\n)engine=MyISAM charset=gbk;\n```\n\n\n\n### 查看表\n\n```mysql\n-- 查看当前数据库所有表\nshow tables;\n\n-- 模糊查询\nshow tables like  '模式';\n\n-- 查看表的定义语句\nshow create table 表名;\n\n-- 查看表结构\ndesc 表名;\n```\n\n``desc``   describe 的简写，描述 。\n\n\n\n**like** 关键字 用于过滤多个表，通常与通配符一起使用。\n\n\n``%`` 匹配任意字符的任意次数（包括0次）的组合  \n``_`` 匹配任意一个字符 \n\n\n在mysql的命令行客户端，如果数据过多，不容易展示！可以使用  ``\\G``  作为语句结束符！\n\n![](desc_table.png)\n\n\n\n### 修改表\n#### 修改表选项\n\n```mysql\nalter  table  表名  [新选项];\n```\n\n![](alter_table_option.png)\n\n\n\n#### 修改表名\n\n```mysql\nrename  table  原表名  to  新表名;\n```\n\n注意，表名可以由``库名.表名`` 形式的！ \n因此，可以跨库修改表名，只要在表名前增加 库名即可\n\n\n\n#### 修改表结构\n\n##### 增加字段\n\n```mysql\nalter  table  表名  add  column  字段定义  [字段位置];\n```\n\n``[字段位置]``\n\n如果不指定其位置 添加的字段会默认在该表最后面！ \n使用关键字 **after** **字段名**  或 使用关键字，**first**  。如：\n\n```mysql\n-- after   在指定字段的后面\nalter table my_table add column num int after name;\n\n-- first   在最前面，后面无需指定字段\nalter table my_table add column id int first; \n```\n\n\n\n##### 修改字段\n\n```mysql\n-- 修改字段的定义，可用 after 或 first 关键字，在后面\nalter  table  表名  modify  column  字段名  新的定义 [位置];\n\n-- 示例\nalter table my_table modify column age varchar(20) first;\n```\n\n\n\n##### 删除字段\n\n```mysql\nalter  table  表名  drop  column  字段名;\n\n-- 示例\nalter table my_table change column name new_name varchar(10);\n```\n\n\n\n##### 字段改名\n\n```mysql\n-- 字段改名\n-- 需要在改名的同时修改定义，不变的话要原样输入\nalter  table  表名  change  column  原字段名  新字段名  新字段定义;\n```\n\n\n\n#### 删除表\n\n```mysql\n-- 删除表 \ndrop table 表名;\n\n-- 可使用  if exists ，表存在才执行命令\ndrop table if exists 表名;\n```\n\n----\n\n\n\n## 数据操作\n### 增加数据\n\n增加 创建 插入 数据(记录)\n\n```mysql\n-- 插入单条记录\n-- 标准语法\ninsert into table_name (column_list) values(value_list);\n\n-- 扩展语法\ninsert into table_name set column_1=value_1,column_2=value_2,... column_n=value_n;\n\n\n-- 同时插入多条记录,逗号分隔\ninsert into table_name (column_list) \nvalues(value_list),\n\t  (value_list),\n\t  (value_list);\n```\n\n``table_name``    表名  \n``column_list``  字段列表，逗号分隔，可省略，表示在值列表中要插入所有字段。 \n``value_list``    值列表，逗号分隔，要与字段对应。    \n``column_n``        字段n   \n``value_n``   \t 值n   \n\n\n\n**注意**：字段与值的数量一定要匹配。数值类型，通常不需要增加引号！ 而字符串类型都需要出现引号内（单引号）。\n\n![](insert_column.png)\n\n\n\n**蠕虫复制**  \n就是在已有的数据的基础之上，将原来的数据进行复制，插入到对应的表中！\n\n语法：\n``insert  into  表名(字段列表)  select *|字段列表 from 表名;``\n\n``(字段列表)``   可省略，即，数据插入所有字段中。   \n`` * | 字段列表 ``    可用 * 或 指定字段\n\n注：表名可相同，即本表的数据查询并追加到本表。\n\n```mysql\n-- 蠕虫复制\ninsert into my_table select * from my_table2;\n\n```\n\n\n\n\n\n### 查询数据\n\n查询  检索  数据(记录)\n\n```mysql\n-- 简单的查询语法\nselect column_list from table_name [where condition];\n```\n``column_list``  字段列表，使用 * 表示 所有字段  \n``table_name``    表名  \n``condition``     条件表达式，默认是没有，表示永远为真，建议添加``where 1`` \n\n\n\n### 更新数据\n\n```mysql\nupdate table_name set column_1=newValue_1, column_n=newValue_n  [where condition]\n```\n\n``table_name``    表名   \n``column_1``      字段1   \n``newValue_1``     新值1  \n``condition``     条件表达式，可以省略。**表示永远为真**。  \n\n每个``字段=值`` 之间逗号分隔   \n**注意** ：在修改和删除记录的时候一定要加指定的条件！ \n\n类似于 删除，也可以使用 ``order by ``和 ``limit ``确定更新的记录！ \n\n\n\n### 删除数据\n\n```mysql\ndelete from table_name [where condition];\n```\n``table_name``    表名  \n``condition``     条件表达式，可以省略。**表示永远为真，即删除所有记录**。   \n\n\n**注意，**删除是不可逆的。要避免没有条件的删除！\n\n```mysql\n-- delete时，支持 order by 和 limit 来限制删除的数据记录!\ndelete from stu order by height desc limit 1;\n```\n\n如果清空表，此时可以独立使用`` truncate ``语句，完成清空表    \n``truncate 表名`` 先将表给删除，然后再重新创建一张表，即 主键可重置。   \n\n通常用于清除测试数据。\n\n```mysql\ntruncate stu;\n```\n\n \n\n----\n\n\n\n## 额外的操作 \n\n在  create  与 drop 时，有两个额外的操作：\n\n* `if not exists`  如果不存在\n* `if exists`   如果存在\n\n```mysql\n-- 如果不存在则创建\ncreate database if not exists 库名;\n\n-- 如果存在才删除\ndrop database if exists 库名;\n```\n\n```mysql\n-- 选择数据库\nuse 库名;\n```\n\n\n\n----\n\n\n\n# 事务(transaction)\n\n一组 SQL 的集合，要不集体都执行成功，要不集体都失败，指的是，应该生成的影响退回到改组sql执行之前！\n\n往往一个业务逻辑，是由多条语句组合完成！\n\n## 语法\n\n**开启事务：** `start transaction`   可以简写成\\[ `begin`\\]\n\n记录下来，之后所执行的sql！（操作与结果）\n\n**提交：**`commit`\n\n如果所有的sql都执行成功，则提交。将sql的执行结果持久化到数据表内！\n\n**回滚：**`rollback`\n\n如果存在失败的sql，则需要回滚。将sql的执行结果，退回到事务开始之前\n\n无论 回滚还是提交，都会关闭该事务！（需要再次开启，才能使用）\n\n**事务在没有进行提交与回滚之前，只针对当前的 连接生效！如果已经提交或者是回滚那么所有的连接都生效！**\n\n开启一个A连接：\n\n![](1536906389_image5.png)\n\n让学生表中的李莫愁这个字段的money +1000\n\n![](1536906389_image6.png)\n\n提交之后 A连接\n\n![](1536906389_image7.png)\n\n![](1536906389_image8.png)\n\n开启一个B连接：\n\n![](1536906389_image9.png)\n\n![](1536906389_image10.png)\n\n## 事务的基本原理(autocommit)\n\n\n\n提交，就会将结果持久化，不提交不会！\n\n**如果不开启事务**，执行一条sql，马上会持久化数据！\n\n可见，普通的执行，是立即提交！\n\n![](1536906389_image11.png)\n\n修改**autocommit**这个内置变量的值\n\n`show variables like 'character-set-%';`\n\n![](1536906389_image12.png)\n\n因为，默认的mysql对sql语句的执行是自动提交的！\n\n![](1536906389_image13.png)\n\n开启事务其实就是，关闭了自动提交的功能！改成了**commit**执行手动提交！\n\n因此，可以通过简单的对 是否自动提交 加以设置，可以完成开启事务的目的！\n\n自动提交的特征是保存在服务的一个叫做 autocommit的一个变量内的！\n\n使用` set 变量名=变量值` 的形式就可以完成修改：\n\n![](1536906389_image14.png)\n\n**注意：**==事务类似于外键约束，只被innodb引擎支持！==\n\n\n\n## 事务的特点(ACID)\n\n**原子性，一致性，隔离型，持久性**\n\n**原子性**：事务是不可分割的。\n\n**一致性**：保证数据在 事务的执行周期内，是一致的！\n\n**隔离型**：多个事务之间的干扰关系！隔离级别！\n\n**持久性**：事务一旦被提交，就不可能在被回滚！\n\n","categories":["Mysql"]},{"title":"MySQL 高级查询","url":"%2Fposts%2F885461339%2F","content":"\n\n# MySQL 高级查询\n\n----\n\n\n\n## 数据查询\n\n查询数据是整个业务逻辑中使用的最多而且也是最复杂的！\n\n\n```mysql\nselect [字段表达式列表子句][from子句] [where 子句][group by 子句] [having 子句][order by子句] [limit 子句]\n```\n\n**七子句**    \nfrom子句的后面的子句称五子句\n\n**注意它们的书写顺序不能乱。**\n\n----\n\n### 字段表达式列表子句\n\n\n```mysql\n-- 示例\n-- 5+10 \nselect 5+10;\n\n-- now()\nselect now();\n\n-- 使用 as 关键字指定别名\nselect now() as n;\n```\n\nas关键字可以省略 不建议省略    \n凡是涉及到表达式到一定会牵扯到一个问题：优先级  \n加上小括号，可提升优先级。 \n\n----\n\n### from子句\n\n表示**查询的来源**，通常是表！\n\n![](mysql_select_01.png)\n\n1，  可以写**表名列表**，使用逗号分割。\n\n ```mysql\nselect * from my_table1,my_table2;\n ```\n\n\n\n如果此时没有条件，相当于形成了一个 笛卡尔积！  \nA表的所有记录，都与B表的所有记录之间存在关联！  \n\n![](mysql_select_02.png)\n\n出现了同样的字段名  可以用``as``关键字给字段取别名 \n\n```mysql\nselect stu.id as s_id,class.id as c_id, name,class_name from stu,class;\n```\n\n\n\n2，  表的别名    \n\n如果多次出现 ``表名.字段名``的情况，可以为表名起别名！ \n\n如下``s.id`` 中的 ``s``使用的是后面定义的表别名\n\n```mysql\nselect s.id as s_id,c.id as c_id, name,class_name from stu as s,class as c;\n```\n\n\n\n3，  dual 虚拟表   \n\n```mysql\nselect 3+5 from dual;\n```\n\n----\n\n### where子句\n\nwhere 条件表达式\n\n省略where子句，相当于永远为真\n\n```mysql\n-- 永远为真\nselect * from stu;\n```\n\n\n\n#### 比较运算符\n\n``>       <       >=     <=   !=     =``\n\n```mysql\n-- 查询stu表中id>4的所有记录\nselect * from stu where id > 4;\n```\n\n\n#### 模糊查询\n\n使用``like``关键字进行模糊查询    \n可以使用 ``% ``和 ``_ ``作为通配符\n\n``%`` 匹配任意字符的任意次数（包括0次）的组合  \n``_`` 匹配任意一个字符 \n\n ```mysql\n-- like 像\nselect * from stu where sex like 'fe%';\n-- not like  不像，取反\nselect * from stu where sex not like 'fe%';\n ```\n\n\n#### between  and \n\n范围比较，而且是闭区间！   \n比如，``between 5 and 10``，相当于数学上的[5,10]\n\n```mysql\n-- 在 2和4之前\nselect * from my_table where id between 2 and 4;\n-- 等价于\nselect * from my_table where where id >=2 and id <=4;\n```\n\n#### in与not in\n\n都属于集合运算符，用于判断前面的元素是否在或不在一个集合当中！   \n\n批量删除这个操作用的特别多。\n\n\n\n**in**，在某个集合之内\n\n``in (元素列表)``\n\n```mysql\nselect * from stu where id in(3,4,8);\n```\n\n\n\n**not in**，不在某个集合内\n\n``not in (元素列表)``\n\n```mysql\nselect * from stu where id not in(3,4,8);\n```\n\n\n\n#### null 值的判断\n\n不能使用普通的运算符，因为运算的结果都是null，而且不能作为查询条件！\n\n![](mysql_select_04.png)\n\n\n\n应该使用 ``is null`` 或者 ``is not null`` 来判断！\n\n```mysql\n-- is null  是空值\nselect * from stu where id is null;\n\n-- is not null  不是空值\nselect * from stu where id is not null;\n```\n\n函数 （``isnull()``）也可以完成类似的判断\n```mysql\n-- isnull()  是空值\nselect * from stu where isnull(id);\n\n--  ! isnull()  不是空值\nselect * from stu where !(isnull(id));\n```\n\n----\n\n### group by子句\n\n\n对查询结果（已经通过where子句过滤之后的数据），按照某个字段，进行分组！   \n\n 语法：``  group by  字段``\n\n\n\n在分组的结果中，只会显示组内的头一条记录！因此，通常，分组之后的数据，除了分组的字段外，其他字段的逻辑含义很轻！ \n\n 分组的作用，不在查询每个组内的具体数据。而其作用主要是在**分组统计**上。\n\n#### 统计函数（聚合函数）\n\n**count()**：求某个组内非null记录的个数。\n\n通常就用count(*)来表示  统计记录数。典型的使用是 count(*)，但是除了*之外，是可以使用字段名的！\n\n```mysql\nselect count(*) as c from my_table where 1 group by id;\nselect count(age) as c from my_table where 1 group by id;\n```\n\n\n\n**sum()**：求和。 \n先根据某个或某几个字段进行分组，然后再对每一个组的某个字段进行相加！\n\n```mysql\nselect sum(age) from my_table where 1 group by id;\n```\n\n\n\n**max()**：求某个组内某个字段的最大值 \n\n```mysql\nselect max(age) from my_table where 1 group by id;\n```\n\n\n\n**min()**：求某个组内某个字段的最小值 \n\n```mysql\nselect min(age) from my_table where 1 group by id;\n```\n\n\n\n**avg()**：求某个组内某个字段的平均值 \n\n```mysql\nselect avg(money) from my_table where 1 group by id;\n```\n\n\n\n#### 分组后排序\n\n分组成默认是升序(``ASC ``)    \n\n``DESC`` 降序 \n\n\n语法：\n\n ``group by 字段名  ASC|DESC ``\n\n```mysql\nselect * from my_table where 1 group by id desc;\n```\n\n\n\n#### 多字段分组\n\n``group by 字段1，字段2……``\n\n```mysql\nselect * from my_table where 1 group by id,age desc;\n```\n\n\n\n#### 回溯统计\n\n*回溯（su）统计*\n\n其实就是向上统计！   \n在进行分组统计的时候，往往需要做向上统计！   \n\n比如，先统计各个班的最高分，然后就可以将各个班的最高分再进行一次统计，可以得到全年级的最高分！\n\n \n\n在MySQL中，也支持回溯统计，其实就是在group by语句的后面加上``with rollup``即可！\n\n```mysql\nselect * from my_table where 1 group by id with rollup;\n```\n\n----\n\n### having子句  \n\n功能上与where类似，都是条件子句！通常与聚合函数配合使用。   \n\n主要的区别，在于执行时机：\n\n**where**，是开始时，从数据源中检索数据的条件。   \n**having**，是在筛选，分组之后，在得到的结果中，再次进行筛选的语法！   \n**因此 having的结果 一定是 where 已经 过滤之后的结果!**   \n\n```mysql\nselect avg(money) as m from my_table where 1 group by id having m>2000;\n```\n\n----\n\n### order by 子句\n\n对结果进行**排序**的语句！\n\n**语法：**\n\n``order by 字段名 [asc|desc], [字段名 [asc|desc],...]``\n\n``asc``  升序  `` desc`` 降序\n\n```mysql\nselect * from my_table order by id desc;\n```\n\n可按照多个字段进行排序 \n\n```mysql\n-- 先让 id 排序，再让 age 排序\nselect * from my_table order by id desc, age asc;\n```\n\n----\n\n### limit 子句\n\n限制 结果记录的数量！   \n从所有的结果中，选择部分结果的字句。\n\n\n\n可以从 某个位置开始，取得多少条！\n\n语法：  \n\n``limit  start,  size;``\n\n``start `` ：起始位置   \n``size``：取得的记录数\n\n```mysql\n-- 从第2条记录开始，获取5条记录\nselect * from my_table where 1 limit 1,5;\n```\n\n\n\n记录的起始下标为0\n\n![1530108083300](mysql_select_05.png)\n\n**注意**，第二个参数是 长度，而不是 终止位置！\n\nlimit使用的最多的地方就是用在分页！取得数量可理解为每页显示的数量。\n\n----\n\n\n\n## 子查询\n\n### 概念\n\n简单来说，所谓的**子查询**，就是一条select语句中又出现了其他的select语句！\n\n**要求：**子查询的语句必须用一对括号括起来！\n\n```mysql\nselect * from stu where height=(select height from stu order by height desc limit 0,1);\n```\n\n\n\n### 子查询的分类\n\n\n两种分类依据：\n\n1 依据 子查询出现的位置！   \n**where型子查询 **， 出现在where子句内！   \n**from 型子查询**， 出现在from子句内！   \n\n \n\n2 依据 子查询的返回数据的格式！   \n**标量子查询**，返回值是一个数据，称之为标量子查询！   一行一列的二维表   \n**列子查询**，返回一个列，多行一列的二维表   \n**行子查询**，返回一个行，一行多列的二维   \n**表子查询**，返回的是一个二维表   \n\n\n\n\n#### from型  表子查询\n\nfrom型子查询一般就是当成一张表来使用，而且大部分出现在from之后，作为数据源！\n\n```mysql\nselect * from (select * from stu where 1) as temp where 1 group by temp.id;\n```\n\n\n\n#### 列子查询\n\n我们通常把列子查询的结果当成一个集合来使用！\n\n所以，通常就是配合``in``或``not in``来使用列子查询！\n\n![](mysql_select_06.png)\n\n\n\n#### 行子查询\n\n一次性查出来一个行（多个行）使用 行进行匹配   \n\n![](mysql_select_07.png)\n\n\n\n### exists型子查询\n\n\nexists子查询的目的不是为了产生结果集，只是用来判断某个子查询是否查询到了数据！   \nexists子查询返回的是一个布尔值！   \n\n如果查询到了结果，就返回true（1），如果没有查询到数据，就返回false（0）   \n\nexists出现在where条件里面 \n\n![](mysql_select_08.png)\n\n\n\n---\n\n\n\n## 连接查询\n\n连接，多个表记录之间的连接！    \n\n关键字 ： ``join``    \n\n   \n\n\n**语法：**   \n``from 表名1  join   表名2  on 连接条件``\n\n``join`` ，连接   \n``on`` ，连接条件   \n\n   \n\n**分类：**    \n内连接   \n外连接(左外连接，右外连接)   \n交叉连接   \n自然连接   \n\n\n\n### 内连接，inner join\n\n记录与真实的记录连接，称之为内连接！（**两条真实存在的记录的连接**）\n\nmysql默认的连接就是 ``inner join``\n\n![](mysql_select_09.png)\n\n \n\n内连接，可以连接省略条件！   \non 可以省略：相当于连接条件永远成立！   \n返回值是一个 **笛卡尔积！**\n\n\n\n### 外连接，left join，right join\n\n分成：左外连接``left join``，右外连接``right join``\n\n连接的记录，可能是一方不存在的！（两条记录中，可能某条不存在）   \n**注意：外连接一定要有连接的条件**\n\n![](mysql_select_10.png)\n\n\n\n内连接，外连接差别不大，只是外连接会将没有连接成功的记录，也出现最终的连接的结果内，而内连接，连接的结果只有连接成功的（两条记录都存在的）   \n\n\n\n**什么是左表** **和** **右表？**   \njoin关键字前面的（左边的）左表，join关键字后边的（右边的）右表！   \n\n \n\n**左外**：如果出现左表记录连接不上右表记录的，左表记录会出现正在最终的连接结果内！而右表记录相应设置成NULL。   \n\n**右外**：如果出现右表记录连接不上左表记录的，右表记录会出现正在最终的连接结果内！而左表记录相应设置成NULL。   \n\n \n\n**总结**：左外连接它是以左表为主，右外连接它是以右表为主   \n\n左右外连接其实它们可以是一样的 ，只需要换表所在的位置  \n\n\n**工作中使用最多就是左外连接**\n\n![](mysql_select_11.png)\n\n\n\n### 交叉连接，cross join\n\n结果与 内连接一致！   \n交叉连接 相当于 是 没有条件的内连接！    \n\n内连接：\n\n![](mysql_select_12.png)\n\n交叉连接：\n\n![](mysql_select_13.png)\n\n \n\n### 自然连接，natural  join\n\n自然连接它是拿多个表中**相同的字段名**来作为连接的条件    \nmysql，自动判断连接条件，帮助我们完成连接！\n\n![](mysql_select_14.png)\n\n\n\n## 连接条件，on，using\n\n``on``，后面使用一个连接条件表达式！\n\n![](mysql_select_15.png)\n\n``using(连接字段)``，要求使用同名字段进行连接！ \n\n![](mysql_select_16.png)\n\n----\n\n\n\n# union查询，联合查询\n\n将 多个查询的结果，并列到一个结果集合内！   \nunion要求两个表中的字段的数量要一样    \n如果union 联合查询，集合里面字段的值是一样的话 ，会去重     \n\n![](mysql_select_17.png)\n\n排序没有起作用\n\n![](mysql_select_18.png)\n\n解决办法，添加 ``limit ``\n\n![1530115688234](mysql_select_19.png)\n\n\n\n----\n\n\n\n# select语句的选项\n\n``distinct``，取消相同的记录，即 去重复。   \n默认是 all，可以不写，表示所有的记录都出现！ \n\n```mysql\nselect distinct age from stu;\n```\n\n","categories":["Mysql"]},{"title":"正则表达式案例","url":"%2Fposts%2F2800343177%2F","content":"\n\n# 十二、案例\n\n## 1、匹配手机号格式是否正确\n\n```javascript\n\t/*\n    手机号特点：\n        11位\n        纯数字\n        1开头\n        2 3位判断[可选，去各大运营商查询]\n     */\n    var tel = '13066668888';\n    var reg = /^1\\d{10}$/g;\n    var result = reg.test(tel);\n    console.log(result);  //true\n```\n\n匹配成功，返回true；失败返回false\n\n\n\n## 2、匹配邮箱格式是否正确\n\n邮箱的格式：\n\n1、 必须有 @\n2、 必须有  .  符号\n3、 必须有域名后缀，如（com / cn/ org / com.cn)\n4、 @前面的邮箱名，要求4~16位，可以是小写字母，数字，下划线组合，下划线不能在收尾（新浪要求）\n\n```php\n$email = \"qw3a_sdf@xx.com.cn\";\n//  ^[a-z0-9] : 限制首个字符的范围\n//  [a-z0-9]  : 末尾的这个限制最后一个字符的范围，即 下划线不能在收尾\n//  \\w+    :  结果如， xx\n//  \\.\\w+  :  结果如， .com\n//  (\\.\\w+)+ : 括号里的作为一个来匹配，结果如，  .com.cn\necho preg_match('/^[a-z0-9][a-z0-9_]{2,14}[a-z0-9]@\\w+(\\.\\w+)+$/', $email);\n```\n\n\n\n## 3、解决结巴程序（去重复）\n\n把“今今今天晚晚晚晚晚晚上吃吃吃吃吃吃鸡”字符串换成单字的形式，即“今天晚上吃鸡”；\n\n```javascript\n\tvar str = \"今今今天晚晚晚晚晚晚上吃吃吃吃吃吃鸡\";\n    //var reslut = str.replace(/([\\u4e00-\\u9fa5])\\1+/g, \"$1\"); //只替换匹配的今、晚、吃\n    var reslut = str.replace(/([\\u4e00-\\u9fa5])\\1*/g, \"$1\");//全部字符都替换\n    console.log(reslut);\n```\n\n\n\n## 4、用户名验证\n\n注册的时候，要求用户名：长度4~10位，不能是纯数字，不能是纯字母，不能有特殊符号，不能以数字打头。\n\n```javascript\n\t// 长度4~10位\n    // 不能以数字打头 \n    // 不能有特殊符号\n    // 不能是纯数字\n    // 不能是纯字母\n\n    var username = \"aaaaa4\";\n\n\t//  1，首个字符范围为  ^[a-zA-Z] 如下非()中，符合  不能以数字打头 \n\t//  2，剩余的字符范围为 [0-9a-zA-Z] ，需要的数量为 {3,9} ，控制结尾用 $\n\t//  \t1和2 为一个整体，符合了 不能有特殊符号，长度4~10位，不能是纯数字(因为开头那个不包含数字)\n\t//  3、(?!^[a-zA-Z]+$) ：此为过滤条件或排除条件，表示开头到结尾都是字母的一个整体排除掉\n\t//  \t3符合了 不能是纯字母\n    var result = username.match(/(?!^[a-zA-Z]+$)^[a-zA-Z][0-9a-zA-Z]{3,9}$/g);\n    if(result){\n        //如果匹配，说明username符合要求\n        console.log('用户名可用');\n    }else{\n        //如果result为null，表示不符合要求\n        console.log('有问题');\n    }\n```\n\n\n","categories":["RegExp"]},{"title":"正则表达式","url":"%2Fposts%2F794273428%2F","content":"\n\n# 三、正则表达式概述\n\nw3c手册位置：上面的JavaScript --- 左侧的JavaScript --- 右侧的参考书 --- 左侧的 **JS RegExp**\n\n## 1、概述\n\n**正则表达式(Regular Expression)**描述了一种字符串 匹配 的模式，可以用来检查一个字符串中是否含有某种子串、将匹配的子串做替换或者从某个字符串中取出符合某个条件的子串等。\n\n==匹配==就是在某个字符串中查找你想要查找的内容（由正则表达式决定），如果查找到了，就表示匹配。没有查找到就表示不匹配。\n\n正则表达式本身是一门独立的技术，可以被大多数编程语言所使用，如Javascript、PHP、Java\n\n正则表达式也是用于查找字符串的，只是比正常的查找更加高级。\n\n怎么高级了，比如在字符串“abacad”中查找a：\n\n普通的查找：JavaScript语法：'abacad'.search('a'); //只查询一次，返回a首次出现的位置0.\n\n普通的查询：php语法：strpos('abacad', 'a');\n\n高级的查找：要求查找a，什么样的a呢？后面必须是c的a。这正是正则表达式的用武之地。\n\n## 2、应用场景\n\n（1）表单验证里面，验证字符的合法性，如邮箱是否合法，手机号是否合法等等。\n\n（2）信息过滤，如论坛帖子或者评论中的非法字符，例如 sql注入、js脚本注入、煽动性的言论。\n\n（3）信息采集，采集别人网站上面的内容，例如整页采集时 筛选出需求的部分\n\n（4）信息替换。\n\n（5）页面伪静态的规则。\n\n----\n\n\n\n# 四、入门案例\n\n## 1、正则用法说明\n\n```html\n<script>\n\n//查找str字符串中h是否存在\n\nvar str = 'php';\n\n//var result = str.match(/参数就是正则表达式/); //返回存放匹配结果的数组\n\n</script>\n\n```\n\n```javascript\n\tvar str = 'php';\n    var result = str.match(/h/); //返回值是 存放匹配结果的数组\n    console.log(result); // Array [ \"h\" ]\n```\n\n==匹配不到，返回null==。\n\n## 2、全局修饰符g\n\ng是global，表示全局的意思，它是正则表达式语法中的修饰符，修饰符应该放到定界符(/)的后面。\n\n```javascript\n\tvar str = 'phphp';\n    //    var result = str.match(/h/); //返回值是 存放匹配结果的数组\n    //    console.log(result); // Array [ \"h\" ]\n    var result = str.match(/h/g); //返回值是 存放匹配结果的数组\n    console.log(result); // Array [ \"h\", \"h\" ]\n```\n\n不加g，表示只匹配一次，就终止继续向后查找；\n\n加入g，表示执行全局匹配，会一直查找到字符串的结尾。\n\n正则表达式要写到两条斜线之间，两条斜线是正则表达式是**定界符**，注意的是修饰符g要放到斜线的外面。\n\n----\n\n\n\n# 五、==正则语法==\n\n## 1、量词\n\nn+   匹配任何包含==至少一个== n 的字符串。匹配一个或多个前导字符（**前导字符就是紧挨着+号的前一个字符**） \n\nn*    匹配任何包含==零个或多个== n 的字符串。前导字符有没有都行 \n\nn?    匹配任何包含==零个或一个== n 的字符串。 \n\nn{X} 匹配包含 X 个 n 的序列的字符串。 \n\nn{X,Y} 匹配包含 X 到 Y 个 n 的序列的字符串，包括X和Y个 。\n        如，实际需求是4~16位，但n前面被占用了1位，所以都需要减去1， n{3,15}\n\nn{X,} 匹配包含至少 X 个 n 的序列的字符串。 \n\nn$    匹配任何结尾为 n 的字符串。(从末尾开始匹配)\n\n^n    匹配任何开头为 n 的字符串。（注意位置在前面）\n\n^n$   表示只匹配字符串n。也就是匹配整个字符串。\n\n```javascript\n//    var str = 'phhhhhhp php  phhhhp  phhhhhhp  pp';\n//    var result = str.match(/ph+p/g);\n//    var result = str.match(/ph?p/g);\n//    var result = str.match(/ph*p/g);\n//    var result = str.match(/ph{4}p/g);\n//    var result = str.match(/ph{4,}p/g);\n//    var result = str.match(/ph{4,6}p/g);\n//    var result = str.match(/^ph?p/g); //表示只检查字符串的开头\n//    var result = str.match(/ph?p$/g); //表示只检查字符串的结尾\n\n    var str = \"php\";\n    var result = str.match(/^php$/g); //只匹配php\n    console.log(result);\n```\n\n\n\n## 2、元字符\n\n==**.**==  表示==任意单个==字符。除了换行和行结束符。 \n\n==**.\\***== 表示任意字符串（0个或多个任意字符，除了换行和行结束符）**.**是任意一个字符，*表示任意个前导字符。二者组合表示任意字符串\n\n![1533006843639](1533006843639.png)\n\n==**\\w**==  匹配任何数字、字母、下划线。**一个\\w表示一个字符，想表示多个字符，可以配合量词，如\\w{5}**。 \n\n**\\W**  匹配任何非数字、非字母、非下划线。 \n\n==**\\d**== 查找数字。 \n\n**\\D** 查找非数字字符。 \n\n==**\\s**== 查找空白字符。 一个\\s表示一个空格\n\n**\\S** 查找非空白字符。 \n\n==**\\b**== 匹配单词边界。（边界字母个数没有限制；\\b放前面表示匹配单词前面的边界，\\b表示匹配单词后面的边界） \n\n**\\B** 匹配非单词边界。 \n\n**\\n** 查找换行符。 \n\n**\\r** 查找回车符。 \n\n**\\t** 查找制表符。\n\n\n\n## 3、方括号\n\n方括号表示一个范围，也称为**字符簇**。\n\n\n\n[abc]  查找方括号之内的任何字符。 \n\n[^abc] 查找任何不在方括号之间的字符。（方括号中的^表示取反） \n\n[0-9] 查找任何从 0 至 9 的数字。表示匹配一个字符 \n\n[a-z] 查找任何从小写 a 到小写 z 的字符。 表示匹配一个字符\n\n[A-Z] 查找任何从大写 A 到大写 Z 的字符。 表示匹配一个字符\n\n[A-z] 查找任何从大写 A 到小写 z 的字符。**包括下划线**。  表示匹配一个字符\n\n[5-8] 查找5 <= 目标 <= 8的字符\n\n**(**red|blue|green**)** 查找任何指定的选项。（竖线|表示**或**者）\n\n\n\n## 4、修饰符\n\n修饰符的用法，是修饰符一定要写到`/正则表达式/`之后，即 `/正则表达式/修饰符` **可以一次性使用多个修饰符**。\n\n**i**  执行对大小写不敏感的匹配。实际上就是不区分大小写的匹配 \n\n**g**  执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 \n\n**m** 执行多行匹配。\n\n\n\n## 5、转义字符\n\n转义字符是 “*==\\\\==\" 如果匹配的字符串在正则中有特殊含义的都必须加转义字符。*\n\n如 [ ] $ . * ? + | ^ { } ( )\n\n==但是不要乱加转义。==\n\n\n\n----\n\n\n\n# 六、==分组/捕获和反向引用==\n\n**捕获和反向引用的语法的解释**：\n\n正则中出现的小括号，就叫**捕获**或者**分组**\n\n在正则语法中（在`/…/`内），在捕获的后面，用`\\1`来引用前面的捕获。用`\\2`表示第二个捕获的内容….\n\n```javascript\nvar str = '1234 5566 7788 9090';\n//查找连续的四个数字\n//var result = str.match(/[0-9]{4}/g);\n//var result = str.match(/[0-9][0-9][0-9][0-9]/g);\n//var result = str.match(/[0-9]+/g);\n//var result = str.match(/\\d\\d\\d\\d/g);\n//var result = str.match(/\\d{4}/g);\n\n//查询连续的四个数字，要求第1个数字和第2个数字相等，要求第3个数字和第4个数字相等\n//如下详解：\n// \\1所处位置为2，\\1指向的引用为第一个（）中的，所以，第1个数字和第2个数字相等\n//var result = str.match(/(\\d)\\1(\\d)\\2/g);\n\n//查询连续的四个数字，要求第1个数字和第3个数字相等，要求第2个数字和第4个数字相等\nvar result = str.match(/(\\d)(\\d)\\1\\2/g);\nconsole.log(result);\n```\n\n\n\n在正则语法外（如replace时），用`$1`来引用前面的捕获。\n\n```javascript\n//替换\n//var str = 'hello123';\n//要求查询str中的数字，然后将数字变为连续的两个数字，如1变成11,2变成22,3变成33，....\n//var result = str.replace(/(\\d)/g, \"$1$1\");\n\n//要求把下面的world hello替换成“hello world”\nvar str = \"world hello\";\nvar result = str.replace(/(\\w+)(\\s+)(\\w+)/g, \"$3$2$1\");\nconsole.log(result);\n```\n\n\n\n### **禁止引用**\n\n**(?:正则)** 这个小括号中的内容不能够被引用\n\n![1533021963971](1533021963971.png)\n\n----\n\n\n\n# 七、匹配中文（utf-8编码）\n\n每个字符（中文、英文字母、数字、各种符号、拉丁文、韩文、日文等）都对应着一个Unicode编码。\n\n查看Unicode编码，找到中文的部分，然后获取中文的Unicode编码的区间，就可以用正则匹配了。\n\n前面我们用[a-z]表示小写字母，[0-9]表示数字，这就是一个范围表示，如果有一个数x能够表示第一个中文，有一个数y能够表示最后一个中文，那么[x-y]就可以表示所有的中文了。\n\n**中文的Unicode编码从4E00开始，到9FA5结束**。\n\n**完整的Unicode编码表**：http://blog.csdn.net/hherima/article/details/9045861\n\n**[4E00-9FA5]**这个区间就能够表示中文。\n\n\n\n**注意写法的细节**\n\n```javascript\n//javascript\n\nvar result = str.match(/[\\u4e00-\\u9fa5]/g);  //需要前缀 \\u\n```\n\n```php\n//php\n\n//需要前缀 \\x ，并且要用｛｝包裹\n// (小写)u  ： 模式和目标字符串都被认为是 utf-8 的。\npreg_match_all('/[\\x{4e00}-\\x{9fa5}]/u', $str, $out); \n```\n\n**示例**\n\n```javascript\nvar str = \"hello中国，你好\";\nvar result = str.match(/[\\u4e00-\\u9fa5]/g); //[ \"中\", \"国\", \"你\", \"好\" ] \n//var result = str.match(/[\\u4e00-\\u9fa5]+/g); //[ \"中国\", \"你好\" ]\nconsole.log(result);\n```\n\n\n\n# 八、环视\n\n**亦称为（断言/零宽断言/正向预测）**\n\n\n\n**N(?=n)** **匹配任何其后紧接指定字符串 n** **的字符串**。\n\n有一个字符串是“abacad”，从里面查找a，什么样的a呢？后面必须紧接b的a。\n\n正则语法是：/a(?=b)/g\n\n```javascript\n\tvar str = 'ab ac ad';\n    var result = str.match(/a(?=b)/g); // [\"a\"]\n    console.log(result);\n```\n\n\n\n**N(?!n)** **匹配任何其后没有紧接指定字符串 n** **的字符串**。\n\n有一个字符串是“abacad”，从里面查找a，什么样的a呢？后面不能紧接b的a。\n\n正则语法是：/a(?!b)/g\n\n```javascript\n\tvar str = 'ab ac ad';\n    var result = str.match(/a(?!b)/g); // [\"a\", \"a\"]\n    console.log(result);\n```\n\n```javascript\n\t//查询大写字母，要求大写字母后面必须是一个数字\t\n\tvar str = 'H5 is Very Good';\n    var result = str.match(/[A-Z](?=\\d)/g); // [\"a\", \"a\"]\n    console.log(result);\n```\n\n\n\n另外，还会看到`(?!B)[A-Z]`这种写法，其实它是[A-Z]范围里，**==排除==**B的意思，前置的(?!B)只是对后面数据的一个限定，从而达到过滤匹配的效果。\n\n```javascript\n\t//(?!xxx)放到前面，表示排除的意思。比如查询所有的字母，但是不要[a-w]\n    var str = 'H5 is Very Good';\n    var result = str.match(/(?![a-w])[A-z]/g); // [ \"H\", \"V\", \"y\", \"G\" ]\n    console.log(result);\n```\n\n\n\n \n\n# 九、正则对象的属性和方法\n\n![1533026547458](1533026547458.png)\n\n## 1、调用方式\n\n正则对象中的成员方法和属性的正确调用方式：\n\n和String对象类似，一种是**直接量语法**（`/[a-z]/.exec()`），另一种方法是实例化正则对象，然后**通过对象去调用成员方法**（`var reg = new RegExp(/[a-z]/);  reg.exec()`）\n\n ```javascript\nstr='abcdd';\n\n//方式一：\n/[a-z]/.exec(str)；//直接使用正则表达式调用方法\n\n//方式二：\nvar reg = new RegExp(/[a-z]/);  //先实例化对象\nreg.exec(str)； //然后通过对象去调用方法\n ```\n\n\n\n## 2、exec方法和lastIndex属性\n\nexec方法执行一个正则匹配，==只匹配一次==，匹配到结果就返回一个数组类型的结果，匹配不到就返回null。并将表示匹配的位置 置为下一个匹配的位置。\n\n**lastIndex**一个整数，标示开始下一次匹配的字符位置。没有更多匹配重置lastIndex为0.\n\n依次调用exec匹配下一个的例子：\n\n![1533027213176](1533027213176.png)\n\n匹配带子表达式(分组)的例子，带子表达式并且依次调用的例子：\n\n![1533027453701](1533027453701.png)\n\n 循环输出：\n\n![1533027517601](1533027517601.png)\n\n\n\n## 3、test方法\n\ntest方法检测目标字符串和正则表达式是否匹配，如果匹配返回**true**，不匹配返回**false**。\n\n案例 --匹配手机号。\n\n```javascript\n/*\n手机号特点：\n    11位\n    纯数字\n    1开头\n    23位判断[可选，去各大运营商查询]\n */\nvar tel = '13066668888';\nvar reg = /^1\\d{10}$/g;\nvar result = reg.test(tel);\nconsole.log(result);  //true\n```\n----\n\n\n\n# 十、JS中支持正则表达式的 String 对象的方法\n\n## 1、search()\n\n在字符串中搜索符合正则表达式的结果。如果找到结果返回结果的==位置==（从0开始的下标），**并停止向后检索**，也就是说忽略全局标识符g；如果没有匹配结果，返回-1.\n\n```javascript\n\tvar str = '1234512345';\n    var regexp = /2/g;\n    var reslut = str.search(regexp);\n    console.log(reslut); // 返回2所在的位置，结果是1\n```\n\n\n\n## 2、match()\n\n在字符串中检索匹配正则表达式的子串；如果匹配，返回包含匹配结果的一个**数组**；不匹配返回**null**。\n\n**不加全局g的情况**：\n\n获取的结果只是第一个匹配的内容，匹配的内容中的第一个单元是匹配的结果，后面的单元是子表达式。\n\n![1533028777940](1533028777940.png)\n\n**加全局的g的情况**：\n\n获取的结果是所有匹配的内容，但是**不**包含子表达式。\n\n![1533028964994](1533028964994.png)\n\n**多次调用和调用一次效果一样**。\n\n\n\n如果要把所有的匹配结果、所有的子表达式都获取到，用什么方法？\n\n答：循环使用正则方法exec()。\n\n\n\n## 3、split()\n\n将字符串分割成数组：\n\n```javascript\n\t//用@或者. 将邮箱分割成数组\t\n\tvar str = '23423452@qq.com';\n    var arr = str.split(/@|\\./);\n    console.log(arr); //[ \"23423452\", \"qq\", \"com\" ]\n```\n\n\n\n## 4、replace()替换\n\n**默认只替换一次，加g全部替换**。\n\n```javascript\n\tvar str = '17:27:50';\n    var result = str.replace(/7/, 5); //只替换一次  15:27:50\n    var result = str.replace(/7/g, 5); //全部替换  15:25:50\n    console.log(result);\n```\n\n\n\n**替换的时候，使用\"$1\"表示第一个子表达式的内容，用“$2”表示第二个子表达式的内容，以此类推**。\n\n```javascript\n\t//替换abc为aabbcc：\n\tvar str = 'abc';\n    console.log(str.replace(/([a-z])/g, \"$1$1\")); //查找到a就替换，然后再查找b，再替换....\n```\n\n\n\n**用  $` 表示捕获的内容左侧的内容，用  $'  表示捕获的内容右侧的内容**\n\n```javascript\n    //替换成 x[x-y-z]z\n\tvar str = 'xyz';\n    console.log(str.replace(/(y)/g, \"[$`-$1-$']\"));\n```\n\n\n\n**复杂的替换，可以用函数处理如何替换**\n\n替换aaa bbb ccc为Aaa Bbb Ccc\n\n![1533030110299](1533030110299.png)\n\n----\n\n\n\n# 十一、==PHP中的正则表达式==\n\n==语法和JavaScript中的正则语法基本一致==。\n\nPHP中的正则函数：\n\n![1533035016089](1533035016089.png)\n\n## 1、preg_match()\n\n**preg_match()  返回匹配的次数，它的返回值是0或者是1.**\n\n0表示不匹配，1表示匹配一次，因为preg_match在匹配一次之后就停止向后检索了。\n\n![1533035541325](1533035541325.png)\n\n查看匹配的结果，使用第三个(引用类型)参数：\n\n![1533035644559](1533035644559.png)\n\n带有子表达式的例子：\n\n![1533035708694](1533035708694.png)\n\n\n\n## 2、preg_match_all()\n\n**preg_match_all()** 返回完整匹配次数（可能是0），或者如果发生错误返回**FALSE**。 \n\n执行正则表达式的全局匹配，类似于js中的带g的匹配。\n\n![1533035944230](1533035944230.png)\n\n带有子表达式的例子：\n\n![1533036134099](1533036134099.png)\n\n\n\n## 3、preg_replace();\n\n替换字符串：\n\n```php\n//preg_replace('/正则表达式/', 替换成什么, 在哪里替换);\n\necho preg_replace('/h/', 'H', 'hello'); //Hello\necho preg_replace('/l/', 'L', 'hello'); //heLLo\n```\n\n补充：preg_replace_callback() ，即`替换成什么` 用函数来处理;\n\n```php\necho preg_replace_callback('/[a-z]+/', function($x){\n    return ucfirst($x[0]); //$x,表示每次匹配到的结果。在本例中，分别表示数组类型的hello和world\n}, 'hello world');\n```\n\n\n\n**案例：解决贪婪问题？**\n\n下面的是贪婪模式：\n\n![1533037239196](1533037239196.png)\n\n非贪婪模式：\n\n```php\n$str = \"this is a [b]php[/b], that is a [b]javascript[/b]\";\n\n//$str = preg_replace('/[b](.*)[/b]/', '<b>$1</b>', $str);\n\n//解决贪婪模式方式一，和js一样，加 ？\n//$str = preg_replace('/\\[b\\](.*?)\\[\\/b\\]/', '<b>$1</b>', $str);  \n//解决贪婪模式二，PHP独有的，加修饰符 U\n$str = preg_replace('/\\[b\\](.*)\\[\\/b\\]/U', '<b>$1</b>', $str); \n\necho $str;\n```\n\n\n\n## 4、php中匹配中文\n\n`[\\x{4e00}-\\x{9fa5}]/u`\n\n```php\n//php\n\n//需要前缀 \\x ，并且要用｛｝包裹\n// (小写)u  ： 模式和目标字符串都被认为是 utf-8 的。\npreg_match_all('/[\\x{4e00}-\\x{9fa5}]/u', $str, $out); \n```\n\n![1533037656030](1533037656030.png)\n\n\n\n## 5、PHP中使用正则注意点\n\nPHP中正则的使用除了//以外，外面还要加引号，这个引号要用==单引号==。\n\n----\n\n\n\n\n","categories":["RegExp"]},{"title":"HTML和HTML5","url":"%2Fposts%2F1392188595%2F","content":"\n\n# 一、HTML简介\n\n## 什么是HTML\n\n-   **HTML**（HyperText Mark-up Language）即超文本标记语言或超文本标签语言。\n\n-   何为超文本：\"超文本\"可以实现页面内可以包含图片、链接，甚至音乐、程序等。\n\n-   网页文件本身是一种文本文件，它通过标记符号来标记要显示的网页中的各个部分。\n\n-   何为标记：当**浏览器**遇到对应的标签符号时， 就实现对应的功能！\n\n-   网页文件扩展名：.html 或 .htm\n\n-   一个网页文件包括\"头\"部分（Head）、和\"主体\"部分（Body），其中\"头\"部提供关于网页的信息，\"主体\"部分提供网页的具体内容。\n\n## HTML的发展历程\n\n**W3C：**万维网联盟 这个组织它是非盈利性的组织。它是用于制定WEB标准。也就是一种规范。这个组织它大概制定了200项web标准。\n\n-   1993 HTML1\n\n-   1995 HTML2\n\n-   1995 HTML3\n\n-   1997 HTML4\n\n-   1999 HTML4.01\n\n-   2000 XHTML1.0 可扩展的超文本标记语言\n\n-   2009 HTML5 它集合了JavaScript、CSS、HTML的功能。\n\n-   2014 HTML5 Finalized 本身HTML5它预定于2020年才正式发布。\n\n## 增强的文本编辑器\n\n-   任何的纯文本编辑器都能够编辑html，比如记事本、editplus、notepad++。\n-   比较有名的编辑器有：\n    -   **DreamWeaver** (Adobe公司的产品，这个东西过时了)\n    -   **Sublime** （高效率的程序书写编辑器） 文本编辑器\n    -   **WebStorm** （更高级的项目级别编辑器）这个编辑器它主要是前端开发工程师\n\n\n\n不管用什么编辑器，你都要知道，做网页和编辑器无关，任何的纯文本编辑器都能够编码代码。我们学习的是代码，而不是所谓的编辑器。不过，不可否认，一个好的编辑器，确实能够提高工作效率，代码书写的速度，但是本质上讲，记事本也能书写网页。\n\n\n\nsublime的中文意思是\"华丽的\"，是2011年开始流行的代码编辑器，可以编辑java、c、php等很多语言。\n\nhtml、css、js在sublime中支持非常好。界面也非常漂亮，安装简单、小巧、插件多。\n\n\n\n**使用sublime导入项目的步骤：**\n\n选择项目选项卡\\-\\--添加文件夹到项目\\-\\-\\-\\-\\-\\--选择我们的项目文件夹\n\n![](image2.png)\n\n![](image3.png)\n\n\n\n**sublime编辑器的快捷键**\n\n----------------- ---------------------\n  **快捷键**                 **功能**\n  !+tab             \t可以生成HTML5的结构\n  ctrl+鼠标滚轮      调整文本的大小\n  ctrl+shift+D         复制当前行\n  ctrl+shift+k          删除当前行\n  ctrl+回车              快速换到下一行\n----------------- ---------------------\n\n**注意：**\n\n我们在使用sublime编辑器的 书写HTML标签的时候， 只需要写标签名就可以 ，然后按一下键盘上面的tab键或者回车键 那么就会进行自动的补全！\n\n\n\n----\n\n\n\n# 二、HTML文件结构\n\n标签、标记、节点、元素 这四个名词都是同一个东西。\n\n一个HTML文件它是由三对标签来组成\n\n\n-   `<html></html>`这一对标签告诉浏览器这是一个HTML文件，在它们之间是文档的头部\\<head\\>和主体\\<body\\>。\n\n-   `<head></head>`标签出现在文档的头部分。\\<head\\>与\\</head\\>之间的内容不会在浏览器的文档窗口显示，但是其间的标签有特殊重要的意义\n\n-   `<body></body>`之间的文本是可见的网页主体内容，body中的标签包含网页中的所有内容（比如文本、超链接、图像、表格和列表等等。）\n\n我们把一个HTML网页可以理解为一封信：信封就好比是这个网页的head标签，虽然说它不是主要的内容 但是它特别重要；信件就好比是这个网页的body标签 一个网页中基本上我们能够看到内容都是放置在body标签里面！\n\n![](image4.png)\n\n----\n\n\n\n# 三、标签分类与书写规则\n\n## 标签分类\n\n-   标签主要分为双边标签与单边标签\n\n-   HTML标签都是放在一对尖括号里面 `<标签名>`\n\n-   HTML标签通常是成对出现的（双边标签），比如 \\<div\\>和 \\</div\\>\n\n-   双边标签中的第一个标签是开始标签，第二个标签是结束标签， 有开始也有结束；\n\n    - `<b></b>`\n\n-   双边标签，有开始有结束，其内容在两个标签中间。如 `<h1>标题</h1>`\n-   也有单独呈现的标签（单边标签）   `<标签名 />`，如：`<br />`、`<hr />`和`<img src=\"images/1.jpg\" />`\n-   单边标签，有开始但是没有结束，其内容在标签属性中赋值。它一般都是用来起到一些特殊的作用。 比如：`<br />` 换行    `<hr />`水平线。\n    -  某一些单边标签如果要显示内容 ，需要将内容放置在单边标签里面的的value属性中`<input type=\"text\" value=\"按钮\" />`。\n\n\n\n**属性的含义：**\n\n为什么标签里面会有属性？属性到底是用来 做什么的？\n\n我们可以用标签来表示一个人 属性一般是用于来描述这个标签有什么\n\n\\<人 性别 身高 体重 \\>张三\\</人\\>\n\n\n\n## 书写规则\n\n-   HTML**标签是由一对尖括号**包围的标签名，比如 \\<html\\>\n\n-   标签名不区分大小写 ，但是建议使用小写 \\<font\\> \\<FONT\\> \\<Font\\>\n\n-   如果标签中有**属性** ，属性与标签名之间要有一个空格， 如果一个标签内有多个属性， 属性与属性之间要有一个空格， 属性要写在开始标签中 ，不能写在结束标签中\n\n-   如果标签中有属性， 属性的值是需要加引号的， 单引号和双引号都可以。\n\n-   每一个标签都需要关闭，单边标签可关可不关。\n\n-   如果是双边标签， 一定要及时的关闭。\n\n-   标签与标签之间是有的嵌套关系， 在标签里面可能还会出现其它的标签。\n\n-   标签与标签之间的嵌套只能使用**顺序嵌套**， 不能交叉嵌套。\n\n![](image5.png)\n\n----\n\n\n\n#  四、文本修饰标签\n\n| **标签名**                                      | **功能**                                                     |\n| ----------------------------------------------- | ------------------------------------------------------------ |\n| <b></b>或<strong></strong>   bold               | 给文本设置加粗的效果                                         |\n| <i></i>或<em></em>         italic               | 给文本设置斜体的效果                                         |\n| <u></u>或<ins></ins>                  underline | 给文本设置下划线的效果                                       |\n| <s></s>或<del></del>         strikethrough      | 给文本设置删除线的效果                                       |\n| <sup></sup>                                     | 上标                                                         |\n| <sub></sub>                                     | 下标                                                         |\n| <font></font>                                   | 给文本设置大小 颜色 字体 。 属性：  ` size`：给文本设置大小  取值:1~7  1小7大   `color`：给文本设置颜色  比如：red   `face`：给文本设置字体  比如：宋体  。一般公司使用的都是微软雅黑 |\n\n![](image6.png)\n\n\n\n# 五、排版标签\n\n| **标签名**          | **功能**                                                     |\n| ------------------- | ------------------------------------------------------------ |\n| <p></p>             | **段落标签**    <br />属性：  ` align`：用于控制段落里面的内容的水平方向的对齐方式。   取值：left   居左对齐  默认值   center 居中对齐   right  居右对齐 |\n| <h1></h1>~<h6></h6> | **标题标签** 加粗显示    <br />1大6小， h1最大 h6最小   `align`：用于控制标题里面的内容的水平方向的对齐。   取值：left   居左对齐  默认值     center 居中对齐    right  居右对齐 |\n| <br />              | **换行标签**                                                 |\n| <hr />              | **水平线标签**  也是一个单边标签      <br />`color`：用于设置水平线的颜色   `width`：用于设置水平线的宽度   取值：固定值和百分比。固定值的单位像素，  百分比它一定是有一个参照物，   它会参照当前hr标签的父元素。   `size`：用于设置水平线的粗细，     `noshade`：用于去除水平线的阴影 ， 这个属性它没有值 ，   它的属性值就等于其自身 noshade   `align`：用于控制水平线的水平对齐方式，   取值：left  居左对齐     center 居中对齐  默认值      right  居右对齐 |\n| <pre></pre>         | **预格式化处理标签**<br />  在这一对标签里面的空格与换行会保留，   在PHP中使用的会比较多。 |\n\nH1\\~H6如下所示：\n\n![](image7.png)\n\np标签如下图所示：\n\n![](image8.png)\n\nbr标签:\n\n![](image9.png)\n\nhr标签\n\n![](image10.png)\n\npre\n\n![](image11.png)\n\n# 六、注释\n\n**为什么要写注释？**\n\n-    方便项目组里的其它程序员了解你的代码，而且可以方便以后你对自己代码的理解与修改等等。\n\n-   可以在HTML文档中加入自己的注释。注释不会显示在页面中，它可以用来提醒程序员回忆相关的程序信息。\n\n**注释的格式：**\n\n```html\n<!--注释的内容-->\n```\n\n\n\n# 七、字符实体\n\n**为什么要有字符实体？**\n\n在 HTML 中，某些字符是预留的。\n\n在 HTML 中不能使用小于号（\\<）和大于号（\\>），这是因为浏览器会误认为它们是标签。\n\n如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体\n\n**常用字符实体**\n\n| 效果 | 字符  |\n| ---- | -------- |\n| 空格 | `&nbsp; `  |\n| >    | `&gt; `    |\n| <    | `&lt; `    |\n| &    | `&amp; `   |\n| ¥    | `&yen; `   |\n| 版权 | `&copy; `  |\n| 注册 | `&reg;`    |\n| ×    | `&times;`   |\n| ÷    | `&divide; `|\n\n\n\n# 八、列表标签\n\n列表标签总共有三种：\n\n-   **无序列表**\n\n-   **有序列表**\n\n-   **自定义列表**\n\n## 无序列表\n\n无序列表是在网页布局中使用的最多的标签\n\n无序列表是用来表示一种没有先后顺序之分的列表项！\n\n**语法：**\n\n`ul`： 是英文中\"unordered list\"简写， 无序列表\n\n`li`：是英文中\"list item\"简写， 列表项\n\n**注意：**\n\n-   我们会发现，这是我们学习的第一个\"**组标签**\"就是要么不写，要么就写一组！\n\n-   li标签它不能单独的存在，必须是包裹在ul标签的里面 反过来说，ul的子元素必须是li标签，而不能是其它的任何标签！\n\n-   所有的的内容都应该放置在li标签里面\n\n-   li标签里面可以存放任何内容！ 图片或者是文本或者是其它的标签\n\n\n\n无序列表前面， 默认会有一个实心的小圆点。\n\nul或者li标签有一个属性：\n\n**type：**表示列表前面的符号的类型\n\n* 取值：disc(默认值 实心的小圆点)、circle(空心圆)、square(实心小方块)\n\n这个type属性对于我们来说并没有什么实际的用处 ，因为在一个网页中到处都是无序列表 但是我们并没有发现在网页上面有这些符号\n\n列表是可以嵌套的：在ul标签里面再嵌套ul标签\n\n注意：列表之间的嵌套只能是在li标签里面嵌套\n\n![](image12.png)\n\n\n\n## 有序列表\n\n有序列表是用表示一种有顺序之分的列表项\n\n**语法格式：**\n\nol：是英文中\"order list\"简写 有序列表的意思\n\nli：是英文中\"list item\"简写 列表项的意思\n\n\n\n**ol与li的属性：**\n\n**type**：用来设置列表前面的序号\n\n* 取值：1(默认值)、a、A、i(小罗马)、I(大罗马)\n\nstart：用于表示序号从哪里开始 取值：数字\n\n其实有序列表使用的非常少 ，因为能够使用有序实现的其实也可以使用无序列表来实现！\n\n![](image13.png)\n\n\n\n## 自定义列表\n\n自定义列表是一个组标签，不过比较复杂，因为它出现了三对标签！\n\ndl：英文中\"definition list\"简写 表示定义列表。\n\ndt：英文中\"definition title\"简写 表示定义标题。\n\ndd：英文中\"definition description \"简写 表示对定义标题的描述。\n\n**注意：**\n\ndt、dd这两对标签它只能出现在dl标签里面 ，反过来说dl里面只能有dt与dd。\n\n定义列表使用非常灵活，每一个dt是可以配多个dd的\n\n![](image14.png)\n\n# 九、图片标签\n\n## 语法\n\n`img`：是英文中\"image\"简写， 图片\n\n`src`：是英文中\"source\"简写 ，资源\n\n![](image15.png)\n\n## alt属性\n\n**alt**  它是英文\"alternate\"的简写， 替代。 如果当图片不存在了， 就显示alt这个属性中的文字信息！\n\n**注意：**\n\nimg是一个单边标签， 单边标签也是需要关闭的！\n\n## 其它属性\n\n------------ ---------------------------------------\n  **属性名**   **功能**\n  title        当把鼠标放在图片上面时， 显示的文字信息\n  width        给图片设置宽度\n  height       给图片设置高度\n------------ ---------------------------------------\n\n![](image16.png)\n\n**注意：**\n\n最好不要给图片同时设置宽度与高度！因为它会将图片给变形！只需要设置其中个属性即可等比例缩放，除非这张图片的是宽高是一样的。\n\n\n\n# 十、文件地址\n\n## 什么叫文件地址？\n\n用于描述，一个文件在磁盘上的位置\n\n位置：相对路径和绝对路径\n\n## 绝对路径 \n\n一个文件在磁盘上面的真实位置！\n\n![](image17.png)\n\n![](image18.png)\n\n## 相对路径\n\n相对于当前文件的描述目标文件位置关系\n\n**平级关系** ：  目标文件与当前文件是在同一个目录下面\n\n`./` 表示当前文件夹\n\n`./文件名` 平级关系\n\n直接写文件名 平级关系\n\n![](image19.png)\n\n**上级关系** ：目标文件在当前文件的上一级目录下面\n\n`../ `上一级\n\n`../../ `上二级\n\n![](image20.png)\n\n**下级关系 ** ：当前文件与目标文件的文件夹在同一个目录下面\n\n格式：\n\n`目标文件的文件夹名称/目标文件`\n\n或者\n\n`./目标文件的文件夹名称/目标文件`\n\n![](image21.png)\n\n**注意：**\n\n-   使用绝对路径的时候：当 当前文件的位置发生改变时， 不会影响到目标文件， 可以找目标文件。\n\n-   使用相对路径的时候：当 当前文件的位置发生改变时 ，会影响到目标文件， 找不到目标文件。\n\n\n\n# 十一、表格标签 \n\n\n## 表格的基本用法\n\n表格一般多用网站的后台，不是网站的前台。\n\n2007年之前，表格是一组标签！\n\n```\n<table>\n    <tr>\n    \t<td></td> \n    </tr>   \n</table>\n```\n\n`tr`：table row  表格行\n\n`td`：table data   表格的普通单元格标签\n\n`th`：table header 表格的标题单元格标签 **文本会加粗显示并且水平居中**\n\n**结构说明：**\n\n-   `<table></table>`  表示表格开始表格结束\n\n-   `<tr></tr>`  表示表格中的行标签 ，一个表格中有多少行就应该书写多少对tr标签\n\n-   `<td></td>`表示表格中的单元格标签 ，一行中有多少个单元格就应该书写多少对td标签\n\n-   表格中所有的内容都必须在放置在td标签里面， 也就是说只有td标签才能存放内容。\n\n-   `<th></th>`表示标题单元格标签， 这个单元格里面的文本会加粗显示并且会居中。\n\n## table标签的常用属性\n\n| **属性名**  | **功能**                                                     |\n| ----------- | ------------------------------------------------------------ |\n| border      | 给表格设置边框    单位是像素   取值：0~n                     |\n| width       | 给表格设置宽度    取值：固定值和百分比                       |\n| height      | 给表格设置高度   一般不用 因为表格的高度一般是由其内容来决定的 |\n| background  | 给表格设置背景图片， 可以使用相对路径和绝对路径              |\n| bgcolor     | 给表格设置背景颜色                                           |\n| bordercolor | 用于设置表格边框的颜色                                       |\n| align       | 给表格设置水平方向的对齐方式      取值：left(居左对齐   默认值)         center 居中对齐         right     居右对齐 |\n| cellpadding | 表格中的单元格里面的内容到单元格边框之间的距离 内填充        |\n| cellspacing | 表格中单元格与单元格之间的距离  外边距                       |\n| rules       | All   合并表格的边框线   很细的表格边框线                    |\n\n\n\n## tr标签的属性\n\n| **属性名** | **功能**                                                     |\n| ---------- | ------------------------------------------------------------ |\n| align      | 用来设置行里面的内容水平方向对齐方式   取值：left  默认值  居左对齐         center    居中对齐         right      居右对齐 |\n| valign     | 用来设置行里面的内容垂直方向对齐方式   取值：top  顶部对齐          middle    居中对齐  默认值          bottom    底部对齐 |\n| bgcolor    | 给行设置背景颜色  一般用于设置隔行变色的表格                 |\n| height     | 给行设置高度                                                 |\n| background | 给行设置背景图片                                             |\n\n\n\nalign属性：\n\n![](2_image1.png)\n\nheight属性：\n\n![](2_image2.png)\n\nbgColor：\n\n![](2_image3.png)\n\n\n\n## td或th标签的属性  \n\n在单元格上面设置\n\n\n\n| **属性名** | **功能**                                                     |\n| ---------- | ------------------------------------------------------------ |\n| align      | 用来设置单元格里面的内容水平方向对齐方式  。 取值：left  默认值  居左对齐         center    居中对齐         right      居右对齐 |\n| valign     | 用来设置单元格里面的内容垂直对齐方式 。  取值：top  顶部对齐          middle    居中对齐  默认值          bottom    底部对齐 |\n| bgcolor    | 给单元格设置背景颜色                                         |\n| height     | 给单元格设置高度 会影响到当前行的整个高度                    |\n| width      | 给单元格设置宽度 会影响到当前单元格所在的列的宽度            |\n| rowspan    | 跨行合并单元格                                               |\n| colspan    | 跨列合并单元格                                               |\n\n\n\nbgColor与background\n\n![](2_image4.png)\n\nwidth与height\n\n![](2_image5.png)\n\n![](2_image6.png)\n\n[Emmet语法 - 快速的生成HTML标签](https://segmentfault.com/a/1190000007812543) \n\n\n\n**合并单元格的时候需要注意的问题：**\n\n1.  要明确知道使用哪一个属性， 跨行还是跨列；\n\n2.  在哪一个单元格中书写合并单元格的属性， 在合并单元格的在第一个单元格中写属性；\n\n3.  属性值合并多少个单元格 ，值就是多少；\n\n4.  合并完成以后要删除多余的单元格 n-1。\n\n    \n\n跨列合并如下：\n\n![](2_image7.png)\n\n![](2_image8.png)\n\n跨行合并如下图：\n\n![](2_image9.png)\n\n![](2_image10.png)\n\n\n## caption\n\n`<caption></caption>`  指的整个表格的标题标签\n\n![](2_image11.png)\n\n\n## 表格其它标签介绍\n\n**\\<thead\\>\\</thead\\>** 表格的头部标签 ，只能有一对。\n\n**\\<tbody\\>\\</tbody\\>** 表格的主体标签 ，可以有多个。\n\n如果我们在写table标签时没有写tbody ，浏览器会自动给我们增加tbody， 也就是说将所有的tr标签放置于tbody标签里面。\n\n**\\<tfoot\\>\\</tfoot\\>** 表格的脚部标签 ，只能有一对。 这一对标签它主要是用于来统计数据来用。\n\n上面的这三个标签 ，我们在编写代码的时候可以加上 ，也可以不加 ！如果不加， 那么浏览器会默认给tr标签的外面添加一个元素为tbody标签。\n\n在一个表格 thead与tfoot标签只能出现一对， 但是tbody可以有多对。\n\n![](2_image12.png)\n\n![](2_image13.png)\n\n**注意：**\n\nThead与tfoot标签里面必须要有tr标签\n\n# 十二、超级链接 \n\n## 什么是超级链接\n\n一个网站，它是由很多个HTML网页组成的，HTML网页之间是可以通过超级链接来实现相互跳转的功能！从而就形成了\"网\"！\n\n## 基本用法\n\na它是英文中\"anchor\"简写 ，中文意思\"锚\" ，就好像是从一个网页上面往另外一个网页上面扔出一个\"锚\"！\n\n![](2_image14.png)\n\n**href**：它们是英文中\"hypertext reference \" ，中文意思\"超级链接地址\"。\n\n![](2_image15.png)\n\n## a标签的另外属性\n\n**title**  ： 标题。 当把鼠标放上超级链接上面显示的文本信息 。**公共属性 通用属性** ，每一个标签都拥有这个属性！\n\n**target**：链接的目标文件打开方式\n\n-   `_blank `在新窗口中打开链接的目标文件\n\n-   `_parent` 在父窗口中打开链接的目标文件\n\n-   `_self` 在本窗口中打开链接的目标文件 默认值\n\n-   `_top `在最顶级窗口中打开链接的目标文件\n\n-   framename 在框架网页中打开链接的目标文件\n\n![](2_image16.png)\n\n不单单只能给文字设置超级链接 ， 同样可以给图片设置超级链接！\n\n![](2_image17.png)\n\n## 空链接\n\n**什么是空链接**：没有指定的链接地址的超级链接。\n\n**作用：**就是用于配合JavaScript来使用！\n\n\n\n**第一种方法： **\n\n```html\n<a href=\"#\">内容</a>\n```\n\n\n\n**第二种方法：**\n\n```html\n<a href=\"javascript:void(0)\">内容</a>\n```\n\n![](2_image18.png)\n\n\n\n## 锚点链接\n\n可以通过锚点链接跳转到一个网页的不同的位置！\n\n\n\n**如何实现锚点链接？**\n\n**第一步：定义一个锚点**\n\n在定义锚点时 a标签的中间不要写任何内容 \n\n```html\n<a name=\"锚点名\"></a>\n```\n\n或者\n\n```html\n<a id=\"锚点名\"></a>\n```\n\n建议使用id这个属性来实现定义锚点 ，因为凡是有\\#出现 ，其实都是找ID属性的值 ，注意在定义锚点的时候 ，a标签双边标签的中间位置**不要放置任何内容**\n![](2_image19.png)\n\n\n\n**第二步：找到锚点**\n\n在浏览器中的网址的最后面**\\#锚点名**\n\n或者\n\n```html\n<a href=\"#锚点名\">内容</a>\n```\n\n![](2_image20.png)\n\n**注意：**\n\n在找锚点的时候 ，不要忘记了有一个\\#号。\n\n**回到顶部的案例**：直接使用空链接中的` href=\"#\"`就可以实现回到网站的顶部功能\n\n![](2_image21.png)\n\n\n\n# 十三、框架网页 \n\n## 什么是框架网页\n\n**框架网页：**将一个网页窗口划分为若干个小窗口，每一个小窗口里面都可以存放一个独立的网页！\n\n框架网页一般多用于网站的后台！\n\n## 基本用法\n\n框架网页是由框架集(`frameset`)和框架页(`frame`)组成！框架页是存放于框架集中， 也就是说 frame这个标签是放置在frameset这个标签里面。\n\n**注意：**只有**框架集标签**才可以分割！\n\n-   \\<frameset\\>\\</frameset\\> 框架集\n\n-   \\<frame /\\> 框架页\n\n\n\n当我们在实现框架页面时 frameset这一对标签它就代替了 body标签 的功能 ！\n\n```html\n<frameset>\n    <frame />\n    <frame />\n</frameset>\n```\n\n![](2_image22.png)![](2_image23.png)\n\n**frameset的属性**\n\n-   **rows** ：它是用来将一个网页窗口进行水平分割\n\n    -   举例：rows=\"180,\\*\" 将一个网页窗口分割为上下型。 上窗口占据180个像素的高度， 其它的部分都给到下窗口。\n\n    -   举例：rows=\"180,100,\\*\" 将一个网页窗口分割为上中下型 。上窗口占据180个像素， 中间的窗口占据100个像素 其它的部分都给到下窗口。\n\n-   **cols**：它是用来将一个网页窗口进行垂直分割\n\n    -   举例：cols=\"180,\\*\" 将一个网页窗口分割为左右 ，左窗口占据180个像素 ，其它的部分都给到右窗口。\n\n    -   举例：cols=\"180,100,\\*\" 将一个网页窗口分割为左中右型 ，左窗口占据180个像素 ，中间的窗口占据100个像素 其它的部分都给到右窗口。\n\n**frame的属性**\n\n-   **noresize=\"noresize\"**  不可以调整小窗口的大小\n\n-   **src**：链接小窗口显示的网页！\n\n-   **name**：规定小窗口的名称。 非常重要， 给每一个小窗口取一个名字 。\n\n-   **scrolling**：控制框架页的滚动条  `yes|no|auto`\n\n![](2_image24.png)\n\n![](2_image25.png)![](2_image26.png)\n\n**在frame标签中有一个非常重要的属性叫：name 。它主要是用于给框架页取名字 ，方便查找 **\n\n![](2_image27.png)\n\n\n\n## 浮动框架\n\n浮动框架又称之为**内联框架**：它就好比在一个页面上面挖出一个坑，然后往这个坑里面填入一个页面！\n\n\\<iframe\\>\\</iframe\\> 这一对标签可以放置在body标签里面！\n\n------------ ----------------\n  **属性名**      **功能**\n  src             放入页面的地址\n  width        浮动框架的宽度\n  height       浮动框架的高度\n  name         浮动框架的名称\n------------ ----------------\n\n![](2_image28.png)\n\n![](2_image29.png)\n\n\n# 十四、表单\n\n## 表单的主要功能\n\n表单它主要是用来收集用户输入的相关数据！\n\n**注意：**\n\n一个完整的表单，是由\"form标签\"和\"表单控件标签\"组成！\n\n![](form_image1.png)\n\n## form标签的属性\n\n注意：在写表单的的时候一定要有这个标签\n\n![](form_image2.png)\n\n-   action：将表单中收集的用户数据提交给\"表单的处理程序\"进行相关的处理！这个属性可以不写 如果不写表示将表单的数据提交给当前页面进行处理！\n\n    ![](form_image3.png)\n    ![](form_image4.png)\n\n\n-   **method：**  指表单数据的提交方式。 取值：get(默认值)|post\n\n    -   **get：**  如果method属性没有书写， 则默认表示表单数据以\"get\"方式进行提交 ，以get方式进行提交的数据会显示在浏览器的地址栏中。\n\n        -   **显示格式**：`action属性的值?name的属性值=value属性值 &name的属性值=value属性值`\n\n        -   如果有多个表单数据会以`&`符号进行连接\n\n            ![](form_image5.png)\n\n-   如果使用的是post进行提交的方式， 不会将表单数据显示在浏览器的地址栏中， 直接发送给表单的处理程序进行处理。\n    ![](form_image6.png)\n\n\n\n**get方式与Post方式之间的优缺点： **\n\n1、以get方式提交的表单数据 ，相对来说不安全 。\n2、以get方式只能提交少量的数据。\n3、以post方式提交的数据相对安全 ，因为不会将数据显示在浏览器地址栏中。\n4、以post方式可以提交大量的数据！ 2M左右。\n\n\n\n**enctype**\n\n值有两个：\n\n```php\napplication/x-www-form-urlencoded   //(默认值)\n```\n\n基本上我们都不用写enctype这个属性 ，不写就表示使用默认值。\n\n\n\n只有在一种情况下要书写enctype这个属性 ：\n\n```php\nmultipart/form-data\n```\n\n只有在**上传文件**的时候需要使用enctype这个属性 。在上传文件的时候需要将 enctype这个属性的值设置为`multipart/form-data `和`method`这个属性的值一定要设置为**POST **\n\n![](form_image7.png)\n\n![](form_image8.png)\n\n\n\n## 表单控件标签\n\n![](form_image9.png)\n\n### 单行文本框\n\n```html\n<input type=\"text\" name=\"名称\" value=\"值\" disabled />\n```\n\n-   name属性的作用是用来区分表单控件标签的数据\n-   value属性表示是用户输入的数据\n-   disabled 表示禁用\n-   readonly 表示只读\n-   文本框里面的内容是以明文进行显示\n\n\n\n> **disabled属性与readonly之间的区别：**\n\n1.  这两个属性都是用来表示不能对input标签进行编辑 (相同点)；\n\n2.  使用了`disabled`这个属性的Input标签， 它不能够将当前的这个表单控件标签里面的数据发送给服务器进行处理；\n\n3.  使用了`readonly`这个属性的Input标签 ，它能够将当前的这个表单控件标签里面的发送给服务器进行处理\n\n![](form_image10.png)\n\n\n\n### 单行密码框\n\n```html\n<input type=\"password\" name=\"名称\" value=\"值\" />\n```\n\n-   name属性的作用是用来区别表单控件标签的数据\n\n-   value属性表示是用户输入的数据\n\n-   密码框里面的内容是以掩码方式显示 ，用户看不见\n\n![](form_image11.png)\n\n![](form_image12.png)\n\n\n\n### 单选按钮\n\n```html\n<input type=\"radio\" name=\"名称\" value=\"值\" checked=\"checked\" />\n```\n\n-   一组单选按钮一定是只能选择一个， **单选按钮是一组相互排斥的按钮！**\n\n-   如何实现相互排斥的按钮：将它们的**name属性值**设置为一样。\n\n-   **单选框的value属性一定要有值 **\n\n-   程序如何知道用户选择的是哪一个选项：是通过value属性值来确定的。\n\n-   **checked**：表示被选中， 这个属性本身没有值 ，就等于其自己。\n\n![](form_image13.png)\n\n\n\n### 多选按钮\n\n```html\n<input type=\"checkbox\" name=\"名称\" value=\"值\" checked=\"checked\" />\n```\n\n-   一组多选按钮name属性值也要一样！\n\n-   **checked**：表示被选中， 这个属性本身没有值 ，就等于其自己\n\n-   checkbox这个标签的value属性一定要有属性值\n\n![](form_image14.png)\n\n\n\n### 提交按钮\n\n```html\n<input type=\"submit\" name=\"submit\" value=\"提交\" />\n```\n\n一般情况下提交按钮的name属性不写 ，因为我们根本就不需要来接受到提交按钮的value属性值。因为它永远是固定的。\n\n**功能：**就是将表单数据提交给表单的处理程序\n\n![](form_image15.png)\n\n\n\n### 重置按钮\n\n```html\n<input type=\"reset\" name=\"名称\" value=\"值\" />\n```\n\n将表单中表单控件标签输入的内容将其重置！\n\n![](form_image16.png)\n\n\n\n### 图片按钮\n\n```html\n<input type=\"image\" src=\"图片的地址\" />\n```\n\n图片按钮它具有将表单进行提交的功能 ，同时它会将鼠标点击图片上面的坐标值也会进行提交！\n\nPHP可以有选择性的来接受表单数据。\n\n![](form_image17.png)\n\n\n\n### 文件上传\n\n```html\n<input type=\"file\" name=\"名称\" />\n```\n\n如果要实现文件上传的功能 一定要将form标签中的method属性的值设置为\"POST\" 同时要将enctype这个属性的值设置：multipart/form-data\n\n![](form_image18.png)\n\n\n\n### 普通按钮\n\n```html\n<input type=\"button\" name=\"名称\" value=\"值\" />\n```\n\n-   普通按钮它不具有表单提交和重置的功能\n\n-   普通按钮几乎没有什么功能 它一般需要配合JavaScript来使用！\n\n![](form_image19.png)\n\n\n\n### 隐藏域\n\n```html\n<input type=\"hidden\" name=\"名称\" value=\"值\" />\n```\n\n隐藏域这个表单控件里面的数据，我们在浏览器上面是看不见的！比如说有一些数据有重要， 但是不想给普通用户看到。 这个数据又需要提交到服务器上面 ，这个时候我们就可以使用隐藏域来实现 ！\n\n![](form_image20.png)\n\n\n\n### 使用按钮标签\n\n-   提交按钮 \\<button type=\"submit\"\\>内容\\</button\\>\n\n    -   它可以等价于\\<input type=\"submit\" /\\>\n\n-   重置按钮 \\<button type=\"reset\"\\>内容\\</button\\>\n\n    -   它可以等价于\\<input type=\"reset\" /\\>\n\n-   普通按钮 \\<button type=\"button\"\\>内容\\</button\\>\n\n    -   它可以等价于\\<input type=\"button\" /\\>\n\n![](form_image21.png)\n\n\n\n### 下拉列表\n\n```html\n<select name=\"名称\">\n    <option value=\"值\"></option>\n    <option value=\"值\" selected=\"selected\"></option>\n    <option value=\"值\"></option>\n</select>\n```\n\n**selected：这个属性表示被选中 ，这个属性本身也没有值 ，其值也要等于自己**\n\n![](form_image22.png)\n\n\n\n### 文本域\n\n富文本编辑器\n\n**在线编辑器**  ， 它本身就是文本域 ，只不过使用了js代替为富文本编辑器\n\n比如论坛回帖、博客、课堂反馈！\n\n```html\n<textarea cols=\"列数\" rows=\"行数\" name=\"名称\"></textarea>\n```\n\n![](form_image23.png)\n\n\n\n# 十五、标签中的公用属性\n\n**何为公用属性？**\n\n每一个标签中都会公用的属性！\n\n-   title：标题。 当鼠标放上的时候显示的文字信息！\n\n-   **class**：我们将class的属性值称之为\"类名\"，只要是拥有相同的class的属性值， 不管是什么标签 ，我们都可以将其称之为一类！class属性一般多用于**CSS**中。\n\n-   id：id的属性，在一个HTML文档中， ID的属性值必须要唯一！它就好多我们的身份证号码一样！id属性一般多用于**JavaScript中**\n\n-   **style**：它主要是用来设置CSS样式的！\n\n![](form_image24.png)\n\n\n\n# 十六、字符编码\n\n## 何为字符编码？\n\n是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，\n\n## 为什么需要有字符编码？\n\n**计算机只能识别二进制**\n\n字母\"A\"在电脑上是如何存储的呢？\n\n小张的电脑上面字母\"A\"是使用二进制的\"110\"来表示，而小王的电脑上面的字母\"A\"是使用二进制的\"111\"来表示，当小张与小王的电脑进行通信时，这样双方交换信息时就会误解。\n\n小张同学 A \\-- 110 B\\-- 111\n\n小王同学 A \\-- 111 B\\--110\n\n## ASCII字符编码\n\n**ASCII**（American Standard Code for Information Interchange，美国信息交换标准代码） \n\n1个字节共可以表示256位；\n\n在ASCII编码下 一个字符 占用一个字节；\n\nASCII通常将这个编码称之为单字节编码；\n\n**美国国家标准学会** 于1967年制定的！美国标准信息交换码！它是使用1个字节来存储字符！每一个字符占据1个字节。共可以存储256个字符！\n\n1个字节共可以表示8个位 共可以表示256种状态！\n\n1个字节可以存储256个字符！\n\n**英文国家** 的文字1个字节可不可以表示完！\n\n**单字节编码：**英文数字它们就是单字节编码 一个英文或者是数字占用一个字节！\n\n## GB2312\n\nGB2312字符编码它是中国标准化局于1980年制定！它是使用**2个字节来存储字符**！2个字节共可以存储65536个字符！只存储了6000多个汉字！一个汉字是采用2个字节来表示。\n\n中国上下5000的文化 ，汉字博大精深 ，远远不止6000个汉字！\n\n有一些生僻字 GB2312这个编码还没有收录到！\n\n## GBK\n\n它是使用2个字节来存储字符！它总共存储了2W多个汉字！这里存储的只是**简体中文**！\n\n在GBK或者是GB2312中 一个汉字是占用两个字节！\n\n## Big5\n\n大5码\n\n主要是用于存储繁体中文！\n\n中国国家内的人民可以通过电脑进行正常的交流！\n\n中国人民想与日本鬼子进行交流\n\n比如我们班上有位同学找了位日本女朋友 GBK是用来翻译中文 日语翻译不了 就会变成乱码！\n\n就是涉及到国家与国家之间进行交流！\n\n## Unicode\n\n基本上是全世界的编码的集合！大概收录了100多个万字符！每一个字符都采用4个字节来进行表示！4个字节共可以表示42亿！比较浪费资源！\n\nA本身就只需要使用1个字节来存储！\n\n一个汉字本身只需要使用两个字节来存储 这个Unicode它偏用4个字节来进行存储 有两个字节的空间浪费！\n\n## UTF-8\n\n对unicode编码的一种改进，不同的字符占用不同的字节！\n\n**一个汉字是使用三个字节来存储的！**\n\n如果我们以后做的网站是面向中国的用户， 其实我们可以使用GB2312来进行表示。\n\n但是如果我们做的网站有一天出国了 ，走向世界了， 那么就应该使用UTF-8。\n\n\n\n# 十七、head标签\n\n## title标签\n\n它主要的作用是用于给网页设置标题！\n\n![](form_image25.png)\n\n![](form_image26.png)\n\n## meta标签\n\n**用于告诉浏览器使用什么字符编码来解析当前的HTML文件**\n\n```html\n<meta charset=\"utf-8\" >\n```\n\n![](form_image27.png)\n\n![](form_image28.png)\n\n![](form_image29.png)\n\n基本上市面的所有的编辑器都是UTF-8的！\n\n\n\n**如何来保证HTML文件不出现乱码？**\n\n1.  我们要确认编辑器的默认编码方式\n\n2.  告诉浏览器使用编辑器的默认编码方式这个编码来解析HTML文件\n\n**二码合一**：编辑器的编码和告诉浏览器的编码是一样的\n\n\n\n**注意：**\n\n工作的时候 ，千万不要将别人写好的PHP代码使用记事本打开！会出现BOM头！\n\n\n\n\n\n# 一、HTML5简介\n\n## 什么是HTML5\n\n**HTML5是W3C和WHATWG两个组织研发的**\n\n-   W3C叫万维网联盟，主要制定WEB标准，是一个非盈利性的组织。\n\n-   WHATWG (Web Hypertext Application Technology Working Group)叫web超文本技术工作组，是由Firefox(火狐)、Chrome（谷歌）、safari（苹果）、IE（微软）等浏览器公司成立了一个组织。\n\n-   HTML5它是新一代的互联网标准。它的出现是为了取代HTML4.01和XHTML1.0\n\n-   XHTML可扩展的超文本标记语言， 它的出现是为了取代HTML4.01 。\n\n-   HTML5它是于2014年9月份正式发布\n\n-   HTML5它已经不再简单的超文本标记语言\n\n-   HTML5= HTML+CSS+JavaScript 的集合\n\n-   HTML5它主要是在移动端使用的非常多！就是因为移动端的兴起才导致HTML5的发展！\n\n\n\n## 目前支持HTML5的浏览器有哪些？\n\n![](form_image30.png)\n\n**注意：**\n\n并不是上面的浏览器都对HTML5的非常好的支持，它们都只能支持HTML5的某一部分功能！\n\n\n\n## HTML5的文档结构\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n   \t\t<meta charset=\"UTF-8\">\n    </head>\n    <body></body>\n</html>\n```\n\n![](form_image31.png)\n\n\n\n## HTML5新增的语义化标签\n\n**语义化：**当我们看到这些标签时就能明白它其中的含义！\n\n我们在html4和XHTML的时代的时候要实现一个盒子！就要使用div与span标签 。但是在HTML5中新增了语义化标签和div标签同样功能的标签，但是这些标签具有语义化！\n\n-   \\<header\\> 头标签\n\n-   \\<nav\\>    导航标签 navigator\n\n-   \\<aside\\>  侧边栏标签\n\n-   \\<article\\> 文章标签\n\n-   \\<footer\\> 页脚标签\n\n-   \\<section\\> 栏目标签\n\n![](form_image32.png)\n\n\n\n## 表单控件标签中新增的属性\n\n| **属性**        | **功能**           |\n| --------------- | ------------------ |\n| **required**    | 必填项内容不能为空 |\n| **placeholder** | 提示信息  占位符   |\n| **autofocus**   | 自动获取焦点       |\n\n\n\n**required属性：**\n![](form_image33.png)\n\n**required属性功能比较强大， 但是使用不多**\n\n* 第一点：因为用户没有办法指定输入的长度的问题 \n\n* 第二点：required属性显示的效果比较固定 ，不一定适合所有的网站的风格\n\n\n\n\n**Placeholder **\n\n![](form_image34.png)\n\n**autofocus**\n\n![](form_image35.png)\n\n\n\n## 表单控件input标签新增的type属性值\n\n**这里新增的input标签中的type属性值其实主要是用于移动端**\n\n| **属性值** | **功能**                                 |\n| ---------- | ---------------------------------------- |\n| **email**  | 限定用户输入的内容必须是一个email类型    |\n| **url**    | 限定用户输入的内容必须网站要包含http://  |\n| **date**   | 限定用户输入的必须是日期类型  年月日     |\n| **week**   | 限定用户输入的必须是周类型               |\n| **time**   | 限定用户输入的必须是时间类型  小时和分钟 |\n| **month**  | 限定用户输入的必须是月类型               |\n| **number** | 限定用户输入的必须是数值类型             |\n| **color**  | 颜色拾色器                               |\n| **range**  | 范围                                     |\n\n\n\n**注意：** \n\n如果浏览器不能解析type的属性值就会把它当成单行文本框来使用！` type=\"text\"`\n\n![](form_image36.png)\n\n![](form_image37.png)\n\n![](form_image38.png)\n\n![](form_image39.png)\n\n\n\n## 网页多媒体标签\n\nflash\n\n网页小游戏 AS3.0 actionscript3.0 \\-\\--JavaScript ECMA\n\nHTML5它自己开发一个标签来支持视频、音频、动画的播放！\n\n### 视频\n\n```html\n<video></video>\n```\n\n这个标签有浏览器兼容性的问题 它支持的视频格式有限， 大概支持3种视频格式\n\nmp4，ogg，webm\n\n![](form_image40.png)\n\n| **属性**     | **值**   | **描述**                                       |\n| ------------ | -------- | ---------------------------------------------- |\n| **src**      | url地址  | 要播放的视频的url地址。                        |\n| **Autoplay** | autoplay | 如果出现该属性，视频则自动播放                 |\n| **controls** | controls | 如果出现该属性，则向用户显示控件，比如播放按钮 |\n| **width**    | 像素     | 设置视频播放器的宽度。                         |\n| **Height**   | 像素     | 设置视频播放器的高度                           |\n| **loop**     | loop     | 如果出现该属性，视频则重复播放                 |\n\n\n\n![](form_image41.png)\n\n![](form_image42.png)\n\n![](form_image43.png)\n\n### 音频\n\n```html\n<audio></audio>\n```\n\n![](form_image44.png)\n\n\n\n| **属性**     | **值**   | **描述**                                       |\n| ------------ | -------- | ---------------------------------------------- |\n| **src**      | url地址  | 要播放的音频的url地址。                        |\n| **autoplay** | autoplay | 如果出现该属性，音频则自动播放                 |\n| **controls** | controls | 如果出现该属性，则向用户显示控件，比如播放按钮 |\n| **loop**     | loop     | 如果出现该属性，音频则重复播放                 |\n\n\n\n### 嵌入标签\n\n```html\n<embed />\n```\n\n| **属性**   | **值**  | **描述**           |\n| ---------- | ------- | ------------------ |\n| **src**    | url地址 | 设置嵌入内容的URL  |\n| **width**  | 像素    | 设置嵌入内容的宽度 |\n| **height** | 像素    | 设置嵌入内容的高度 |\n\n![](form_image45.png)\n\n\n\n# 二、计算机的单位与进制 \n\n## 计算机中的单位\n\n计算机中的最小单位：比特(Bit) 1个比特位 = 2种状态 1与0 (二进制)\n\n字节(Byte) 1个字节 = 8个比特位 2^8^ = 256 2^16^ = 65536\n\nKB 1KB = 1024个字节\n\nMB 1MB = 1024KB\n\nGB 1GB = 1024MB 256G \\-\\-\\-\\-\\--\\> 200G\n\nTB 1TB = 1024GB\n\n但是硬件在出产的时候都是以1000作为单位来进行计算！\n\n## 计算机中的进制\n\n一种进位的机制 0 1 01 二进制 八进制 十进制 十六进制\n\n二进制：0 1\n\n八进制：0 1 2 3 4 5 6 7\n\n十进制：0 1 2 3 4 5 6 7 8 9\n\n十六进制：0 1 2 3 4 5 6 7 8 9 A B C D E F\n\n计算机它只能识别二进制！ 我们在电脑上面输入任何东西它都将其转换化二进制来进行存储\n\n**进制：**它是一种进位的机制！\n\n\n\n**生活中的进制：**\n\n十进制\n\n24小时1天\n\n60分钟1小时\n\n365天1年\n\n7天1周\n\n\n\n**计算机中的进制**\n\n**二进制：**0、1 运算规则：逢二进一\n\n**八进制：**0、1、2、3、4、5、6、7 运算规则：逢八进一\n\n**十进制：**0、1、2、3、4、5、6、7、8、9 运算规则：逢十进一\n\n**十六进制**：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F 运算规则：逢十六进一\n\n\n\n**基数：**二进制的基数就是2 、八进制的基数就是8 、十进制的基数是10、十六的基数的16\n\n**位权：**每一个位上面都有个权重值\n\n**按权展开相加法**\n\n\n\n**先来观察如何将十进制转换为十进制：**\n\n123456.78 = 1\\*10^5^+2\\*10^4^+3\\*10^3^+4\\*10^2^+5\\*10^1^+6\\*10^0^ + 7\\*10^-1^+8\\*10^-2^\n\n二进制数转换为十进制\n\n101011 = 1\\*2^5^+0\\*2^4^+1\\*2^3^+0\\*2^2^+1\\*2^1^+1\\*2^0^\n\n\n\n**将其他进制转换为十进制：**\n\n(123456.78)~10~ = 1\\*10^5^+2\\*10^4^+3\\*10^3^+4\\*10^2^+5\\*10^1^+6\\*10^0^+7\\*10^-1^+8\\*10^-2^\n~(1101)~2~ = 1\\*2^3^+1\\*2^2^+0\\*2^1^+1\\*2^0^ = 8+ 4+1 = 13\n\n(567)~8~ = 5\\*8^2^+6\\*8^1^+7\\*8^0^ 320 +48+7 = 375\n\n(ABC)~16~ = 10\\*16^2^+11\\*16^1^+12\\*16^0^ = 2748\n\n\n\n**将十进制转换为二进制 分为整数部分和小数部分 **\n\n**整数部分除2取余法 **\n\n**(67)~10~ = (1000011)~2~**\n\n![](2_image30.png)\n\n**小数部分：**\n\n乘2取整法 保留几位小数 也就是说一个问题：如果保留的小数位越多 就越精确 保留的小数越少 就越不精确\n\n(0.75)~10~ = (0.11)~2~\n\n\n\n**将二进制与八进制之间进行互转**\n\n一位八进制要等于三位二进制 \n\n二转八：三合一 将三位二进制合并为一位8进制数\n\n八转二：一拆三 将一位8进制数拆分为三位二进制数 \n\n\n\n**二进制与十六进制之间进行相互转换**\n\n二转十六：四合一 将四位二进制合并为一位16进制\n\n十六转二：一拆四 将一位16进制数拆分为四位二进制 \n\n\n\n**八进制与十六进制之间进行互转**\n\n八转十六：一拆三再四合一 先将一个8进制拆分为3位二进制 再将4位二进制合并为一个16进制 \n\n十六转八：一拆四再三合一 先将一个16进制拆分为4位二进制 再将3位二进制合并为一个8进制 \n\n\n\n# 三、网页中的颜色表示方式\n\n\\<font color=\"red\"\\>\\</font\\>   用于给文本设置大小、字体、颜色\n\n## 颜色的表示方式\n\n比如我们需要给文本设置颜色， 就必须要使用到font标签。\n\nfont标签里面有一个color的属性， 这个属性的值有三种表示方式。\n\n![](form_image46.png)\n\n* `rgb(x,x,x) `  rgb色彩模式 ，十进制表示方式\n* `#xxxxxx`    十六进制表示方式\n* `colorname`    表示颜色的英文单词\n\nrgb(红,绿,蓝) r\\-\\-\\--\\>red g\\-\\-\\-\\--\\>green b\\-\\-\\-\\--\\>blue\n\n\\#xxxxxx 十六进制表示方式\n\nrgb(255,0,0) 表示红色\n\n\\#FF0000 表示红色 15\\*16^1^+15\\*16^0^\n\n## rgb色彩模式\n\n在自然界中有三种基本的颜色 红色、绿色、蓝色 三原色 其它的颜色都可以通过这三种混合而成\n\n计算机同样的引用了这个色彩模式 一个基本色采用一个字节来表示 256种级别的颜色\n\n三种基本色 可以混合出 256^3^ 1677万颜色\n\n问题：我们有三种方式可以来表示颜色 我们最好使用哪一种来表示颜色？\n\n![](form_image47.png)\n\n\n\n\n\n\n\n## 三原色\n\n-   在自然界中有三种基本的颜色：红、绿、蓝 。其RGB色彩模式它的颜色都可以通过这三种基本色混合而成！它们又称之为加色模式！\n\n-   在计算机中同样也是有三种基本色：红、绿、蓝 。每一个基本色是使用1个字节来表示 ，每一个基本色共可以表示256种级别的颜色！那么这三种基本色可以混合多少种颜色？256\\*256\\*256 = 1677万种 。虽然并不一定可以完全表示我们自然界中所有的颜色。\n\n\n","categories":["Html"]},{"title":"Bootstrap","url":"%2Fposts%2F3545416915%2F","content":"\n\n# 一、Bootstrap简介\n\n## 什么是Bootstrap\n\n-   Bootstrap 是由 Twitter 的 Mark Otto 和 Jacob Thornton 两位设计师开发的。\n\n-   Bootstrap 是 2011 年8月在 GitHub 上发布的开源产品。\n\n-   Bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。\n\n-   Bootstrap 是基于 HTML、CSS、JavaScript 的。\n\n-   Bootstrap简洁灵活，使得 Web 开发更加快捷。\n\n-   Bootstrap可以构建出非常优雅的前端界面，而且占用资源非常小。\n\n## 为什么要学习Bootstrap\n\n-   移动设备优先。框架包含了贯穿于整个库的移动设备优先的样式。\n\n-   浏览器支持。所有的主流浏览器都支持。\n\n-   容易上手。只要你具备HTML、CSS、JS基础知识，就可以开始学习。\n\n-   响应式设计。Bootstrap 的响应式 CSS 能够自适应于台式机、平板电脑和手机\n\n-   因为现在Bootstrap很流行， 大多数公司都有在使用！\n\n## 将bootstrap部署到项目中\n\n(1)先下载bootstrap\n\n中文网：[[www.bootcss.com]](http://www.bootcss.com)\n\n![](image1.png)\n\n(2)解压压缩包\n\n![](image2.png)\n\n![](image3.png)\n\nCSS文件夹：\n\n![](image4.png)\n\nFonts文件夹\n\n![](image5.png)\n\nJavaScript文件夹\n\n![](image6.png)\n\n(3)**将bootstrap文件部署到项目中**\n\nbootstrap要求使用的是HTML5的文档！\n\n1.  要设置移动设备优先\n\n![](image7.png)\n\n2.  将bootstrap中的css文件引入到我们当前的项目中 ，通过link标签来引入\n\n![](image8.png)\n\n3.  需要引入bootstrap中的js文件， 通过script标签的src属性来引入\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n  <head>\n    <meta charset=\"utf-8\">\n    <!-- 为了兼容edge浏览器  -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <!-- 设置移动设备优先  -->\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\n    <title>Bootstrap 101 Template</title>\n\n    <!-- Bootstrap  引入CSS文件 -->\n    <link href=\"bootstrap/css/bootstrap.css\" rel=\"stylesheet\">\n\n    <!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 -->\n    <!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 \n    判断ie浏览器如果小于9 就引入下面的两个JS文件  \n    -->\n    <!--[if lt IE 9]>\n      <script src=\"bootstrap/js/html5shiv.min.js\"></script>\n      <script src=\"bootstrap/js/respond.min.js\"></script>\n    <![endif]-->\n  </head>\n  <body>\n    <h1>你好，世界！</h1>\n\n    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\n    <script src=\"bootstrap/js/jquery.min.js\"></script>\n    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\n    <script src=\"bootstrap/js/bootstrap.min.js\"></script>\n  </body>\n</html>\n```\n\n\n\n# 二、全局CSS样式\n\nbootstrap官网给程序猿写好了很多CSS效果！它封装了很多类名 ， 我们只需要使用其封装好的类名\n\n```\n<div class=\"类名\"></div>\n```\n\n## 布局容器\n\n-   .container 类， 用于固定宽度并支持响应式布局的容器。\n\n默认的宽度是1170px\n\n-   .container-fluid 类，用于 100% 宽度，占据全部视口（viewport）的容器。\n\n![](image9.png)\n\n## 排版样式\n\n-   `<p></p>`\n\n![](image10.png)\n\n-   `<h1>~<h6>`或者`.h1~.h6`\n\n![](image11.png)\n\n-   `.text-center` 让文本居中\n\n-   `.text-right` 让文本居右\n\n-   `.text-left` 让文本居左\n\n-   `.text-lowercase` 大转小\n\n-   `.text-uppercase` 小转大\n\n-   `.text-capitalize` 首字母大写\n\n![](image12.png)\n\n-   `.list-unstyled ` 去掉了列表前面的项目符号 清除了ul的padding\n\n-   `.list-inline` 将所有的Li标签的内容排成同一行， 增加了少量的padding ，使用了`display:inline-block `\n\n![](image13.png)\n\n-   `.dl-horizontal` 将dt与dd中的内容排列成一行\n\n![](image14.png)\n\n![](image15.png)\n\n## 按钮样式\n\n-   .btn 按钮的基类 父类的意思\n\n-   .btn-default 默认的按钮\n\n-   .btn-success 成功的按钮\n\n-   .btn-danger 危险的按钮\n\n-   .btn-warning 警告的按钮\n\n-   .btn-info 一般信息的按钮\n\n-   .btn-link 链接效果的按钮\n\n-   .btn-primary 首选项的按钮\n\n-   .btn-lg 超大按钮\n\n-   .btn-sm 小按钮\n\n-   .btn-xs 超小按钮\n\n![](image16.png)\n\n## 表格样式\n\n-   .table  少量的内填充（padding）和水平方向的分隔线\n\n-   .table-bordered 带边框的表格\n\n-   . table-striped 隔行变色的表格\n\n-   .table-hover 鼠标放上高亮的效果\n\n-   .table-condensed 紧凑型的表格， 将padding减半\n\n**下图状态类：**只能行标签与单元格标签设置，也就是说只能给tr或者td 和th\n\n![](image17.png)\n\n![](image18.png)\n\n## 栅格系统\n\n**什么是栅格系统？**\n\nBootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。\n\n栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，把内容放置在列中。\n\n一行最多只能放12个列，表格布局！\n\n### 栅格参数\n\n![](image19.png)\n\n**需求：**\n\n-   如果设备的分辨率在1200像素以上， 我们就1行12列\n\n-   如果设备的分辨率在992到1200像素之间，我们就1行6列\n\n-   如果设备的分辨率在768到992像素之间，我们就1行4列\n\n-   如果设置的分辨率小于768像素， 我们就1行2列\n\n![](image20.png)\n\n### 格式：列偏移 \n\n```\ncol-m-offset-n\n```\n\n说明：\n\nm表示是栅格参数\n\nn表示的是偏移量\n\n### 列嵌套\n\n在一个列里面 嵌套一个栅格系统\n\n## 表单样式\n\n-   .form-control \\<input\\>、\\<textarea\\> 和 \\<select\\> 元素都将被默认设置宽度属性为 width: 100%;。 建议只给单行文本框与单行密码框使用\n\n![](image21.png)\n\n-   form-horizontal  水平排列的表单\n\n-   form-inline 内联表单\n\n> 将这个表单中的所有的表单控制显示在一行内\n>\n> 注意这个form-inline要给form标签设置\n\n![](image22.png)\n\n![](image23.png)\n\n-   form-group 表单组\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n  <head>\n    <meta charset=\"utf-8\">\n    <!-- 为了兼容edge浏览器  -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <!-- 设置移动设备优先  -->\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\n    <title>Bootstrap 101 Template</title>\n\n    <!-- Bootstrap  引入CSS文件 -->\n    <link href=\"bootstrap/css/bootstrap.css\" rel=\"stylesheet\">\n\n    <!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 -->\n    <!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 \n    判断ie浏览器如果小于9 就引入下面的两个JS文件  \n    -->\n    <!--[if lt IE 9]>\n      <script src=\"bootstrap/js/html5shiv.min.js\"></script>\n      <script src=\"bootstrap/js/respond.min.js\"></script>\n    <![endif]-->\n    <style type=\"text/css\"></style>\n  </head>\n  <body>\n    <div class=\"container\">\n      \n     <form class=\"form-horizontal\">\n      <!-- 表现为栅格系统的row -->\n        <div class=\"form-group\">\n          <label for=\"user\" class=\"col-md-2 control-label\">用户名：</label>\n          <div class=\"col-md-4\"><input type=\"text\" id=\"user\" class=\"form-control\"></div>\n        </div>\n         <div class=\"form-group\">\n          <label for=\"pass\" class=\"col-md-2 control-label\">密码：</label>\n          <div class=\"col-md-4\"><input type=\"password\" id=\"pass\" class=\"form-control\"></div>\n        </div>\n        <div class=\"form-group\">\n          <div class=\"col-md-4 col-md-offset-2\">\n            <div class=\"checkbox\">\n              <label>\n                <input type=\"checkbox\">记住我\n              </label>\n            </div>\n          </div>\n        </div>\n        <div class=\"form-group\">\n          <div class=\"col-md-4 col-md-offset-2\">\n            <button class=\"btn btn-success\">提交</button>\n          </div>\n        </div>       \n     </form> \n    </div>\n\n    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\n    <script src=\"bootstrap/js/jquery.min.js\"></script>\n    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\n    <script src=\"bootstrap/js/bootstrap.min.js\"></script>\n  </body>\n</html>\n```\n\n\n\n## 响应式图片\n\n-   img-rounded 有圆角的图片\n\n-   img-circle 圆形图片\n\n-   img-thumbnail 有边框的图片 支持响应式\n\n-   img-responsive 响应式的图片\n\n![](image24.png)\n\n# 三、组件\n\n## 字体图标\n\n[[http://fontawesome.dashgame.com/]](http://fontawesome.dashgame.com/) 一套绝佳的图标字体库和CSS框架\n\n![](image25.png)\n\n## 下拉菜单\n\n-   .dropdown 表示下拉菜单\n\n-   .dropup 上拉菜单\n\n-   .dropdown-menu 它是给ul设置\n\n-   data-toggle:dropdown 是用来控制下拉菜单的显示与隐藏\n\n![](image26.png)\n\n## 按钮组\n\n.btn-group\n\n![](image27.png)\n\n## 分页\n\n.pagination\n\n![](image28.png)\n\n## 路径导航\n\n面包屑导航\n\n![](image29.png)\n\n## 徽章\n\n.badge\n\n## 导航条\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n  <head>\n    <meta charset=\"utf-8\">\n    <!-- 为了兼容edge浏览器  -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <!-- 设置移动设备优先  -->\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\n    <title>Bootstrap 101 Template</title>\n    <!-- Bootstrap  引入CSS文件 -->\n    <link href=\"bootstrap/css/bootstrap.css\" rel=\"stylesheet\">\n\n    <!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 -->\n    <!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 \n    判断ie浏览器如果小于9 就引入下面的两个JS文件  \n    -->\n    <!--[if lt IE 9]>\n      <script src=\"bootstrap/js/html5shiv.min.js\"></script>\n      <script src=\"bootstrap/js/respond.min.js\"></script>\n    <![endif]-->\n    <style type=\"text/css\">\n    </style>\n  </head>\n  <body style=\"height: 2000px;\">\n  <!-- 表示导航条 -->\n   <nav class=\"navbar navbar-inverse navbar-fixed-top\">\n    <!-- 表示布局容器 1170 -->\n    <div class=\"container\">\n    <!-- Brand and toggle get grouped for better mobile display -->\n    <div class=\"navbar-header\">\n      <button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\">\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n      </button>\n      <a class=\"navbar-brand\" href=\"#\">黑马程序员</a>\n    </div>\n    <!-- Collect the nav links, forms, and other content for toggling -->\n    <div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\">\n      <ul class=\"nav navbar-nav\">\n        <li class=\"active\"><a href=\"#\">首页<span class=\"sr-only\">(current)</span></a></li>\n        <li><a href=\"#\">公开课</a></li>\n        <li><a href=\"#\">免费视频教程</a></li>\n        <li><a href=\"#\">学习路线图</a></li>\n        <li><a href=\"#\">技术社区</a></li>\n      </ul>\n      <ul class=\"nav navbar-nav navbar-right\">\n        <li><a href=\"#\">登录</a></li>\n        <li><a href=\"#\">注册</a></li>\n      </ul>\n      <form class=\"navbar-form navbar-right\">\n        <div class=\"form-group\">\n          <input type=\"text\" class=\"form-control\" placeholder=\"Search\">\n        </div>\n        <button type=\"submit\" class=\"btn btn-default\">搜索</button>\n      </form>\n    </div><!-- /.navbar-collapse -->\n  </div><!-- /.container-fluid -->\n</nav> \n    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\n    <script src=\"bootstrap/js/jquery.min.js\"></script>\n    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\n    <script src=\"bootstrap/js/bootstrap.min.js\"></script>\n  </body>\n</html>\n```\n\n","categories":["Bootstrap"]},{"title":"docker技术","url":"%2Fposts%2F1951862235%2F","content":"\n\n# docker 技术\n\n## 简介\n\n**Docker** 是一种容器虚拟化技术，使用Go 语言（golang 谷歌出的一门新的语言，目前也是最有发展潜力的语言，俗称21世纪的C语言，并且作者之一就是之前的C语言之父）（区块链技术的公链开发也是使用GO语言）开发，并遵从 Apache2.0 协议开源。其主要的目的是让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后可以快速的部署到服务器上进行运用。\n\n\n\n![1535707891599](1535707891599.png)\n\n\n\n**相关资源：**\n\n+ [官网](https://www.docker.com/)\n+ [docker仓库](https://hub.docker.com/)\n+ [官方文档](https://docs.docker.com/install/overview/)\n+ [中文社区](http://www.docker.org.cn/index.html)\n+ [docker菜鸟教程](http://www.runoob.com/docker/docker-tutorial.html)\n\n\n\n## 为什么要使用Docker呢\n\n当我们做一个项目，最不想面对的不是开发，也不是调试，而是部署！\n\n\n比如你这个机器上的环境是 PHP7 你用另一个机器上却是 PHP5 或者压根就没有 PHP 环境。\n\n好了，这个时候你怎么解决呢。 对，只要去新机器上你就要部署 PHP。\n\n\n\n嗯~ 好吧， 部署PHP 就 PHP，但是你的项目里面还要用到 MySQL，好的没问题， 你又要去编译安装PHP 操作 mysql 的扩展。 哦对了，有的时候项目里面还有 redis、memcache、swoole， 哦， 还有阿里云的接口，对对对对对对哦。 乱七八糟的东西真的好多，搞完了几个小时没有了，遇到网络卡了，那就更没有谱了。\n\n\n\n**那么，对于上面的问题，常见的解决方案是怎样的呢？**\n\n\n\n希望做到开发和运维是同一个人进行完成，也就是提出一个 **devops** 这个职位。\n\n![1538204318442](1538204318442.png)\n\n学习了docker之后，则开发人员就是代替运维人员进行项目的部署的吗？\n\n答： 不是。因为有些硬件部署的东西还是要运维人员（懂数据库---> 一般都是DBA）。\n\n\n\n**好了， 我们进化到，快速1.0 时代**\n\n1. 购买服务器或者云服务器\n\n2. 项目运行环境搭建，例如lamp或者lnmp环境\n\n3. 将本地开发好的项目代码上传至测试服务器，调试运行\n\n4. 当测试无误后，`灰度发布`到正式的服务器\n\n5. 本地开发，然后在上传测试服务器.....\n\n\n**于是，我们再次加入光荣的进化， 快速2.0时代**\n\n1. 将代码和环境打包至docker的镜像里面，上传至镜像仓库\n2. 将形成的镜像文件，一个命令 pull 了下来，一个命令 docker start XXXXXX 服务起来了。如果是多服务，那就写个docker-compose.file吧。如果是集群部署，有Kubernetes(k8s)、Mesos，Fleet和Swarm这些技术。 所以docker 是部署的最佳辅助。\n\n\n\n## Docker能干什么呢？\n\nDocker属于这种==容器技术==，也使用了虚拟化，那么**容器虚拟化**和**传统的虚拟化**有啥区别呢？\n\n\n\n### 虚拟化简介\n\n虚拟化，是指通过虚拟化技术将一台物理计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。\n\n![1535707942475](1535707942475.png)\n\n+ **VMM** 全称是 Virtual Machine Monitor，虚拟机监控系统，也叫 **Hypervisor**，是虚拟化层的具体实现。主要是以软件的方式，实现一套和物理主机环境完全一样的虚拟环境，物理主机有的所有资源，包括 CPU、内存、网络 IO、设备 IO等等，它都有。这样的方式相当于 VMM 对物理主机的资源进行划分和隔离，使其可以充分利用资源供上层使用。虚拟出的资源以虚拟机的形式提供服务，一个虚拟机本质上和一台物理机没有什么区别，可以跑各种操作系统，在之上再跑各种应用。这种方式无疑是计算机历史上非常里程碑的一步，你想想，以前可能要买多台服务器才能解决的事，现在只用一台就解决了。\n\n+ 虚拟机通常叫做**客户机（guest）**，物理机叫**宿主机（host）**，VMM 处在中间层，既要负责对虚拟资源的管理，包括虚拟环境的调度，虚拟机之间的通信以及虚拟机的管理等，又要负责物理资源的管理，包括处理器、中断、内存、设备等的管理，此外，还要提供一些附加功能，包括定时器、安全机制、电源管理等。\n\n  ![1535707976594](1535707976594.png)\n\n\n\n### 典型的虚拟化产品\n\n- **VMware** \n\n  VMware 可以说是虚拟化的鼻祖，现在很多公司都是在模仿 VMware 的产品，相应用过 VMware 虚拟机的朋友应该不陌生了，VMware 提供了很多的虚拟化产品，从服务器到桌面都有很多应用。主要有面向企业级应用的 ESX Server，面向服务端的入门级产品 VMware Server，面向桌面的主打产品 VMware Workstation（这个相信大家经常用），面向苹果系统的桌面产品 VMware Fusion，还有提供整套虚拟应用产品的 VMware vSphere，细分的话还有 VMware vStorage（虚拟存储），VMware vNet（虚拟网络）等。\n\n\n- **Xen** \n\n  Xen 是一款开源虚拟机软件，Xen 结合了 Hypervisor 模型和宿主模型，属于一种混合的虚拟化模型，基于 Xen 的虚拟化产品也有很多，比如 Ctrix、VirtualIron、RedHat 和 Novell 等都有相应的产品。这个一般是研究机构用得多一些，生产环境中大部分用的是 KVM。\n\n- **KVM** \n\n  KVM 也是一款开源软件，于 2007 年 2 月被集成到了 Linux 2.6.20 内核中，成为了内核的一部分。KVM 采用的是基于 Intel VT 的硬件辅助虚拟化技术，以及结合 Qemu 来提供设备虚拟化，从实现上看，属于宿主模型。使用 KVM 的厂商很多啊，像我们比较熟悉 VMware Workstation 和 VirtualBox 都在使用，在此就不一一列举了。\n\n\n\n### 容器虚拟化\n\n![1538205542757](1538205542757.png)\n\n\n\n上面的传统的虚拟化技术。在很长的一段时间内占据了很大的市场份额，带了的很多的便捷之处，但随之而来的弊端的也是比较多的。\n\n**传统的虚拟化技术弊端：**\n\n+ **虚拟机内部攻击:** 传统的网络安全设备无法查看虚拟机内的网络通信，因而无法检测或抑制源于同一主机的虚拟机的攻击。\n\n- **雪崩效应:** 如果同时一台物理机挂了，上面跑的虚拟机就全挂了。\n- **资源调度复杂:** 由于虚拟机里面的资源的调用都是通过中间层进行转换后最终还是需要物理机进行调用。这样无形之中增加了调度的复杂程度。\n\n\n\n通过上面的了解，我们发现虚拟化的技术存在的主要问题就是安全方面和资源调度的复杂度。则有没有更好的技术来解决这些问题呢？例如对资源调用方面的问题的解决。通过上面的讲解我们发现出现问题的本质是在中间多了一个虚拟主机，则我们是否可以减少虚拟主机，而是通过一定的技术来直接通过物理主机的操作系统来调用资源呢？达到一个轻量级的虚拟化呢？\n\n答：**使用docker基于容器的虚拟化技术**\n\n\n\n### Docker 的应用场景\n\n+ Web 应用的自动化打包和发布\n+ 自动化测试和持续集成、发布\n+ 在服务型环境中部署和调整数据库或其他的后台应用\n+ ......\n\n\n\n\n\n### Docker 的优点\n\n+ **简化程序**：Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成。\n+ **避免选择恐惧症**：如果你有选择恐惧症，还是资深患者。Docker 帮你打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。\n+ **节省开支**：一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。\n\n\n\n\n\n## Docker 引擎\n\n一般我们常说的docker指的就是docker引擎，也就是docker这个应用软件。那么docker引擎到底是啥呢？\n\n\n\n**Docker 引擎**是一个包含以下主要组件的C/S架构应用程序。\n\nDocker 引擎组件的流程如下图所示：\n\n![1535708028027](1535708028027.png)\n\n## Docker 特点\n\n**轻松快捷的配置**\n\n这是Docker的一个主要功能，可帮助我们轻松快速地配置系统。可以在更少的时间和精力的情况下部署代码。 由于Docker可以在各种各样的环境中使用，基础架构不再要求与应用程序的环境相关联。\n\n\n\n**提高工作效率**\n\n通过放宽技术配置和应用的快速部署。 毫无疑问，它节约了时间提高了生产率。 Docker不仅有助于在孤立环境中执行应用程序，而且还减少了资源。\n\n\n\n**应用隔离**\n\nDocker提供用于在隔离环境中运行应用程序的容器。 每个容器独立于另一个容器，并允许执行任何类型的应用程序。\n\n\n\n**云调度**\n\n它是Docker容器的集群和调度工具。 Swarm使用Docker API作为其前端，这有助于我们使用各种工具来控制它。 它还可以将Docker主机集群控制为一个虚拟主机。 这是一个用于启用可插拔后端的自组织引擎组。\n\n\n\n**安全管理**\n\n它允许将保密数据保存到云群 (swarm) 中，然后选择给予服务访问某些保密数据。它包括一些重要的命令给引擎，如保密数据检查，保密数据创建等。\n\n\n\n## Docker 系统架构\n\nDocker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。\n\nDocker 容器通过 Docker 镜像来创建。\n\n\n\n容器与镜像的关系类似于面向对象编程中的对象与类。\n\n| Docker | 面向对象 |\n| ------ | ---- |\n| 镜像     | 类    |\n| 容器     | 对象   |\n\n![1535708059536](1535708059536.png)\n\n\n\n**docker基本组成**\n\n| 标题            | 备注                                                         |\n| --------------- | ------------------------------------------------------------ |\n| 镜像(Images)    | Docker 镜像是用于创建 Docker 容器的模板。                    |\n| 容器(Container) | 容器是独立运行的一个或一组应用。                             |\n|                 |                                                              |\n| 主机(Host)      | 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。       |\n| 仓库(Registry)  | Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。[Docker Hub](https://hub.docker.com/)，国内   [Docker阿里云 ](https://dev.aliyun.com)  提供了庞大的镜像集合供使用。 |\n\n\n\n# ==Docker安装==\n\n可以在任何操作系统上安装 Docker，无论是 Mac，Windows，Linux 还是任何云服务器。在这里，我们将以 Linux Centos 6.8 作为开发环境。注意：这个软件在windows下支撑十分不友好，并且目前只能在windows10通过模拟软件实现，所有不建议使用。\n\n1. centos\n2. Ubuntu操作系统（支撑最好）更新迭代非常快（每半年更新一次）18.x  (14.4 、16.x  LTS)\n\n\n\n## 前提条件\n\nDocker 需要两个重要的安装要求：\n\n- Docker运行在CentOS7上，系统必须是 64 位，且内核版本为3.10以上\n\n- Docker运行在CentOS6.5或者更高的版本上，系统必须是64位，且内核版本为2.6.32-431或者更高\n\n\n要查看当前的内核版本，请打开终端并键入`uname -r`命令以查看内核版本：\n\n```\n[root@dockerTest /]# uname -r\n2.6.32-696.6.3.el6.x86_64\n```\n\n\n\n查看操作系统是32位还是64位，请打开终端并键入`uname -m`命令以查看内核版本：\n\n```\n[root@dockerTest /]# uname -m \nx86_64\n```\n\n\n\n本次使用的阿里云的Centos6.8作为演示。以前使用的 centos5.5是无法使用的，大家需要自行使用 centos6.8 或者 centos7。\n\n\n\n## CentOS6.8安装Docker\n\n1. 安装epel源，这个是一个单独开发出来的yum源，里面包含了redHat公司开发出来的大部分rpm包。\n\n   ```\n   yum -y install epel-release\n   ```\n\n2. 安装docker\n\n   ```\n   yum install -y docker-io\n   ```\n\n3. 查看配置文件\n\n   ```\n   cat /etc/sysconfig/docker\n   ```\n\n4. 启动服务\n\n   ```\n   service docker start\n   ```\n\n5. 查看版本信息\n\n   ```\n   docker version\n   ```\n\n   \n\n6. 由于网络原因，我们在 pull Image 的时候，从`Docker Hub`上下载会很慢... 所以，国内的 Docker 爱好者们就添加了一些国内的镜像 (mirror)，方便大家使用。使用比较多的是阿里云镜像和163镜像。在 `/etc/sysconfig/docker`文件，加入如下信息\n\n   ```\n   # /etc/sysconfig/docker\n   #\n   # Other arguments to pass to the docker daemon process\n   # These will be parsed by the sysv initscript and appended\n   # to the arguments list passed to docker -d\n   \n   # 开始注意 在这里加上如下的阿里云镜像信息\n   # https://dev.aliyun.com/search.html\n   other_args=\"--registry-mirror=https://w59xfqxq.mirror.aliyuncs.com\"\n   # 结束\n   ```\n\n   前往阿里的docker网站，然后找到属于自己的加速镜像url地址\n\n   ![1538209122316](1538209122316.png)\n\n   url地址：\n\n   ![1538209096174](1538209096174.png)\n\n7. 重启docker服务，让配置文件生效\n\n\n```\nservice docker restart\n```\n\n\n\n# ==Docker常用命令==\n\n## 帮助命令\n\n+ docker version\n\n+ docker info\n\n+ docker --help\n\n+ docker COMMAND --help\n\n\n## 镜像命令\n\n+ `docker images `：查看镜像，查看当前这个操作系统里面，docker管理了哪些镜像，如果没有，则我们需要使用一定的命令去docker的仓库（我们配置好的阿里云的加速镜像）下载一些镜像回来。\n\n\n\n+ `docker search  镜像名称`   ：搜索镜像信息\n\n  ![1538209735450](1538209735450.png)\n\n+ `docker pull 镜像名称`     ： 从仓库拉取镜像\n\n  ![1538210011991](1538210011991.png)\n\n+ `docker rmi  镜像ID `：删除镜像\n\n  ![1538211202985](1538211202985.png)\n\n\n\n# ==Docker基本使用==\n\n## 第一个 Docker 应用程序 - hello world\n\nDocker 允许你在容器内运行应用程序， 使用 **docker run** 命令来在容器内运行一个应用程序。\n\n输出Hello world\n\n```\n> docker run ubuntu:15.10 /bin/echo \"Hello world\"\n```\n\n各个参数解析：\n\n- docker：Docker 的二进制执行文件\n- run ：与前面的 docker 组合来运行一个容器\n- ubuntu:15.10   ：指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像\n- /bin/echo \"Hello world\" ：在启动的容器里执行的命令\n\n\n\n以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器(启动该操作系统)，然后在容器里执行 bin/echo \"Hello world\"，然后输出结果。\n\n\n\n通过上面的操作我们可以通过容器输出一个 hello world，那么docker run 到底做了什么呢？\n\n\n\n## 底层原理\n\n1. 先在本地查找镜像文件是否存在 \n   * 如果不存在，则使用 `docker pull` 去docker仓库下载对应的镜像到本地\n   * 如果存在，则直接运行\n2. 然后在使用`docker run`运行这个镜像\n\n\n\n思考：上面的命令我们运行完毕之后，输出hello world，好像不可以在输入其他的命令，也就是没有一个交互式的窗口供开发者输入其他的命令。现在希望可以和\"镜像\"进行交互？\n\n\n\n## 运行交互式的容器\n\n我们通过 docker 的两个参数 `-i` `-t`，让 docker 运行的容器实现\"对话\"的能力\n\n```\n> docker run [--name container_name] -it ubuntu:15.10 /bin/bash\n```\n\n参数解释：\n\n- `-t`：在新容器内指定一个伪终端或终端\n- `-i`：允许你对容器内的标准输入进行交互\n- `--name`： 可选，给容器指定名称，在不使用的情况下，系统自动生成\n\n此时我们已进入一个 ubuntu15.10 系统的容器\n\n我们尝试在容器中运行命令 ls 当前目录下的文件列表\n\n```\nroot@1820f09f44a2:/# ls\nbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n```\n\n\n\n## 退出容器\n\n退出容器的环境，可用如下方法：\n\n- 运行 exit\n- 使用 CTRL + D\n\n\n\n注意：如果启用的是交互模式，则会占据当前的终端，如果要退出，可以按一下ctrl+d，但是这样按了之后，当前的这个启动的镜像就会立刻关闭（相当于该操作系统已经关机）。但是有的我们希望操作系统类似一个服务在后台进行运行，作为一个守护进程。\n\n\n\n## 以后台模式运行容器\n\n使用以下命令创建一个以进程方式运行的容器\n\n```\n > docker run -d ubuntu:15.10 /bin/sh -c \"while true; do echo hello docker; sleep 1; done\"\n```\n\n注意：`-d`选项代表的 daemon ，代表是在后台作为守护进程，不会占据终端，到时候如果我们镜像是一个Nginx服务则会有明显的优势。\n\n\n\n在输出中，我们没有看到期望的\"hello docker\"，而是一串长字符\n\n`0977407542d16c5xxx....`\n\n这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。\n\n首先，我们需要确认容器有在运行，可以通过 `docker ps` 来查看\n\n```\ndocker ps \n```\n\nCONTAINER ID：容器ID\n\nNAMES：自动分配的容器名称\n\n在容器内使用 `docker logs` 命令，查看容器内的标准输出\n\n```\ndocker logs 容器ID\n```\n\n\n\n## 与正在运行的容器交互\n\n```\ndocker exec -it <container_id> /bin/bash\n```\n\n\n\n## 停止容器\n\n```\ndocker stop container_name | container_id\n```\n\n\n\n\n\n# ==Docker 容器管理==\n\n## Docker 客户端\n\ndocker 客户端非常简单 ,我们可以直接输入 `docker` 命令来查看到 Docker 客户端的所有命令选项。\n\n```\n[root@localhost ~]# docker\nUsage: docker [OPTIONS] COMMAND [arg...]\n\nA self-sufficient runtime for linux containers.\n\nOptions:\n\n  --api-cors-header=                   Set CORS headers in the remote API\n  -b, --bridge=                        Attach containers to a network bridge\n  ......\n  --userland-proxy=true                Use userland proxy for loopback traffic\n  -v, --version=false                  Print version information and quit\n\nCommands:\n    attach    Attach to a running container\n    build     Build an image from a Dockerfile\n \t......\n    rmi       Remove one or more images\n    run       Run a command in a new container\n  \t\nRun 'docker COMMAND --help' for more information on a command.\n\n```\n\n可以通过命令 `docker command --help` 更深入的了解指定的 Docker 命令使用方法。\n\n例如我们要查看 `docker run` 指令的具体使用方法\n\n```\n[root@localhost ~]# docker run --help\n\nUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n\nRun a command in a new container\n\n  -a, --attach=[]             Attach to STDIN, STDOUT or STDERR\n  ......\n  -w, --workdir=              Working directory inside the container\n\n```\n\n\n\n## 运行 WEB 容器\n\n前面我们运行的容器并没有一些什么特别的用处。\n\n接下来让我们尝试使用 docker 构建一个 web 应用程序。\n\n我们将在 docker 容器中运行一个 nginx服务。\n\n```\n[root@localhost ~]# docker run -d -P nginx\n73c7e70ab5066a0ea3a8637ad105aec2135bc89281df73a957b88dc9fc00f8f1\n\n```\n\n参数说明：\n\n- `-d`：让容器在后台运行\n- `-P`： 大写，将容器内部使用的网络端口映射到我们使用的主机上\n\n\n\n## 查看 WEB 容器\n\n使用 `docker ps` 来查看我们正在运行的容器\n\n```\n[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                   NAMES\n73c7e70ab506        nginx               \"nginx -g 'daemon of   30 seconds ago      Up 30 seconds       0.0.0.0:32768->80/tcp   thirsty_curie  \n```\n\n这里多了端口信息\n\n```\nPORTS\n0.0.0.0:32768->80/tcp \n```\n\nDocker 开放了 `80` 端口（nginx 默认端口）映射到宿主机端口 `32768` 上。\n\n\n\n这时我们可以通过浏览器访问WEB应用\n\n```\nWelcome to nginx!\nIf you see this page, the nginx web server is successfully installed and working. Further configuration is required.\n\nFor online documentation and support please refer to nginx.org.\nCommercial support is available at nginx.com.\n\nThank you for using nginx.\n```\n\n\n\n我们也可以指定小写的 `-p` 标识来绑定指定端口\n\n```\ndocker run -d -p 8080:80 nginx\n```\n\n`8080` ： 宿主机端口\n\n`80` ： 客户机端口\n\n\n\n## 查询全部容器\n\n```\ndocker ps -a\n```\n\n\n\n## 查看 WEB 应用日志\n\ndocker logs [ID或者名字] 可以查看容器内部的标准输出：\n\n```\n docker logs -f container_name\n```\n\n这个命令和之前的` tail -f log.txt` 实时的刷新文件里面的内容\n\n参数说明：\n\n- `-f`：让 dokcer logs 像使用 tail -f 一样来输出容器内部的标准输出\n\n从上面，我们可以看到应用程序使用的是 8080 端口并且能够查看到应用程序的访问日志。\n\n\n\n## 查看 WEB 应用容器的进程\n\n我们还可以使用 `docker top` 来查看容器内部运行的进程\n\n```\n docker top container_name\n```\n\n\n\n## 检查 WEB 应用程序\n\n使用 `docker inspect` 来查看Docker的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息：\n\n```\ndocker inspect container_name\n```\n\n\n\n## 重启 WEB 应用容器\n\n```\ndocker restart container_name\n```\n\n\n\n## 查询最后一次创建的容器\n\n```\ndocker ps -l\n```\n\n\n\n## 停止WEB应用容器\n\n```\ndocker stop amazing_archimedes\n```\n\n\n\n## 启动已停止的容器\n\n```\ndocker start container_name\n```\n\n\n\n## 移除 WEB 应用容器\n\n我们可以使用 `docker rm` 命令来删除不需要的容器：\n\n```\ndocker rm container_name\n```\n\n**注意**：删除容器时，容器必须是停止状态，否则会报错\n\n\n\n### 一次性删除所有的容器\n\n1. 一次性的获取到所有的容器id\n\n   ```\n   [root@dockerTest ~]# docker ps --help\n   \n   Usage: docker ps [OPTIONS]\n   \n   List containers\n   \n     -a, --all=false       Show all containers (default shows just running)\n     --before=             Show only container created before Id or Name\n     -f, --filter=[]       Filter output based on conditions provided\n     --help=false          Print usage\n     -l, --latest=false    Show the latest created container, include non-running\n     -n=-1                 Show n last created containers, include non-running\n     --no-trunc=false      Don't truncate output\n     -q, --quiet=false     Only display numeric IDs\n     -s, --size=false      Display total file sizes\n     --since=              Show created since Id or Name, include non-running\n   \n   \n   ```\n\n   通过上面的 `-q` 和` -a `选项得知可以获取到所有的container_id\n\n   ```\n   [root@dockerTest ~]# docker ps -qa\n   b05b380be910\n   426e1205819c\n   56f7777b2202\n   53136538a213\n   \n   ```\n\n2. 删除的命令\n\n   ```\n   docker rm container_id\n   \n   ```\n\n   结合起来操作\n\n   ```\n   [root@dockerTest ~]# docker rm -f  $(docker ps -aq)\n   ```\n\n   `-f `必须加上，代表将所有的运行或者没有运行的全部删除，**强制**的意思。\n\n\n\n### 一次性删除所有的镜像\n\n1. 获取所有的镜像的id\n\n   ```\n   [root@dockerTest ~]# docker images --help\n   \n   Usage: docker images [OPTIONS] [REPOSITORY]\n   \n   List images\n   \n     -a, --all=false      Show all images (default hides intermediate images)\n     --digests=false      Show digests\n     -f, --filter=[]      Filter output based on conditions provided\n     --help=false         Print usage\n     --no-trunc=false     Don't truncate output\n     -q, --quiet=false    Only show numeric IDs\n   [root@dockerTest ~]# docker images -qa\n   f0b47291ac45\n   1b7e7036c201\n   1b7e7036c201\n   3b1857c391bb\n   a20949e68a8f\n   254ab22d517d\n   ```\n\n2. 删除镜像\n\n   ```\n   docker rmi image_id\n   ```\n\n   结合起来\n\n   ```\n   [root@dockerTest ~]# docker rmi $(docker images -qa)\n   ```\n\n\n\n# ==Docker镜像管理==\n\n## 镜像列表\n\n我们可以使用 `docker images` 来列出本地主机上的镜像：\n\n```\n[root@localhost ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE\ntomcat              latest              fb269ccd26c4        6 days ago          462.5 MB\nnginx               latest              27b195993ac0        6 days ago          109 MB\nmysql               5.6                 c3354236fd23        6 days ago          256 MB\nhello-world         latest              3535063d9957        13 days ago         1.848 kB\ncentos              latest              88ec626ba223        7 weeks ago         199.7 MB\n[root@localhost ~]# \n```\n\n**选项说明：**\n\n- REPOSITORY：表示镜像的名称\n- TAG：镜像的标签\n- IMAGE ID：镜像ID\n- CREATED：镜像创建时间\n- SIZE：镜像大小\n\n同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有15.10、14.04等多个不同的版本，我们使用 `REPOSITORY:TAG` 来定义不同的镜像。\n\n\n\n所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下：\n\n```\ndocker run -it ubuntu:15.10 /bin/bash\n```\n\n\n\n如果要使用版本为14.04的ubuntu系统镜像来运行容器时，命令如下：\n\n```\ndocker run -it ubuntu:14.04 /bin/bash\n```\n\n如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。\n\n\n\n## 获取镜像\n\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 `docker pull` 命令来下载它。\n\n```\ndocker pull ubuntu:14.04\n```\n\n下载完成后，我们可以直接使用这个镜像来运行容器。\n\n\n\n## 查找镜像\n\n我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： [https://hub.docker.com/](https://hub.docker.com/)\n\n我们也可以使用 `docker search` 命令来搜索镜像。比如我们需要一个 `httpd` 的镜像来作为我们的 `web` 服务。我们可以通过 `docker search` 命令搜索 `httpd` 来寻找适合我们的镜像。\n\n```\ndocker search ubuntu\n```\n\n说明：\n\n- NAME：镜像仓库源的名称\n- DESCRIPTION：镜像的描述\n- STARS：收藏数\n- OFFICIAL：是否docker官方发布\n\n\n\n## 创建镜像\n\n当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改：\n\n- 从已经创建的容器中更新镜像，并且提交这个镜像\n- 使用 Dockerfile 指令来创建一个新的镜像\n\n\n\n## 更新镜像\n\n更新镜像之前，我们需要使用镜像来创建一个容器：\n\n```\ndocker run -it ubuntu:15.10 /bin/bash\n```\n\n\n\n在运行的容器==内==使用 `apt-get update` 命令进行更新。\n\n在完成操作之后，输入 `exit` 命令来退出这个容器。\n\n此时ID为 `9a3dcafd7a83` 的容器，是按我们的需求更改的容器。我们可以通过命令 `docker commit` 来提交容器副本。\n\n**各参数说明：**\n\n- `-m`：提交的描述信息\n- `-a`：指定镜像作者\n- `9a3dcafd7a83`：容器ID\n- `lusifer/ubuntu:v2`：指定要创建的目标镜像名\n\n我们可以使用 `docker images` 命令来查看我们的新镜像 `lusifer/ubuntu:v2`：\n\n```\n docker images\n```\n\n\n\n使用我们的新镜像 lusifer/ubuntu 来启动一个容器：\n\n```\n docker run -it lusifer/ubuntu:v2 /bin/bash\n```\n\n\n\n## 设置镜像标签\n\n我们可以使用 `docker tag` 命令，为镜像添加一个新的标签。\n\ndocker tag 镜像ID，这里是 **6cdd9c6b840d** ，用户名称、镜像源名(repository name)和新的标签名(tag)。\n\n使用 `docker images` 命令可以看到，ID为 **6cdd9c6b840d** 的镜像多一个标签。\n\n```\ndocker images\n```\n\n\n\n# ==Docker数据卷==\n\n## 简介\n\n数据卷是一个可以供一个或多个容器使用的特殊目录。可以保存容器运行过程中产生的数据，达到主机和容器之间的数据共享，同时也可以实现多个容器之间的**数据共享和持久化**。\n\n\n\n## 为什么要使用数据卷呢？\n\n由于docker的容器只能做读操作，在容器运行期间产生的任何数据信息，在关闭后都不会被保留，但是在运行的过程中，有些服务例如mysql产生数据的数据需要做持久化操作，则这个时候就需要一个地方进行数据的持久化操作。\n\n![1538273772522](1538273772522.png)\n\n\n\n**那么当我们使用数据卷后，会解决那些问题呢？**\n\n1. 绕过 \"写-拷贝\" 系统，以达到本地磁盘 IO 的性能，（比如运行一个容器，在容器中对数据卷修改内容，会直接改变宿主机上的数据卷中的内容，所以是本地磁盘IO的性能，而不是先在容器中写一份，最后还要将容器中的修改的内容拷贝出来进行同步。）\n2. 绕过 \"写-拷贝\" 系统，有些文件不需要在 `docker commit` 打包进镜像文件。\n3. 在多个容器间共享目录。\n4. 在宿主和容器间共享目录。\n5. 在宿主和容器间共享一个文件。\n\n## 如何使用呢？\n\n**方法一**：在dockerfile 的 VOLUME 中指定目录，如 `VOLUME /var/lib/test`\n\n**方法二**：`docker run` 命令中加 `-v` 选项。如：\n\n```\n# 直接共享容器目录 -v 容器目录\ndocker run -d -P -v /var/www/html   nginx \n```\n\n\n\n![1538273986512](1538273986512.png)\n\n\n\n**注意：** 这里定义的 `/var/www/html` 数据卷，但是不知道宿主机上与之对应的在哪里。我们需要仔细的观察 `docker inspect` 的结果，是非常长的一段东西。\n\n```\n# 直接挂载宿主机目录 -v 宿主机目录:容器目录\ndocker run -d -P -v /root/docker/nginx:/usr/local/nginx/www   nginx\n```\n\n**注意：** 这里 “Name”: “ae15b45565ac99bc...”，这个并不是容器 id 而是数据卷的 ID，我们可以在 `/var/lib/docker/volumes/` 下找到名为这个数字的目录。它就是我们数据卷在宿主机上对应的目录。\n\n\n\n\n\n## 备份数据卷\n\n这其实是利用 `tar` 命令来执行的。\n\n备份的原理：使用 `tar -zcvf` 对数据卷打包压缩\n\n\n\n如，创建一个 MySQL 容器：\n\n```\ndocker run -p 3306:3306 --name mysql \\\n-v /usr/local/docker/mysql/conf:/etc/mysql \\\n-v /usr/local/docker/mysql/logs:/var/log/mysql \\\n-v /usr/local/docker/mysql/data:/var/lib/mysql \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-d mysql\n\n```\n\n进入 `/usr/local/docker/mysql` 目录，使用 `tar -zxvf backup.tar.gz .` 打包当前目录，即可得到一个压缩包，这个压缩包就是我们需要的备份数据。\n\n\n\n## 恢复数据卷\n\n解压缩备份数据压缩包\n\n```\ntar -zxvf backup.tar.gz\n```\n\n重新启动一个新的容器并将数据卷指向需要还原的数据卷目录(`mysql/backup`)\n\n```\ndocker run -p 3306:3306 --name mysql \\\n-v /usr/local/docker/mysql/backup/conf:/etc/mysql \\\n-v /usr/local/docker/mysql/backup/logs:/var/log/mysql \\\n-v /usr/local/docker/mysql/backup/data:/var/lib/mysql \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-d mysql\n```\n\n\n\n# ==Dockerfile==\n\n## 简介\n\nDockerfile是一个包含 多条docker指令 的文本文档。可以编写的指令为 docker在命令行中的任何命令。 Docker通过读取Dockerfile中的指令自动生成镜像。\n\n\n\n`docker build` 命令用于从Dockerfile构建镜像。\n\n```\ndocker build -t asion:v1.0 . \n```\n\n\n\n## Dockerfile文件示例\n\n```\n# 该指令用于设置后续操作的基础镜像。有效的 Dockerfile 必须使用FROM作为其第一条指令。\nFROM scratch\n# 设置作者信息\nMAINTAINER asion<gogery@163.com>\nADD file.txt /\nLABEL name=\"CentOS Base Image\" \\\n    vendor=\"CentOS\" \\\n    license=\"GPLv2\" \\\n    build-date=\"2016-06-02\"\n\n# 设置执行的命令\nCMD [\"/bin/bash\"]\n```\n\n**注意**：docker的镜像是分层处理的，每层只能完成读的操作，不支持写入。\n\n![1538275210672](1538275210672.png)\n\n![1538275268972](1538275268972.png)\n\n\n\n## Dockerfile构建过程解析\n\n### 基础知识\n\n1. 每条保留字指令都必须为大写字母且后面至少要一个参数\n2. 指令按照从上到下，顺序执行\n3. \\# 代表注释\n4. 每条指令都会创建一个新的镜像层，并对该镜像层进行提交\n\n\n\n### Dockerfile执行流程\n\n1. docker从基础镜像运行一个容器\n2. 执行一条指令并对容器作出修改\n3. 执行类型 docker commit 的操作提交一个新的镜像层\n4. docker基于刚提交的镜像运行一个新的容器\n5. 执行Dockerfile中的下一条指令直到所有的指令执行完成\n\n\n\n## Dockerfile保留字指令\n\n可以在Dockerfile文件中使用`RUN`，`CMD`，`FROM`等指令来快速的构建自己的镜像。\n\n\n\n### FROM\n\n该指令用于设置后续操作的基础镜像。有效的 Dockerfile 必须使用`FROM`作为其第一条指令。\n\n```\nFROM ubuntu\n```\n\n\n\n### MAINTAINER\n\n指定镜像的作者\n\n```\nMAINTAINER <name>\n```\n\n\n\n### RUN\n\n该指令用于执行当前镜像的任何命令。\n\n```\nRUN /bin/bash -c 'echo \"Hello World\"'\n```\n\n\n\n### CMD\n\n用于执行镜像的应用程序。应该以下形式使用CMD\n\n```\nCMD [\"executable\", \"param1\", \"param2\"]\n```\n\n这是使用CMD的首选方法。Dockerfile文件中只能有一个CMD。如果使用多个CMD，则只会执行最后一个CMD。\n\n例：`CMD [\"/bin/echo\", \"this is a echo test\"]`\n\n\n\n### COPY\n\n该指令用于将来自源的新文件或目录复制到目的地的容器的文件系统。\n\n```\nCOPY abc/  /xyz\n```\n\n规则：\n\n* `source`路径必须在构建的上下文之内。无法使用`COPY ../something /something`，因为docker构建的第一步是将上下文目录(和子目录)发送到 docker 守护程序。\n* 如果`source`是目录，则会复制目录的全部内容，包括文件系统元数据。\n\n\n\n### WORKDIR\n\nWORKDIR用于为Dockerfile中的`RUN`，`CMD`和`COPY`指令设置工作目录。\n\n备注：可以简单理解为 `cd` 命令，但是如果目录不存在它会自动创建。\n\n\n\n## 构建镜像\n\n我们使用命令 `docker build` ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。\n\n\n\n每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。\n\n第一条FROM，指定使用哪个镜像源\n\nRUN 指令告诉docker 在镜像内执行命令，安装了什么......\n\n\n\n然后，我们使用 Dockerfile 文件，通过 `docker build` 命令来构建一个镜像。\n\n```\ndocker build -t asion/centos:latest .\n```\n\n**参数说明：**\n\n* `-t` ：指定要创建的目标镜像名\n* `. `：Dockerfile 文件所在目录，可以指定 Dockerfile 的绝对路径\n\n使用 `docker images` 查看创建的镜像已经在列表中存在\n\n\n\n我们可以使用新的镜像来创建容器\n\n```\n docker run -it asion/centos /bin/bash\n```\n\n\n\n# 本地镜像发布到阿里云\n\n当开发者在本地构建好一个拥有各类开发环境的镜像后，可以共享给互联网上的其他的用户使用？\n\n当然可以，这个时候我们可以将自己的本地镜像发布到阿里云的仓库，实现共享。\n\n\n\n1. 基于Dockerfile构建一个容器\n2. 在该容器中配置好相关的环境\n3. 使用docker commit 创建一个新的本地镜像\n4. 登录到阿里云docker平台 https://dev.aliyun.com/search.html\n5. 在后台创建仓库\n6. 将本地镜像推到到仓库\n7. 查看发布的镜像信息\n8. 将阿里云上发布的镜像下载到本地进行使用\n\n\n\n# Docker附录\n\n## Docker 资源链接\n\n### 官方网站\n\nDocker 官方主页：https://www.docker.com\nDocker 官方博客：https://blog.docker.com/\nDocker 官方文档：https://docs.docker.com/\nDocker Store：https://store.docker.com\nDocker Cloud：https://cloud.docker.com\nDocker Hub：https://hub.docker.com\nDocker 的源代码仓库：https://github.com/moby/moby\nDocker 发布版本历史：https://docs.docker.com/release-notes/\nDocker 常见问题：https://docs.docker.com/engine/faq/\nDocker 远端应用 API：https://docs.docker.com/develop/sdk/\n\n\n\n### 实践参考\n\nDockerfile 参考：https://docs.docker.com/engine/reference/builder/\nDockerfile 最佳实践：\nhttps://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/\n\n\n\n### 技术交流\n\nDocker 邮件列表： https://groups.google.com/forum/#!forum/docker-user\nDocker 的 IRC 频道：https://chat.freenode.net#docker\nDocker 的 Twitter 主页：https://twitter.com/docker\n\n\n\n### 其它\n\nDocker 的 StackOverflow 问答主页：https://stackoverflow.com/search?q=docker\n\n\n\n# 参考阅读\n\n\n\n[用Docker和Vagrant构建简洁高效开发环境](http://cloud.51cto.com/art/201503/470256.htm)\n\n[八种最常见Docker开发模式](http://cloud.51cto.com/art/201503/469496.htm)\n\n[Docker学习总结之Docker与Vagrant之间的特点比较](https://www.cnblogs.com/vikings-blog/p/3973265.html)\n\n[**Docker与Vagrant的简单区别**](http://dockone.io/article/271)\n\n[docker 和vagrant比较](https://blog.csdn.net/carolzhang8406/article/details/80153869)\n\n\n\n\n\n","categories":["Docker"]},{"title":"CSS","url":"%2Fposts%2F3999917138%2F","content":"\n\n# 一、CSS简介\n\n## 什么是CSS\n\nCascading Style Sheets  **层叠样式表** 或者叫 **级联样式表**\n\n## CSS的作用\n\n从审美的角度 ，对HTML页面进行美化\n\n## CSS的语法规则 \n\n![](CSS1_image1.png)\n\n-   CSS是由选择器和一对大括号来组成\n\n-   大括号里面是由一条一条的声明语句组成\n\n-   每一条语句的末尾需要有一个英文状态下面的分号\n\n-   语句是由 `属性:值` 组成\n\n-   属性值一般不需要加引号\n\n-   属性值如果是数字 ，一般情况下是有单位的 单位是px\n\n## CSS快速入门\n\n![](CSS1_image2.png)\n\n\n\n# 二、CSS的书写方式\n\n书写方式，即CSS代码写在哪里\n\n**嵌入式**   **外链式**    **行内式**\n\n## 嵌入式\n\n指的是将CSS代码写在HTML文件中的style标签中\n\n![](CSS1_image3.png)\n\n## 外链式\n\n我们可以将CSS代码写在一个文本文件中 ，然后将这个文本文件的扩展名修改为css\n\n要通过HTML中的一个link标签， 然后将css文件链接到html文件中。\n\n![](CSS1_image4.png)\n\n\n\n## 行内式\n\n将CSS代码书写在HTML标签中， 写在HTML标签的style属性值中。\n\n**格式:**\n\n```html\n<标签名 style=\"属性:值;属性:值;\" ></标签名>\n```\n\n![](CSS1_image5.png)\n\n\n\n# 三、注释\n\n**格式：**\n\n```css\n/* 注释的内容 */\n```\n\n**注意：**\n\n千万不要在CSS代码中使用HTML的注释\n\n![](CSS1_image6.png)\n\n\n\n# 四、选择器\n\n## 什么是选择器\n\n选择器是指通过一定的语法规则选取到对应的HTML标记，然后给这个对应的HTML标记设置样式\n\n**选择器分为四大类**：\n\n* 基本选择器\n* 复合选择器\n* 伪类选择器\n* 属性选择器\n\n## 基本选择器\n\n![](CSS1_image7.png)\n\n\n\n**通用选择器：**\n\n![](CSS1_image8.png)\n\n**标签选择器：**\n\n![](CSS1_image9.png)\n\n**类选择器：**\n\n![](CSS1_image10.png)\n\n**交集选择器：**\n\n**格式：**\n\n```CSS\n标签名.class属性值{属性:值;}\n```\n\n![](CSS1_image11.png)\n\n**ID选择器 **\n\n![](CSS1_image12.png)\n\n## 复合选择器\n\n![](CSS1_image13.png)\n\n多元素选择器：\n\n![](CSS1_image14.png)\n\n后代元素选择器：\n\n![](CSS1_image15.png)\n\n子元素选择器：\n\n![](CSS1_image16.png)\n\n相邻元素选择器：\n\n![](CSS1_image17.png)\n\n![](CSS1_image18.png)\n\n## 伪类选择器\n\n> **什么是伪类选择器？**\n>\n> 类选择器：给页面上的指定的类名的元素设置样式\n>\n> 伪类选择器：给页面上的元素设置样式，必须满足一定的条件，我们的伪类选择器设置的样式才会显示。\n>\n> 总结：与类选择器相似，但是又有所不同。\n\n### 锚伪类\n\n**超级链接的不同状态**\n\n-   未访问的状态：超级链接没有被访问 **:link**\n\n-   访问过后状态： 超级链接已经被访问 **:visited**\n\n-   鼠标放上状态： 鼠标放在超级链接上面，但是并没有将鼠标的左键按下去 **:hover**\n\n-   激活状态： 鼠标左键已经按下去了，但是并没有将鼠标的左键弹出 **:active**\n\n**伪类选择器都是带有冒号\":\"**\n\n> ![](CSS1_image19.png)\n>\n> 第一步：我们先创建了一个叫\"27-锚伪类选择器.html文件\"\n>\n> 第二步：我们观察其效果\n>\n> 未访问的状态如下图：\n>\n> ![](CSS1_image20.png)\n>\n> 访问过后的状态效果如下：\n>\n> ![](CSS1_image21.png)\n>\n> 鼠标放上的状态\n>\n> ![](CSS1_image22.png)\n>\n> 激活状态：\n>\n> ![](CSS1_image23.png)\n>\n> **注意：**\n>\n> 超级链接的不同状态它其实是有顺序。也就是说锚伪类选择器设置其实是有顺序。\n>\n> 如果不按照锚伪类选择器的顺序，那么样式就会失效。\n>\n> **顺序：**要遵守\"**爱恨准则**\"要先有爱，才有恨。\"Love Hate\"\n\n\n\n### 超级链接的美化\n\n我们通常会去掉超级链接的下划线，然后同时会给超级链接设置一个颜色。\n\n**一般情况下：**\n\n正常状态与访问过后的状态的样式设置为一样\n\n当鼠标放上的时候给其设置另外一个颜色 激活状态一般不会设置 因为激活状态的时间太短\n\n**举例：**\n\na:link,a:visited{去掉超级链接的下划线;设置一个颜色;}\n\n第一步：我们需要创建一个叫\"28-对超级链接的美化.html\"\n\n![](CSS1_image24.png)\n\n第二步：我们开始写CSS代码 然后对超级链接进行美化\n\n![](CSS1_image25.png)\n\n接下来我们来观察 www.qq.com 这个网站是如何对超级链接进行美化？\n\n```css\na{color:#172c45;text-decoration:none}\n```\n\n上面的这种设置的方式 是集合了a:link与a:visited的功能\n\n```css\na:hover{color:#cd0200;text-decoration:underline}\n```\n\n请参考：29-借鉴腾讯网对超级链接的美化效果.html\n\n![](CSS1_image26.png)\n\n\n\n## 属性选择器\n\n**什么是属性选择器？**\n\n-   属性选择器它是与HTML标签的属性名和属性值有关。\n\n-   属性选择器是通过HTML标签的属性名和属性值来匹配元素。\n\n**attr** 是英文单词\"attribute\"的简写，中文意思\"属性\" 属性名。\n\n**val** 是英文单词\"value\"的简写，中文意思是\"值\" 属性值。\n\n![](CSS1_image27.png)\n\n创建31-属性选择器.html文件\n\n先观察[attr\\]的含义： 通过属性名来匹配元素\n\n![](CSS1_image28.png)\n\n观察\\[attr=val\\]的含义： 通过属性名要等于指定的值来匹配元素\n\n![](CSS1_image29.png)\n\n观察\\[attr\\^=val\\]的含义： 通过属性名要等于指定的值开头的元素才匹配\n\n![](CSS1_image30.png)\n\n观察\\[attr\\$=val\\]的含义： 通过属性名要等于指定的值结尾的元素才匹配\n\n![](CSS1_image31.png)\n\n观察\\[attr\\*=val\\]的含义： 通过属性名中包含指定值则匹配\n\n![](CSS1_image32.png)\n\n\n\n# 五、尺寸样式属性\n\n![](CSS1_image33.png)\n\n![](CSS1_image34.png)\n\n\n\n# 六、文本与字体属性\n\n## 文本属性\n\n| **属性名**      | **值**                                                       | **含义**                                                     |\n| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| color           | \\#ff0000或red或rgb(3,5,8)                                    | 给文本设置颜色                                               |\n| text-align      | left(居左)、right(居右)、center(居中)                        | 设置文本的水平方向对齐 。  **注意：**这个属性只能给块级元素使用 |\n| text-decoration | none(去掉文本修饰线)、**underline**(下划线),、overline(上划线) 、line-through(删除线) | 设置文本修饰线                                               |\n| text-transform  | capitalize、uppercase 、lowercase                            | 大小写转换或者首字母大写                                     |\n| line-height     | 固定值或百分比                                               | 设置行高 一行文字的高度                                      |\n| text-indent     | px或者em                                                     | 设置首行缩进  ，允许负值                                     |\n| letter-spacing  | px                                                           | 设置字符间距 ，  专用于对汉字设置间距                        |\n| word-spacing    | px                                                           | 设置单词间距 ，  专用于对英文单词设置间距                    |\n\n![](CSS1_image35.png)\n\n![](CSS1_image36.png)\n\n![](CSS1_image37.png)\n\n## 字体属性\n\n\n\n| 属性名      | **值**                                                       | **功能**                                                     |\n| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| font-style  | normal(正常)、(italic)斜体                                   | 设置文本为斜体                                               |\n| font-weight | normal(正常)、bold(加粗)                                     | 设置文字粗细                                                 |\n| font-size   | px                                                           | 给文本设置大小   ，如12px、14px 记得加单位                   |\n| font-family | 微软雅黑、楷体、宋体…..                                      | 给文本设置字体                                               |\n| font        | 举例：font:italic bold 14px “微软雅黑”   font-style \\| font-weight \\|   font-size \\| line-height \\| font-family | 简写属性。   能够同时给文本设置斜体、加粗、大小、行高、字体  。   每一个值之间需要使用空格，  并且一定要有顺序 |\n\n\n\n![](CSS1_image38.png)\n\n![](CSS1_image39.png)\n\n## 文本与字体属性综合案例\n\n![](CSS1_image40.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.one{\n\t\t\tcolor: #b52f28;\n\t\t\tfont-size: 24px;\n\t\t}\n\n\t\t.two{\n\t\t\tfont-size: 12px;\n\t\t\tcolor: #ccc;\n\t\t\tfont-family: 楷体;\n\t\t}\n\t\t.three{\n\t\t\tcolor: #00a;\n\t\t}\n\t\n\t\t.first{\n\t\t\tfont-size: 36px;\n\t\t\tcolor: #0f0;\n\t\t}\n\t\t.second{\n\t\t\tfont-size: 36px;\n\t\t\tcolor: #0ff;\n\t\t\tfont-style: italic;\n\t\t\tfont-family: \"宋体\";\n\t\t}\n\t</style>\n</head>\n<body>\n\t<p class=\"one\">新华社北京5月15日电 中共中央总书记、国家主席、中央军委主席、中央外事工作委员会主任习近平5月15日上午主持召开中央外事工作委员会第一次会议并发表重要讲话。习近平强调，要加强党中央对外事工作的集中统一领导，准确把握当前国际形势发展变化，锐意进取，开拓创新，努力开创中国特色大国外交新局面，为实现“两个一百年”奋斗目标、实现中华民族伟大复兴的中国梦作出更大贡献。</p>\n\t<p class=\"two\">新华社北京5月15日电 中共中央总书记、国家主席、中央军委主席、中央外事工作委员会主任习近平5月15日上午主持召开中央外事工作委员会第一次会议并发表重要讲话。习近平强调，要加强党中央对外事工作的集中统一领导，准确把握当前国际形势发展变化，锐意进取，开拓创新，努力开创中国特色大国外交新局面，为实现“两个一百年”奋斗目标、实现中华民族伟大复兴的中国梦作出更大贡献。</p>\n\t<p class=\"three\"><span class=\"first\">新</span>华社北京5月15日电 <span class=\"second\">中共中央总书记、国家主席、中央军委主席</span>、中央外事工作委员会主任习近平5月15日上午主持召开中央外事工作委员会第一次会议并发表重要讲话。习近平强调，要加强党中央对外事工作的集中统一领导，准确把握当前国际形势发展变化，锐意进取，开拓创新，努力开创中国特色大国外交新局面，为实现“两个一百年”奋斗目标、实现中华民族伟大复兴的中国梦作出更大贡献。</p>\n\t<p>新华社北京5月15日电 中共中央总书记、国家主席、中央军委主席、中央外事工作委员会主任习近平5月15日上午主持召开中央外事工作委员会第一次会议并发表重要讲话。习近平强调，要加强党中央对外事工作的集中统一领导，准确把握当前国际形势发展变化，锐意进取，开拓创新，努力开创中国特色大国外交新局面，为实现“两个一百年”奋斗目标、实现中华民族伟大复兴的中国梦作出更大贡献。</p>\n</body>\n</html>\n```\n\n\n\n# 七、列表样式属性\n\n这里的列表指的是：**无序列表**和**有序列表**\n\n因为在整个网页布局中无序列表是使用的最多的。\n\n![](CSS1_image41.png)\n\n**list-style-image**：将列表前面的项目符号设置为一张图片 。它的值是：url(图片的地址)\n\n凡是在CSS中跟图片地址有关的， 都需要将图片的地址放置在url(图片的地址)\n\n**list-style：**这个属性是一个简写属性 它集成了上面三个属性的功能。可以同时设置上面的三个属性。每一个属性值之前使用空格分隔！ 它的属性值可以有一个也可以有两个也可以三个。其属性值个数不定，位置也不定！\n\n**要记的：**\n\n```css\nlist-style-type:none;\nlist-style:none;\n```\n\n![](CSS1_image42.png)\n\n\n\n# 八、列表样式属性加上伪类选择器案例\n\n创建 30-列表样式属性加上伪类选择器案例.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\tli{list-style: none;}\n\t\t.box li{\n\t\t\tline-height: 30px;\n\t\t}\n\n\t\t/*对a标签进行美化*/\n\t\ta{\n\t\t\ttext-decoration: none;\n\t\t\tcolor: #222;\n\t\t}\n\t\t\n\t\ta:hover{\n\t\t\tcolor: #f00;\n\t\t\ttext-decoration: underline;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"box\">\n\t\t<ul>\n\t\t\t<li><a href=\"#\">习近平会见朝鲜劳动党友好参观团</a></li>\n\t\t\t<li><a href=\"#\">习近平会见朝鲜劳动党友好参观团</a></li>\n\t\t\t<li><a href=\"#\">习近平会见朝鲜劳动党友好参观团</a></li>\n\t\t\t<li><a href=\"#\">习近平会见朝鲜劳动党友好参观团</a></li>\n\t\t\t<li><a href=\"#\">习近平会见朝鲜劳动党友好参观团</a></li>\n\t\t\t<li><a href=\"#\">习近平会见朝鲜劳动党友好参观团</a></li>\n\t\t\t<li><a href=\"#\">习近平会见朝鲜劳动党友好参观团</a></li>\n\t\t</ul>\n\t</div>\n</body>\n</html>\n```\n\n![](CSS1_image43.png)\n\n# 九、块级元素与行内元素\n\n在HTML中有两个元素 一种元素称之为**块级元素**， 另外一种元素称之为**行内元素**\n\n块级元素的代表是：**div标签**\n\n行内元素的代表是：**span标签 **\n\n**块级元素的特点：**\n\n1）块级元素它很霸道，它不允许其它的标签或者内容与其排列成一行， 独占一行的空间\n\n![](CSS1_image44.png)\n\n2）块级元素可以设置宽度与高度\n\n![](CSS1_image45.png)\n\n3）如果不能块级元素设置宽度 ，那么它默认宽度会是其父元素的100%\n\n![](CSS1_image46.png)\n\n\n\n**行内元素的特点：**\n\n1.  它允许其它的标签或者是内容与其排列成一行\n\n![](CSS1_image47.png)\n\n2）行内元素不能设置宽度与高度 ，它的宽度与高度要由其内容来决定。\n\n![](CSS1_image48.png)\n\n在CSS中块级元素使用block来表示\n\n在CSS中行内元素使用inline来表示\n\n文本修饰标签、a标签、input标签是行内元素\n\n排版标签、列表标签、表格、表单标签是属于块级元素\n\n**img标签 既不是行内元素也不是块级元素 。它同时拥有行内元素与块级元素的元素 ，行内块元素**\n\n![](CSS1_image49.png)\n\n\n\n# 十、继承性\n\n所谓的继承性指的不是给自身设置样式，它身上的样式是继承性！\n\n## 祖先元素身上的样式会被后代所继承\n\n![](CSS1_image50.png)\n\n## 就近原则\n\n![](CSS1_image51.png)\n\n## 并不是所有的属性都能够被继承\n\n![](CSS1_image52.png)\n\n![](CSS1_image53.png)\n\n在CSS中有以下属性能够被继承：\n\n**文本、字体、列表属性能够被继承！**\n\n**一般情况下我们会给body标签设置以下样式**\n\n**字体大小、字体、文本颜色 **\n\n```html\nbody{\n\tfont-size:XXXX;\n\tfont-family:XXX;\n\tcolor:xxxx;\n}\n```\n\n\n\n**有一个标签非常特殊：a 标签 。这个标签的样式不能继承其父级元素 ，这个标签只能给自己设置！**\n\n![](CSS1_image54.png)\n\n\n\n# 十一、选择器的优先级\n\n选择器的优先级指的是属性设置在当前元素的身上！\n\n## 单个选择器之间的优先级\n\n行内样式\\>ID选择器\\>类选择器\\>标签选择器\n\n![](CSS1_image55.png)\n\n## 多个选择器之间的优先级\n\n**关于多个选择器之间的优先级的计算方法：**\n\n我们要数ID选择器、类选择器、标签选择器的个数\n\nID选择器个数,类选择器个数,标签选择器个数\n\n无论多少个标签选择器都干不过一个类选择器\n\n无论多少个类选择器都干不过一个ID选择器\n\n无论多少个ID选择器都干不过一个行内样式\n\n![](CSS1_image56.png)\n\n个数相同时：如果多个选择器之间的个数相同时要观察CSS代码的书写顺序 ，**谁写在后面就听谁写**！\n\n![](CSS1_image57.png)\n\n选择器之间优先级的问题\n\n![](CSS1_image58.png)\n\n\n\n# \n\n# 十三、!important属性\n\n## 什么是important\n\nimportant在英文中含义是\"重要的\"意思\n\n## !important在CSS中的作用\n\n它主要是用来提升属性的权重。其属性的权重值无穷大！\n\n## 语法格式\n\n```css\n属性:值 !important;\n```\n\n一定要注意!important的语法规则：\n\n-   正确的写法\n\n    -   属性:值 !important;\n\n-   错误的写法\n\n    -   属性:值;!important; 不能将!important写在分号的外面 ，一定要写在分号的里面。\n\n    -   属性:值 important; 不能将`!`给忘记了。\n\n## 使用!important一定要注意以下几点：\n\n先创建02-!important.html\n\n![](CSS2_image1.png)\n\n1.  !important它是提升的属性的权重，而不是提升选择器的优先级！\n\n2.  !important它不能提升继承过来的权重！\n\n![](CSS2_image2.png)\n\n**关于!important综合使用的案例：**\n\n![](CSS2_image3.png)\n\n# 十四、CSS层叠性\n\n==一个标签内可以携带多个类名 (CSS层叠性)==\n\n**类名：指的是class的属性值**\n\n一个标签内可以携带多个类名，指的是class的属性值可以有多个，每一个属性值之间使用空格分隔。\n\n**举例：**\n\n```\n<标签名 class=\"值1 值2 值3\"></标签名>\n```\n\n**多个类名的优点：**\n\n减少CSS的代码量\n\n![](CSS2_image4.png)\n\n**注意：**\n\n如果说一个标签内的多个类名，它们设置的样式是一样的话，就会存在样式的冲突！\n\n这个时候我们主要要观察CSS中的代码的书写顺序 谁写在后面就听谁的！\n\n![](CSS2_image5.png)\n\n# 十五、背景样式属性\n\n![](CSS2_image6.png)\n\n注意：\n\n-   **background-color**：用于给元素设置背景颜色， 但是前提这个元素要么有内容，要么有宽度和高度才可以。![](CSS2_image7.png)\n\n-   **background-image** 用于给元素设置背景图片， 图片的地址一定放在url(图片的地址) 。但是前提这个元素要么有内容，要么有宽度和高度才可以 ，背景图片默认是平铺的。\n\n    ![](CSS2_image8.png)\n-   **background-repeat** 是用于设置背景图片是否平铺 repeat(是平铺)、repeat-x(水平方向平铺)、repeat-y(垂直方向平铺)、no-repeat(不平铺)\n  ![](CSS2_image9.png)\n\n-   **background-position** 用于设置背景图片的位置 ，如果要设置背景图片的位置 ，这个属性就会有两个值。\n\n    水平位置 ， 垂直位置 。这两个值的表示方式有三种 ：`英文单词` `固定值 ` `百分比 ` 。  并且这三种方式可以混合使用 ，可以同时使用英文单词或者是固定值或者是百分比。\n\n    -   英文单词的表示方式\n\n        -   水平位置：left(居左)、center(居中)、right(居右)\n        -   垂直位置：top(居上)、center(居中)、bottom(居下)\n        \n    ![](CSS2_image10.png)\n\n-   固定值的表示方式\n\n    固定值可以是负数， 右下是正值， 左上是负值\n\n    ![](CSS2_image11.png)\n\n-   百分比的表示方式\n\n    ![](CSS2_image12.png)\n\n-   混合表示方式\n\n    关于位置的表示方式， 可以是这三种表示方式混合表示\n\n    ![](CSS2_image13.png)\n\n\n\n# 十六、CSS雪碧图 (CSS精灵图)\n\n**什么是雪碧图？**\n\n在一张大图片上 ， 面放了很多个小图片， 我们可以使用CSS中的图片定位的属性来找到这张大图中的小图片所在的位置。\n\n![](CSS2_image14.png)\n\n**background-attachment** 属性\n\n![](CSS2_image15.png)\n\n-   **background** ：简写属性 ，它可以同时设置多个样式 ，比如背景颜色、背景图片、背景图片是否平铺 ，水平位置， 垂直位置。\n\n-   **background**：简写属性 ，其值的个数不定， 顺序也不定， 每一个值之前使用空格分隔。\n\n![](CSS2_image16.png)\n\n# 十七、背景样式属性综合案例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\tli{\n\t\t\tlist-style: none;\n\t\t\tline-height: 30px;\n\t\t\theight: 30px;\n\t\t\tbackground-image: url(images/li01.jpg);\n\t\t\tbackground-repeat: no-repeat;\n\t\t\t/*设置背景图片的位置*/\n\t\t\tbackground-position: left center;\n\t\t\tpadding-left: 12px;\n\t\t}\n\t\ta{\n\t\t\ttext-decoration: none;\n\t\t\tcolor: #444;\n\t\t}\n\t\ta:hover{\n\t\t\tcolor: #f00;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"box\">\n\t\t<ul>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t\t<li><a href=\"#\">开奥迪男子醉驾撞警车未果</a></li>\n\t\t</ul>\n\t</div>\n</body>\n</html>\n```\n\n![](CSS2_image17.png)\n\n# 十八、标准文档流(了解)\n\n## 什么是标准文档流\n\n我们制作的HTML网页和PS画图软件画图时有本质上面的区别：\n\nHTML网页在制作的时候 都得遵循一个\"流\"的规则：==从左至右、从上至下==\n\n使用PS软件画图时 ，我们想在哪里画个东西 ，就可以在哪里画。\n\n## 标准文档流要注意的事项\n\n1)  空白折叠现象\n\n![](CSS2_image18.png)\n\n![](CSS2_image19.png)\n\n2)  高矮不齐，底部对齐\n\n![](CSS2_image20.png)\n\n**在标准文档流中，**标签只会有三种：\n\n* 行内元素\n* 块级元素\n* 行内块级元素\n\n\n\n# 十九、浮动\n\n**需求：**\n\n能够实现让多个元素排在同一行，并且给这些元素设置宽度与高度！\n\n让多个元素排在同一行：**行内元素的特性**\n\n给这些元素设置宽高：**块级元素的特性**\n\n在标准文档流中的元素只有两种：块级元素和行内元素。如果想让一些元素既要有块级元素的特点也要有行内元素的特点，只能让这些元素脱离标准文档流。\n\n\n\n**浮动**可以让元素脱离标准文档流 ，就可以实现让多个元素排在同一行 ，并且可以设置宽高！\n\n浮动主要是用来解决让多个元素排列在同一行！！！可以是块元素 ，还可以是行内元素。\n\n浮动它是通过一个浮动属性来实现。\n\n\n\n**float：**这个属性有两个值 left(向左浮动) 向左移动 、right(向右浮动) 向右移动\n\n\n\n什么叫浮动元素：\n\n凡是设置了float属性的元素我们就称之为浮动元素！\n\n![](CSS2_image21.png)\n\n**浮动元素的特性： **\n\n-   浮动元素它脱离标准文档流， 它不再占用空间了\n\n-   我们可以把浮动理解为\"漂\"\n\n-   浮动元素它的层级要比标准文档流里面的元素层级要高，它会将标准文档流中的元素给压盖住\n\n-   浮动元素它会向左或者向右进行浮动(移动)\n\n-   浮动元素它遇到了父元素的边框然后就停止了浮动\n\n-   浮动元素它还会遇到上一个浮动元素后就停止了浮动\n\n-   浮动元素浮动以后 ，其父元素不会再包裹着浮动元素\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.box{\n\t\t\tborder:1px solid #000;\n\t\t\twidth: 600px;\n\t\t}\n\t\t.div1{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground-color: #f00;\n\t\t\tfloat: right; /*向右浮动*/\n\t\t}\n\t\t.div2{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground-color: #0f0;\n\t\t\tfloat: right; /*向右浮动*/\n\t\t}\n\t\t.div3{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground-color: #00f;\n\t\t\tfloat: left; /*向左浮动*/\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"box\">\n\t\t<div class=\"div1\"></div>\n\t\t<div class=\"div2\"></div>\n\t\t<div class=\"div3\"></div>\n\t</div>\n</body>\n</html>\n```\n\n![](CSS2_image22.png)\n\n# 二十、浮动案例\n\n浮动的主要目的 ：就是为了实现让**块元素排列在一行**\n\n不是说只有块元素才可以浮动，行内元素也是可以浮动！\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t body{\n\n\t\t    margin-top: 0px;\n\t\t    margin-right: 0px;\n\t\t    margin-left: 0px;\n\t\t    margin-bottom: 0px;\n\n\t\t }\n\t\t.box{\n\t\t\twidth: 100%;\n\t\t\theight: 30px;\n\t\t\tbackground-color: #ccc;\n\t\t}\n\t\t.inner_c{\n\t\t\twidth: 1000px;\n\t\t\theight: 30px;\n\t\t\tline-height: 30px;\n\t\t\tbackground-color: #f00;\n\t\t\tmargin: 0 auto; /*可以实现标签的水平居中*/\n\t\t}\n\t\t\n\t\t.floatR{\n\t\t\tfloat: right;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"box\">\n\t\t<div class=\"inner_c\">\n\t\t\t<span>传智播客</span>\n\t\t\t<span class=\"floatR\">黑马程序员</span>\n\t\t</div>\n\t</div>\n</body>\n</html\n```\n\n![](CSS2_image23.png)\n\n# 二十一、清除浮动\n\n**注意：**\n\n只要有浮动， 那么必须有清除浮动。\n\n**为什么要清除浮动？**\n\n-   因为经过浮动了元素 ，它会影响到它下面的元素的排版布局。\n\n-   还有浮动元素的父元素没有将浮动元素包裹着。\n\n**只要清除了浮动**， 不会影响到浮动元素的下面进行排版布局， 浮动元素的父元素会将浮动元素从视觉上包裹着\n\n\n\n**清除浮动有以下四种方法：**\n\n-   给浮动元素的**父元素**设置一个**固定的高度**\n\n![](CSS2_image24.png)\n\n-   使用清除浮动的样式属性` clear ` 。clear这个属性是专用于来清除浮动的 ，这个属性有三个值 \n    -   clear:left;  清除左浮动\n    -   clear:right; 清除右浮动\n    -   clear:both; 两者都清除 \n\n> 这个属性一般是用在最后一个浮动元素的下面新建一个空白的div ，这个div什么都不要放 ，不要给这个div里面放置内容， 它只做一件事件就是清除浮动\n\n![](CSS2_image25.png)\n\n-   使用`overflow:hidden `这个属性来清除浮动， overflow是一个属性\n\n> overflow:hidden 它原意是用来将溢出的部分进行隐藏， 但是它还可以用于清除浮动\n\n![](CSS2_image26.png)\n\n> **overflow:hidden** 它一般主要是用来将列表的浮动给清除。 overflow:hidden这个方法是给浮动元素的父元素来设置！\n\n![](CSS2_image27.png)\n\n-   使用**伪元素**来清除浮动\n\n![](CSS2_image28.png)\n\n**注意：**\n\n什么时候需要清除浮动，我们的宗旨 ：凡是浮动了元素它影响到下面的元素进行排版的 ，就需要清除。\n\n# 二十二、盒子模型\n\nCSS它把HTML的每一个标签都看作为一个盒子\n\n标签里面可以存放内容\\-\\--标签、文本、图片........\n\n在一个网页中其实就是由一个一个的盒子组成！\n\n**什么是盒子？**\n\n盒子是用来存储物品\n\n**思考一下：**一个盒子是由哪些部分进行组成！\n\n我们可以将一个盒子理解为一个快递的包裹：\n\n有内容+有填充物+纸盒子\n\n那我们如何去理解CSS中的盒子呢？\n\n![](CSS2_image29.png)\n\n在CSS中一个盒子的组成部分：内容(content)+内填充(padding)+边框(border)+外边距(margin)\n\n一个盒子中的主要属性：width、height、padding、border、margin\n\n**width：**指\"宽度\"的意思 但是这里的宽度指的盒子里面的内容的宽度 而不是盒子的宽度\n\n**hegiht：**指\"高度\"的意思 但是这里的高度指的盒子里面的内容的高度 而不是盒子的高度\n\n**padding：**是\"内填充\"的意思，指的盒子里面的内容到盒子边框的距离\n\n**border：**是\"外边框\"的意思 指的盒子的边框\n\n**margin：**是\"外边距\"的意思 指的是盒子与盒子之间的间距\n\n![](CSS2_image30.png)\n\n问：请回答如何计算一个盒子的总宽度？\n\n**一个盒子的总宽度**=盒子里面内容的宽度+左右两边的填充+左右两边的边框线\n\n**一个盒子的总高度**=盒子里面内容的高度+上下两边的填充+上下两边的边框线\n\n**注意：**一个盒子的高度一般情况下是不用设置的，因为一个盒子的高度它应该是由其内容来决定的。\n\n为什么要去计算盒子的宽度？ 为了排版\n\n![](CSS2_image31.png)\n\n![](CSS2_image32.png)\n\n# 二十三、padding\n\npadding是\"内填充\"的意思 指的是盒子中间的内容到边框的这一段距离\n\n方法有两种：第一种我们称之为**全写属性**，第二种我们称之为**简写属性**\n\npadding是有4个方向的 所以我们能够分别的描述这4个方向的padding\n\n## 全写属性\n\npadding-top：上内填充\n\npadding-right：右内填充\n\npadding-bottom：下内填充\n\npadding-left：左内填充\n\n## 简写属性\n\n-   **padding**：这个属性是有方向的 可以同时表示四个方向。 这个属性的方向是有顺序的 ，顺序是顺时针方向， 也就是：上、右、下、左 这个顺序\n\n-   padding:10px 20px 30px 40px; /\\*表示上10 右20 下30 左40\\*/\n\n-   padding: 10px 20px 30px; 表示上10 左右是20 下30\n\n-   padding: 10px 20px; 表示上下10 左右20\n\n-   padding: 10px; 表示上右下左四个方向的内填充都是10\n\n如果说单独设置某一个方向的内填充 ，这个时候我们需要使用到全写属性 ；如果说要同时设置四个方向的内填充 就建议使用简写属性！\n\n![](CSS2_image33.png)\n\n# 二十四、margin\n\nmargin它表示\"外边距\"的意思 **它是指盒子与盒子之间的距离 **\n\nmargin它也是有4个方向的 所以我们也能够通过4个方向对其进行描述\n\n方法有两种：第一种我们称之为全写属性，第二种我们称之为简写属性\n\n## 全写属性\n\nmargin-top：上外边距\n\nmargin-right：右外边距\n\nmargin-bottom：下外边距\n\nmargin-left：左外边距\n\n## 简写属性\n\n-   margin：简写属性它是有方向的 ，这里的方向是一个顺时针的方向， 它的方向是的顺序是：上、右、下、左\n\n-   margin:10px;  表示上右下左这四个方向的外边距都是10像素。\n\n-   margin:10px 20px; 表示上下这两个方向的外边距为10像素 ，左右两个方向的外边距为20像素\n\n-   margin:10px 20px 30px;  表示上外边距为10像素 ，左右外边距为20像素 下外边距为30像素\n\n-   margin:10px 20px 30px 40p;  表示上外边距为10像素， 右外边距为20像素 ，下外边距为30像素 ，左外边距为40像素\n\n> ![](CSS2_image34.png)\n>\n> 什么情况下使用margin使用情况下使用padding\n>\n> 盒子里面的内容到边框的距离 padding\n>\n> 盒子与盒子之间的距离就使用 margin\n\n# 二十五、margin的注意事项\n\n## margin合并现象\n\n**什么是margin的合并现象**\n\n> 1、在标准的文档流中， 垂直方向的元素的margin值会合并 ，它会取较大的值。\n>\n> ![](CSS2_image35.png)\n>\n> 2、水平方向是没有margin的合并现象\n>\n> ![](CSS2_image36.png)\n>\n> 3、浮动元素垂直方向的盒子它是没有margin合并现象\n>\n> ![](CSS2_image37.png)\n\n## margin居中\n\nmargin的值可以是auto auto表示\"自动\"的意思。 当左外边距与右外边距的值都是auto时，当前的这个盒子会在其父元素中水平居中。\n\n![](CSS2_image38.png)\n\n**注意：**\n\n-   使用margin来实现水平居中时， 一定要有固定的宽度(给这个盒子设置一个宽度) 。只有块元素可以实现水平居中， 行内元素是不能实现居中的。\n\n-   只有标准文档流中的盒子才可以使用margin来实现水平居中。\n\n-   margin属性是用来实现盒子的水平居中， 而不是文本的水平居中。\n\n-  **text-align**这个属性它是用于实现文本的水平方向对齐方式 ，如果其值为center就表示文本水平居中， 但是它不能实现盒子的水平居中\n\n![](CSS2_image39.png)\n\n## margin塌陷现象\n\n![](CSS2_image40.png)\n\n第一种方法：给其父元素设置一个边框线\n\n![](CSS2_image41.png)\n\n第二种：给其父元素设置overflow:hidden这个属性也可以实现\n\n![](CSS2_image42.png)\n\n第三种方法：给其父元素设置一个padding-top来实现\n\n![](CSS2_image43.png)\n\n**注意：**\n\nmargin属性是用于描述兄弟与兄弟之间的关系 ，而不是用于描述父子之间的关系。\n\n如果是父子关系， 要善于使用父元素的padding ，而不是使用子元素的margin！\n\n\n\n**如何保证一个盒子高度或者是宽度不变？**\n\n假设一个盒子的总高度是500，本身已经设置了height属性为500，但是突然又设置100个像素 的上内填充 ，这个时候为了保证盒子的高度不变 ，就要减少内容的高度\n\n反过来说， 如果盒子的内容的变高导致整个盒子变高了 ，就要减内填充。\n\n\n\n# 二十六、关于HTML标签的默认样式\n\n因为有一些HTML标签是有默认的样式的 ，有一些内填充与外边距 ，这些样式它会影响到我们使用CSS来布局网页！所以我们需要将这些标签的内填充与外边距的值都要设置为0\n\n**设置的方法有两种：**\n\n1，`*{margin:0;padding:0;} `将所有的标签的内填充与外边距都设置为0 \n\n2，找到对应的标签将这些标签的内填充与外边距设置为0 ，我不知道哪些标签有默认的样式。可以借鉴其它的CSS代码\n\n```css\nbody,dd,dl,fieldset,form,h1,h2,h3,h4,h5,h6,input,legend,ol,p,select,td,textarea,th,ul{margin:0;padding:0}\n```\n\n如果在CSS中的属性的值是数值型数据时候需要加单位\n\n如果值为0 ，可以不用加px\n\n\n\n# 二十七、border\n\nborder：它是\"边框\"的意思\n\n**border-width**\n\n**border-color**\n\n**border-style**\n\n边框有三个要素：粗细、线型、颜色\n\n\n\n**语法格式：**\n\n```css\nborder：粗细 线型 颜色;\n```\n\n说明：\n\n边框的颜色可以省略不写， 但是如果不写的话就表示边框的颜色为黑色， 其它的两个属性值不能不写 ，如果不写的话就会不显示边框。\n\n**边框的线型：** \n\n![](CSS3_image1.png)\n\n**其实边框也是有四个方向的：**\n\nborder-top:上边框\nborder-right:右边框\n\nborder-bottom:下边框\n\nborder-left:左边框\n\nborder-top-color 颜色\n\nborder-top-width 粗细\n\nborder-top-style 线型\n\n\n\n# 二十八、display\n\ndisplay 它是\"显示\"的意思，它就是用来将行内元素与块级元素之间的相互转换！将隐藏的元素显示或者是将显示的元素进行隐藏。它主要是给JavaScript来使用。\n\n**display 属性取值**：inline(行内)、block(块级)、none(无)、inline-block(行内块)\n\n**如何将一个行内元素转换为块级元素呢？**\n\n将display这个属性的值设置为block 这个行内元素就会强制的转换为了块级元素。转换为块级元素后，当前的行内元素就会拥有块级元素的特点。\n\n当我们将一个行内元素的display属性的值设置为block以后， 那么这个元素就会被转换为块级元素。\n\n\n\n**如何将一个块级元素转换为行内元素呢？**\n\n将display这个属性的值设置为inline 这个块级元素就会强制的转换为了行内元素。转换为行内元素后，当前的块级元素就会拥有行内元素的特点。\n\n将我们将一个块级元素的display属性的值设置为inline以后 这个元素就会从块级元素转换为行内元素。\n\n\n\n**注意：**\n\n-   如果说将行内元素转换为了块级元素，那么这个元素它就会拥有块级元素的特点\n\n-   如果说将块级元素转换为了行内元素，那么这个元素它就会拥有行内元素的特点。\n\n将一个显示的元素隐藏、将一个隐藏的元素显示。\n\n```\ndisplay:none(将一个显示的元素进行隐藏)\ndisplay:block(将一个隐藏的元素显示出来)\n```\n\n\n\n# 二十九、position\n\nposition 在英文中表示\"位置\"的意思， 它主要是用于实现对元素的定位\n\n**在CSS中定位分为三种：**\n\nposition:fixed 固定定位\n\nposition:relative 相对定位\n\nposition:absolute 绝对定位\n\n**注意：**\n\n在使用定位属性时，一定要配合定位的坐标来使用！\n\n**left：**表示定位的元素离左边多远\n\n**right：**表示定位的元素离右边多远\n\n**top：**表示定位的元素离上边多远\n\n**bottom：**表示定位的元素离下边多远\n\n\n\n## 固定定位\n\n**语法：**\n\n```css\nposition:fixed;\n```\n\n**固定定位，**它是相对于浏览器窗口来进行定位。不管页面如何滚动，固定定位元素显示的位置不会改变！\n\n![](CSS3_image2.png)\n\n![](CSS3_image3.png)\n\n**特点：**\n\n-   固定定位元素它脱离了标准文档流\n\n-   固定定位元素的的层级比标准文档流里面的元素要高 ，所以固定定位元素它会压盖住标准文档流里面的元素\n\n-   固定定位元素它不再占用空间\n\n-   固定定位元素它显示的位置不会随着浏览器滚动而滚动\n\n**案例1：使用固定定位来实现返回顶部的按钮**\n\n![](CSS3_image4.png)\n\n**案例2：使用固定定位来实现顶部的导航栏**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t*{\n\t\t\tmargin: 0;\n\t\t\tpadding: 0;\n\t\t}\n\t\tli{\n\t\t\tlist-style-type: none;\n\t\t}\n\n\t\t.box{\n\t\t\twidth: 100%;\n\t\t\theight: 58px;\n\t\t\tbackground-color: #222;\n\t\t\t/*固定定位*/\n\t\t\tposition: fixed;\n\t\t\tleft: 0px;\n\t\t\ttop: 0px;\n\t\t}\n\t\t.inner_c{\n\t\t\twidth: 1100px;\n\t\t\theight: 58px;\n\t\t\tline-height: 58px;\n\t\t\tmargin: 0px auto;\n\t\t}\n\t\t.floatL{\n\t\t\tfloat: left;\n\t\t}\n\t\t\n\t\t.floatL ul li{\n\t\t\tfloat: left;\n\t\t\twidth: 160px;\n\t\t\ttext-align: center;\n\t\t}\n\t\t.floatR{\n\t\t\tfloat: right;\n\t\t\tcolor: #9d9d9d;\n\t\t}\n\t\ta{\n\t\t\ttext-decoration: none;\n\t\t\tcolor: #9d9d9d;\n\t\t\tdisplay: block;\n\t\t\twidth: 160px;\n\t\t\theight: 58px;\n\n\t\t}\n\t\ta:hover{\n\t\t\tcolor: #fff;\n\t\t}\n\n\t\tbody{\n\t\t\tpadding-top: 58px;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"box\">\n\t\t<div class=\"inner_c\">\n\t\t\t<div class=\"floatL\">\n\t\t\t\t<ul>\n\t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n\t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n\t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n\t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n\t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n\t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n\t\t\t\t</ul>\n\n\t\t\t</div>\n\t\t\t<div class=\"floatR\">关于</div>\n\n\n\t\t</div>\n\t</div>\n\t<img src=\"images/jd.jpg\">\n</body>\n</html>\n```\n\n![](CSS3_image5.png)\n\n\n\n## 相对定位\n\n**语法：**\n\n```css\nposition:relative;\n```\n\n相对定位它是相对于\"原来的自己\"来进行定位！\n\n**特点：**\n\n-   相对定位元素它没有脱离标准文档流\n\n-   相对定位元素如果没有设置定位的坐标，那么相对定位元素它还在原来的位置\n\n-   相对定位元素设置了定位的坐标以后，那么它会在老家留下一个坑\n\n-   相对定位元素它的层级比标准文档流中的元素要高 所以会将标准文档流里面的元素压盖住\n\n-   相对定位元素的定位坐标值可以是负数\n\n**注意：**\n\n相对定位元素它会在老家留下一个坑，所以一般情况下它很少单独使用，相对定位元素它主要是用来配合\"绝对定位\"元素来使用的。\n\n![](CSS3_image6.png)\n\n![](CSS3_image7.png)\n\n## 绝对定位\n\n**语法：**\n\n```css\nposition:absolute;\n```\n\n**什么是绝对定位？**\n\n绝对定位元素是相对于\"祖先定位元素\"来进行定位！\n\n**什么是祖先定位元素？**\n\n绝对定位元素它会先去判断其父元素是否设置了定位的属性， 如果有设置定位的属性 ，那么它就会相对于其父元素来进行定位；但是如果它的父元素没有设置定位属性， 那么它就会去查找其父元素的上一级元素是否设置了定位的属性，如果有设置就相对于其父元素的上一级元素进行定位， 但是如果没有设置， 那么会继续往向一级进行查找，如果其祖先元素都没有设置定位属性，那么它会相对于\"浏览器窗口\"来进行定位！\n\n**子绝父相**：子元素设置绝对定位，其父元素设置相对定位。\n\n子绝父绝、子绝父固都可以。但是一般我们只会使用子绝父相。\n\n\n\n**问题：**\n\n如果当前元素的父元素与其爷爷元素都设置了相对定位，那么请回答当前的绝对定位元素它会相对于\"谁\"来进行定位？\n\n答：当前的绝对定位元素它会相对于其父元素来进行定位，也就是说当绝对定位元素查找到了其祖先元素已经设置了定位的属性就**不会再去查找上一级元素**。\n\n**特点：**\n\n-   绝对定位元素它脱离了标准文档流\n\n-   绝对定位元素它不再占用空间\n\n-   绝对定位元素它会压盖住标准文档流中的元素\n\n-   绝对定位元素它会相对于其\"祖先定位元素\"来进行定位，这里的祖先定位元素可以是相对定位，也可以是固定定位，还可以是绝对定位。 但是我们一般只会给其实祖先定位元素设置相对定位属性。\"子绝父相\"子元素设置绝对定位父元素设置相对定位\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t*{margin: 0;padding:0;}\n\t\t.box{\n\t\t\twidth: 600px;\n\t\t\tborder:1px solid #000;\n\t\t\tmargin:100px auto;\n\t\t\tposition: relative;\n\t\t}\n\t\t.div1{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground-color: #f00;\n\t\t}\n\n\t\t.div2{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground-color: #0f0;\n\t\t\t/*绝对定位\n\t\t\t它是相对于其祖先定位元素来进行定位的  它先会去判断其父元素是否有设置定位的属性 如果有相对于其父元素来进行定位  如果没有就查找其父元素的上一级元素   然后依次查找  如果它的祖先元素都没有定位  最后它会找到body标签来进行定位 \n\t\t\t*/\n\t\t\tposition: absolute;  \n\t\t\tleft: -50px;\n\t\t\ttop: -50px;\n\t\t\t\t\t\n\t\t}\n\t\t.div3{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground-color: #00f;\n\t\t}\n\t\t.yeye{\n\t\t\twidth: 900px;\n\t\t\tborder:1px solid #000;\n\t\t\t\n\t\t\tmargin: 100px auto;\n\t\t\tposition: relative;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"yeye\">\n\t\t<div class=\"box\">\n\t\t\t<div class=\"div1\"></div>\n\t\t\t<div class=\"div2\"></div>\n\t\t\t<div class=\"div3\"></div>\n\t\t</div>\n\t</div>\n\t\n</body>\n</html>\n```\n\n\n\n**案例二：使用绝对定位来实现京东网的焦点轮播图的效果**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t*{\n\t\t\tmargin:0px;padding:0px;\n\t\t}\n\t\t.jd{\n\t\t\twidth: 790px;\n\t\t\theight: 340px;\n\t\t\tmargin:100px auto;\n\t\t\t/*相对 定位*/\n\t\t\tposition: relative;\n\t\t}\n\t\tli{\n\t\t\tlist-style-type: none;\n\t\t}\n\t\t\n\t\ta{\n\t\t\ttext-decoration: none;\n\t\t\t/*将行内元素转换为块元素*/\n\t\t\tdisplay: block;\n\t\t\theight: 40px;\n\t\t\twidth: 30px;\n\t\t\tline-height: 40px;\n\t\t\ttext-align: center;\n\t\t\tbackground-color: rgba(0,0,0,0.3);\n\t\t\tcolor: #fff;\n\t\t\tfont-weight: bold;\n\t\t\t/*绝对定位*/\n\t\t\tposition: absolute;\n\t\t\ttop: 44%;\n\t\t\tfont-size: 24px;\n\t\t\t/*将a标签隐藏 */\n\t\t\tdisplay: none;\n\t\t}\n\t\t.left{\n\t\t\tleft: 0;\n\t\t}\n\t\t.right{\n\t\t\tright:0;\n\t\t}\n\t\t\n\t\t/*当鼠标放在jd这个div上面时 要让a标签显示出来*/\n\t\t.jd:hover a{\n\t\t\t/*如何将一个隐藏的元素显示出来  也是使用提display属性  但是值是block     */\n\t\t\tdisplay: block;\n\t\t}\n\n\t\ta:hover{\n\t\t\tbackground-color: rgba(0,0,0,0.6);\n\t\t}\n\n\n\n\t</style>\n</head>\n<body>\n\t<div class=\"jd\">\n\t\t<div class=\"img\">\n\t\t\t<ul>\n\t\t\t\t<li><img src=\"./images/1.jpg\"></li>\n\t\t\t</ul>\n\t\t</div>\n\t\t<a href=\"#\" class=\"left\"><</a>\n\t\t<a href=\"#\" class=\"right\">></a>\n\t</div>\n</body>\n</html>\n```\n\n![](CSS3_image8.png)\n\n### 绝对定位的盒子居中\n\n绝对定位之后，所有标准流的规则，都不适用了。所以`margin:0 auto;`失效。\n\n> width: 600px;\n>\n> height: 60px;\n>\n> **position: absolute;**\n>\n> **left: 50%;**\n>\n> top: 0;\n> **margin-left: -300px; → 宽度的一半并且是负数**\n\n![](CSS3_image9.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t*{\n\t\t\tmargin:0px;padding:0px;\n\t\t}\n\t\t.jd{\n\t\t\twidth: 790px;\n\t\t\theight: 340px;\n\t\t\tmargin:100px auto;\n\t\t\t/*相对 定位*/\n\t\t\tposition: relative;\n\t\t}\n\t\tli{\n\t\t\tlist-style-type: none;\n\t\t}\n\t\t\n\t\ta{\n\t\t\ttext-decoration: none;\n\t\t\t/*将行内元素转换为块元素*/\n\t\t\tdisplay: block;\n\t\t\theight: 40px;\n\t\t\twidth: 30px;\n\t\t\tline-height: 40px;\n\t\t\ttext-align: center;\n\t\t\tbackground-color: rgba(0,0,0,0.3);\n\t\t\tcolor: #fff;\n\t\t\tfont-weight: bold;\n\t\t\t/*绝对定位*/\n\t\t\tposition: absolute;\n\t\t\ttop: 44%;\n\t\t\tfont-size: 24px;\n\t\t\t/*将a标签隐藏 */\n\t\t\tdisplay: none;\n\t\t}\n\t\t.left{\n\t\t\tleft: 0;\n\t\t}\n\t\t.right{\n\t\t\tright:0;\n\t\t}\n\t\t\n\t\t/*当鼠标放在jd这个div上面时 要让a标签显示出来*/\n\t\t.jd:hover a{\n\t\t\t/*如何将一个隐藏的元素显示出来  也是使用提display属性  但是值是block     */\n\t\t\tdisplay: block;\n\t\t}\n\n\t\ta:hover{\n\t\t\tbackground-color: rgba(0,0,0,0.6);\n\t\t}\n\n\t\t.focus{\n\t\t\twidth: 120px;\n\t\t\theight: 12px;\n\t\t\tposition: absolute;\n\t\t\tleft: 50%;\n\t\t\tbottom: 20px;\n\t\t\tmargin-left: -60px;\n\t\t}\n\t\t.focus li{\n\t\t\twidth: 12px;\n\t\t\theight: 12px;\n\t\t\tbackground-color: #f00;\n\t\t\tborder-radius: 50%;\n\t\t\tfloat: left;\n\t\t\tmargin-right: 15px;\n\t\t}\n\n\t\t.focus li.last{\n\t\t\tmargin-right: 0px;\n\t\t}\n\n\t</style>\n</head>\n<body>\n\t<div class=\"jd\">\n\t\t<div class=\"img\">\n\t\t\t<ul>\n\t\t\t\t<li><img src=\"./images/1.jpg\"></li>\n\t\t\t</ul>\n\t\t</div>\n\t\t<a href=\"#\" class=\"left\"><</a>\n\t\t<a href=\"#\" class=\"right\">></a>\n\t\t<div class=\"focus\">\n\t\t\t<ol>\n\t\t\t\t<li></li>\n\t\t\t\t<li></li>\n\t\t\t\t<li></li>\n\t\t\t\t<li></li>\n\t\t\t\t<li class=\"last\"></li>\n\t\t\t</ol>\n\t\t</div>\n\t</div>\n</body>\n</html>\n```\n\n\n\n# 三十、z-index属性\n\n-   z-index表示谁压盖着谁，数值大的会压盖住数值小的\n\n-   只有定位的元素才有z-index值 。只有设置了固定定位、相对定位、绝对定位了的元素它们才会拥有z-index\n\n-   z-index的值是没有单位的。 值是一个正整数 。默认的z-index的值是0\n\n-   如果多个定位元素没有设置z-index属性 或者z-index值设置一样 ，那么写在HTML后面的定位元素就会压盖住前面的定位元素\n\n    ![](CSS3_image10.png)\n\n    ```html\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n    \t<meta charset=\"UTF-8\">\n    \t<title>Document</title>\n    \t<style type=\"text/css\">\n    \t\t*{\n    \t\t\tmargin: 0;\n    \t\t\tpadding: 0;\n    \t\t}\n    \t\tli{\n    \t\t\tlist-style-type: none;\n    \t\t}\n    \n    \t\t.box{\n    \t\t\twidth: 100%;\n    \t\t\theight: 58px;\n    \t\t\tbackground-color: #222;\n    \t\t\t/*固定定位*/\n    \t\t\tposition: fixed;\n    \t\t\tleft: 0px;\n    \t\t\ttop: 0px;\n    \t\t\tz-index: 99999999;\n    \t\t}\n    \t\t.inner_c{\n    \t\t\twidth: 1100px;\n    \t\t\theight: 58px;\n    \t\t\tline-height: 58px;\n    \t\t\tmargin: 0px auto;\n    \t\t}\n    \t\t.floatL{\n    \t\t\tfloat: left;\n    \t\t}\n    \t\t\n    \t\t.floatL ul li{\n    \t\t\tfloat: left;\n    \t\t\twidth: 160px;\n    \t\t\ttext-align: center;\n    \t\t}\n    \t\t.floatR{\n    \t\t\tfloat: right;\n    \t\t\tcolor: #9d9d9d;\n    \t\t}\n    \t\ta{\n    \t\t\ttext-decoration: none;\n    \t\t\tcolor: #9d9d9d;\n    \t\t\tdisplay: block;\n    \t\t\twidth: 160px;\n    \t\t\theight: 58px;\n    \n    \t\t}\n    \t\ta:hover{\n    \t\t\tcolor: #fff;\n    \t\t}\n    \n    \t\tbody{\n    \t\t\tpadding-top: 58px;\n    \t\t}\n    \t\tp{\n    \t\t\twidth: 100px;\n    \t\t\theight: 100px;\n    \t\t\tbackground-color: #f00;\n    \t\t\tposition: relative; /*相对定位*/\n    \t\t}\n    \t</style>\n    </head>\n    <body>\n    \t<div class=\"box\">\n    \t\t<div class=\"inner_c\">\n    \t\t\t<div class=\"floatL\">\n    \t\t\t\t<ul>\n    \t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n    \t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n    \t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n    \t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n    \t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n    \t\t\t\t\t<li><a href=\"#\">bootstrap中文网</a></li>\n    \t\t\t\t</ul>\n    \n    \t\t\t</div>\n    \t\t\t<div class=\"floatR\">关于</div>\n    \n    \n    \t\t</div>\n    \t</div>\n    \t<p></p>\n    \t<img src=\"images/jd.jpg\">\n    \t\n    </body>\n    </html>\n    ```\n\n    \n\n* 如果父元素怂了  那么子元素再牛逼都没有用\n\n  ```html\n  <!DOCTYPE html>\n  <html lang=\"en\">\n  <head>\n  \t<meta charset=\"UTF-8\">\n  \t<title>Document</title>\n  \t<style type=\"text/css\">\n  \t\t.box{\n  \t\t\twidth: 200px;\n  \t\t\theight: 200px;\n  \t\t\tbackground-color: #f00;\n  \t\t\tposition: relative;\n  \t\t\tz-index: 999;\n  \t\t}\n  \t\t.box1{\n  \t\t\twidth: 200px;\n  \t\t\theight: 200px;\n  \t\t\tbackground-color: #00f;\n  \t\t\tposition: relative;\n  \t\t\tz-index: 2;\n  \t\t}\n  \t\t.son{\n  \t\t\twidth: 100px;\n  \t\t\theight: 100px;\n  \t\t\tbackground-color: pink;\n  \t\t\tposition: absolute;\n  \t\t\tleft: 300px;\n  \t\t\ttop: 400px;\n  \t\t\tz-index: 2;\n  \t\t}\n  \n  \t\t.son1{\n  \t\t\twidth: 100px;\n  \t\t\theight: 100px;\n  \t\t\tbackground-color: skyblue;\n  \t\t\tposition: absolute;\n  \t\t\tleft: 350px;\n  \t\t\ttop: 250px;\n  \t\t\tz-index: 99999;\n  \t\t}\n  \n  \t</style>\n  </head>\n  <body>\n  \t<div class=\"box\">\n  \t\t<div class=\"son\"></div>\n  \t</div>\n  \n  \t<div class=\"box1\">\n  \t\t<div class=\"son1\"></div>\n  \t</div>\n  </body>\n  </html>\n  ```\n\n\n  ![](CSS3_image11.png)\n\n\n\n# 三十一、CSS 3\n\n## CSS3与CSS2之间的区别\n\n**css3**=css2+新语法+新的属性\n\n就是对css2进行扩充 删减 优化\n\n## 结构伪类\n\n| **选择器**                                       | **功能**                        |\n| ------------------------------------------------ | ------------------------------- |\n| **E:first-child**                                | 匹配第一个孩子                  |\n| **E:last-child**                                 | 匹配最后一个孩子                |\n| **E:nth-child(n)**                               | 匹配第n个孩子                   |\n| **E:nth-child(2n)**   或   **E:nth-child(even)** | 匹配偶数的孩子  如：2、4、6…..  |\n| **E:nth-child(2n+1)**   **E:nth-child(odd)**     | 匹配奇数的孩子  如：1、3、5…..  |\n| **E:only-child**                                 | 匹配有且只有一个孩子 (独生子女) |\n| **E:nth-last-child(n)**                          | 匹配第几个孩子，倒着计算        |\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\n\t\tul{\n\t\t\twidth: 600px;\n\t\t\tlist-style: none;\n\t\t\tmargin: 100px auto;\n\t\t}\n\t\tli{\n\t\t\twidth: 80px;\n\t\t\theight: 80px;\n\t\t\ttext-align: center;\n\t\t\tline-height: 80px;\n\t\t\tborder:1px solid #000;\n\t\t\tfloat: left;\n\t\t\tmargin: 0px -1px -1px 0px;\n\t\t}\n\n\t\t/* li:first-child{\n\t\t\tbackground-color: #f00;\n\t\t} */\n\n\t\t/* li:last-child{\n\t\t\tbackground-color: #f00;\n\t\t} */\n\t\t/* li:nth-last-child(3){\n\t\t\tbackground-color: #f00;\n\t\t} */\n\n\t\tli:nth-child(7n){\n\t\t\tbackground-color: #f00;\n\t\t}\n\n\t\tli:only-child{\n\t\t\tbackground-color: purple;s\n\t\t}\n\n\t</style>\n</head>\n<body>\n\t<ul>\n\t\t<li>1</li>\n\t\t<li>2</li>\n\t\t<li>3</li>\n\t\t<li>4</li>\n\t\t<li>5</li>\n\t</ul>\n\t\n\t<ul>\n\t\t<li>独生子女</li>\n\t</ul>\n\n</body>\n</html>\n```\n\n\n\n## border-collapse\n\n这个属性主要是用于来合并表格的边框线， 其值为：`collapse`\n\n```css\nborder-collapse:collapse;\n```\n\n![](CSS3_image12.png)\n\n\n\n## 伪元素\n\n| **选择器**        | **功能**                           |\n| ----------------- | ---------------------------------- |\n| **:first-letter** | 操作当前元素中第一个字             |\n| **:first-line**   | 操作当前元素中第一行文字           |\n| **::before**      | 在之前插入，在一个盒子内部的最前面 |\n| **::after**       | 在之后插入，在一个盒子内部的最后面 |\n\n\n![](CSS3_image13.png)\n\n![](CSS3_image14.png) \n\n\n\n## 文本阴影\n\n```css\ntext-shadow:水平阴影 垂直阴影 模糊距离 阴影颜色\n```\n\n![](CSS3_image15.png)\n\n**描述：**\n\n-   文字阴影可以有多组值，多组之间用逗号隔开就可以\n\n-   水平阴影正值，阴影在右边， 负值在左边\n\n-   垂直阴影正值，阴影在下边，负值在阴影上边\n\n-   模糊距离，值越大越模糊\n\n![](CSS3_image16.png)\n\n\n\n## 盒子阴影\n\n```css\nbox-shadow:水平方向阴影 垂直方向阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴\n```\n\n水平阴影和垂直阴影必须的写，其余的是可以省略不写;\n\n![](CSS3_image17.png)\n\n![](CSS3_image18.png)\n\n-   盒子阴影可以有多组值，多组之间用逗号隔开就可以\n\n-   水平阴影正值阴影在右边 ，负值在左边\n\n-   垂直阴影正值在下边，负值在上边\n\n-   模糊尺寸，值越大越模糊\n\n\n\n## 圆角边框\n\n```css\nborder-radius:左上 右上 右下 左下;\n```\n\n如果说border-radius的四个值都是一样的话，就可以只需要写一个参数就可以了。\n\n![](CSS3_image19.png)\n\n## CSS透明度\n\n只要是颜色，都可以用透明度\n\n```css\nrgba(红色,绿色,蓝色,透明度)\n```\n\n**a**：表示透明度的意思 。透明度取值：0\\~1之间 。0表示完全透明 ，1表示不透明\n\n-   背景颜色透明\n\n    ```css\n    Background-color:rgba(255,255,255,0.3)\n    ```\n\n-   文本颜色透明\n\n    ```css\n     Color:rgba(255,255,255,0.3)\n    ```\n\n-   边框颜色透明\n\n    ```css\n    Border:1px solid rgba(255,255,255,0.5)\n    ```\n\n想给图片设置透明度\n\n![](CSS3_image20.png)\n\n\n","categories":["CSS"]},{"title":"Composer 笔记","url":"%2Fposts%2F2185734586%2F","content":"\n\n# Composer\n\n## 前言\n\n![img](wpsC3D.tmp.jpg) \n\n当我们在做项目开发的时候，我们不可避免的需要进行一些`通用性`的功能，例如文件上传、缩略图的处理、二维码生成等等；当遇到这些需求后我们可以自己进行代码编写，函数封装、类库封装等操作，然后形成自己的代码库，以便下一次使用，但是自己写出来的代码毕竟经受的检验较少，所以我们一般会去网上搜寻相关的类库进行使用（便捷性），但是如果是在网上搜索的代码安全性和健壮性又很难得到保障，则这个时候有个我们迫切的需要一个类似nodejs里面的npm、python里面的pip、java里面的maven、linux下yum、apt-get等这样的包管理器，可以帮我们去管理这些类库，让开发者专门于业务的开发。哪里有需求，则哪里就有活雷锋，这个时候PHP的类库管理工具composer横空出生了！\n\n 例如：我们现在学习laravel框架\n\n```\n> composer create-project laravel/laravel=5.2.* local.laravel52.com\n```\n\n例如：我们现在学习日志类\n\n```\n> composer  require monolog/monolog \n```\n\n\n\n当我们使用composer管理的这些类库的时候，这些类库都遵循PHP-FIG这个组织制定的一些列的规范，所以在正式需要composer之前，我们的先了解一下这些规范(PSR : php 标准推荐)。\n\n \n\n## psr规范简介\n\n**php-fig**组织：主要是为了多个开源产品之间的一个互通问题。所以有一些开发者资源的组织起来来规范了PHP代码书写的标准，形成的标准规范被称为PSR规范。注意，该规范里面定义了很多的标准，例如：\n\n \n\npsr-1：代码基本规范，规范代码基本书写风格\n\npsr-2：对psr-1该版本的补充，增强\n\npsr-3：对日志类库进行规范 ，例如常见的 monolog类库（定义好日志类的 interface）\n\npsr-4：类库的自动加载机制，命名空间需要和类库的目录结构一致\n\n \n\n**参考文档：**\n\nhttp://psr.phphub.org/\n\n<http://www.cnblogs.com/52php/p/5852572.html>\n\n\n\n## Composer简介\n\n今天学习的知识点是PHP里面的类库管理，在正式讲解该知识点的时候，我们回顾这样一些这样的场景，当我们在Windows上装一些软件的时候，在iPhone手机或者安卓上装APP的时候，我们会怎么做呢？\n\n \n\n我们习惯于去软件管家商店进行下载APP store，例如常见的QQ软件管家，360软件管家，同样的问题也是会在PHP开发里面出现，例如我们的项目需要使用验证码、做文件上传、还有微信开发的类库，则我们该如何处理这些类库呢？\n\n答： 百度查询…\n\n![img](wpsC4E.tmp.jpg) \n\n\n\n在互联网上存在一个[PHP的应用商店](https://packagist.org/)，提供了PHP开发过程中常见的类库（需要遵循psr规范）。但是该网站只是提供一个类库对应的描述信息，以及下载地址。最终的类库文件的源码还是存在**GitHub代码托管**平台上的。该商店只是提供了对应的链接，下载的时候还是去GitHub上面进行下载。\n\n![img](wpsC5E.tmp.jpg) \n\n \n\n \n\n那么我们使用什么样的工具去下载PHP应用商店里面的类库信息呢?\n\n答：使用**composer软件**即可。\n\n\n\nComposer 是 PHP 的一个包==依赖管理工具== ， 不是一个包管理器。 能够帮助我们安装我们项目所需要的依赖包。\n\n除了解决文件依赖的关系，它还有更多的**优点**：\n\n* 下载网络上别人分享的优秀的类库（包）。\n* 可对下载的类库进行管理，如：删除、更新等众多便利的操作。\n\n\n\n其实composer也就类似与Linux中yum，前端中的npm、bower等操作。这些工具都是可以用来管理我们项目的依赖文件。\n\n\n\n**Composer 官网**：<https://getcomposer.org/>\n\n**Composer 包地址**：https://packagist.org/\n\n**国内网站**：<http://www.phpcomposer.com/>\n\n \n\n## 为什么要学习Composer呢？\n\n1. 不用重复造轮子（把被人的上传类库拿过来直接使用，不要自己编写）\n2. 不用过分的关心某个功能的底层，只需要会看文档即可\n3. 解决类库的依赖问题（例如某个项目需要使用其他的产品，则会自动的解决）\n4. ..............\n\n \n\n## 如何使用Composer呢？\n\n### 安装\n\n**安装方式一般有两种方式：**\n\n* 第一种方式：\n\n  去composer官网( https://getcomposer.org/download/ )下载`Composer-setup.exe`进行在线安装，由于此软件安装需要联网且服务器在国外安装很难成功，所以这里推荐使用下面第二种方式进行安装。\n\n  ![](image2.png)\n\n* \\[**==推荐==**\\]第二种方式\n\n  去官网https://getcomposer.org/download 下载`composer.phar`文件。\n\n  ![](image3.png)\n\n  找到并进入 PHP 的安装目录,将下载的`composer.phar` 复制到 ==PHP 的安装目录==下面，也就是和 php.exe 在同一级目录。\n\n  ![](image4.png)\n\n  在 PHP 安装目录（如，`D:\\phpStudy\\php\\php-5.6.27-nts`）下新建一个` composer.bat `文件，并将下列代码保存到此文件中。\n\n  ```basic\n  @php \"%~dp0composer.phar\" %*\n  ```\n\n  至此composer的安装就完成。\n\n\n\n### 测试\n\n 进入对应php版本目录(`D:\\phpStudy\\php\\php-5.6.27-nts`)中输入`composer`指令，出现如下提示代表安装成功：\n\n![](image5.png)\n\n  \n\n  为了可以全局（任意位置）访问composer，可以把php.exe的所在目录（`D:\\phpStudy\\php\\php-5.6.27-nts`）定义在环境变量path选项中。\n\n  ![](image6.png)\n\n  设置好后输入`php -v`  即可看到php版本号。\n\n  ![](image7.png)\n\n  cmd中任意位置输入`composer`指令：\n\n  ![](image8.png)\n\n\n\n通过上面的安装我们可以使用composer这个软件，没有任何问题，但是在使用过程，可能还需要去开启PHP的一些扩展。\n\n1. php_curl扩展\n2. php_openssl扩展\n3. php_fileinfo扩展\n4. php_mbstring扩展（多字节扩展库）\n\n在成功开启后，使用 phpinfo函数进行测试。\n\n \n\n### 为composer配置国内镜像\n\n由于composer需要去网址为https://packagist.org 获取代码库地址，再通过地址去github上去下载代码到我们项目本地，由于这两个地址服务器都在国外，访问比较慢，也不稳定。\n\n![](image9.png)\n\n**镜像原理**\n\n![img](wpsDF5.tmp.jpg) \n\n \n\n配置国内镜像：https://pkg.phpcomposer.com/\n\n输入命令\n\n其它源：\n\n```\ncomposer config -g repo.packagist composer https://packagist.laravel-china.org \n```\n\n\n\n**全局配置**：\n\n```\ncomposer config -g repo.packagist composer https://packagist.phpcomposer.com\n```\n\n![](image10.png)\n\n如上，参看composer配置命令，可查看composer配置保存的路径，全局的默认在当前用户文件夹下。\n\n\n\n**局部配置**：若只想在当前项目中有效，把上面的命令去掉 -g 即可。\n\n```\ncomposer config  repo.packagist composer https://packagist.phpcomposer.com\n```\n\n\n\n# ==Composer常见命令使用==\n\n在composer做类库的管理过程中，我们先需要去PHP的应用商品。去查看开发过程中需要的类库。然后使用composer进行下载。\n\n ![1537667106801](1537667106801.png)\n\n\n\n \n\n## composer create-project 命令\n\n该命令是用来安装项目的，可以通过该命令去下载对应的项目文件，例如 laravel框架。\n\n```\n> composer create-project   团队名称/包名称[=版本号] [指定下载目录]  [-vvv打印交互信息]\n```\n\n注意：在使用composer安装项目的过程中，我们可能需要做两件事\n\n1. 指定安装的目录名称\n2. 指定安装的版本，默认是安装最新的版本\n\n**注意：** 如果不指定版本，则下载最新的版本，如果不指定安装目录，则会把框架下载到命令执行的文件夹下，以包名称创建一个目录。\n\n\n\n注意：版本号需要根据packagist.org网站提供的版本进行指定\n\n![img](wpsCA3.tmp.jpg) \n\n\n\n**示例：**\n\n```\n> composer create-project laravel/laravel=5.4.15  mylaravel\n```\n\n现在的意思是安装laravel5.4.15这个版本，并且把该包安装到 mylaravel文件夹下。\n\n![img](wpsCB3.tmp.jpg) \n\n \n\n```\n> composer create-project laravel/laravel \n```\n\n当我们不指定版本信息，也不指定安装目录的时候，这样会在命令执行目录下安装一个最新的laravel产品，并且文件夹的名称为laravel。\n\n \n\n## composer require 命令\n\n该命令是用来安装项目开发中的依赖文件，例如上传类库、验证码类库。\n\n![img](wpsCC4.tmp.jpg) \n\n```\ncomposer require 厂商/包名[=版本号]\n```\n\n**注**：若不指定版本号默认安装最新版本\n\n\n\n**示例**\n\n如安装tp5验证码1.0.3 版本：\n\n`composer require topthink/think-captcha=1.0.3`\n\n如安装tp5验证码1.0的最高版本：\n\n`composer require topthink/think-captcha=1.0.*`\n\n\n\n## composer.json文件\n\n该文件是用来记录composer管理的类库信息，以及项目的信息、作者、联系方式....\n\n![1537660787366](1537660787366.png)\n\n\n\n## composer.lock文件\n\n![1537660761864](1537660761864.png)\n\n主要是为了防止项目部署的时候，去下载最新的版本导致不兼容，在安装之后，需要把当前版本锁定起来。以后部署的时候，还是使用当时所锁定的版本，如果希望使用最新的版本，而不是锁定的版本，只需要删除该文件即可。\n\n \n\n## composer install 命令\n\n![1537660827975](1537660827975.png)\n\n以后去公司之后，如果从git或者是svn上面检出了laravel项目，则第一步应该是先去项目的根目录下执行 **composer install** 去根据 composer.lock 或者composer.json 文件下载项目开发中的依赖信息。\n\n  \n\n**安装`composer.json`指定的依赖包**\n\n```\ncomposer install\n```\n\n会自动安装在composer.json文件中所指定的各种依赖包，执行成功后会**多处**生成一个composer.lock的锁文件。后面需要更新依赖库只能通过`composer update`实现安装。\n\n`composer.json`文件说明：\nhttps://docs.phpcomposer.com/01-basic-usage.html#composer.json-Project-Setup\n\n`composer.json`文件架构详解：https://docs.phpcomposer.com/04-schema.html\n\n\n\n## 在配置文件指定具体的版本\n\n1. 指定版本\n\n![img](wpsCE7.tmp.jpg) \n\n \n\n2. 使用命令进行安装\n\n```\n> composer install\n```\n\n![1537660855716](1537660855716.png)\n\n删除composer.lock文件，重新执行 `composer install` 命令\n\n![1537660871530](1537660871530.png)\n\n安装后\n\n![1537660908979](1537660908979.png)\n\n \n\n## composer update-类库升级\n\n如果我们在开发过程中，现在希望某个类库可以升级\n\n![img](wpsD1A.tmp.jpg) \n\n \n\n1. 修改一个composer.json里面的信息\n\n![img](wpsD1B.tmp.jpg) \n\n \n\n2. `composer update`进行更新\n\n![img](wpsD2C.tmp.jpg) \n\n\n\n## 其它命令\n\n* **查看所有的composer可以使用的命令**\n\n  ```\n  composer list\n  ```\n\n\n\n* **查看某个命令的使用**\n\n  ```\n  composer require --help\n  ```\n\n  \n\n* **删除指定的包**\n\n  ```\n  composer remove topthink/think-captcha\n  ```\n\n  \n\n* **搜索指定的包**\n\n  ```\n  composer search topthink/think-captcha\n  ```\n\n  \n\n* **更新依赖包**\n\n  ```\n  composer update\n  ```\n\n  若修改`composer.json`中**require**指定的依赖包，则存在`composer.lock`文件，则只能通过\n\n  `composer update`进行更新。\n\n\n\n* **取消镜像**\n\n  ```\n  composer config -g --unset repos.packagist\n  ```\n\n  \n\n* **查看当前composer版本**\n\n  ```\n  composer -v\n  ```\n\n  \n\n* **升级composer版本**\n\n  ```\n  composer selfupdate\n  ```\n\n------\n\n\n\n# 演示：项目下载\n\n例如这里演示一下ci这个小框架的使用。\n\n1. 在网站进行搜索ci框架\n\n![img](wpsD3C.tmp.jpg) \n\n \n\n2. 使用`composer create-project` 进行安装\n\n![img](wpsD4D.tmp.jpg) \n\n \n\n3. 查看\n\n![img](wpsD5E.tmp.jpg) \n\n \n\n4. 启动一下\n\n![1537660973121](1537660973121.png)\n\n```\n> php -S localhost:8080 -t . \n```\n使用PHP开启一个调试服务器，使用的端口是8080 \n\n`-t `代表是设置网站根目录\n\n`. `代表将当前目录设置为网站根目录\n\n\n\n5. 浏览器查看\n\n![1537661008485](1537661008485.png)\n\n\n\n# 演示：日志类库下载\n\n**参考阅读**\n\n[热门的包](https://packagist.org/explore/popular)\n\n[Monolog 优化及打造 ELK 友好的日志格式](https://laravel-china.org/articles/3567/monolog-optimization-and-elk-friendly-log-format) \n\n\n\n这里演示monolog的使用。\n\n1. 查看下载并monolog\n\n![img](wpsD91.tmp.jpg) \n\n \n\n2. 查看安装后的目录结构\n\n![img](wpsDA1.tmp.jpg) \n\n3. 使用\n\n![img](wpsDA2.tmp.jpg) \n\n一般来说类库的使用方式，需要查看文档。\n\n \n\n \n\n# 版本号问题\n\n**参阅文档：**\n\n[版本语义化](https://semver.org/lang/zh-CN/)\n\n[Composer 基本使用](https://docs.phpcomposer.com/01-basic-usage.html)\n\n \n\n注意：在我们使用composer管理类库的时候，存在一些版本的配置信息。\n\n![img](wpsDB3.tmp.jpg) \n\n \n\n```\n^\n\n~\n\n*\n```\n\n具体的含义\n\n \n\n![img](wpsDC3.tmp.jpg) \n\n \n\n如果只有两位版本号 x.y，则这个时候 ^ ~ 是代表一样的含义，就是代表 >x.y 但是小于 (x+1).0;\n\n \n\n^1.2\n\n~1.2\n\n都是代表版本大于1.2 但是要小于 2.0;\n\n \n\n但是如果版本号是 x.y.z 则这个时候，^ ~ 代表含义是不一样的\n\n~1.2.3 代表含义 代表的大于bug修复版本，但是小于次版本号\n\n^1.2.3 代表含义 代表大于当前版本，但是小于主版本号\n\n![img](wpsDD4.tmp.jpg) \n\n \n\n \n\n# **相关资料**\n\n[Composer是干嘛的，怎么用它](http://blog.csdn.net/think2me/article/details/38456931)\n\n[Composer使用](https://www.cnblogs.com/52fhy/p/5246013.html)\n\n[如何创建一个自己的【Composer/Packagist】包](https://segmentfault.com/n/1330000006227425)\n\n[Laravel5学习笔记：Composer.json配置文件说明](http://blog.csdn.net/hel12he/article/details/46503875)\n\n[动手开发自己的第一个 composer 包](https://www.cnblogs.com/zhangwei595806165/p/5814476.html)\n\n[提交PHP组件到Packagist 发布自己的Composer包](http://www.jquerycn.cn/a_16976)\n\n\n\n[**利用 Composer 完善自己的 PHP 框架**](https://lvwenhan.com/php/410.html)\n\n\n\n[如何从 phpcomposer 的 Composer 镜像迁移到 Laravel China 维护的镜像？](https://laravel-china.org/wikis/16722)\n\n\n\n\n\n\n\n\n\n","categories":["Composer"]},{"title":"GitHub  Blog架构","url":"%2Fposts%2F3884487082%2F","content":"\n# GitHub  Blog架构\n\n## TODO\n\n> 脚本分离\n\n\n\n## 参考方案\n\n\n\n### 环境配置\n\n**博客程序** ： [hexo](https://hexo.io/zh-cn/)  -  静态站点生成器\n\n**写作程序** ： [Typora](https://www.typora.io/)  -  makedown 编辑器\n\n**持续集成** ： [Travis-ci](https://travis-ci.com)  - 用于构建项目的开源持续集成环境\n\n\n\n### 项目规划\n\n#### Blog仓库\n\nBlog仓库名：`KumaNNN.github.io`\n\n* 此为用户站点，通过各分支进行管理。\n\n* **master**  ： 内容发布分支。\n\n* **<blog\\>**  ： blog源程序分支（以 blog源程序的名称命名，如 `Hexo`）\n\n  * `source_md/<SubModules>`  ：内容源，子模块，拉取文档库中可引用的分支(默认：`md`)\n\n    * 本地管理时，用子模块方式；\n    * 集成环境，~~直接当作仓库管理~~  [Travis CI默认克隆git子模块](https://docs.travis-ci.com/user/customizing-the-build/#git-submodules)  ，且集成环境中并不需要操作此目录。\n\n  * `source/_post`  ： hexo内容源，通过一定的脚本自动化将`source_md/<SubModules>`  的内容复制到此。\n\n    * 因为hexo每次生成时都需要修改源文件，所以分开存放。 \n\n  * `themes/<SubModules>  `  ：主题源，子模块，拉取主题库中的`MyMaster`分支。\n\n  * `Script`  ： 脚本存放目录，存放相关的自定义脚本或钩子脚本。\n\n  * `public`  ：  hexo发布目录。子模块(或git仓库)，已配置将其下内容发布到本仓库`master`分支。\n\n    * 当作 子模块，易于管理，因为子模块提交记录不在当前分支。\n    * 使用`hexo g`生成内容前，通常需要使用`hexo clean` 清除此文件夹及其内容，以确保更改达到预期效果。这样会将此文件夹下的版本数据库`.git`也删除，如果每次都初始化，将不能保留提交记录。\n      * **本地**： \n        * 方案一：(当作git仓库时) 手动执行脚本，在其它地方克隆并检出`master` 分支，并复制`.git` 目录到`public`下。 \n          * 会产生git嵌套，在管理上带来一定的麻烦，慎用。\n          * 在线上，只提交了此文件夹的内容，而放弃其它内容，倒无所谓。\n        * 方案二：(当作子模块时) 用脚本修复`public/.git` 文件。==使用中== \n          * 在不使用线上的 **持续集成** 时，可这样做。\n          * 使用线上的 **持续集成** 时，放弃此子模块的提交。\n      * **线上**： 已在配置文件中配置，可保留提交记录。\n        * Travis-ci 根据配置，克隆并检出指定分支(`Hexo`) ，安装依赖，`hexo g`生成内容，在其它地方克隆并检出`master` 分支并复制`.git` 目录到`public`下，最后只提交并推送`public`下的内容到`master`分支，放弃其它内容。\n\n    \n\n#### 文档(子仓库)和主题\n\n==修正==：**文档(子仓库)** 已采用单分支(`master`) ，子模块化到`source_md/<SubModules>` ，再通过脚本复制`source_md/<SubModules>/doc/md/*` 到 `source/<SubModules>/` \n\n\n\n**注意**： 文档和主题 ，可用组织进行管理\n\n* 文档<组织名>： `KumaDocCenter`\n  * 管理库[^1]： `KumaDocCenter.github.io`\n  * 文档分库存储，~~特定目录（如，md）新建分支(`md`)，以便引用。~~  已采用单分支\n  * ~~保持数据一致性：`md分支` 定期合并到master分支，或参考 [git从其他分支checkout文件到当前分支](#git从其他分支checkout文件到当前分支)。~~ 已采用单分支\n* 主题<组织名>：`BlogThemes<blog源程序名称>`    如，`BlogThemesHexo`\n  * 管理库[^1]： `BlogThemes<blog源程序名称>.github.io`     如，`BlogThemesHexo.github.io`\n  * blog源程序的主题，Fork成独立库，以便管理。\n  * 库命名格式：\n    * `<username>_<blog源程序名称>_主题名称`\n    * `<orgname>_<blog源程序名称>_主题名称`\n  * 从`master`新建分支`mymaster`，作为自己的博客主题，所有配置修改存储在此分支。\n\n\n\n\n\n## 工作流\n\n注： ==推荐每个分支一个目录，而不是在同一目录切换分支==。\n\n`staged`  :  暂存。在此脚本中通常用于待处理目录。\n\n\n\n### 本地\n\n#### 子仓库初始化\n\n* 复制父项目下的`Start.bat`文件和`Script`文件夹到未初始化的子仓库，并运行`Start.bat`文件\n* ~~修改某些子仓库的名称和git地址。嵌套领域可用`.`连结，如 `Apache.httpd`~~  已通过脚本实现\n  * ~~需修改的文件：`*.add` `*.init` `*.del`  `*.updata`  `.git/config`~~ 已通过脚本实现\n  * git嵌套： 可以忽略整个子目录\n    * 因为文件夹已嵌套，且用`.`连结作为仓库名，已便于区分，才可以这样做。\n    * 适用于，想把上级目录也用git管理的情景。\n* 根据名称，建立远端仓库，并进行推送，以便子模块拉取。\n* **多分支脚本流程**：\n  1. 检测`.git` 文件，存在则退出脚本。不存在则继续执行脚本。\n  2. 特定目录处理。\n     * 一些不存在的目录会自动创建，如 `doc/md`  `doc/Readme`\n  3. 空目录处理。\n     * 因为git会自动忽略空目录。\n     * 对于空目录，添加 .gitkeep 文件\n  4. 仓库配置。\n     * 初始化仓库，配置用户名，邮箱，添加远程仓库等等。\n  5. 首次提交\n     * 提交空白仓库，只包含 .gitignore 文件\n     * 提交信息： `Commit_0 : init`\n  6. 第2次提交 + 新建分支\n     * 增加 doc/md 和 Script目录，并依此新建md分支\n     * 提交信息： `Commit_1 : + doc/md/* and Script`\n  7. 第3次提交\n     * 添加所有文件\n     * 提交信息：`Commit_2 : + All file`\n  8. 复制钩子\n     * ~~==提交钩子(post-commit)==~~  子仓库暂无\n  9. YAML输出\n  10. 输出子模块批处理配置文件\n     * 手动复制此配置文件到其它地方。\n  11. 结果输出\n* **单分支脚本流程**：\n  1. 检测`.git` 文件，存在则退出脚本。不存在则继续执行脚本。\n  2. 特定目录处理。\n     * 一些不存在的目录会自动创建，如 `doc/md`  `doc/Readme`\n  3. 空目录处理。\n     * 因为git会自动忽略空目录。\n     * 对于空目录，添加 .gitkeep 文件\n  4. 仓库配置。\n     * 初始化仓库，配置用户名，邮箱，添加远程仓库等等。\n  5. 首次提交\n     * 提交空白仓库，只包含 .gitignore 文件\n     * 提交信息： `Commit_0 : init`\n  6. 第2次提交\n     * 添加所有文件\n     * 提交信息：`Commit_1 : + All file`\n  7. 复制钩子\n     * ~~==提交钩子(post-commit)==~~  子仓库暂无\n  8. YAML输出\n  9. 输出子模块批处理配置文件\n    * 手动复制此配置文件到其它地方。\n  10. 结果输出\n\n\n\n**产生的文件有：**\n\n* `init.log`  ： 仓库初始化日志，转移\n  * 管理库： `data\\SubRepo\\init`\n* `*.[Repo]add` `*.init` `*.[Repo]del`  `*.[Repo]updata`  ： 子模块批处理配置文件，转移\n  * 父项目： `.git\\myconf\\submodule\\staged`\n  * 管理库： `data\\SubRepo\\conf`\n* `doc/md/*.YAML`  ：(`md` 分支或`doc/md`) md 文件的YAML头，处理后删除\n  * 将其内容复制到相应的md文件头部，然后删除此`*.YAML`文件，最后git提交。\n\n\n\n\n\n#### 父项目添加子模块(子仓库)\n\n* 运行脚本 `Script\\sh\\submodule_batch.bat` ，添加子模块。\n* 子模块稀疏检出(`doc/md`)\n* 复制钩子\n  * ==提交钩子(post-commit)== ，在配置文件中已配置，脚本会自动复制此钩子。\n* 脚本配置如下\n  * 配置读取目录  ： `.git\\myconf\\submodule\\staged` \n    * 从该目录下读取子模块批处理配置文件\n  * 完成目录  ： `.git\\myconf\\submodule\\ok`\n    * 处理完毕后，将配置文件移动到此。\n* 配置文件格式参考  `Script\\sh\\git_submodule\\Template` \n* 注： 子模块git数据库在父项目下的.git目录下。\n\n\n\n\n\n#### 写作在子仓库\n\n* 完全可当做为普通git仓库来管理。\n* (==单分支==)子仓库有`master`分支。\n* (==多分支==)子仓库有`master`分支和`md` 分支。\n  * `md` 分支源自`master`分支的`doc/md` ，最终需要将最新的数据合并到`master`分支，以作存储。\n  * 所以`doc/md`的更改推荐在`md`分支下进行，然后定期合并到`master`分支\n  * `master`分支==不能==合并到`md` 分支，会造成结构不符合当初预期。\n  * 若需要从`master`分支检出`md` 分支所需的最新数据，可通过其它方法，如[git从其他分支checkout文件到当前分支](#git从其他分支checkout文件到当前分支)\n* git提交并推送。\n\n\n\n\n\n#### 写作在子模块\n\n* 进入子模块，当做为普通git仓库来管理单分支。\n* (==单分支==)子模块只检出`master` 分支，且==禁止==检出其它分支。\n* (==多分支==)子模块只检出`md` 分支，且==禁止==检出其它分支。\n  * `md` 分支源自`master`分支的`doc/md` ，最终需要将最新的数据合并到`master`分支，以作存储。\n  * 所以`doc/md`的更改推荐在`md`分支下进行，然后定期合并到`master`分支\n  * `master`分支==不能==合并到`md` 分支，会造成结构不符合当初预期。\n  * 若需要从`master`分支检出`md` 分支所需的最新数据，可通过其它方法，如[git从其他分支checkout文件到当前分支](#git从其他分支checkout文件到当前分支)\n* [可选] 手动执行`md.bat` 脚本，处理新增的md文件。\n* git提交\n* 触发==提交钩子(post-commit)== \n  * 写入`复制状态` 数据到子模块git数据库目录下。\n* git推送。\n\n\n\n\n\n#### 写作在父仓库\n\n> 可能某些内容并没有依赖子仓库，是在本项目中(`source/*`)，此时，就需要在父仓库中写在。\n\n* 在父仓库 `source/*` 下更改内容 。\n  * **使用**线上持续集成时，本地工作流：\n    *  提交当前分支(`Hexo`) ~~，忽略`public` 子模块~~ `.gitignore` 文件中实现忽略`public` 目录。\n    * ~~所需的配置方案，参考 [忽略submodule中的修改或新增文件](#忽略submodule中的修改或新增文件)。~~\n  * **不使用**线上持续集成时，本地工作流： \n    * ~~先提交`public`子模块，再提交当前分支(`Hexo`) 。~~\n    * `hexo d` 命令处理时，会自动在`.deploy_git` 目录中处理，不影响 `public` 目录。\n      * `.deploy_git` 目录可删除或提交\n    * `Manage.bat` 处理时，会自动在`public_deploy` 目录中处理，不影响 `public` 目录。\n      * `public_deploy`目录可删除或提交\n    * `public` 目录 提交到当前分支(`Hexo`) 。\n* git提交\n* 触发==预提交钩子(pre-commit)==，\n  * ~~修复public。~~\n  * 调用脚本，读取配置(`copy.conf`) ，按需复制 `source_md/<SubModuleName>/doc/md/` 下的内容到 `source/_posts/Dev/<SubModuleName>` 。\n  * ~~处理source/* md文件~~\n\n\n\n\n\n### 线上\n\n#### 使用 Travis-ci 持续集成\n\n**已配置如下流程**\n\n* Travis-ci 检测仓库接收的推送。\n\n  * 拉取博客程序分支(`Hexo`)\n  * 安装依赖，`hexo g`生成内容\n  * ~~方案1：在其它地方克隆并检出`master` 分支并复制`.git` 目录到`public`下~~\n  * 方案2： 直接将`public_git`目录下的固定文件复制到新生成的`public` 目录下。\n    * 仓库每次都初始化，即永远只有1个提交。\n  * 最后只提交并推送`public`下的内容到远端`master`分支，放弃其它内容。\n\n  \n\n\n\n## Build\n\n### bat脚本\n\n* 子模块(子仓库)，==提交钩子(post-commit)==，写入数据到配置文件中（包含`状态`，`路径` 等信息）\n* 父仓库(Hexo)，==预提交钩子(pre-commit)==   , for   读取（遍历）子仓库中配置文件的变量，根据status参数，直接执行相应的命令。\n\n  \n\n\n\n### shell 脚本\n\ngit钩子的shell脚本，用`#!/bin/sh` ，而大部分任务流有bat脚本完成。\n\n根据shell脚本调用方式，最终选择 fork方式。\n\n这样能保证shell后面的命令继续执行，但不能获取子 Shell 中的环境变量\n\n> 如\n>\n> ```\n> #!/bin/sh\n> \n> ./out.bat $@\n> echo AAAAA\n> ```\n>\n> * $# 是传给脚本的参数个数\n> * $0 是脚本本身的名字\n> * $1 是传递给该shell脚本的第一个参数\n> * $2 是传递给该shell脚本的第二个参数\n> * $@ 是传给脚本的所有参数的列表\n\n\n\n[Shell 脚本中调用另一个 Shell 脚本的三种方式](https://www.cnblogs.com/insane-Mr-Li/p/9095668.html) \n\n> 主要以下有几种方式：    \n>\n> | 命令   | 说明                                                         |\n> | ------ | ------------------------------------------------------------ |\n> | fork   | 新开一个子 Shell 执行，子 Shell 可以从父 Shell 继承环境变量，但是子 Shell 中的环境变量不会带回给父 Shell。<br />fork 是最普通的, 就是直接在脚本里面用 path/to/foo.sh 来调用 ，不需 fork 关键字 |\n> | exec   | 在同一个 Shell 内执行，但是父脚本中 exec 行之后的内容就不会再执行了 |\n> | source | 在同一个 Shell 中执行，在被调用的脚本中声明的变量和环境变量, 都可以在主脚本中进行获取和使用，相当于合并两个脚本在执行 |\n\n\n\n### 涉及的命令\n\nfor\n\nxcopy\n\n```\nxcopy 1\\* 11 /eiy\n\n/E           复制目录和子目录，包括空目录。\n/I           如果目标不存在，且要复制多个文件，则假定目标必须是目录。\n/Y           取消提示以确认要覆盖现有目标文件。\n```\n\n复制1目录下的所有，不包含隐藏文件夹，到 11 目录\n\n\n\n\n\n----\n\n## 参考阅读\n\n[^1]: 管理组织内所有库，默认为 `<orgname>.github.io`  ，`<orgname>`不用下划线等特殊字符\n\n[把 git 仓库的子目录独立成新仓库](https://segmentfault.com/a/1190000012277504)\n\n[Git 仓库拆拆拆](https://segmentfault.com/a/1190000002548731)\n\n\n\n\n> ### git从其他分支checkout文件到当前分支\n>\n> 使用场景，把当前分支的某个文件替换为其他分支的文件\n>\n> 执行命令\n>\n> ```git\n> git checkout <branch name> -- path\n> ```\n>\n> path 就是你想要替换的目录或文件\n\n\n\n> ### 忽略submodule中的修改或新增文件\n>\n> 我们要做的就是在`.gitmodules`的`[submodule “ProjectName”]`中添加一个`ignore`子项，这个ignore子项可以有3个可选的值，`untracked`, `dirty`和`all`, 它们的意思分别是：\n>\n> * **untracked** ：忽略 在子模块 新添加的，未受版本控制内容\n> * **dirty** ： 忽略对\\<ProjectName>目录下受版本控制的内容进行了修改\n> * **all** ： 同时忽略untracked和dirty","categories":["Pre"]},{"title":"Node.js入门和企业级项目开发06","url":"%2Fposts%2F676924322%2F","content":"\n# 前言\n\n> 第6天课堂笔记\n>\n> 讲师：邵山欢\n>\n> 日期：2017年11月11日\n\n# 一、NodeJS学习成果自查\n\n**只要会写Ajax的接口，结合Mongoose做一套RESTful API的接口，就能学习React了。**\n\nNodeJS无法挑战老牌3P语言的，asp.net、jsp、php。\n\n上课的时候很多时候在讲面向对象，还有一些经验上的东西。\n\n\n\n# 二、用户头像功能继续完善\n\n当用户上传头像、剪裁之后，立即将头像移动位置，从uploads到www/useravatars/文件夹中。\n\n页面单独的js文件喜欢写在\\</body\\>之后，所有的公共的js文件（包括各种lib库）都喜欢写在页面的\\<head\\>中。\n\n\n\n```javascript\n$(function(){\n\n});\n```\n\n等价于\n\n```javascript\n$(document).ready(function(){\n});\n```\n\n表示当页面的骨架结构加载完毕之后，执行回调函数。和window.onload类似，但是不一样。\n\n\\$(document).ready()要早于window.onload事件。\n\n* \\$(document).ready() 是骨架结构加载完毕\n\n* window.onload 是所有的css、图片、音乐都加载完毕\n\n\n\n\n# 三、首页的开发\n\n## 3.1 发帖图片开发\n\n点击一个悬浮框的外部，就关闭这个悬浮框。此时要给document绑定监听。\n\n```javascript\n//点击插入图片按钮的事件\n$(\"#insertpic_button\").click(function(event){\n    //阻止事件继续传播，这样的话就不会点击a标签的时候，也会触发document的点击事件了\n    event.stopPropagation();\n    $(\"#insertpic_box\").removeClass('fade').addClass('show');\n});\n\n//点击插入图片框的外部关闭这个框框\n$(document).click(function(event){\n    //你点击的最内层元素\n    var target = event.target || event.srcElement;\n\n    if($(target).parents(\"#insertpic_box\").length <= 0 && !$(target).is(\"#insertpic_box\")){\n        $(\"#insertpic_box\").removeClass('show').addClass('fade');\n    } \n});\n```\n\n\n\n## 3.2 图片的异步上传\n\nHTML没有图片异步上传功能。\n\n\n\n**先复习一下同步和异步：**\n\n如果有一个form表单，里面有一些输入框，一个提交按钮，form标签有action、method属性，点击提交按钮页面会跳转，这种表单提交我们称之为\"**同步提交**\"：\n\n```html\n<form action=\"/tijiao\" method=\"post\">\n\t<p>\n\t\t<input type=\"text\" name=\"yonghuming\" />\n\t</p>\n\t<p>\n\t\t<input type=\"submit\">\n\t</p>\n</form>\n```\n\n\n\n如果表单没有action、method属性，没有submit按钮，而是普通按钮。点击普通按钮的时候，通过ajax提交，此时我们称之为\"**异步提交**\"：\n\n```html\n<form>\n\t<p>\n\t\t<input type=\"text\" name=\"yonghuming\" />\n\t</p>\n\t<p>\n\t\t<input type=\"button\">\n\t</p>\n</form>\n\n$(\"input[type=button]\").click(function(){\n\t$.post(\"/tijiao\" , {\n\t\tyonghuming : $(\"input[name=yonghuming]\").val();\n\t});\n});\n```\n\n\n\n如果表单中有file控件（让用户选择一个文件），此时这个表单原则上讲、API层级没有任何办法异步提交！\n\n老老实实这么写：\n\n```html\n<form action=\"/tijiao\" method=\"post\">\n\t<input type=\"file\" />\n\t<input type=\"submit\">\n</form> \n```\n\n这样一来，用户体验极差，用户上传一张图片之后必须死等，不能流畅的操作，不能让上传图片的操作放到后台。\n\n\n\n所以中国人发明了一个猫腻写法，解决了这个事情：\n\n-   隐藏`<input type=\"file\" />`控件\n\n-   写一个外部form表格\n\n-   做一个其他的东西比如+号，点击+号的时候触发(trigger)那个file的click事件，会弹出框框\n\n-   监听file控件onchange事件，当onchange事件发生，命令`$(form).submit()`\n\n> 理一下逻辑：因为图片上传是不能有异步的，必须用form来模拟，而form提交会跳转页面，所以就要内嵌到iframe里面。此时form上传成功的回调就需要通过form提交到的那个页面/fatupian来写一个`<script>window.parent.finish()</scirpt>`传给主页面。 \n> ![img](image2.png) \n> ![img](image3.png)\n> ![img](image4.png)\n\n\n麻烦的是，每一个图片上传完毕之后，不能都调用名字叫做finish()的函数，这样就乱套了。此时：我们现在给每一个li这个类，**一上来就创建一个随机数，这个数字就是回调函数的名字**。通过iframe的src引用时候的GET参数传给form2页面，form2页面中提交的网址也不是/fatupian了，而是/fatupian?callback=\\....\n\n![](media/image5.png)\n\n\n\njQueryUI中，sortable表示可以拖拽排序，最后一项不参加排序：\n\n```javascript\n//可以被排序\n$(\"#insertpic_box_ul\").sortable({\n\t\"items\" : \"li:not(:last)\"\n});\n```\n\n\n\n## 3.3 发问题的实现\n\n所有的问题存储在一个集合中，帖子有哪些属性：\n\n-   content内容\n\n-   images图片数据\n\n-   email发帖人的email\n\n-   time发帖时间\n\n我们实现了发帖功能的API接口，这是一个POST请求：\n\n**实话：我们的nodejs课程，你只需要能够流畅写出下面的语句就满分毕业！**\n\n```javascript\n//发帖功能\nexports.doSaveQ = function(req,res){\n\tvar form = new formidable.IncomingForm();\n\tform.parse(req , function(err , fields , files){\n\t\tvar email = req.session.email;\n\t\tvar content = fields.content;\n\t\tvar images = fields.images;\n\t\tvar time = new Date();\n\n\t\t//保存\n\t\tQ.create({\n\t\t\temail  : email ,\n\t\t\tcontent : content, \n\t\t\timages  : images ,\n\t\t\ttime  : time \n\t\t},function(){\n\t\t\tres.json({\"result\" : 1});\n\t\t});\n\t});\n}\n```\n\n\n\n## 3.4 拉取所有帖子\n\n**套路**：写接口，用Ajax拉取，面向对象上树。\n\n**分页的实现**：比如每页5条，页码从1开始。第3页就是跳过10条，读5条，此时读取的就是第11\\~15条。\n\n**第page页，就是跳过(page-1)\\*pagesize条，读pagesize条。**\n\n```javascript\nexports.getQ = function(req,res){\n\tvar page = url.parse(req.url , true).query.page;\n\tvar pagesize = url.parse(req.url , true).query.pagesize;\n\t//得到所有的帖子，按时间倒序\n\tQ.find({}).sort({\"time\" : -1}).skip((page - 1) * pagesize).limit(pagesize).exec(function(err,results){\n\t\tres.json({\"results\" : results});\n\t});\n}\n```\n\n\n\n![1542533881927](1542533881927.png)\n\n\n\n","categories":["js.NodeJS"]},{"title":"Node.js入门和企业级项目开发05","url":"%2Fposts%2F2974833176%2F","content":"\n\n\n# 前言\n\n> 第5天课堂笔记\n>\n> 讲师：邵山欢\n>\n> 日期：2017年11月10日\n\n# 一、后期课程的学习方法\n\n2014年：只需要会简单的JavaScript基础，DOM操作，jQuery，HTML5、CSS3，就能找到工作。\n\n2014年的夏天行业巨变：React、Vue这些MVVM框架，让很多C/S架构的项目变为B/S项目，网页项目变得越来越大。单页面应用开始火热。**前端开发工程师现在的主要工作变为开发Dashboard系统**。\n\n![](image2.png)\n\n如果跟不上了，一定先把现在阶段的课程学完，然后再复习之前的，可以选择留级。现在的前端，值得你用大半年的时间学习。\n\n工作的时候，**90%以上的同学是搞React和Vue技术栈，写组件的**。\n\n\n\n**NodeJS对于React和Vue项目的作用：提供有数据库支持的RESTful风格的API接口**。比如我们做一个《宠物店消费管理系统》，有会员管理功能、积分卡功能，能够记录每个主人有什么宠物、消费记录，此时就需要NodeJS和mongoose提供数据库的功能和一套RESTful API的接口。\n\n\n\n现在说说React和Vue到底是干嘛的？\n\n**传统的jQuery编程最麻烦的事情就是数据和DOM的一致性问题。数据变化了，视图也要写代码让它变化**。\n\n![](image3.png)\n\n\n\n**能不能自动变化？？**\n\n能！Vue和React解决了这个问题：**Angular、Vue和React能够让数据变化的时候，DOM自动变化**。\n\n\n\n# 二、用户信息更改页面的制作\n\n## 2.1 用户信息的拉取接口\n\n用户的基本信息：\n\n-   email（一旦注册，不能更改）\n\n-   昵称（全站不能相同）\n\n-   一句话简介（默认：这家伙很懒，什么都没有留下）\n\n-   头像\n\n-   密码（加密之后的密码）\n\n\n\n只要是用户的基本信息，就要更改User这个schema。\n\n```javascript\nvar mongoose = require(\"mongoose\");\n\nvar schema = new mongoose.Schema({\n\t\"email\" : String ,\t\t//email\n\t\"password\" : String ,\t//密码，加密之后的密码\n\t\"nickname\" : String ,\t//昵称\n\t\"introduction\" : {\n\t\t\"type\" : String,\n\t\t\"default\" : \"这家伙很懒，什么都没有留下\"\n\t},\t//简介\n\t\"avatar\" : String //数据库中不保存图片，只保存图片的文件名。\n});\n\nmodule.exports = mongoose.model(\"User\" , schema);\n```\n\n\n\n个人资料页的修改，是建立在用户已经登录的情况下！\n\n**所有的页面信息：涉及安全的内容，用模板引擎；如果普通信息，要用Ajax。**\n\n**只要涉及Ajax，你的服务器必须要开一个GET请求的接口，这个接口可以读取用户的所有信息。接口：**\n\n![](image4.png)\n\n\n\n## 2.2 头像上传\n\n头像的上传很简单，因为formidable天生支持文件的上传，用files来接收就行了。\n\n\n\n图片的上传有两种形式：\n\n-   同步上传 : 必须有form表单，用submit按钮来提交\n\n-   异步上传 ： 用ajax来提交表单（实际上不是ajax，是猫腻，下午说）\n\n\n\n这里使用同步上传，一个能够上传图片的表单，必须有enctype属性：\n\n```html\n<form action=\"/uploadavatar\" method=\"post\" enctype=\"multipart/form-data\">\n\t<input type=\"file\"  name=\"avatar\"/>\n\t<input type=\"submit\" />\n</form>\n```\n\n\n\n后端的中间件基本不用写什么东西，只需要写uploadDir即可。\n\n```javascript\n//处理上传\nexports.uploadavatar = function(req,res){\n\t//得到前端提交的表单信息\n\tvar form = new formidable.IncomingForm();\n\t//设置上传文件夹\n\tform.uploadDir  = path.resolve(__dirname , \"../uploads\");\n\t//保留拓展名\n\tform.keepExtensions = true;\n\n\tform.parse(req , function(err , fields , files){\n\t\tres.send(\"123\");\n\t});\n}\n```\n\n**我们的`<form>`标签有一个特点，当你点击submit按钮的时候，会自动跳转到提交到的那个页面去！**\n\n**此时如何阻止跳转呢？可以内嵌一个iframe小窗口，小这个\"小电视\"中，呈递流程页面**。\n\n![](image5.png)\n\n所以我们单独做一个/form的路由，这个页面专门做一个表单：\n\n![](image6.png)\n\n把这个/form放到iframe中。这样的话，当form被submit的时候，大的URL不会跳转。跳转发生杂小电视里面。\n\n\n\nbootstrap中很方便做一个弹出层。要有一个按钮：\n\n```html\n<button data-target=\"#avatarModal\" data-toggle=\"modal\">更改头像</button>\n```\n\n\n\n一个模态框的div\n\n```html\n<div class=\"modal fade\" id=\"avatarModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"exampleModalLabel\" aria-hidden=\"true\">\n\t\t<div class=\"modal-dialog\" role=\"document\">\n\t\t\t<div class=\"modal-content\">\n\t\t\t\t<div class=\"modal-header\">\n\t\t\t\t\t<h5 class=\"modal-title\" id=\"exampleModalLabel\">Modal title</h5>\n\t\t\t\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n\t\t\t\t\t\t<span aria-hidden=\"true\">&times;</span>\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"modal-body\">...</div>\n\t\t\t\t<div class=\"modal-footer\">\n\t\t\t\t\t<button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"modal\">Close</button>\n\t\t\t\t\t<button type=\"button\" class=\"btn btn-primary\">Save changes</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n```\n\n\n\n## 2.3 头像的剪裁界面的开发\n\n**如何知道用户上传的是什么图片呢？**是在formidable的files变量中。\n\n配合url模块的parse()方法和正则表达式中的match方法，可以轻松提炼上传文件的文件名。\n\n```javascript\nform.parse(req , function(err , fields , files){\n\t//提炼出刚刚上传的图片的文件名\n\tvar pathname = url.parse(files.avatar.path).pathname.match(/\\/(upload_.+)$/)[1];\n\tconsole.log(pathname);\n});\n```\n\n\n\n开路由！将uploads文件夹也静态化出来。所以我们改变app.js文件，增加：\n\n```javascript\n//静态化uploads文件夹\napp.use(\"/uploads\" , express.static(\"uploads\"));\n```\n\n![](image7.png)\n\n\n\n**在裁切页面时，怎么显示刚刚上传的图片呢？**\n\n当用户上传完毕图片之后，将文件名存储到session中，然后呈递cut.ejs模板，通过字典将图片的网址传入。\n\n\n\n处理上传的时候存入session：\n\n```javascript\n//处理上传\nexports.uploadavatar = function(req,res){\n\t//得到前端提交的表单信息\n\tvar form = new formidable.IncomingForm();\n\t//设置上传文件夹\n\tform.uploadDir  = path.resolve(__dirname , \"../uploads\");\n\t//保留拓展名\n\tform.keepExtensions = true;\n\n\tform.parse(req , function(err , fields , files){\n\t\t//提炼出刚刚上传的图片的文件名\n\t\tvar pathname = url.parse(files.avatar.path).pathname.match(/\\/(upload_.+)$/)[1];\n\t\t//将这个文件夹名存入session！\n\t\treq.session.avatarurl = pathname;\n\t\t//跳转页面\n\t\tres.redirect(\"/cut\");\n\t});\n}\n```\n\n\n\n在裁切页面使用这个session:\n\n```javascript\n//呈递裁切页面\nexports.showcut = function(req,res){\n\tres.render(\"cut\" , {\n\t\t\"avatarurl\" : req.session.avatarurl \n\t});\n}\n```\n\n![](image8.png)\n\njQuery-ui有什么功能：\n\n-   Draggable ：拖拽\n\n-   Droppable : 拖放\n\n-   Resizable : 可更改尺寸\n\n-   Selectabel : 可被选择\n\n-   Sortable : 可更改顺序\n\n我们的cut小框框可以被更改尺寸。此时使用jquery-ui提供的：\n\n```javascript\n$(\"#cut_rect\").resizable();\n```\n\n但是一定要注意，必须引用jquery-ui的样式表。\n\n```html\n<link rel=\"stylesheet\" href=\"//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css\">\n```\n\ncss文件夹中必须有图片\n\n![](image9.png)\n\njQuery中有一个trigger()的方法，可以模拟别的元素的事件。\n\n\n\n## 2.4 使用gm裁剪图片\n\ngm就是GraphicsMagick的缩写。\n\nhttp://www.graphicsmagick.org/\n\n> 开源的库真的很值得尊敬，比如割绳子、愤怒的小鸟都是依靠box2d这个库。\n>\n> 可以看这个演示：http://yuehaowang.github.io/demo/box2d_linkage/ \n\n安装软件，![](image10.png)\n\n下一步、下一步无脑安装。\n\n**然后将你的安装目录C:\\\\Program Files\\\\GraphicsMagick-1.3.22-Q16设置为环境变量！**\n\n设置环境变量成功之后，打开CMD就能使用gm命令了\n\n```\ngm -version\n```\n\n![](image11.png)\n\n命令行里面就能裁剪图片：\n\n```\ngm convert -crop 100x100+50+60 1.jpg 3.jpg\n```\n\n\n\nnode.js如何操作它？此时就要安装npm包gm。\n\n安装依赖：\n\n```\ncnpm install --save gm\n```\n\n程序中引包：\n\n```javascript\nvar gm = require('gm');\n```\n\n使用：\n\n```javascript\ngm(avatarurl).crop(w,h,x,y).write(avatarurl, function (err) {\n\tconsole.log(\"裁剪成功！\");\n});\n```\n\n\n\n**iframe内嵌的页面可以用js调用外部的DOM；但是反之不行。**\n\n调用方法：\n\n```javascript\n$(\"#avatarModal\" , window.parent.document)\n```\n\n\n\n\n","categories":["js.NodeJS"]},{"title":"Node.js入门和企业级项目开发04","url":"%2Fposts%2F3327617678%2F","content":"\n\n\n# 前言\n\n\n> 第4天课堂笔记\n>\n> 讲师：邵山欢\n>\n> 日期：2017年11月7日    \n\n# 一、复习\n\n我们现在学习数据库的目的就是让你面试的时候，能够有一套有完整API接口的作品。前端React、Vue。\n\n\n\n**数据库：数据的存储 + 一套数据操作的API。**\n\n比如我们用txt文件**模拟**数据库：\n\n```json\n[\n\t{\"id\":10001,\"name\":\"小明\",\"age\":12},\n\t{\"id\":10002,\"name\":\"小红\",\"age\":12},\n\t{\"id\":10003,\"name\":\"小刚\",\"age\":13}\n]\n```\n\n\n\n现在的需求是：更改id为10002的age为16。需要用遍历的方法，看看哪个项的id是10002，改变这项之后重新写全部的数组。\n\n如果是真实数据库，此时不需要遍历直接写一条语句就可以更改：\n\n```javascript\nStudent.update({\"id\":10002} , {\"$set\" : {\"age\" : 16}} , function(){\n\n});\n```\n\n\n\nNoSQL和SQL的不同一定要知道：没有字段的限制，每个条目和每个条目可以有不同的字段，每个字段可以有不同的类型。\n\n```json\n[\n\t{\"id\":10001,\"name\":\"小明\",\"age\":12},\n\t{\"id\":10002,\"name\":\"小红\",\"age\":12},\n\t{\"id\":10003,\"name\":\"小刚\",\"age\":13,\"sex\":\"男\"},\n\t{\"id\":\"CR10001\",\"name\":\"小名\",\"age\":13,\"sex\":\"男\"}\n]\n```\n\n\n\nMongoDB的使用，如何安装的？绿色软件，直接解压缩，设置环境变量。能够使用4个CMD命令：\n\n| mongod      | `mongod --dbpath c:\\database `开机                          |\n| ----------- | ----------------------------------------------------------- |\n| mongo       | 管理数据库的，进入REPL环境                                  |\n| mongoimport | mongoimport -d 数据库名字 -c 集合名字 文件的名字.txt --drop |\n| mongoexport | mongoexport -d 数据库名字 -c 集合名字 -o 文件的名字.txt     |\n\n\n\n数据库和NodeJS的连接，有原生的方法，不要求会了。只要会Mongoose。\n\n**两步走：创建schema和model → CRUD操作。**\n\n第一步，创建schema和model：\n\n```javascript\nvar mongoose = require(\"mongoose\");\n\nvar schema = new mongoose.Schema({\n\t\"name\" : String ,\n\t\"color\" : String ,\n\t\"age\" : Number ,\n\t\"pinzhong\" : {\n\t\t\"type\" : String ,\n\t\t\"default\" : \"中型犬\"\n\t}\n});\n\nmodule.exports = mongoose.model(\"Dog\" , schema);\n```\n\n第二步，写CRUD操作：\n\n```javascript\nvar mongoose = require(\"mongoose\");\n\nmongoose.connect(\"mongodb://localhost/cwgl_system\");\n\nvar Dog = require(\"./models/Dog.js\");\n\nDog.create({\n\t\"name\" : \"小白\" ,\n\t\"color\" : \"白色\" ,\n\t\"age\" : 2 \n},(err)=>{\n\tconsole.log(err);\n});\n```\n\n\n\nExpress中静态化一个资源文件夹\n\n```javascript\napp.use(express.static(\"www\"));\n```\n\n现在的套路是nodejs制作JSON、JSONP接口 ， 静态资源文件夹里面的文件负责页面的样式，用Ajax请求接口的数据。\n\n\n\nformidable要熟悉：\n\n```javascript\napp.post(\"/tijiao\" , function(req,res){\n\t//只要是post请求、delete等等，一定要用formidable来处理请求的参数\n\tvar form = new formidable.IncomingForm();\n\tform.parse(req , function(err , fields , files){\n\t\t//往数据库中存一个数据，存的数据来自POST请求的参数\n\t\tSurvey.create({\n\t\t\t\"timu1\" : fields.timu1 ,\n\t\t\t\"timu2\" : fields.timu2 ,\n\t\t\t\"timu3\" : fields.timu3 ,\n\t\t\t\"date\" : new Date()\n\t\t},function(err){\n\t\t\tres.json({\"result\" : err ? -1 : 1});\n\t\t});\n\t});\n});\n```\n\n\n\n**编程实际上就是多个东西配合使用：**\n\n* express的中间件\n\n  ```javascript\n  app.get(\"/\" , function(req,res){\n  \t\n  });\n  ```\n\n* formidable\n\n  ```javascript\n  var form = new formidable.IncomingForm();\n  form.parse(req , (err , fields , files)=>{\n  \t\n  });\n  ```\n\n* 数据库\n\n  ```javascript\n  Dog.create({\n  \n  },(err)=>{\n  \t\n  });\n  ```\n\n  \n\n结合起来就是这样：\n\n```javascript\napp.get(\"/\" , function(req,res){\n\tvar form = new formidable.IncomingForm();\n\tform.parse(req , (err , fields , files)=>{\n\t\tDog.create({\n\t\t\tname : fields.name , \n\t\t\tage : fields.age\n\t\t},(err)=>{\n\t\t\t\n\t\t})\n\t});\n});\n```\n\n\n\n# 二、模板引擎\n\n**如果要使用模板引擎，要做4个事情：**\n\n1.  安装依赖，`npm install --save ejs`\n\n2.  设置默认模板引擎 ` app.set(\"view engine\" , \"ejs\"); `\n\n3.  在views文件夹中创建一个.ejs后缀的页面，就是模板\n\n4.  在express的中间件中用`res.render()`来呈递视图，语法就是`res.render(模板文件名字 , {字典}); `\n\n    \n\n我们学习ejs模板引擎，首先安装依赖\n\n```\ncnpm install --save express ejs\n```\n\n```\n┣ views\n┃  ┣ shouye.ejs\n┣ app.js\n```\n\n\n\nshouye.ejs：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n</head>\n<body>\n\t<div class=\"wrap\">\n\t\t<h1>好<%=xinqing%>啊！今天我买了<%=dongxi%>，花了<%=qian%>元！</h1>\n\t</div>\n</body>\n</html>\n```\n\n\n\napp.js:\n\n```javascript\nvar express = require(\"express\");\nvar app = express();\n\n//设置默认模板引擎为ejs\napp.set(\"view engine\" , \"ejs\");\n\napp.get(\"/\" , function(req,res){\n\t//我们现在的res有的功能是：\n\t//res.send()、res.json()、res.jsonp()、res.sendFile()\n\t//现在多了一个res.render()表示使用模板页面\n\t//不需要加上views文件夹，因为模板引擎默认就是放在views文件夹中的\n\t//也不需要加上.ejs后缀\n\tres.render(\"shouye\" , {\n\t\t\"xinqing\" : \"高兴\",\n\t\t\"dongxi\" : \"苹果叉\",\n\t\t\"qian\" : 8000\n\t});\n});\n\napp.listen(3000);\n```\n\n\n\n**一些注意事项：**\n\n1. views文件夹可以改变，使用语\n    ```javascript\n    app.set(\"views\" , \"templates\");\n    ```\n\n    这样我们所有的.ejs文件都要放到 templates文件夹中了。\n\n2. 拓展名必须是`.ejs`，render的时候不需要写`.ejs`\n\n    ```javascript\n    res.render(\"shouye\" , {\n        \"xinqing\" : \"高兴\",\n        \"dongxi\" : \"苹果叉\",\n        \"qian\" : 8000\n    });\n    ```\n\n3. 可以使用一些for循环和if语句：\n\n    ```ejs\n    <ul>\n        <% for(var i = 0 ; i < ouxiang.length ; i++){ %>\n        \t<li><%= ouxiang[i] %></li>\n        <% } %>\n    </ul>\n    ```\n\n    `<% %>`表示for循环、if语句；\n\n    `<%= %>`表示输出\n\n\n\n对应的**字典**就必须是数组：\n\n```javascript\nres.render(\"shouye\" , {\n\t\"xinqing\" : \"高兴\",\n\t\"dongxi\" : \"苹果叉\",\n\t\"qian\" : 8000 ,\n\t\"ouxiang\" : [\"鹿晗\",\"王源\",\"王俊凯\",\"胡歌\"]\n});\n```\n\n\n\n再比如做一个年份选择的下拉列表：\n\n```ejs\n<select name=\"\" id=\"\">\n\t<% for(var i = 1930 ; i <= 2017 ; i++){ %>\n\t\t<option value=\"<%= i %>\"><%= i %></option>\n\t<% } %>\n</select>\n```\n\n\n\n还有其他的模板引擎[pug](https://www.npmjs.com/package/pug)（原名叫做Jade） ，有兴趣的同学自己研究。\n\n\n\n# 三、cookie和session\n\n## 3.1 cookie\n\nHTTP连接是无状态的，所以产生了身份识别问题：\n\n![](image2.png)\n\n工程师是神奇的物种，解决问题的思路往往非常简单：\n\n![](image3.png)\n\n**老外喜欢用\"曲奇饼干\"（cookie）当做信物，所以cookie就是上图中的信物。**\n\n>  服务器会下发一个Set-Cookie的下行报文字段，今后每一次访问这个服务器的时候，浏览器都要携带Cookie上行报文上去。这样服务器就知道你是你了。\n\n\n\nexpress中使用cookie需要安装一个依赖cookie-parser\n\n```\ncnpm install --save cookie-parser\n```\n\n\n\n设置cookie：\n\n```\nres.cookie('visited', visitedArr, { maxAge: 86400 });\n```\n\n\n\n读取cookie：\n\n```javascript\n//提前装好cookie-parser\nvar cookieParser = require('cookie-parser');\napp.use(cookieParser());\n//中间件中\napp.get(\"/:city\" , function(req,res){\n\treq.cookies.visited;\n});\n```\n\n![](image4.png)\n\n浏览器在2011年之前，如果想往硬盘中存储东西，唯一可以的办法就是cookie。\n\n2011年本地存储 localStorage诞生了，在2011年之前，cookie扮演了很多本地存储的角色。\n\n![](image5.png)\n\n\n\n## 3.2 session\n\n刚才我们制作了cookie的案例，发现服务器每次下发的cookie是有意义的文字。**session的机理是下发一个随机乱码，服务器记录下这个随机乱码的持有者的情况**。\n\n![](image6.png)\n\nsession的使用是对程序员是透明的，程序员不用刻意的设置session，Set-Cookie和Cookie就已经设置好了。\n\n\n\nsession在express中的使用，需要npm包：express-session。\n\n```\ncnpm install --save express express-session ejs\n```\n\n\n\n登录成功后，浏览器会下发随机乱码：\n\n![](image7.png)\n\n对于服务器来说，它只需要记住：\n\n> **携带s%3ApsMwf4mopanFucq4Urrv2VxaUAB2oD5b.7TvI5TSU1gk9LV55tFvMGyrGYgzn4uTBn1RPiNlDWRk**\n>\n> **的人login是true了，yonghuming是邵山欢。**\n\n\n\n```javascript\n//登录\napp.post(\"/login\" , function(req,res){\n\tvar form = new formidable.IncomingForm();\n\tform.parse(req , function(err , fields){\n\t\tif(fields.mima = \"123123\"){\n\t\t\t//下发session\n\t\t\treq.session.login = true;\n\t\t\treq.session.yonghuming = fields.yonghuming;\n\n\t\t\tres.redirect(\"/\");\n\t\t}\n\t});\n});\n```\n\n\n\n```javascript\n//首页\napp.get(\"/\" , function(req,res){\n\t//呈递模板，把登录信息也带上去：\n\tres.render(\"shouye\" , {\n\t\tlogin : req.session.login ,\n\t\tyonghuming : req.session.yonghuming ,\n\t\tanlian : req.session.anlian\n\t});\n});\n```\n\n\n\n# 四、问答平台项目\n\n## 4.1 基本文件夹的结构\n\n创建项目文件夹，安装依赖：\n\n```\ncnpm intsall --save express mongoose formidable cookie-parser express-session ejs\n```\n\n\n\n项目的基本文件结构：\n\n```\n┣ models\n┣ views\n┣ controllers\n┣ www\n┃  ┣  js\n┃  ┣  css\n┃  ┣  images\n┣ app.js\n```\n\n\n\n## 4.2 注册业务\n\n**开通一个业务，有三个事儿要做：**\n\n1.  开路由，罗列一个`app.get(\"/regist\" , *****);`\n2.  开模板引擎，在views文件夹中创建一个同名的`.ejs`结尾的模板文件;\n3.  思考模板引擎中的字典，用`res.render()`呈递\n\n\n\n路由：\n\n| URL     | 方法     | 作用                 |\n| ------- | -------- | -------------------- |\n| /regist | GET      | 显示注册页面         |\n| /regist | POST     | 执行注册             |\n| /regist | CHECKOUT | 验证用户名是否被占用 |\n\n![](image8.png)\n\n**一定要注意一个行业操守：不能将用户的密码的明文直接保存在数据库中。**\n\nCSDN有一次被黑了，结果用户的密码都泄露了，考拉老师的百度贴吧、QQ、网易邮箱都用的一个密码，全完蛋。\n\n**我们不能防止被黑，但是我们可以不让用户的密码泄露。黑客只能得到加密之后的密码。**\n\n这里介绍一个加密的东西MD5或者SHA256：这些加密都是不可逆的加密，不能从密文翻译为明文。常用于校验信息的正确性。\n\n在线加密网站：http://tool.oschina.net/encrypt?type=2\n\n\n\n我们来看SHA256：\n\n| 明文                                       | 密文                                                         |\n| ------------------------------------------ | ------------------------------------------------------------ |\n| 妈妈说不管你有多长的文字要加密，一律是64位 | 57f146775795fc42689b98cb9e756f7347efd4cfe6626b0a9aeea8c6de58eec7 |\n| 妈妈讲不管你有多长的文字要加密，一律是64位 | b56c5f6e489fbd69df47bf21ae9dcaa9771094a6e8224a379eeae6fa96490b5e |\n| 我爱你                                     | c0ad5411b19cfcba9d674d21411a970159f6ae4e180831ddd6a91797be547752 |\n| 你爱我                                     | f3a5bb9836b59f01cf001bc70c95318fea4cf43a1b148a8b5344aea07b34a279 |\n\n\n**注册的原理**：服务器的表格中，存储用户名，和加密之后的密码。当用户登录的时候，再次将用户登录填写的密码加密，和数据库的加密的密码进行比对，如果正确了说明用户密码填写正确。\n\nNodeJS中有一个原生模块叫做crypto，可以实现SHA256、MD5加密。\n\n\n","categories":["js.NodeJS"]},{"title":"Node.js入门和企业级项目开发03","url":"%2Fposts%2F1479802669%2F","content":"\n\n\n# 前言\n\n> 第3天课堂笔记\n>\n> 讲师：邵山欢\n>\n> 日期：2017年11月6日\n\n# 复习\n\n**先说一下，工作的时候关于nodejs有两种情况：**\n\n1.  直接找关于nodejs的工作，此时99%是在写HTTP业务。不会让你去写nodejs内核。\n\n    现在企业需要的人就是能够加班、有超强学习能力。刚刚过去的两天，Vue出了2.5、Angular出了5。\n\n    ![](image2.png)\n\n2.  在开发vue（40%市场份额）、react（60%市场份额）的时候，使用nodejs的工作流工作，比如gulp、grunt、yeoman、webpack等等。最常见的，就是用nodejs做路由层。\n\n\n\n项目的后台现在80%以上仍然是PHP、ASP、JSP，因为nodejs是单线程的脚本程序，无法撼动老牌后台服务器语言的。PHP、ASP、JSP是绝对不会找前端去写接口的。\n\n\n\n**复习一些知识点：**\n\n* nodejs不是一个语言，是一个平台。js是语言。和PHP + Apache不同，nodejs即是语言的承接平台又是提供http服务的平台。\n\n\n* nodejs的安装，跨操作系统的，我们写的代码在任何的操作系统中都能运行。但是要装不同的nodejs环境。\n\n\n* nodejs没有根目录，得用http和fs共同配合做顶层路由设计，在原生的开发中，通常用：\n\n  ```javascript\n  var server = http.createServer(function(req,res){\n  \tif(req.url == \"\"){\n  \n  \t}else if(req.url == \"\"){\n  \n  \t}\n  });\n  ```\n\n*  npm要会用，模块的使用。\n\n\n* Express简化了http程序的开发：\n\n  ```javascript\n  var express = require(\"exprss\");\n  var app = express();\n  \n  app.get(\"/\" , function(req,res){\n  \tres.send(\"<h1>你好</h1>\")\n  });\n  \n  app.listen(3000);\n  ```\n\n*  GET请求和POST请求\n\n  ```javascript\n  app.get(\"/\" , function(req,res){\n  \tvar id = url.parse(req.url , true).query.id;\n  \tres.send(\"<h1>你好</h1>\");\n  });\n  \n  app.post(\"/\" , function(req,res){\n  \tvar form = new formidable.IncomingForm();\n  \tform.parse(req , function(err , fields , files){\n  \n  \t});\n  });\n  ```\n\n*   params：\n\n  ```javascript\n  app.get(\"/:xuehao\" , function(req,res){\n  \tvar xuehao = req.params.xuehao;\n  \tres.send(\"<h1>你好</h1>\");\n  });\n  ```\n\n  \n\n# 二、TodoList的深入学习\n\n## 2.1 复习\n\n我们有了db.js这个模拟数据库之后，接下来写了一个todo.js的文件，里面有4个函数是操作db.js的。\n\n此时我们说db.js文件是**可被预测状态的（predictable）**。\n\n说A文件可被预测状态：\n\n1.  **清晰性**：对A文件的所有操作，都罗列出函数了；\n\n2.  **私有性**：对A对象的操作，必须通过这些函数；\n\n3.  **灵活性**：对A的操作可以任意插拔，删除一个函数就去掉了一种操作，增加一个函数就增加一个操作。\n\n\n\nnodejs中的所有的关于文件的操作，都是异步的。比如：\n\n```javascript\nfs.readFile();\nfs.writeFile();\nfs.appendFile();\n```\n\n所以他们都提供了回调函数：\n\n```javascript\nfs.write(filepath , function(err , data){\n\n});\n```\n\n\n\n**如果再把这个异步函数封装成一个函数，外层函数要接受一个callback回调函数，当fs的readFile执行完毕之后，调用callback通过实参将data传出去**。\n\n```javascript\nfunction read(callback){\n\tfs.write(filepath , function(err , data){\n\t\tcallback(JSON.parse(data.toString()));\n\t});\n}\n\nread(function(jsonobj){\n\tconsole.log(jsonobj);\n});\n```\n\n\n\n**RESTful接口：**\n\n| 功能         | URL地址    | 请求   |\n| ------------ | ---------- | ------ |\n| 增加TodO     | /todo      | POST   |\n| 列出TODO     | /todo      | GET    |\n| 更改TODO顺序 | /todo      | MOVE   |\n| 删除TODO     | /todo/id号 | DELETE |\n| 更改TODO     | /todo/id号 | PATCH  |\n\n\n\n我们将app.js中的中间件的function(req,res)都挪出去：\n\n```javascript\nvar express = require(\"express\");\nvar app = express();\n\n//引入控制器\nvar mainctrl = require(\"./controllers/mainctrl.js\");\n//静态化www文件夹\napp.use(express.static(\"www\"));\n\n//罗列中间件\napp.get(\"/todo\"  \t\t, mainctrl.showTodo);\t\t//列出所有的todo\napp.post(\"/todo\" \t\t, mainctrl.addTodo);\t\t//增加todo\napp.delete(\"/todo/:id\"  , mainctrl.removeTodo); \t//删除todo\napp.patch(\"/todo/:id\" \t, mainctrl.updateTodo); \t//更改todo\napp.move(\"/todo\" \t\t, mainctrl.moveTodo);\t\t//更改TODO的顺序\n\n//监听端口\napp.listen(3000);\n```\n\n控制器controllers/mainctrl.js:\n\n```javascript\nvar formidable = require(\"formidable\");\n//引入苦工（就是我们的model）\nvar todo = require(\"../models/todo.js\");\n\n//列出所有todo\nexports.showTodo = function(req,res){\n\t//当用户访问/todo命令苦工读取数据库\n\ttodo.allTodo(function(data){\n\t\t//呈递在页面上\n\t\tres.json({\"results\" : data});\n\t});\n}\n\n//增加todo\nexports.addTodo = function(req,res){\n\t//识别用户传入的title\n\tvar form = new formidable.IncomingForm();\n\n\tform.parse(req , function(err , fields , files){\n\t\tvar title = fields.title;\n\t\ttodo.addTodo(title , function(){\n\t\t\tres.json({\"result\" : 1});\n\t\t})\n\t});\n}\n\n//删除todo\nexports.removeTodo = function(req,res){\n\tvar id = req.params.id;\n\n\t//命令苦工删除\n\ttodo.removeTodo(id , function(){\n\t\tres.json({\"result\" : 1});\n\t});\n}\n\n\n//更改todo\nexports.updateTodo = function(req,res){\n\tvar id = req.params.id;\n\n\tvar form = new formidable.IncomingForm();\n\n\tform.parse(req , function(err , fields , files){\n\t\t//命令苦工删除\n\t\ttodo.updateTodo(id , fields.k , fields.v , function(){\n\t\t\tres.json({\"result\" : 1});\n\t\t});\n\t});\n}\n\n\n//移动todo\nexports.moveTodo =  function(req,res){\n\tvar form = new formidable.IncomingForm();\n\n\tform.parse(req , function(err , fields , files){\n\t\tvar startidx = fields.startidx;\n\t\tvar endidx = fields.endidx;\n\n\t\t//命令苦工更改顺序\n\t\ttodo.moveTodo(startidx , endidx , function(){\n\t\t\tres.json({\"result\" : 1});\n\t\t});\n\t});\n}\n```\n\n\n\n## 2.2 MVC架构\n\n**MVC、MVVM不是设计模式，而是代码的架构模式**。\n\n-   **设计模式**比如中介者模式、发布订阅模式、装饰器模式等等，他们解决的是偶尔性问题，类和类中间怎么一起工作；\n\n-   **代码的架构**模式是编程的时候文件的组织的模式。\n\n**MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写。**\n\n-   **Model（模型）**是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。\n\n-   **View（视图）**是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。\n\n-   **Controller（控制器）**是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\n\n![](image3.png)\n\nMVC的一个图示：\n\n![IMG\\_256](image4.jpeg)\n\n\n\n# 三、MongoDB\n\n## 3.1 NoSQL简介\n\n之前学习的是SQL（structure query language ， 结构化查询语言）。**SQL数据库有一个最大特点：限制每一个字段的类型。**\n\n![](image5.png)\n\n比如id现在是数字类型，但是突然间国家开放成人本科，此时学校说学号要以CR打头，你就傻了，因为id必须是数字。**现在我们要修改字段类型，时间耗费很多，因为所有已经存在的条目要跟着一起修改**。**如果要增加列，更是灾难，因为所有已经存在的条目都要跟着一起修改**。\n\n\n\nNoSQL（非结构化数据库，Not Only SQL）应运而生。\n\n下面的数据就是合法的4条NoSQL数据：\n\n```\n{\"id\":10001 , \"name\":\"小明\" , \"age\" : 12 , \"sex\" : \"男\"}\n{\"id\":10002 , \"name\":\"小强\" , \"age\" : 13 , \"sex\" : \"男\"}\n{\"id\":10003 , \"name\":\"小吕\" , \"age\" : 14 , \"sex\" : \"女\"}\n{\"id\":\"CR10001\" , \"name\":\"小钢炮\" , \"age\" : 44 , \"sex\" : \"男\",\"score\":560}\n```\n\n每个字段都不限制类型，id可以是数字，然后突然间变为字符串是合法的；也可以增加字段。\n\n|       | 优点                                                         | 缺点                                                 |\n| ----- | ------------------------------------------------------------ | ---------------------------------------------------- |\n| SQL   | 适合复杂的查找、查询很迅速                                   | 限制了字段的类型、表格一旦确定不容易更改表格的形态。 |\n| NoSQL | 不限制字段类型，数据条目每一条都可以有不同的字段，便于修改表格的形态。 | 不适合复杂的查找、查询不迅速                         |\n\n\n\n## 3.2 MongoDB数据库的安装\n\n官网：https://www.mongodb.com/\n\n![](image6.png)\n\n下载之后：\n\n![](image7.png)\n\n注意系统是64位的同学，学习mongodb3.0.6，32位的同学只能安装2代。\n\n![](image8.png)\n\n![](image9.png)\n\n现在要把bin这个文件夹设置为系统的环境变量。\n\n![](image10.png)\n\n一路确定之后，就可以打开CMD：\n\n![](image11.png)\n\n输入：\n\n```\nmongo -version\n```\n\n可以查看mongo数据库的版本号了，说明安装成功。\n\n\n\n## 3.3 数据库的开机mongod\n\n开启数据库我们称作\"开机\"。\n\n首先需要在c盘创建一个database文件夹。然后打开CMD输入：\n\n```\nmongod --dbpath c:\\database\n```\n\nmongo**d**负责开机。读作\"芒果第\"。\n\n`--dbpath`表示设置数据库的存放目录。\n\n![](image12.png)\n\n如果能够在CMD的最后一行看见：waiting for connections on port 27017\n\n说明开机成功。\n\n\n\n**注意，必须事先安装了windows补丁KB2731284，如果没有安装这个补丁，数据库将开机失败。**\n\n怎么知道自己是不是安装了这个补丁呢？\n\n```\nsysteminfo\n```\n\n![](image13.png)\n\n如果就是跑不成功，此时尝试用管理员模式打开CMD：\n\n![](image14.png)\n\n如果还是开不了，就换为2.0.6版本即可。\n\n\n\n## 3.4 简单的数据库操作mongo\n\nMongoDB有可视化管理软件，叫做MongoBooster，前期我们先用CMD来管理。\n\n使用数据库之前要先用mongod开机，然后此CMD不能关闭，再次打开一个窗口，用mongo命令进入REPL环境。\n\nbin文件夹中两个工具：\n\n| 工具名字        | 负责的事情     |\n| --------------- | -------------- |\n| mongod.exe      | 负责开机       |\n| mongo.exe       | 负责管理数据库 |\n| mongoimport.exe | 负责导入数据   |\n| mongoexport.exe | 负责导出数据   |\n\n\n![](image15.png)\n\n\n\n**数据库**用use来**创建**，比如创建一个学生管理数据库：\n\n```\n> use xsgl\n```\n\n这个叫做使用数据库，只不过当这个数据库不存在的时候，系统自动帮你创建。\n\n创建完数据库之后，要创建一个\"表格\"叫做banji0716，\"表格\"在MongoDB中称为\"集合\"。\n\n集合不用刻意创建，只需要在集合中插入一条数据，集合自动创建。\n\n**插入数据**的语法：\n\n```\n> db.banji0716.insert({\"id\":10001,\"name\":\"小明\",\"age\":12,\"sex\":\"男\"});\n```\n\n数据库中的数据就是JSON。\n\n![](image16.png)\n\n\n\n查看集合中的全部数据，用\n\n```\n> db.banji0716.find()\n```\n\n![](image17.png)\n\n\n\n查看0716班所有男生：\n\n```\n> db.banji0716.find({\"sex\":\"男\"});\n```\n\n\n\n查看0716班所有大于15岁的男生：\n\n```\n> db.banji0716.find({\"sex\":\"男\" , \"age\" : {\"$gt\" : 15}});\n```\n\n\n\n查看0716班所有大于15岁的男生或者小于17岁的女生：\n\n```\n> db.banji0716.find({\"$or\" : [{\"sex\":\"男\",\"age\":{\"$gt\":15}},{\"sex\":\"女\",\"age\":{\"$lt\":17}}]});\n```\n\n也就是说NoSQL的CRUD（增删改查）操作，一律不使用SQL。\n\n\n\n原来的SQL现在不用了：\n\n```sql\nSELECT * FROM banji0716 WHERE (sex = \"男\" AND age > 13) OR (sex = \"女\" AND age < 17)\n```\n\n\n\n查看已经有的数据库\n\n```\n> show dbs\n```\n\n![](image18.png)\n\n\n\n需要注意的是：数据库中必须有一条数据之后，才能被创建。\n\n\n\n删除数据库（实现要use 一个数据库）\n\n```\n> db.dropDatabase()\n```\n\n\n\n查看已有集合：\n\n```\n> show collections\n```\n\n\n\n删除集合：\n\n```\n> db.banji0716.drop()\n```\n\n\n\n删除一个条目：\n\n```\n> db.banji0716.remove({\"id\":\"CR10001\"})\n```\n\n\n\n## 3.5 数据的导入(mongoimport)和导出(mongoexport)\n\n先开机，但是不要进入REPL环境！\n\n**数据导入**：\n\n在桌面上准备一个数据.txt\n\n```json\n{\"id\":10001 , \"name\":\"小明\" , \"age\" : 12 , \"sex\" : \"男\"}\n{\"id\":10002 , \"name\":\"小强\" , \"age\" : 13 , \"sex\" : \"男\"}\n{\"id\":10003 , \"name\":\"小吕\" , \"age\" : 14 , \"sex\" : \"女\"}\n{\"id\":\"CR10001\" , \"name\":\"小钢炮\" , \"age\" : 44 , \"sex\" : \"男\",\"score\":560}\n```\n\n使用CMD命令：\n\n```bash\nmongoimport -d xsgl -c banji0716 C:\\Users\\Danny\\Desktop\\数据.txt --drop\n```\n\n`-d`表示选择database数据库\n\n`-c`表示选择collection集合（表）\n\n`--drop`表示删除这个集合中已经有的数据\n\n\n\n**导出数据**：\n\n```\nmongoexport -d xsgl -c banji0716 -o c:\\beifen.txt\n```\n\n\n\n## 3.6 使用mongobooster可视化数据库管理软件\n\n![](image19.png)\n\n\n\n\n# 四、NodeJS操作MongoDB（非重点）\n\n> 因为一会儿我们就要讲解Mongoose，将颠覆这里的知识。\n>\n> 手册：https://docs.mongodb.com/ecosystem/drivers/node-js/\n>\n> 或者：https://www.npmjs.com/package/mongodb\n\n\n\n## 4.1 连接数据库\n\n安装依赖\n\n```\ncnpm install --save mongodb\n```\n\n用mongod开启数据库之后，写app.js:\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\n\n//数据库的地址，最末尾的斜杠是数据库的名字\nvar url = 'mongodb://localhost:27017/xsgl';\n\nMongoClient.connect(url, function(err, db) {\n\tif(!err){\n\t\tconsole.log(\"数据库连接成功\");\n\t}else{\n\t\tconsole.log(\"数据库连接失败\");\n\t\treturn;\n\t}\n});\n```\n\n\n\n运行node app.js即可。\n\n![](image20.png)\n\n\n\n## 4.2 查询和增加操作\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\n\n//数据库的地址，最末尾的斜杠是数据库的名字\nvar url = 'mongodb://localhost:27017/xsgl';\n\n//连接数据库\nMongoClient.connect(url, function(err, db) {\n\tif(!err){\n\t\tconsole.log(\"数据库连接成功\");\n\t}else{\n\t\tconsole.log(\"数据库连接失败\");\n\t\treturn;\n\t}\n\t\n\n\t//查询\n\t// db.collection(\"banji0716\").find({}).toArray(function(err , docs){\n\t// \tconsole.log(docs);\n\t// });\n\n\t//增加\n\tdb.collection(\"banji0716\").insert({\"name\":\"小张\",\"age\":7},function(err){\n\t\tif(!err){\n\t\t\tconsole.log(\"插入成功\");\n\t\t}\n\t});\n\t\n});\n```\n\n**原生nodejs操作mongodb问题很多：**\n\n1.  语法形式上大的回调函数太大了，要包裹所有的代码，甚至要包裹express的中间件；\n\n2.  不利于MVC编程，我们几乎不能将所有对数据库的操作封装到一个文件中。\n\n\n\n\n\n# 五、Mongoose\n\nMongoose简化了nodejs对nodejs的操作。\n\nmongoose是nodejs中的model那个文件。\n    \n![](image21.png)\n\n\n\n## 5.1 基本使用\n\n安装\n\n```\ncnpm install --save mongoose\n```\n\n\n\n两步走：\n\n![](image22.png)\n\n我们首先创建一个models的文件夹，创建一个Student.js的构造函数：\n\n```javascript\nvar mongoose = require(\"mongoose\");\n\n//创建schema\nvar studentSchema = new mongoose.Schema({\n\t\"xuehao\" \t: Number, \n\t\"xingming\" \t: String,\n\t\"age\" \t\t: Number,\n\t\"sex\" \t\t: String\n});\n\n//通过schema创建model\nvar Student = mongoose.model(\"Student\" , studentSchema);\n\n//暴露\nmodule.exports = Student;\n```\n\n然后创建app.js:\n\n```javascript\nvar mongoose = require('mongoose');\n\n//连接数据库\nmongoose.connect('mongodb://localhost/xsgl');\n\n//连接我们的model\nvar Student = require(\"./models/Student.js\");\n\n//实例化一个Student类的实例：\nvar xiaoming = new Student({\n\t\"xuehao\" : 10001 ,\n\t\"age\" : 12,\n\t\"sex\" : \"男\",\n\t\"xingming\" : \"小明\"\n});\n\n//调用它的save方法即可放到数据库中持久\nxiaoming.save(function(err){\n\tif(err){\n\t\tconsole.log(\"保存失败\");\n\t}else{\n\t\tconsole.log(\"保存成功\");\n\t}\n});\n```\n\n\n\n集合就是students，会被自动加上复数s：\n\n![](image23.png)\n\n\n\n你创建model的时候：\n\n```javascript\nvar Student = mongoose.model(\"Student\" , studentSchema);\n```\n\n它将会自动将开头字母变为小心，末尾加s作为集合名字。\n\n\n\n## 5.2 增\n\n**注意，mongoose牛逼之处在于，schema、model一旦写好了，再也不用改**！\n\n方法1：（实例化，然后save）\n\n```javascript\nvar xiaohong = new Student({\n\t\"xuehao\" \t: 10002, \n\t\"xingming\" \t: \"小红\",\n\t\"age\" \t\t: 9,\n\t\"sex\" \t\t: \"女\"\n});\n\nxiaohong.save((err)=>{\n\t!err && console.log(\"成功\");\n});\n```\n\n\n\n方法2：（直接调用create）\n\n```javascript\nStudent.create({\n\t\"xuehao\" \t: 10003, \n\t\"xingming\" \t: \"小花\",\n\t\"age\" \t\t: 5,\n\t\"sex\" \t\t: \"女\"\n},(err)=>{\n\t!err && console.log(\"成功\");\n});\n```\n\n\n\n## 5.3 删\n\n方法1（先找到这个人，然后remove）：\n\n```javascript\nStudent.find({\"xingming\" : \"小红\"} , function(err , results){\n\tvar zhegeren = results[0];\n\tzhegeren.remove((err)=>{\n\t\t!err && console.log(\"成功\");\n\t});\n});\n```\n\n\n\n方法2（直接remove）：\n\n```javascript\nStudent.remove({\"xingming\" : \"小花\"} , (err)=>{\n\t!err && console.log(\"成功\");\n});\n```\n\n\n\n## 5.4 改\n\n方法1（找到，改了，然后save）\n\n```javascript\nStudent.find({\"xingming\" : \"小明\"} , function(err , results){\n\tvar thepeople = results[0];\n\n\tthepeople.sex = \"女\";\n\n\tthepeople.save((err)=>{\n\t\t!err && console.log(\"成功\");\n\t});\n});\n```\n\n\n\n方法2（直接改）：\n\n```javascript\nStudent.update({\"xingming\" : \"小明\"} , {\"$set\" : {\"age\" : 99}} , function(err){\n\t!err && console.log(\"成功\");\n});\n```\n\n\n\n语法：\n\n```javascript\nStudent.update(改变谁 , {\"$set\" : 怎么改} , function(err){\n\t!err && console.log(\"成功\");\n});\n```\n\n\n\n## 5.5 查\n\n```javascript\nStudent.find({\"xingming\" : \"小红\"} , function(err , results){\n\n});\n```\n\n\n\n# 六、Mongoose小案例 - 小小调查问卷表单\n\n**我们设计三个题目：**\n\n【单选题】双十一你最期待的事情：商场打折、淘宝购物节、单身狗过节啦\n\n【多选题】双十一你想买的东西：零食、衣服、电子产品、美容产品\n\n【数字题】你预算花费：range条，10块 \\~ 20000块\n\n我们现在从前端、nodejs服务端、数据库，都是JavaScript语境！数据库也是JOSN！所以数组不会变形！\n\n\n\n**统计集合中有多少数据：**\n\n```\n> db.surveys.count()\n```\n\n\n\n存储数据库特别简单：\n\n```javascript\n//中间件\napp.post(\"/tijiao\" , function(req,res){\n\tvar form = new formidable.IncomingForm();\n\tform.parse(req , function(err , fields){\n\t\tSurvey.create({\n\t\t\t\"timu1\" : fields.timu1 ,\n\t\t\t\"timu2\" : fields.timu2 ,\n\t\t\t\"timu3\" : fields.timu3 ,\n\t\t\t\"date\" : new Date()\n\t\t},function(err){\n\t\t\tres.json({\"result\" : err ? -1 : 1});\n\t\t});\n\t});\n});\n```\n\n数据可视化：http://echarts.baidu.com/demo.html#pie-simple\n\n\n\n","categories":["js.NodeJS"]},{"title":"Node.js入门和企业级项目开发02","url":"%2Fposts%2F791990203%2F","content":"\n\n\n# 前言\n\n> 第2天课堂笔记\n>\n> 讲师：邵山欢\n>\n> 日期：2017年11月3日\n\n# 一、作业讲解\n\n**开发一个小网站，功能是：**\n\n1. 网址/  ，显示对考拉老师的话（别说坏话）。\n\n2. 网址/qian/12321 ，显示人民币一万两千三百二十一块整\n\n3. 网址/riqi/1997/5/8 ，显示这一天是农历丁酉年甲子月甲子年\n\n4. 网址/pinyin/我爱鹿晗  ，显示wǒ ài lù hán\n\n\n\n\n**讲一下作业：**\n\n第1步，创建package.json文件，使用CMD命令\n\n```\nnpm init\n```\n\n第2步，安装依赖。\n\n这里学习一下，可以用空格隔开所有的依赖的名字，一次性安装多个：\n\n```\nnpm install --save nzh solarlunar pinyin\n```\n\n第3步，写app.js跑一个HelloWorld，验证引包都是正确的，没有少文件。\n\n```javascript\nvar http = require(\"http\");\nvar nzh = require(\"nzh\");\nvar solarlunar = require(\"solarlunar\");\nvar pinyin = require(\"pinyin\");\n\nhttp.createServer((req,res)=>{\n\tres.end(\"123\");\n}).listen(3000);\n```\n\n第4步，写app.js，得到用户的URL，并且得到里面有用的部分。\n\n这里我们使用一个新的内置模块叫做url，这个url模块有一个parse的方法，可以将url进行分解。\n\n比如url：http://127.0.0.1:3000/qian/123123?haha=2&sex=nan\n\n进行\n\n```javascript\nvar url = require(\"url\");\nconsole.log( url.parse(req.url) );\n```\n\n![](image10.png)\n\n两个东西最有用：\n\n● pathname 就是url的主干部分\n\n● query 就是GET请求的查询参数\n\n进一步的，如果parse函数里面加上第二个参数true，此时参数query将会自动成为对象。\n\n```\nurl.parse(req.url , true);\n```\n\n![](image11.png)\n\n第5步，进行正则模式的匹配。\n\n```javascript\nhttp.createServer((req,res)=>{\n\t//得到用户访问的地址的主干部分\n\tvar pathname = url.parse(req.url , true).pathname;\n\n\tif(pathname == \"/\"){\n\t\tres.setHeader(\"Content-Type\" , \"text/html;charset=UTF8\");\n\t\tres.end(\"这是首页\");\n\t}else if(/\\/qian\\/.+$/.test(pathname)){\n\t\tres.setHeader(\"Content-Type\" , \"text/html;charset=UTF8\");\n\t\t//尝试得到qian后面的部分\n\t\tvar money = pathname.match(/\\/qian\\/(.+)$/)[1];\n\t\tvar toMoney = nzh.toMoney(money);\n\t\t//nzh这个包有一个特点，当你toMondy转一个不合法的输入的时候，会返回原串\n\t\tif(money == toMoney){\n\t\t\tres.end(\"不合法的输入\");\n\t\t}else{\n\t\t\tres.end(toMoney);\n\t\t}\n\t}\n}).listen(3000);\n```\n\n第6步，可以将所有的业务放到其他的文件夹中。\n\n```javascript\nvar http = require(\"http\");\nvar url = require(\"url\");\nvar showqian = require(\"./controllers/showqian.js\");\nvar showriqi = require(\"./controllers/showriqi.js\");\nvar showpinyin = require(\"./controllers/showpinyin.js\");\nvar fs = require(\"fs\");\n\nvar server = http.createServer(function(req,res){\n\t//得到用户访问的地址的主干部分\n\tvar pathname = url.parse(req.url , true).pathname;\n\n\tif(pathname == \"/\"){\n\t\tres.setHeader(\"Content-Type\" , \"text/html;charset=UTF8\");\n\t\tfs.readFile(\"./public/index.html\" , function(err , data){\n\t\t\tres.end(data);\n\t\t});\n\t}else if(/\\/qian\\/.+$/.test(pathname)){\n\t\t//如果URL匹配了/qian/...的模式，此时调用外部的函数\n\t\tshowqian(res , pathname);\n\t}else if(/\\/riqi\\/.+$/.test(pathname)){\n\t\tshowriqi(res , pathname);\n\t}else if(/\\/pinyin\\/.+$/.test(pathname)){\n\t\tshowpinyin(res , pathname);\n\t}else{\n\t\tres.statusCode = 404;\n\t\tres.setHeader(\"Content-Type\" , \"text/html;charset=UTF8\");\n\t\tres.end(\"<h1>没有这个页面</h1>\");\n\t}\n});\n\nserver.listen(3000);\n```\n\n\n\n# 二、淘宝CNPM镜像\n\n淘宝做了一个npm的镜像，叫做cnpm。\n\n官网： npm.taobao.org\n\n特别简单复制下面的程序到CMD中按回车就行了：\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n`-g`安装表示全局安装命令行程序，安装完毕之后，我们就能在CMD中使用cnpm了。\n\n![](image12.png)\n\n今后使用cnpm命令代替npm命令，比如：\n\n```\ncnpm install --save solarlunar\n```\n\n\n\n# 三、Express框架\n\n## 3.1 整体感知\n\n做http服务的时候，不方便：\n\n-   匹配URL很不方便 if(//.test()){}\n\n-   使用静态页面不方便 fs.readFile(function(err,data){res.end(data)})\n\n-   不能静态化一个文件夹，我们想将一个文件夹中的所有文件自动拥有路由，实现不了\n\n-   ......\n\n    \n\n**Express简化了HTTP应用程序的开发。**\n\n官网： http://www.expressjs.com.cn/\n\n![](image13.png)\n\n\n安装依赖：\n\n```\ncnpm intsall --save express\n```\n\n我们用昨天的作业在express中进行一个演示：\n\n```javascript\nvar express = require(\"express\");\nvar app = express();\n\napp.get(\"/\" , function(req,res){\n\tres.send(\"我是首页\");\n});\n\napp.get(\"/qian/:shu\" , function(req,res){\n\tres.send(\"转钱为大写，要转的钱\" + req.params.shu);\n});\n\napp.get(\"/riqi/:nian/:yue/:ri\" , function(req,res){\n\tres.send(\"客官你好，我会将这个日期转为农历：\" + req.params.nian + req.params.yue + req.params.ri);\n});\n\napp.get(\"/pinyin/:word\" , function(req,res){\n\tres.send(\"将这个词\" + req.params.word + \"转为拼音\");\n});\n\napp.listen(3000);\n```\n\n\n\n## 3.2 创建app和app的监听\n\n我们引入express之后，这个express是一个函数，这个函数可以调用创建出一个app对象。\n\n今后所有的操作都是用app对象来完成，需要注意的是，一个程序中只有一个app。也就是说express不能多次调用。\n\n\n\n**express程序的基本结构：**\n\n```javascript\nvar express = require(\"express\");\nvar app = express();\n\n中间件\n中间件\n中间件\n中间件\n\napp.listen(3000);\n```\n\n\n\n## 3.3 中间件\n\n### 3.3.1 动词\n\n中间件的语法：\n\n```javascript\napp.动词(\"地址\" , function(req,res){\n\n});\n```\n\n我们先说动词，它是26种HTTP请求，必须是小写字母：\n\n![](image14.png)\n\n动词表示当用户用这种请求访问这个页面的时候做的事情。\n\n我们现在就可以区分出用GET请求访问首页和POST请求访问首页做不同的事情：\n\n```javascript\nvar express = require(\"express\");\nvar app = express();\n\napp.get(\"/\" , function(req,res){\n\tconsole.log(\"A\");\n});\n\napp.post(\"/\" , function(req,res){\n\tconsole.log(\"B\");\n});\n\napp.listen(3000);\n```\n\n\n\n### 3.3.2 中间件的路径是自动比对主干部分\n\n路径已经自动被url.parse()了，也就是说express会用用户输入的URL的主干部分来进行比对。\n\n也就是说我的中间件如果是：\n\n```javascript\napp.get(\"/xinwen\" , function(req,res){\n\tres.send(\"<h1>新闻频道</h1>\");\n})\n```\n\n下面的URL都是合法的能够进入这个频道的：\n\n```\nhttp://127.0.0.1:3000/xinwen\nhttp://127.0.0.1:3000/xinwen/\nhttp://127.0.0.1:3000/xinwen?id=234234\nhttp://127.0.0.1:3000/xinwen?id=234234#234234345435234\n```\n\n![](image15.png)\n\n\n\n### 3.3.3 中间件可以有通配符\n\n用`:`来表示画一个通配，要注意这里没有正则表达式的，在程序中可以通过`req.params.***`得到它。\n\n```javascript\napp.get(\"/:banji/:xuehao\" , function(req,res){\n\tvar banji = req.params.banji;\n\tvar xuehao = req.params.xuehao;\n\n\tres.send(banji + \"班\" + xuehao + \"号\");\n});\n```\n\n今后的编程就不用写match()和test()方法了。\n\n还有一种\\*的通配符，没啥用，自己看手册。\n\n\n\n### 3.3.4 中间件的顺序很关键\n\n比如我们输入班级、学号查询学生信息，但是不能查询3班8号。此时一定要注意中间件的顺序。\n\n中间件一旦匹配上的路由，此时不再进行其他匹配。有一种\"拦截\"的感觉。\n\n```javascript\napp.get(\"/3/8\" , function(req,res){\n\tres.send(\"<h1>校长的儿子你也敢查！</h1>\")\n});\n\napp.get(\"/:banji/:xuehao\" , function(req,res){\n\tvar banji = req.params.banji;\n\tvar xuehao = req.params.xuehao;\n\n\tres.send(banji + \"班\" + xuehao + \"号\");\n});\n```\n\n\n\n### 3.3.5 用next()放行拦截\n\n当一个中间件已经匹配了路径，但是自己不希望单独处理这次请求，可以用next来放行。\n\n我们做一个业务能够查询学生或者老师的信息，不管查询什么都要增加计数器的数量。此时可以单独用一个中间件写计数器，放行请求即可：\n\n```javascript\napp.get(\"/chaxun/*\" , function(req,res,next){\n\tcount++;\n\tnext();\n});\n\napp.get(\"/chaxun/xuesheng/:banji/:xuehao\" , function(req,res){\n\tres.send(\"查询\" + req.params.banji + \"班\" + req.params.xuehao + \"号\" + \"<br /> 共查询了\" + count + \"次\");\n});\n\napp.get(\"/chaxun/laoshi/:gonghao\" , function(req,res){\n\tres.send(\"查询\" + req.params.gonghao + \"工号的老师\" + \"<br /> 共查询了\" + count + \"次\");\n});\n```\n\n\n\n## 3.4 输出\n\n● 输出可以用res.send()做输出，会自动加上utf-8。\n\n```javascript\napp.get(\"/\" , function(req,res){\n\tres.send(\"中文\");\n});\n```\n\n● 如果输出的内容是一个JSON，此时要用res.json()来进行输出。\n\n```javascript\napp.get(\"/\" , function(req,res){\n\tres.json({\"a\":1,\"b\":2,\"c\":[1,2,3,4,{\"m\":4}]});\n});\n```\n\n● 如果输出的内容是一个JSONP，此时要用res.jsonp()来输出，此时它会自动检测callback的GET请求，并且加上圆括号的调用。\n\n```javascript\napp.get(\"/\" , function(req,res){\n\tres.jsonp({\"a\":1,\"b\":2,\"c\":[1,2,3,4,{\"m\":4}]});\n});\n```\n\n\n\n**复习一下jQuery中的jsonp跨域：**\n\n```javascript\n$.ajax({\n\t\"url\" : \"/?callback=?\",\n\t\"dataType\" : \"JSONP\",\n\t\"success\" : function(data){\n\n\t}\n});\n\n//原理\n//jQuery帮我们创建了一个<script>标签，src是这个url，用随机的字符串替换了?\n//用随机的字符串为名字创建了一个全局的函数，将success指向它\n```\n\n![](image16.png)\n\n● 如果输出的是一个外置页面，此时要用sendFile()这个API，注意这里必须要用绝对路径，此时我们用***\\_\\_dirname***来进行一个拼合。\n\n```javascript\napp.get(\"/\" , function(req,res){\n\t//__dirname表示当前文件所在的目录\n\tres.sendFile(__dirname + \"/public/a.html\");\n});\n```\n\n● 如果想要跳转页面，用res.redirect()即可\n\n```javascript\napp.get(\"/\" , function(req,res){\n\tres.redirect(\"http://www.163.com\");\n});\n```\n\n\n\n**复习：**\n\nres.send()\n\nres.sendFile()\n\nres.json()\n\nres.jsonp()\n\nres.redirect()\n\n\n\n## 3.5 静态化一个文件夹\n\n如果我们想让某文件夹中的所有文件自动拥有路由，此时非常简单，一句话即可：\n\n```javascript\napp.use(express.static(\"public\"));\n```\n\n此时将把public文件夹进行静态化。\n\n```\n┣ app.js\n┣ public\n┃  ┣  a.html\n┃  ┣  m\n┃  ┃ ┣  n\n┃  ┃ ┃ ┣ wangjunkai.png\n```\n\n\n\n我们在app.js中静态化public文件夹：\n\n```javascript\nvar express = require(\"express\");\nvar app = express();\n\napp.use(express.static(\"public\"));\n\napp.listen(3000);\n```\n\n此时：\n\n![](image17.png)\n\n![](image18.png)\n\n更进一步，如果我们不希望静态的文件夹出现在底层，而是在URL中体现public的名字，此时可用：\n\n```javascript\napp.use(\"/public\" , express.static(\"public\"));\n```\n\n![](image19.png)\n\n\n\n# 四、Express中的GET请求和POST请求参数的获得\n\n## 4.1 GET请求参数的获得\n\n![](image20.png)\n\nGET请求参数的识别实际上就是URL地址的解析。URL解析使用内置的url模块的parse方法即可。\n\n```javascript\nvar url = require(\"url\");\napp.get(\"/tijiao\" , function(req,res){\n\tvar query = url.parse(req.url , true).query;\n\tconsole.log(\"服务器收到了前端交来的数据\" , query);\n});\n```\n\n![](image21.png)\n\n\n\n## 4.2 POST请求参数的获得\n\nPOST请求的参数携带在上行报文的报文体中。\n\n我们使用npm包formidable来识别这样的上行报文。\n\nAPI：https://www.npmjs.com/package/formidable\n\n安装依赖：\n\n```\ncnpm intsall formidable --save\n```\n\n后台app.js识别POST请求需要使用formidable这个包。\n\n```javascript\nvar formidable = require('formidable');\napp.post(\"/tijiao\" , function(req,res){\n\tvar form = new formidable.IncomingForm();\n\n\tform.parse(req , function(err , fields , files){\n\t\tres.json({\"result\" : 1})\n\t});\n});\n```\n\n\n\n总结一下两种请求后台怎么得到参数（伪代码）：\n\n**GET请求** \n\n```\nvar url = require(\"url\");\nvar query = url.parse(req.url , true).query;\n```\n\n**POST请求** \n\n```\nvar formidable = require(\"formidable\");\n\napp.post(\"/tijiao\" , function(req,res){\n\tvar form = new formidable.IncomingForm();\n\tform.parse(req , function(err , fields , files){\n\t\tconsole.log(fields);\n\t});\n});\n```\n\n\n\n## 4.3 其他请求\n\n一共有26种请求，注意只有GET请求是通过URL缀`?`参数来传递参数的。其他的25种请求，都是通过上行报文来传参数的。formidable能够识别其他25种请求的参数。\n\n\n\n先说一下jQuery如何发出DELETE请求：\n\n```javascript\n$(\"#btn3\").click(function(){\n\t$.ajax({\n\t\t\"url\" : \"/tijiao\" ,\n\t\t\"type\" : \"DELETE\" ,\n\t\t\"data\" : {\n\t\t\t\"id\" : 10086\n\t\t},\n\t\t\"success\" : function(data){\n\t\t\talert(data.result);\n\t\t}\n\t});\n});\n```\n\n我们的Express这样识别它：（你会发现和POST请求的处理方法是一样的，都是formidable）：\n\n```javascript\n//识别DELETE请求\napp.delete(\"/tijiao\" , function(req,res){\n\tvar form = new formidable.IncomingForm();\n\tform.parse(req , (err , fields , files) => {\n\t\tconsole.log(\"服务器收到DELETE请求参数\" , fields);\n\t\tres.json({\"result\" : 1});\n\t});\n});\n```\n\n\n\n总结一下：\n\n**GET请求** \n\n```\nvar url = require(\"url\");\nvar query = url.parse(req.url , true).query;\n```\n\n\n\n**其他请求**\n\n```\nvar formidable = require(\"formidable\");\n\napp.动词(\"/tijiao\" , function(req,res){\n\tvar form = new formidable.IncomingForm();\n\tform.parse(req , function(err , fields , files){\n\t\tconsole.log(fields);\n\t});\n});\n```\n\n\n\n## 4.4 RESTful风格路由\n\n注意这个单词的写法：RESTful。REST是Representational State Transfer。\n\n**RESTful风格的路由很简单，指的是用URL表示操作的资源，用HTTP动词表示何种操作。**\n\n\n\n不是RESTful风格的路由：\n\n| 事儿                            | 处理这个事儿的URL                                  |\n| ------------------------------- | -------------------------------------------------- |\n| 增加一个学生                    | http://127.0.0.1/addStudent.php                    |\n| 删除一个学号为10086的学生       | http://127.0.0.1/removeStudent.php?id=10086        |\n| 修改一个学号为10086的学生的性别 | http://127.0.0.1/updateStudent.php?id=10086&sex=男 |\n| 列出所有学生                    | http://127.0.0.1/allStudent.php                    |\n\n\n\nRESTful风格的路由\n\n| 事儿                            | 处理这个事儿的URL                           |\n| ------------------------------- | ------------------------------------------- |\n| 增加一个学生                    | http://127.0.0.1/student   （POST）         |\n| 删除一个学号为10086的学生       | http://127.0.0.1/student/10086   （DELETE） |\n| 修改一个学号为10086的学生的性别 | http://127.0.0.1/student/10086   （PATCH）  |\n| 列出所有学生                    | http://127.0.0.1/student   （GET）          |\n\n\n\n# 五、做一个RESTful风格路由的TodoList\n\n![](image22.png)\n    \n创建身份证，\n```\nnpm init\n```\n安装依赖\n\n```\ncnpm install --save express formidable\n```\n\n先从做一个模拟数据库开始（事实上，第三节课就要学习MongoDB和mongoose）。\n\n创建db文件夹创建db.js文件：\n\n```json\n[\n\t{\"id\" : 1 , \"title\" : \"吃饭\" , \"done\" : false},\n\t{\"id\" : 2 , \"title\" : \"睡觉\" , \"done\" : true},\n\t{\"id\" : 3 , \"title\" : \"打豆豆\" , \"done\" : false}\n]\n```\n\n创建models文件夹，里面创建todo.js的文件。\n\n-   **[这个js文件暴露所有能够操作db.js数据库文件的函数，所有对db的操作必须找它！]**\n\n-   **[这个js文件不是中间件，和http的服务没有关系，这个文件做的是最脏最累的底层的活儿，看不清楚和全局的关系，这个js文件可以单独的进行单元测试]**。\n\nnodejs中内置了一个叫做path的模块，里面提供了resolve()的函数，可以智能合并\\_\\_dirname和层级路径。\n\n```javascript\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\n//【查】列出所有的todo。结果通过回调函数返回。\nvar allTodo = function(callback){\n\t//path.resolve()表示只能合并路径。\n\tfs.readFile(path.resolve(__dirname , \"../db/db.js\") , function(err , data){\n\t\tcallback(data.toString());\n\t});\n}\n\n//单元测试，测试查询功能：\nallTodo(function(data){\n\tconsole.log(\"哈哈读取啦\" , data);\n});\n```\n\n这个todo.js的全貌：\n\n```javascript\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\n//文件路径\nvar filepath = path.resolve(__dirname , \"../db/db.js\");\n\n//【查】列出所有的todo。结果通过回调函数返回。\nexports.allTodo = function(callback){\n\t//path.resolve()表示只能合并路径。\n\tfs.readFile(filepath , function(err , data){\n\t\tcallback(data.toString());\n\t});\n}\n\n//【增】增加Todo。思路是先读取所有的Todo，往数组中push一项，然后写文件\nexports.addTodo = function(title , callback){\n\t//利用刚刚写好的allTodo函数读取所有todo\n\tallTodo(function(data){\n\t\t//将字符串的数组变为真的数组\n\t\tvar data = JSON.parse(data);\n\t\t//遍历这个数组找最大的ID，为什么要找呢？因为我们的新Todo要为当前最大id+1\n\t\tvar maxid = 1;\n\t\tfor(var i = 0 ; i < data.length ; i++){\n\t\t\tif(data[i].id > maxid){\n\t\t\t\tmaxid = data[i].id;\n\t\t\t}\n\t\t}\n\t\t//将data中push一项\n\t\tdata.push({\"id\" : maxid + 1 , \"title\" : title , \"done\" : false});\n\t\t//写！\n\t\tfs.writeFile(filepath , JSON.stringify(data) , function(){\n\t\t\tcallback();\n\t\t});\n\t});\n}\n\n//【删】思路是读取全部的数组，删除其中一项，然后写入文件\nexports.removeTodo = function(id , callback){\n\t//利用刚刚写好的allTodo函数读取所有todo\n\tallTodo(function(data){\n\t\t//将字符串的数组变为真的数组\n\t\tvar data = JSON.parse(data);\n\t\t//删除这个todo\n\t\tfor(var i = 0 ; i < data.length ; i++){\n\t\t\tif(data[i].id === id){\n\t\t\t\tdata.splice(i , 1);\n\t\t\t}\n\t\t}\n\t\t//写！\n\t\tfs.writeFile(filepath , JSON.stringify(data) , function(){\n\t\t\tcallback();\n\t\t});\n\t});\n}\n\n//【改】思路是读取全部的数组，改变其中一项，写入\n//k可能是title或者是done\nexports.updateTodo = function(id , k , v , callback){\n\t//利用刚刚写好的allTodo函数读取所有todo\n\tallTodo(function(data){\n\t\t//将字符串的数组变为真的数组\n\t\tvar data = JSON.parse(data);\n\t\t//改变这个todo，遍历所有todo看看哪个todo的id和你要改的id是一样的\n\t\tfor(var i = 0 ; i < data.length ; i++){\n\t\t\tif(data[i].id === id){\n\t\t\t\tdata[i][k] = v;\n\t\t\t}\n\t\t}\n\t\t//写！\n\t\tfs.writeFile(filepath , JSON.stringify(data) , function(){\n\t\t\tcallback();\n\t\t});\n\t});\n}\n```\n\n写app.js主文件，主要是静态化www文件夹。\n\n```javascript\nvar express = require(\"express\");\nvar app = express();\n\n//静态化www文件夹\napp.use(express.static(\"www\"));\n\n//监听端口\napp.listen(3000);\n```\n\n\n\n**接口：就是没有界面的数据，通常是JSON或者JSONP形式**。\n\n","categories":["js.NodeJS"]},{"title":"Node.js入门和企业级项目开发01","url":"%2Fposts%2F3057491457%2F","content":"\n\n\n# 前言\n\n> 第1天课堂笔记\n>\n> 讲师：邵山欢\n>\n> 日期：2017年11月2日\n\n\n\n# 一、复习B/S架构\n\n## 1.1 B/S架构图示\n\n![](image2.png)\n\n服务器上运行着一些程序，这些程序是PHP、JSP、ASP、Python、Scala等等，这些语言都是后台语言。\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n> 当用户从浏览器发出HTTP请求（点击了一个超级链接、输入了网址、提交了表单）之后，后台语言就开始执行了。后台语言往往需要根据这个HTTP请求携带的参数，进行不同的、差异化的工作，与数据库通信完毕之后，组件一个页面用HTTP响应发回给浏览器。浏览器解析渲染HTML、CSS和JS脚本。\n\n\n\n## 1.2 集合PHP程序来复习GET请求和POST请求\n\nPHP是一个语言，不能独立运行，必须运行在阿帕奇（Apache）之上。计算机只要安装了这些服务器的软件（比如阿帕奇、IIS、Nginx、Tomcat、glassfish）就能提供HTTP服务，此时计算机就是服务器了。\n\n阿帕奇有一个最大的特点：**就能能够自动根据文件的物理层次映射出URL。**\n\n------------------------------- -------------------------\n| 物理文件的地址                | URL                     |\n| ----------------------------- | ----------------------- |\n| 阿帕奇根目录/index.html       | http://127.0.0.1/       |\n| 阿帕奇根目录/a/index.html     | http://127.0.0.1/a/     |\n| 阿帕奇根目录/a/b/c/index.html | http://127.0.0.1/a/b/c/ |\n\n------------------------------- -------------------------\n\n下面复习一下GET请求和POST请求，我们结合PHP和数据库来做演示案例。\n\n**GET请求的哲学是：问服务器要东西，使用POST请求往往是传给服务器id，希望服务器发回这个id的文章。**\n\n下面就是一个简单的GET请求的PHP程序。\n\n```php+HTML\n<?php\n\t//链接数据库\n\t$conn = mysql_connect(\"localhost\",\"root\",\"123456\");\n\t//选择数据库\n\tmysql_select_db(\"kaolaxinwen\", $conn);\n\t//中文\n\tmysql_query(\"SET NAMES UTF8\");\n\t//得到id\n\t$id = $_GET[\"id\"];\n\t//SQL语句\n\t$sql = \"SELECT * FROM xinwen WHERE id = {$id}\";\n\t//执行SQL语句\n\t$result = mysql_query($sql);\n\t//转变结果的格式\n\t$row = mysql_fetch_array($result);\n?>\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.box{\n\t\t\twidth:1000px;\n\t\t\tmargin: 0 auto;\n\t\t\tbackground-color: skyblue;\n\t\t}\n\t\th1{\n\t\t\ttext-align: center;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"box\">\n\t\t<h1><?php echo $row[\"biaoti\"] ?></h1>\n\t\t<div class=\"content\">\n\t\t\t<?php echo $row[\"neirong\"] ?>\n\t\t</div>\n\t</div>\n</body>\n</html>\n```\n\n效果：\n\n![](image3.png)\n\n查看源代码：\n\n![](image4.png)\n\n**POST请求的哲学是：希望服务器根据我的参数来对数据库进行一些增、删、改的操作。**\n\n比如我们做一个表单页面houtai.html，这个页面中的表单在往tijiao.php中提交内容。tijiao.php负责写入数据库。\n\n![](image5.png)\n\n**GET请求优缺点**：便于分享网址、安全性不强、不能传超长的参数。\n\n**POST请求的优缺点**： 不便于分享网址、安全性强、理论是无限长的参数。\n\n\n\n**总结一下你要会的东西：**\n\n-   HTTP有请求、响应。\n\n-   HTTP请求有GET请求和POST请求的区别，要知道他们的优缺点和哲学。\n\n-   知道PHP是如何和数据库交互的。\n\n-   知道GET请求的参数和POST请求的参数。\n\n服务器上的语言有哪些：PHP、JSP、ASP、Python、Scala等等。\n\n今天，它迎来了Node.js。\n\n\n\n**Node.js将JavaScript的触角伸到了服务器上。Node.js让服务器上可以运行JS！**\n\nJS如今不是做个正则、做个轮播图、做个选项卡的浏览器端的语言了！今天，Node.JS可以让JS处理GET请求、POST请求、可以操作数据库！\n\n\n\n# 二、Node.js的诞生和安装\n\n## 2.1 创始人\n\nRayn Dahl发现：以老牌PHP为例，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。\n\n![](image6.png)\n\n这个哥们就立志要发明一个平台，比PHP、JSP要有更高的性能、并发性。\n\n他将Chrome浏览器的V8引擎（目前世界上最快的JS解析引擎）移植到了服务器上，开发出了Node.js平台。\n\n2009年底，Ryan Dahl在柏林举行的JSConf EU会议上发表关于Node.js的演讲，之后Node.js逐渐流行于世。\n\n**Node.js是一个平台不是一个语言，语言仍然是JavaScript。此时Node.js平台可以让我们用JavaScript语言来开发服务器程序。**\n\n\n\n## 2.2 安装Node.js\n\nnode.js可以安装在windows、mac、linux上（绝大部分的服务器都是linux操作系统）。\n\n语言是一样的，都是JavaScript，所以node.js特别像java虚拟机，大家只需要写一份语言，就可以运行在windows、mac、linux上。\n\nnodejs官网：http://nodejs.org/\n\nnodejs中文网：http://nodejs.cn/\n\n![](image7.png)\n\n下载nodejs：\n\n![](image8.png)\n\nnodejs有稳定版和最新版之分，我们学习的是最新版v8.7.0，今天的稳定版是v6.0.0。\n\n![](image9.png)\n\n双击图标即可进行安装：\n\n| ![img](image10.png) | 正在等待安装                                                 |\n| ------------------- | ------------------------------------------------------------ |\n| ![img](image11.png) | 点击下一步next                                               |\n| ![img](image12.png) | 同意协议，然后下一步                                         |\n| ![img](image13.png) |                                                              |\n| ![img](image14.png) | nodejs的安装包给计算机安装了4个东西。见左图。   不需要我们进行什么操作，直接点击next。 |\n| ![img](image15.png) | 点击Install进行安装。                                        |\n| ![img](image16.png) | 安装成功                                                     |\n\n\n\n我们要检查nodejs是否已经安装成功了。此时需要打开系统的\"命令提示符\"窗口。\n\n| ![img](image17.png) | 按windows徽标键 + R键                                        |\n| ------------------- | ------------------------------------------------------------ |\n| ![img](image18.png) | 输入CMD按回车   CMD就是command命令的缩写。                   |\n| ![img](image19.png) | 然后就能看见这个黑底白字的命令提示符窗口。   我们以后简称“CMD”窗口。 |\n| ![img](image20.png) | 输入node -v   此时就能看见版本号，说明nodejs安装成功了。     |\n\n\n\n## 2.3 什么是环境变量？\n\n任何操作系统（windows、mac、linux）都有环境变量的概念，作用很简单：\n\n**在环境变量中的文件夹里面的所有exe程序都可以被当做系统级别的命令在CMD窗口中被调用。**\n\n对计算机图标点击属性，然后：\n\n![](image21.png)\n\n环境变量是用英语分号隔开的一系列文件夹的路径。比如老师耍宝，将QQ的文件夹添加进去了。\n\n此时再次打开CMD创建，就可以运行QQ命令了：\n\n![](image22.png)\n\n我们的node.js的msi安装包自动的将nodejs的安装目录设置为了环境变量。极大的方便了我们。\n\n因为nodejs的目录在环境变量中，所以我们刚才可以在CMD中运行\n\n`node -v`\n\n\n\n# 三、Node.js的基本使用 - 运行谁就node谁\n\n我们创建今天的案例文件夹，是c盘的node\\_study文件夹，里面创建day1文件夹。\n\n我们先来认知一个事情：**js的运行需要宿主环境。**\n\n\n\n我们创建一个01.js文件：\n\n```javascript\nfor(var i = 0 ; i < 10 ; i++){\n\tconsole.log(i * 2);\n}\n```\n\n这个js文件不能直接拖入浏览器运行，因为没有html宿主环境。\n\n我们必须创建html文件：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<script type=\"text/javascript\" src=\"01.js\"></script>\n</body>\n</html>\n```\n\n浏览这个html文件，此时控制台将有输出。\n\n![](image23.png)\n\nJS需要宿主环境才能运行。截止今日，我们只知道js的一个宿主环境，就是HTML。\n\n今天我们迎来了新的宿主：**nodejs平台！**\n\n\n\n在nodejs平台中运行js文件，此时需要使用CMD窗口。**此时需要将CMD的\"光标路径\"更改为我们的项目文件夹**。\n\n此时使用下面的命令可以切换路径：\n\n```\ncd 路径\n```\n\ncd就是change directory，切换文件夹的意思。\n\n![](image24.png)\n\n我们的口号是：运行谁就node谁\n\n![](image25.png)\n\n告诉大家一个快捷操作：\n\n在项目文件夹中按住shift键的同时，点击鼠标右键，此时就能看见：\n\n![](image26.png)\n\n![](image27.png)\n\n由于nodejs平台没有DOM所以不能使用下面的语法：\n\nwindow、document、alert、document.getElementById()......\n\n但是nodejs能够识别函数、if语句、for、while等等js核心语法：\n\n```javascript\nfor(var i = 0 ; i < 10 ; i++){\n\tconsole.log(haha(i));\n}\n\nfunction haha(a){\n\treturn a * 3;\n}\n```\n\n补充一下：\n\n```\ncls\n```\n\n表示清屏\n\n\n\n# 四、使用Node.js搭建服务器\n\n## 4.1 最简单的demo\n\n我们需要使用nodejs中的内置模块http模块，nodejs中有很多模块，我们最先使用的就是http模块。\n\n```javascript\n//得到内置http模块\nvar http = require(\"http\");\n\n//创建服务器，使用createServer方法来创建服务器。\n//回调函数中有一个req参数表示请求，res参数表示响应。\nvar server = http.createServer(function(req,res){\n\t//输出\n\tres.end(\"Hello NodeJS !!\");\n});\n\n//监听，我们的默认80端口已经被阿帕奇占用了，所以我们监听3000端口。\nserver.listen(3000\n```\n\n先照着写，然后就可以运行这个程序。\n\n![](image28.png)\n\n此时不要关闭CMD窗口！打开浏览器，输入网址：\n\nhttp://127.0.0.1**:3000**/\n\n冒号表示端口号，默认端口是80，但是我们的80被阿帕奇占用了，所以我们就使用3000端口了。\n\n![](image29.png)\n\n如果想要打断服务器的执行，此时在CMD中按ctrl+c键。\n\n![](image30.png)\n\n一旦打断了挂起的CMD，此时浏览器中就崩溃了：\n\n![](image31.png)\n\n**注意：如果改变了js文件，此时刷新浏览器没用，必须重新执行node命令！**\n\n\n\n**两个问题：**\n\n●问题1：\n\n```javascript\nres.end(\"好高兴啊我买了一个iPhone\" + (1+32));\n```\n\n在浏览器中查看源代码，不能看见1+32的运算结果的。这是因为程序运行在服务器上。\n\n\n\n●问题2：\n\n用户的电脑里面没有安装nodejs平台，此时也可以访问nodejs服务器。\n\n因为nodejs运行在服务器上，发给客户端的时候已经变为纯的、平的HTML了！\n\n\n\n**补充：**\n\n● 多条输出用write，但是最后必须有end：\n\n```javascript\nres.write(\"哈哈\");\nres.write(\"哈哈\");\nres.write(\"哈哈\");\nres.write(\"哈哈\");\nres.write(\"哈哈\");\nres.end(\"好高兴啊我买了一个iPhone\" + (4+4));\n```\n\n● res.write()和res.end()中只能是字符串不能是数字：\n\n```javascript\nres.end(123); //错误的\nres.end(\"123\"); //正确的\n```\n\n● 可以结合HTML标签：\n\n```javascript\nres.end(\"<h1>你好，NodeJS我来了</h1>\");\n```\n\n\n\nNode.js中有很多的内置模块，手册就是按模块来列出的API：\n\n![](image32.png)\n\n\n\n## 4.2 使用外置页面\n\n我们现在的目标就是做一个外面的页面public/wangjunkai.html，此时就要使用新的内置模块fs。\n\n**fs模块**最重要的API，就是readFile，可以异步读取文件，第一个参数就是URL，要读取的文件路径（注意：必须以`./`开头，表示从当前js文件出发寻找html文件）。第二个参数是回调函数，表示读取完毕之后做的事情。\n\n```javascript\nfs.readFile(\"./public/wangjunkai.html\" , function(err , data){\n\tres.end(data);  //让res显示文件。\n});\n```\n\n\n\nhttp和fs共同配合完成这个事情：\n\n![](image33.png)\n\n\n\n## 4.3 路由（重点）\n\n上面的案例，不管输入什么URL，都是访问wangjunkai.html页面：\n\n```javascript\nvar server = http.createServer(function(req,res){\n\t//设置UTF8\n\tres.setHeader(\"Content-Type\",\"text/html;charset=UTF8\");\n\t//需要读取文件\n\tfs.readFile(\"./public/wangjunkai.html\" , function(err , data){\n\t\tres.end(data);\n\t});\n});\n```\n\n![](image34.png)\n\n\n\n我们可以利用req.url得到用户输入的URL地址。\n\n```javascript\nvar http = require(\"http\");\nvar fs = require(\"fs\");\n\n//创建一个服务器\nvar server = http.createServer(function(req,res){\n\t//设置UTF8\n\tres.setHeader(\"Content-Type\",\"text/html;charset=UTF8\");\n\t//输出访问的URL地址\n\tif(req.url == \"/mingxing/wjk\"){\n\t\t//需要读取文件\n\t\tfs.readFile(\"./public/wangjunkai.html\" , function(err , data){\n\t\t\tres.end(data);\n\t\t});\n\t}else if(req.url == \"/shuaige/lh\"){\n\t\t//需要读取文件\n\t\tfs.readFile(\"./public/luhan.html\" , function(err , data){\n\t\t\tres.end(data);\n\t\t});\n\t}else{\n\t\tres.end(\"没有这个页面！\");\n\t}\n});\n\n//监听\nserver.listen(3000);\n```\n\n\n\n**顶层路由设计：**\n\n-   物理文件的层次和URL是没有关系的！\n\n-   Node.js可以做顶层路由设计！一个页面想叫什么URL就可以叫做什么URL！\n\n-   用户输入的URL可以被路由映射为任何HTML页面！\n\n![](image35.png)\n\n\n\n现在的时代主流，有意义的URL非常的重要。比如知乎的URL：\n\n| URL                                                 | 用途                 |\n| --------------------------------------------------- | -------------------- |\n| https://www.zhihu.com/people/albanybear/activities  | albanybear用户的活动 |\n| https://www.zhihu.com/people/albanybear/answers     | albanybear用户的回答 |\n| https://www.zhihu.com/people/albanybear/asks        | albanybear用户的提问 |\n| https://www.zhihu.com/people/albanybear/posts       | albanybear用户的文章 |\n| https://www.zhihu.com/people/albanybear/columns     | albanybear用户的专栏 |\n| https://www.zhihu.com/people/albanybear/pins        | albanybear用户的想法 |\n| https://www.zhihu.com/people/albanybear/collections | albanybear用户的收藏 |\n\n老一代的路由：\n\nhttp://www.zhihu.com/tiwen.php?username=albanybear\n\nhttp://www.zhihu.com/answers.php?username=albanybear\n\n\n\n我们现在可以模拟知乎的路由，首先先复习正则表达式的知识：\n\n![](image36.png)\n\n代码：\n\n```javascript\nvar server = http.createServer(function(req,res){\n\t//设置UTF8\n\tres.setHeader(\"Content-Type\",\"text/html;charset=UTF8\");\n\n\t//得到用户的url\n\tvar url = req.url;\n\t//用正则拆\n\tvar arr = url.match(/\\/user\\/(.+)\\/(.+)$/);\n\n\t//验证是否提炼成为了数组\n\tif(!arr){\n\t\tres.end(\"<h1>没有这个网址</h1>\");\n\t\treturn;\n\t}\n\n\t//得到$1，就是正则中的第一个()\n\tvar $1 = arr[1];\n\t//得到$2，就是正则中的第二个()\n\tvar $2 = arr[2];\n\n\t\n\t//模拟数据库\n\tvar users = {\n\t\t\"wangjunkai\" : \"王俊凯\" ,\n\t\t\"liyifeng\" : \"李易峰\",\n\t\t\"luhan\" : \"鹿晗\",\n\t\t\"wuyifan\" : \"吴亦凡\"\n\t};\n\n\tvar list = {\n\t\t\"post\" : \"文章\",\n\t\t\"ask\" : \"提问\",\n\t\t\"answers\" : \"回答\",\n\t\t\"pins\" : \"想法\"\n\t};\n\n\tres.end(\"<h1>欢迎查看\" + users[$1] + \"的\" + list[$2] + \"</h1>\");\n});\n```\n\n我们就模拟出了知乎的路由设计：\n\n![](image37.png)\n\n现在我们就**不能**认为根目录下有一个user文件夹，然后有luhan文件夹，然后有answers文件夹。\n\n\n\n## 4.4 顶层路由设计有不方便的地方\n\n我们刚才通过案例知道了顶层路由设计的方便之处，URL非常的规整，类似知乎的路由。\n\n但是不方便的地方就是一些静态文件：图片、样式表等等。此时都需要一个一个开路由。\n\n比如页面上插入一个图片：\n\n```htl\n<img src=\"wangjunkai.png\" alt=\"\"\n```\n\n此时就要专门给这个图片开路由：\n\n```javascript\n……\nelse if(req.url == \"/mingxing/wangjunkai.png\"){\n\t//设置UTF8\n\tres.setHeader(\"Content-Type\",\"image/png\");\n\t//需要读取文件\n\tfs.readFile(\"./public/wangjunkai.png\" , function(err , data){\n\t\tres.end(data);\n\t});\n}else if(req.url == \"/mingxing/goupi.css\"){\n\t//设置UTF8\n\tres.setHeader(\"Content-Type\",\"text/css\");\n\t//需要读取文件\n\tfs.readFile(\"./public/css.css\" , function(err , data){\n\t\tres.end(data);\n\t});\n}\n……\n```\n\n**理论上：如果页面上有100个图片，此时就要开100个路由。**\n\n我们明天将会在express中介绍将一个文件夹\"静态化\"。就是指这个文件夹中的文件将自动拥有URL路由。\n\n\n\n# 五、模块（重点）\n\n## 5.1 HTML宿主环境中的多js文件\n\nHTML宿主环境中，多个js文件共用一个html宿主，所以它们之间的**作用域是打通的**。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<script type=\"text/javascript\" src=\"1.js\"></script>  → 这里面var a = 100;\n\t<script type=\"text/javascript\" src=\"2.js\"></script>  → 能够alert(a);\n</body>\n</html>\n```\n\n因为1.js文件中定义的**a是全局变量就是window的属性**，2.js文件中当然共用window对象。\n\nnodejs是如何处理多个js文件的？多个js文件如何搭配工作，是后面40分钟的内容。\n\n\n\n## 5.2 require谁就会运行谁\n\n```\n┣ app.js\n┣ a.js\n```\n\napp.js:\n\n```javascript\nrequire(\"./a.js\");\nconsole.log(\"我是app.js\");\n```\n\na.js:\n\n```javascript\nconsole.log(\"你好我是a.js\");\n```\n\n现在node app.js\n\n![](image38.png)\n\n**在nodejs中，可以js文件中require（引用）另一个js文件，此时就会立即运行那个引用的js文件**。\n\napp.js可以require a.js文件，a.js文件也可以require b.js文件。\n\n\n\n## 5.3 js文件在Node.js中天生作用域隔离\n\n```\n┣ app.js\n┣ a.js\n```\n\n在a.js文件中定义了所谓的\"全局\"m，然后app.js文件引用a.js之后，尝试显示m变量。\n\napp.js:\n\n```javascript\nrequire(\"./a.js\");\nconsole.log(m);\n```\n\na.js：\n\n```javascript\nvar m = 100;  //尝试定义全局变量\n```\n\n此时node app.js报错了。\n\n![](image39.png)\n\n**js文件在Node.js中天生作用域隔离的！为什么？**\n\n**因为没有了window对象。**\n\n\n\n## 5.4 使用`exports.** = ** `的语法进行暴露\n\n```\n┣ app.js\n┣ a.js\n```\n\na.js文件中定义了m值，并且进行了暴露。\n\n```javascript\nvar m = 100;\nexports.m = m;\n```\n\n在app.js文件中：\n\n```javascript\nvar a = require(\"./a.js\");\nconsole.log(a.m);\n```\n\n\n\n**需要注意的是两点：**\n\n① 建议：暴露的时候必须是`exports.** = ** `， \\*\\*必须一致。你别玩杂技。\n\n明明变量是m你非要用n暴露。\n\n```javascript\n//错误的：\nvar m = 100;\nexports.n = m;\n```\n\n虽然语法没有问题，但是成熟程序员不会这样玩儿。\n\n② 建议：接收的时候，文件名是什么，就用什么接收。你别玩杂技。\n\n```javascript\n//正确的：\nvar a = require(\"./a.js\");\nconsole.log(a.m);\n\n//错误的：\nvar b = require(\"./a.js\");\nconsole.log(a.m);\n```\n\nnodejs在运行的时候，接受的那个变量（a）会自动成为exports对象。\n\n`exports.** = **`的写法天生有namespace（命名空间）\n\n```\n┣ app.js\n┣ yuan.js\n┣ juxing.js\n```\n\nyuan.js和juxing.js文件里面都定义了mianji和zhouchang函数，但是引入的时候由于又命名空间，所以不乱套。\n\n```javascript\nvar yuan = require(\"./yuan.js\");\nvar juxing = require(\"./juxing.js\");\n\nconsole.log(yuan.mianji(15));\nconsole.log(yuan.zhouchang(15));\nconsole.log(juxing.mianji(10,12));\nconsole.log(juxing.zhouchang(10,12));\n```\n\n![](image40.png)\n\n\n\n## 5.5 使用`module.exports = ** `暴露\n\n当一个js文件中仅仅希望暴露一个东西（通常是构造函数），此时我们可以使用`module.exports = ** `的方法暴露。\n\n```\n┣ app.js\n┣ People.js\n```\n\nPeople.js:\n\n```javascript\nfunction People(name,age,sex){\n\tthis.name = name;\n\tthis.age = age;\n\tthis.sex = sex;\n}\nPeople.prototype.sayHello = function(){\n\tconsole.log(\"你好我是\" + this.name);\n}\n\nmodule.exports = People\n```\n\napp.js:\n\n```javascript\nvar People = require(\"./People.js\");\n\nvar xiaoming = new People(\"小明\" , 12 , \"男\");\nxiaoming.sayHello();\n```\n\n\n\n如果仍然使用exports.People = People的方法暴露，此时就势必要：\n\n```javascript\nvar xiaoming = new People.People(\"小明\" , 12 , \"男\");\n```\n\n\n\n**总结一下：**\n\n● 如果一个js文件中有多个东西要暴露（通常是暴露一些相关的函数比如面积、周长），此时用`exports.** = **`暴露。\n\n● 如果一个js文件中只暴露一个文件（通常是构造函数），此时用`module.exports = **; `暴露。\n\n\n\n## 5.6 使用文件夹\n\n```\n┣ app.js\n┣ jihe\n┃ ┣ yuan.js\n┃ ┣ juxing.js\n┃ ┣ index.js\n```\n\n我们将yuan.js和juxing.js放入了一个叫做jihe的文件夹中，被index.js\"统领\"。\n\n此时我们先看jihe/index.js:\n\n```javascript\nvar juxing = require(\"./juxing.js\");\nvar yuan = require(\"./yuan.js\");\n\nexports.juxing = juxing;\nexports.yuan = yuan;\n```\n\n这个文件很性感，接受之后什么都不调用直接暴露。这个文件的作用就是一个小中转器，是一个小统领。\n\n此时yuan.js、juxing.js的文件内容和5.4一致，不再写了。\n\napp.js\n\n```javascript\nvar jihe = require(\"./jihe\");\n\nconsole.log(jihe.yuan.mianji(10));\nconsole.log(jihe.juxing.zhouchang(10,19));\n```\n\n需要注意，当我们require()的时候，如果没有写.js后缀，此时nodejs将认为我们在引入一个文件夹，此时将会自动引入这个文件夹中的index.js文件。\n\n也就是说\n\n```javascript\nvar jihe = require(\"./jihe\");\n```\n\n等价于：\n\n```javascript\nvar jihe = require(\"./jihe/index.js\")\n```\n\n注意`./`不能省！！\n\n\n\n## 5.7 神奇的node\\_modules文件夹\n\n**nodejs中有一个设置，就是如果js的文件夹放入了node\\_modules文件夹中，此时引用它的将可以不写`./`**。\n\n```\n┣ app.js\n┣ node_modules\n┃  ┣ jihe\n┃  ┃  ┣ yuan.js\n┃  ┃  ┣ juxing.js\n┃  ┃  ┣ index.js\n```\n\njihe文件夹中的内容和5.6小节一样的，不写了。\n\napp.js引用jihe.js文件的时候，此时require的特别漂亮！\n\n```javascript\nvar jihe = require(\"jihe\");\n\nconsole.log(jihe.yuan.mianji(10));\nconsole.log(jihe.juxing.zhouchang(10,19));\n```\n\n也就是说：\n\n\n| require的形式     | 引用的谁                                      |\n| ----------------- | --------------------------------------------- |\n| require(\"./a.js\") | 同目录的a.js文件                              |\n| require(\"./a\")    | a文件夹中的index.js文件                       |\n| require(\"a\")      | node_modules文件夹中的a文件夹中的index.js文件 |\n| require(\"a.js\")   | node_modules文件夹中的a.js                    |\n\n\n\n## 5.8 模块的概念\n\n当一个js文件可以独立完成一个事情，这个js文件就是一个模块。\n\n当一些js文件共同配合完成一个事情，这些js文件就是一个模块。\n\n模块（module，不是model模型）是一个文件的功能性的、组织性的概念，不是物理性的概念。\n\njuxing.js是一个模块，因为它可以独立完成关于矩形的所有计算。\n\nyuan.js也是一个模块，因为它可以独立完成关于圆形的所有计算。\n\n他们结合在一起，成为jihe文件夹，jihe又称一个新模块。\n\n\n\n# 六、npm的世界\n\n## 6.1 npm install命令\n\n这是一个模块的分享社区，我们可以免费的、自由的使用别人的模块。\n\n而别人的模块，很可能也在使用其他人的模块。每个人都站在巨人的肩膀上，这个世界变得更简单，轮子不需要重复的造，我们只专注于造汽车。\n\n比如有一天，老板让你实现当用户输入网址\n\nhttp://127.0.0.1:3000/12321\n\n的时候，页面显示一二三二一。或者一万两千三百二十一元。\n\n此时你会路由的知识，但是不知道如何进行阿拉伯数字和汉语的转换。\n\n找模块！找巨人！npm就是这样的社区，npm就是node package manager的意思。\n\nnode包管理器。\n\n官网：https://www.npmjs.com/\n\n> npm is the package manager for JavaScript and the world's largest software registry. Discover packages of reusable code --- and assemble them in powerful new ways.\n>\n> npm是JavaScript的包管理器，是世界上最大的软件托管仓库。浏览这些包，这些包都是可服用的代码。组合他们开发出你自己的新的东西！\n\n输入大写，按回车：\n\n![](image41.png)\n\n我们发现了一个叫做nzh的一个包，网址：https://www.npmjs.com/package/nzh\n\n此时我们想要下载这个叫做nzh的包，此时我们使用CMD命令：\n\n```\nnpm install nzh\n```\n\n\n\nnpm包管理器随着nodejs安装而安装了。所以我们已经可以使用npm了。\n\n注意要使用npm的时候，必须联网。\n\n当我们输入`npm install nzh`之后，此时项目文件夹中就自动多了`node\\_modules`文件夹。\n\n![](image42.png)\n\nnode\\_modules文件夹中就有了nzh文件夹！这是一个模块！\n\n![](image43.png)\n\n此时通过查看API我们可以写出app.js文件了：\n\n```javascript\nvar nzh = require(\"nzh\");\nvar nzhcn = nzh.cn; \nconsole.log(nzhcn.toMoney(12321))\n```\n\n也就是说别人开发的nzh这个包现在就被我们自己使用了！\n\n这里说一嘴，所有的API的路径都是\n\n```\nhttps://www.npmjs.com/package/包名字\n```\n\n\n\n老板新需求：让你把1997年5月8日变为农历。\n\n![](image44.png)\n\n参考API，此时就能写出自己的程序：\n\n```javascript\nvar solarLunar = require(\"solarlunar\")\n\n//API看来的\nvar obj = solarLunar.solar2lunar(1997, 5, 8);\nconsole.log(obj.gzYear + obj.gzMonth + obj.gzDay);\n```\n\n\n\n老板新需求：将一个数组变为excel表格。\n\n此时我们下载node-xlsx这个包，此时你会发现依赖的依赖也会被同时下载。\n\n```\nnpm install node-xlsx\n```\n\n结合API我们写：\n\n```javascript\nvar xlsx = require(\"node-xlsx\");\nvar fs = require(\"fs\");\n\n//API看来的\nvar data = [[\"国家\",\"人口\",\"GDP\"],[\"中国\",13,200],[\"印度\",15,1],[\"日本\",1,0.08]];\nvar buffer = xlsx.build([{name: \"各国数据\", data: data}]);  \nfs.writeFile(\"./老板请您简约.xlsx\" , buffer);\n```\n\n\n\n## 6.2 依赖\n\n我们从npm上下载的node\\_modules文件夹称之为依赖。\n\n此时我们可以用package.json文件管理这些依赖，我们称为项目的\"身份证\"。\n\n我们在开发项目的时候，第一步就是创建一个项目的身份证。\n\n```\nnpm init\n```\n\n![](image45.png)\n\n就会显示一个调查问卷。将引导你创建这个身份证。\n\n![](image46.png)\n\n他会询问你包名字、版本、描述、入口文件、测试命令、git网址、关键词、作者、版权协议。\n\n你回答一下，系统会猜测一些答案就是括号中的内容，直接按回车就是使用它。\n\n系统会创建这个文件：\n\n![](image47.png)\n\n内容：\n\n```json\n{\n  \"name\": \"day1\",\n  \"version\": \"0.0.1\",\n  \"description\": \"这是考拉老师的一个案例\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [\n    \"考拉\",\n    \"牛逼\",\n    \"爱前端\"\n  ],\n  \"author\": \"考拉\",\n  \"license\": \"MIT\"\n}\n```\n\n\n\n今后安装依赖的时候要加上\\--save后缀，比如：\n\n```\nnpm install nzh --save\n```\n\n此时加上`--save`之后，我们身份证会自动更新一个依赖项：\n\n```json\n{\n  \"name\": \"day1\",\n  \"version\": \"0.0.1\",\n  \"description\": \"这是考拉老师的一个案例\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [\n    \"考拉\",\n    \"牛逼\",\n    \"爱前端\"\n  ],\n  \"author\": \"考拉\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"node-xlsx\": \"^0.11.0\",\n    \"nzh\": \"^1.0.1\",\n    \"solarlunar\": \"^2.0.1\"\n  }\n}\n```\n\n\n\n**有了这个有什么好处呢？？**\n\n此时我们的项目拷贝给别人的时候、做版本管理的时候，可以完全忽略node\\_modules文件夹！\n\n因为我们任何使用可以使用\n\n```\nnpm install\n```\n\n来安装项目的所有依赖。\n\n","categories":["js.NodeJS"]},{"title":"【转载】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析","url":"%2Fposts%2F1353166163%2F","content":"\n\n\n### 前言\n\n> **原作者：** TDsimon\n>\n> **转载来源：** <https://www.simon96.online/2018/10/12/hexo-tutorial/>\n>\n> **版权声明：** 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议。转载请注明出处！\n\n\n\n### 博客搭建\n\n#### 准备环境\n\n1. [Node.js](http://nodejs.org/) 下载，并安装。详细步骤：<https://www.simon96.online/2018/11/10/hexo-env/>\n\n2. [Git](http://git-scm.com/) 下载，并安装。详细步骤：<https://www.simon96.online/2018/11/10/hexo-env/>\n\n3. 安装Hexo，在命令行（即Git Bash）运行以下命令：\n\n   > npm install -g hexo-cli\n\n4. 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可：\n\n   以下，即存放Hexo初始化文件的路径， 即站点目录。\n\n   ```\n   $ hexo init <folder>\n   $ cd <folder>\n   $ npm install\n   ```\n\n   新建完成后，在路径下，会产生这些文件和文件夹：\n\n   ```\n   .\n   ├── _config.yml\n   ├── package.json\n   ├── scaffolds\n   ├── source\n   |   ├── _drafts\n   |   └── _posts\n   └── themes\n   ```\n\n   **注**：\n\n   * hexo相关命令均在**站点目录**下，用**Git Bash**运行。\n\n   * 站点配置文件：站点目录下的`_config.yml`。\n\n      路径为`<folder>\\_config.yml`\n\n   * 主题配置文件：站点目录下的`themes`文件夹下的，主题文件夹下的`_config.yml`。\n\n      路径为`<folder>\\themes\\<主题文件夹>\\_config.yml`\n\n5. 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可：\n\n   > hexo server\n\n6. 浏览器访问网址： `http://localhost:4000/`\n\n至此，您的Hexo博客已经搭建在本地。\n\n\n\n#### 实施方案\n\n##### 方案一：GithubPages\n\n1. 创建[Github](https://github.com/)账号\n\n2. 创建仓库， 仓库名为：<Github账号名称>.github.io\n\n3. 将本地Hexo博客推送到GithubPages\n\n   3.1. 安装`hexo-deployer-git`插件。在命令行（即Git Bash）运行以下命令即可：\n\n   ```\n   $ npm install hexo-deployer-git --save\n   ```\n\n   3.2. 添加SSH key。\n\n   * 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可：\n\n     ```\n     $ ssh-keygen -t rsa -C \"邮箱地址\"\n     ```\n\n   * 添加到 github。 复制密钥文件内容（路径形如`C:\\Users\\Administrator\\.ssh\\id_rsa.pub`），粘贴到[New SSH Key](https://github.com/settings/keys)即可。\n\n   * 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功：\n\n     ```\n     $ ssh -T git@github.com\n     $ yes\n     ```\n\n   3.3. 修改`_config.yml`（在站点目录下）。文件末尾修改为：\n\n   ```\n   # Deployment\n   ## Docs: https://hexo.io/docs/deployment.html\n   deploy:\n     type: git\n     repo: git@github.com:<Github账号名称>/<Github账号名称>.github.io.git\n     branch: master\n   ```\n\n   注意：上面仓库地址写ssh地址，不写http地址。\n\n   3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回`INFO Deploy done: git`即成功推送：\n\n   ```\n   $ hexo g\n   $ hexo d\n   ```\n\n4. 等待1分钟左右，浏览器访问网址： `https://<Github账号名称>.github.io`\n\n至此，您的Hexo博客已经搭建在GithubPages, 域名为`https://<Github账号名称>.github.io`。\n\n##### 方案二：GithubPages + 域名\n\n在方案一的基础上，添加自定义域名（您购买的域名）。\n\n1. 域名解析。\n\n   类型选择为 CNAME；\n\n   主机记录即域名前缀，填写为www；\n\n   记录值填写为自定义域名；\n\n   解析线路，TTL 默认即可。\n\n2. 仓库设置。\n\n   2.1. 打开博客仓库设置：`https://github.com/<Github账号名称>/<Github账号名称>.github.io/settings`\n\n   2.2. 在Custom domain下，填写自定义域名，点击`save`。\n\n   2.3. 在站点目录的`source`文件夹下，创建并打开`CNAME.txt`，写入你的域名（如`www.simon96.online`），保存，并重命名为`CNAME`。\n\n3. 等待10分钟左右。\n\n   浏览器访问自定义域名。\n\n   至此，您的Hexo博客已经解析到自定义域名，`https://<Github账号名称>.github.io`依然可用。\n\n##### 方案三：GithubPages + CodingPages + 域名\n\nGithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。\n\n1. 创建[Coding](https://coding.net/)账号\n\n2. 创建仓库， 仓库名为：<Coding账号名称>\n\n3. 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。\n\n4. 将本地Hexo博客推送到CodingPages\n\n   4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如`C:\\Users\\Administrator\\.ssh\\id_rsa.pub`）， 粘贴到[新增公钥](https://dev.tencent.com/user/account/setting/keys)。\n\n   4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功：\n\n   ```\n   $ ssh -T git@git.coding.net\n   $ yes\n   ```\n\n   4.3. 修改`_config.yml`（在存放Hexo初始化文件的路径下）。文件末尾修改为：\n\n   ```\n   # Deployment\n   ## Docs: https://hexo.io/docs/deployment.html\n   deploy:\n   - type: git\n     repo: git@github.com:<Github账号名称>/<Github账号名称>.github.io.git\n     branch: master\n   - type: git\n     repo: git@git.dev.tencent.com:<Coding账号名称>/<Coding账号名称>.git\n     branch: master\n   ```\n\n   4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回`INFO Deploy done: git`即成功推送：\n\n   ```\n   $ hexo g\n   $ hexo d\n   ```\n\n5. 域名解析\n\n   1. 添加 CNAME 记录指向 <Coding账号名称>.coding.me\n\n      类型选择为 CNAME；\n\n      主机记录即域名前缀，填写为www；\n\n      记录值填写为自定义域名；\n\n      解析线路，TTL 默认即可。\n\n   2. 添加 两条A 记录指向 192.30.252.153和192.30.252.154\n\n      类型选择为 A；\n\n      主机记录即域名前缀，填写为@；\n\n      记录值填写为192.30.252.153和192.30.252.154；\n\n      解析线路，境外或谷歌。\n\n   3. 在『Pages 服务』设置页（`https://dev.tencent.com/u/<Coding账号名称>/p/<Coding账号名称>/git/pages/settings`）中绑定自定义域名。\n\n至此，您的Hexo博客已经解析到自定义域名，`https://<Github账号名称>.github.io`和`https://<Coding账号名称>.coding.me`依然可用。\n\n##### 方案四：云服务器 + 域名\n\n该方案需要先购买云服务器和域名。\n\n1. 在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。)\n\n   登陆root用户，运行：\n\n   ```\n   $ yum -y update\n   $ yum install -y git nginx\n   ```\n\n2. Nginx配置\n\n   2.1. 创建文件目录(用于博客站点文件存放)\n\n   ```\n   cd /usr/local/\n   mkdir hexo\n   chmod 775 -R /usr/local/hexo/\n   ```\n\n   2.2. 添加 index.html(用于检测配置 Nginx 是否成功)\n\n   ```\n   vim /usr/local/hexo/index.html\n   ```\n\n   添加以下代码，并保存。\n\n   ```\n   <!DOCTYPE html>\n   <html>\n     <head>\n       <title></title>\n       <meta charset=\"UTF-8\">\n     </head>\n     <body>\n       <p>Nginx running</p>\n     </body>\n   </html>\n   ```\n\n   2.3. 配置 Nginx 服务器\n\n   ```\n   vim /etc/nginx/nginx.conf\n   ```\n\n   修改server_name和root：\n\n   ```\n   server {\n         listen       80 default_server;\n         listen       [::]:80 default_server;\n         server_name  www.baidu.com; # 填个人域名      \n         root         /usr/local/hexo/;\n     }\n   ```\n\n   2.4. 启动nginx服务；\n\n   ```\n   service nginx start\n   ```\n\n   2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。\n\n3. git配置\n\n   3.1. 创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。\n\n   ```\n   cd /usr/local/\n   mkdir hexoRepo\n   chmod 775 -R /usr/local/hexoRepo/\n   ```\n\n   3.2. Git 初始化裸库。\n\n   ```\n   cd hexoRepo/\n   git init --bare hexo.git\n   ```\n\n   3.3. 创建 Git 钩子(hook)。\n\n   ```\n   vim /usr/local/hexoRepo/hexo.git/hooks/post-receive\n   ```\n\n   3.4. 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。\n\n   ```\n   #!/bin/bash\n   \n   git --work-tree=/usr/local/hexo --git-dir=/usr/local/hexoRepo/hexo.git checkout -f\n   ```\n\n   3.5. 保存并退出后, 给该文件添加可执行权限。\n\n   ```\n   chmod +x /usr/local/hexoRepo/hexo.git/hooks/post-receive\n   ```\n\n4. 本地博客推送到云服务器\n\n   4.1. 安装`hexo-deployer-git`插件。在命令行（即Git Bash）运行以下命令即可：\n\n   ```\n   $ npm install hexo-deployer-git --save\n   ```\n\n   4.2. 添加SSH key。\n\n   * 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可：\n\n     ```\n     $ ssh-keygen -t rsa -C \"邮箱地址\"\n     ```\n\n   * 添加到 github。 复制密钥文件内容（路径形如`C:\\Users\\Administrator\\.ssh\\id_rsa.pub`），粘贴到[New SSH Key](https://github.com/settings/keys)即可。\n\n   * 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功：\n\n     ```\n     $ ssh -T git@github.com\n     $ yes\n     ```\n\n   4.3. 修改`_config.yml`（在站点目录下）。文件末尾修改为：\n\n   ```\n   # Deployment\n   ## Docs: https://hexo.io/docs/deployment.html\n   deploy:\n     type: git\n     repo: root@xxx.xxx.xxx.xxx:/usr/local/hexoRepo/hexo  //用户名@域名或 IP 地址:/usr/local/hexoRepo/hexo\n     branch: master\n   ```\n\n   注意：上面仓库地址写ssh地址，不写http地址。\n\n   4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回`INFO Deploy done: git`即成功推送：\n\n   ```\n   $ hexo g\n   $ hexo d\n   ```\n\n5. 等待1分钟左右，浏览器访问个人域名。\n\n   至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。\n\n\n\n### 主题优化\n\n#### 选择主题\n\nHexo默认的主题是landscape，推荐以下主题：\n\n1. [snippet](https://github.com/shenliyang/hexo-theme-snippet#hexo-theme-snippet)\n2. [Hiero](https://github.com/iTimeTraveler/hexo-theme-hiero#hiero)\n3. [JSimple](https://github.com/tangkunyin/hexo-theme-jsimple#jsimple)\n4. [BlueLake](https://github.com/chaooo/hexo-theme-BlueLake#bluelake)\n\n\n\n#### 应用主题\n\n1. 下载主题\n2. 将下载好的主题文件夹，粘贴到站点目录的`themes`下。\n3. 更改站点配置文件`_config.yml` 的theme字段，为主题文件夹的名称：\n\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: <主题文件夹的名称>\n```\n\n\n\n#### 主题优化\n\n以上主题都有比较详细的说明文档，本节主要解决主题优化的常见问题。\n\n主题优化一般包括：\n\n* **设置「RSS」**\n\n* **添加「标签」页面**\n\n* **添加「分类」页面**\n\n* **设置「字体」**\n\n  问题：引用国外字体镜像较慢。\n\n  解决：可以改用国内的。将\\themes\\*\\layout_partials\\head external-fonts.swig文件中fonts.google.com改成fonts.lug.ustc.edu.cn。\n\n* **设置「代码高亮主题」**\n\n* **侧边栏社交链接**\n\n  问题：图标哪里找？\n\n  解决：[Font Awesome](https://fontawesome.com/icons?d=gallery)\n\n* **开启打赏功能**\n\n  问题：微信支付宝二维码不美观，规格不一。\n\n  解决：[在线生成二维码](https://cli.im/weixin)\n\n* **设置友情链接**\n\n* **腾讯公益404页面**\n\n* **站点建立时间**\n\n* **订阅微信公众号**\n\n* **设置「动画效果」**\n\n  问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。\n  解决：将主题配置文件`_config.yml`中，use_motion字段的值设为 `false` 来关闭动画。\n\n* **设置「背景动画」**\n\n\n\n主题优化还包括：\n\n##### 添加背景图\n\n在 themes/*/source/css/_custom/custom.styl 中添加如下代码：\n\n```\nbody{\n    background:url(/images/bg.jpg);\n    background-size:cover;\n    background-repeat:no-repeat;\n    background-attachment:fixed;\n    background-position:center;\n}\n```\n\n##### 修改Logo字体\n\n在 `themes/*/source/css/_custom/custom.styl` 中添加如下代码：\n\n```\n@font-face {\n    font-family: Zitiming;\n    src: url('/fonts/Zitiming.ttf');\n}\n.site-title {\n    font-size: 40px !important;\n\tfont-family: 'Zitiming' !important;\n}\n```\n\n其中字体文件在 `themes/next/source/fonts` 目录下，里面有个 `.gitkeep` 的隐藏文件，打开写入你要保留的字体文件，比如我的是就是写入 `Zitiming.ttf` ，具体字库自己从网上下载即可。\n\n##### 修改内容区域的宽度\n\n编辑主题的 `source/css/_variables/custom.styl` 文件，新增变量：\n\n```\n// 修改成你期望的宽度\n$content-desktop = 700px\n\n// 当视窗超过 1600px 后的宽度\n$content-desktop-large = 900px\n```\n\n##### 网站标题栏背景颜色\n\n```\n.site-meta {\n  background: $blue; //修改为自己喜欢的颜色\n}\n```\n\n##### 自定义鼠标样式\n\n打开 `themes/*/source/css/_custom/custom.styl` ,在里面写下如下代码：\n\n```\n// 鼠标样式\n  * {\n      cursor: url(\"http://om8u46rmb.bkt.clouddn.com/sword2.ico\"),auto!important\n  }\n  :active {\n      cursor: url(\"http://om8u46rmb.bkt.clouddn.com/sword1.ico\"),auto!important\n  }\n```\n\n##### 文章加密访问\n\n打开 `themes/*/layout/_partials/head.swig`文件,在 ``之前插入代码：\n\n```\n<script>\n    (function(){\n        if('{{ page.password }}'){\n            if (prompt('请输入密码') !== '{{ page.password }}'){\n                alert('密码错误');\n                history.back();\n            }\n        }\n    })();\n</script>\n```\n\n写文章时加上`password: *`：\n\n```\n---\ntitle: 2018\ndate: 2018-10-25 16:10:03\npassword: 123456\n---\n```\n\n##### 实现点击出现桃心效果\n\n1. 在`/themes/*/source/js/src`下新建文件`click.js`，接着把以下粘贴到`click.js`文件中。\n   代码如下：\n\n```\n!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e<d.length;e++)d[e].alpha<=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&&e.onclick;e.onclick=function(e){t&&t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);\n```\n\n1. 在`\\themes\\*\\layout\\_layout.swig`文件末尾添加：\n\n```\n<!-- 页面点击小红心 -->\n<script type=\"text/javascript\" src=\"/js/src/clicklove.js\"></script>\n```\n\n##### 静态资源压缩\n\n在站点目录下：\n\n```\n$ npm install gulp -g\n```\n\n安装gulp插件：\n\n```\nnpm install gulp-minify-css --save\nnpm install gulp-uglify --save\nnpm install gulp-htmlmin --save\nnpm install gulp-htmlclean --save\nnpm install gulp-imagemin --save\n```\n\n在 `Hexo` 站点下新建 `gulpfile.js`文件，文件内容如下：\n\n```\nvar gulp = require('gulp');\nvar minifycss = require('gulp-minify-css');\nvar uglify = require('gulp-uglify');\nvar htmlmin = require('gulp-htmlmin');\nvar htmlclean = require('gulp-htmlclean');\nvar imagemin = require('gulp-imagemin');\n// 压缩css文件\ngulp.task('minify-css', function() {\n  return gulp.src('./public/**/*.css')\n  .pipe(minifycss())\n  .pipe(gulp.dest('./public'));\n});\n// 压缩html文件\ngulp.task('minify-html', function() {\n  return gulp.src('./public/**/*.html')\n  .pipe(htmlclean())\n  .pipe(htmlmin({\n    removeComments: true,\n    minifyJS: true,\n    minifyCSS: true,\n    minifyURLs: true,\n  }))\n  .pipe(gulp.dest('./public'))\n});\n// 压缩js文件\ngulp.task('minify-js', function() {\n    return gulp.src(['./public/**/.js','!./public/js/**/*min.js'])\n        .pipe(uglify())\n        .pipe(gulp.dest('./public'));\n});\n// 压缩 public/demo 目录内图片\ngulp.task('minify-images', function() {\n    gulp.src('./public/demo/**/*.*')\n        .pipe(imagemin({\n           optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）\n           progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片\n           interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染\n           multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化\n        }))\n        .pipe(gulp.dest('./public/uploads'));\n});\n// 默认任务\ngulp.task('default', [\n  'minify-html','minify-css','minify-js','minify-images'\n]);\n```\n\n只需要每次在执行 `generate` 命令后执行 `gulp` 就可以实现对静态资源的压缩，压缩完成后执行 `deploy` 命令同步到服务器：\n\n```\nhexo g\ngulp\nhexo d\n```\n\n##### 修改访问URL路径\n\n默认情况下访问URL路径为：`domain/2018/10/18/关于本站`,修改为 `domain/About/关于本站`。 编辑 `Hexo` 站点下的 `_config.yml` 文件，修改其中的 `permalink`字段：\n\n```\npermalink: :category/:title/\n```\n\n##### 博文置顶\n\n1. 安装插件\n\n   ```\n   $ npm uninstall hexo-generator-index –save\n   $ npm install hexo-generator-index-pin-top –save\n   ```\n\n   然后在需要置顶的文章的Front-matter中加上top即可：\n\n   ```\n   ---\n   title: 2018\n   date: 2018-10-25 16:10:03\n   top: 10\n   ---\n   ```\n\n2. 设置置顶标志\n\n   打开：/themes/*/layout/_macro/post.swig，定位到`<div class=\"post-meta\">`标签下，在此便签下行，插入如下代码：\n\n   ```yaml\n   {% if post.top %}\n     <i class=\"fa fa-thumb-tack\"></i>\n     <font color=7D26CD>置顶</font>\n     <span class=\"post-meta-divider\">|</span>\n   {% endif %}\n   ```\n\n   \n\n##### 在右上角或者左上角实现fork me on github\n\n1. 选择样式[GitHub Ribbons](https://blog.github.com/2008-12-19-github-ribbons/),\n2. 修改图片跳转链接,将`<a href=\"https://github.com/you\">`中的链接换为自己Github链接：\n3. 打开 `themes/next/layout/_layout.swig` 文件，把代码复制到`<div class=\"headband\"></div>`下面。\n\n##### 主页文章添加边框阴影效果\n\n打开 `themes/*/source/css/_custom/custom.styl` ,向里面加代码:\n\n```\n// 主页文章添加阴影效果\n.post {\n   margin-top: 0px;\n   margin-bottom: 60px;\n   padding: 25px;\n   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);\n   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);\n}\n```\n\n##### 显示当前浏览进度\n\n修改`themes/*/_config.yml`，把 `false` 改为 `true`：\n\n```\n# Back to top in sidebar\nb2t: true\n\n# Scroll percent label in b2t button\nscrollpercent: true\n```\n\n##### 创建分类页\n\n在终端窗口下，定位到 `Hexo` 站点目录下，新建：\n\n```\n$ cd <站点目录>\n$ hexo new page categories\n```\n\n##### 加入 广告\n\n主要有两种：[百度SSP](https://ssp.baidu.com/static/register.html)和[谷歌Adsense](https://www.google.com/adsense/start/#/?modal_active=none)。方法类似：\n\n1. 注册，复制广告代码\n\n2. 部署到网站。\n\n   2.1. 新建 `theme/*/layout/_custom/google_ad.swig`，将 AdSense 上的代码粘贴进去\n\n   2.2. 头部。在 `theme/*/layout/_custom/head.swig` 中也粘贴一份\n\n   2.3. 每篇博客。在 `theme/*/layout/post.swig` 里中在希望看到的地方加上：\n\n   ```\n   {% include '_custom/google_ad.swig' %}\n   ```\n\n   例如：在 `<div id=\"posts\" class=\"posts-expand\"> </div>` 中间插入，总代码如下：\n\n   ```\n   {% block content %}\n     <div id=\"posts\" class=\"posts-expand\">\n       {{ post_template.render(page) }}\n       {% include '_custom/google_ad.swig' %}\n     </div>\n   {% endblock %}\n   ```\n\n3. 等待审核通过。如果失败，可再次申请。\n\n##### 添加萌萌哒\n\n1. 安装插件\n\n   ```\n   npm install --save hexo-helper-live2d\n   ```\n\n2. 复制你喜欢的模型名字：\n\n   Epsilon2.1\n\n   [![img](Epsilon2.1.gif)](https://huaji8.top/img/live2d/Epsilon2.1.gif)\n\n   Gantzert_Felixander\n\n   [![img](Gantzert_Felixander.gif)](https://huaji8.top/img/live2d/Gantzert_Felixander.gif)\n\n   haru\n\n   [![img](haru.gif)](https://huaji8.top/img/live2d/haru.gif)\n\n   miku\n\n   [![img](miku.gif)](https://huaji8.top/img/live2d/miku.gif)\n\n   ni-j\n\n   [![img](ni-j.gif)](https://huaji8.top/img/live2d/ni-j.gif)\n\n   nico\n\n   [![img](nico.gif)](https://huaji8.top/img/live2d/nico.gif)\n\n   nietzche\n\n   [![img](nietzche.gif)](https://huaji8.top/img/live2d/nietzche.gif)\n\n   nipsilon\n\n   [![img](nipsilon.gif)](https://huaji8.top/img/live2d/nipsilon.gif)\n\n   nito\n\n   [![img](nito.gif)](https://huaji8.top/img/live2d/nito.gif)\n\n   shizuku\n\n   [![img](shizuku.gif)](https://huaji8.top/img/live2d/shizuku.gif)\n\n   tsumiki\n\n   [![img](tsumiki.gif)](https://huaji8.top/img/live2d/tsumiki.gif)\n\n   wanko\n\n   [![img](wanko.gif)](https://huaji8.top/img/live2d/wanko.gif)\n\n   z16\n\n   [![img](z16.gif)](https://huaji8.top/img/live2d/z16.gif)\n\n   hibiki\n\n   [![img](hibiki.gif)](https://huaji8.top/img/live2d/hibiki.gif)\n\n   koharu\n\n   [![img](koharu.gif)](https://huaji8.top/img/live2d/koharu.gif)\n\n   haruto\n\n   [![img](haruto.gif)](https://huaji8.top/img/live2d/haruto.gif)\n\n   Unitychan\n\n   [![img](Unitychan.gif)](https://huaji8.top/img/live2d/Unitychan.gif)\n\n   tororo\n\n   [![img](tororo.gif)](https://huaji8.top/img/live2d/tororo.gif)\n\n   hijiki\n\n   [![img](hijiki.gif)](https://huaji8.top/img/live2d/hijiki.gif)\n\n3. 将以下代码添加到主题配置文件`_config.yml`，修改<你喜欢的模型名字>：\n\n   ```\n   live2d:\n     enable: true\n     scriptFrom: local\n     pluginRootPath: live2dw/\n     pluginJsPath: lib/\n     pluginModelPath: assets/\n     tagMode: false\n     log: false\n     model:\n       use: live2d-widget-model-<你喜欢的模型名字>\n     display:\n       position: right\n       width: 150\n       height: 300\n     mobile:\n       show: true\n   ```\n\n4. 建配置文件\n\n   4.1. 在站点目录下建文件夹`live2d_models`，\n\n   4.2. 再在`live2d_models`下建文件夹`<你喜欢的模型名字>`,\n\n   4.3. 再在`<你喜欢的模型名字>`下建json文件：<你喜欢的模型名字>.model.json\n\n5. 安装模型。在命令行（即Git Bash）运行以下命令即可：\n\n   > npm install –save live2d-widget-model-<你喜欢的模型名字>\n\n6. 在命令行（即Git Bash）运行以下命令， 在`http://127.0.0.1:4000/`查看测试结果:\n\n   > hexo clean && hexo g && hexo s\n\n\n\n### 插件配置\n\n以下插件（评论系统、数据统计与分析、内容分享服务、搜索服务）各选一个即可。\n\n#### 评论系统\n\n|                                             | 推荐指数 | 优点                        | 缺点               |\n| ------------------------------------------- | -------- | --------------------------- | ------------------ |\n| [Valine](https://valine.js.org/)            | 4        | 每天30000条评论，10GB的储存 | 作者评论无标识     |\n| [来必力/livere](https://livere.com/)        | 4        | 多种账号登录                | 评论无法导出       |\n| [畅言](http://changyan.kuaizhan.com/)       | 3        | 美观                        | 必须备案域名       |\n| [gitment](https://github.com/imsun/gitment) | 3        | 简洁                        | 只能登陆github评论 |\n| Disqus                                      | 1        |                             | 需要翻*墙          |\n\n##### Valine\n\n1.1. 获取APP ID 和 APP Key\n\n请先登录或注册 [LeanCloud](https://leancloud.cn/), 进入控制台后点击左下角创建应用，\n\n进入刚刚创建的应用，选择左下角的`设置`>`应用Key`，然后就能看到你的`APP ID`和`APP Key`了。\n\n1.2. 填写APP ID 和 APP Key到主题配置文件`_config.yml`\n\n1.3. 运行`hexo g&&hexo d`推送到博客。\n\n##### 来必力/livere\n\n2.1. 登陆 [来必力](https://livere.com/) 获取你的 LiveRe UID。\n\n2.2. 填写LiveRe UID到主题配置文件`_config.yml`\n\n##### 畅言\n\n3.1.获取APP ID 和 APP Key\n\n请先登录或注册 [畅言](http://changyan.kuaizhan.com/), 点击“立即免费获取畅言”，\n\n新建站点，点击管理，点击评论插件>评论管理，\n\n点击后台总览，然后就能看到你的`APP ID`和`APP Key`了。\n\n3.2. 填写APP ID 和 APP Key到主题配置文件`_config.yml`\n\n3.3. 运行`hexo g&&hexo d`推送到博客。\n\n##### gitment\n\n4.1. 安装插件：\n\n> npm i –save gitment\n\n4.2. 申请应用\n\n在[New OAuth App](https://github.com/settings/applications/new)为你的博客应用一个密钥:\n\n```\nApplication name:随便写\nHomepage URL:这个也可以随意写,就写你的博客地址就行\nApplication description:描述,也可以随意写\nAuthorization callback URL:这个必须写你的博客地址\n```\n\n4.3. 配置\n\n编辑主题配置文件`themes/*/_config.yml`:\n\n```\n# Gitment\n# Introduction: https://imsun.net/posts/gitment-introduction/\ngitment:\n  enable: true\n  mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway\n  count: true # Show comments count in post meta area\n  lazy: false # Comments lazy loading with a button\n  cleanly: false # Hide 'Powered by ...' on footer, and more\n  language: # Force language, or auto switch by theme\n  github_user: {you github user id}\n  github_repo: 公开的git仓库,评论会作为那个项目的issue\n  client_id: {刚才申请的ClientID}\n  client_secret: {刚才申请的Client Secret}\n  proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect\n  redirect_protocol: # Protocol of redirect_uri with force_redirect_pro\n```\n\n##### Disqus\n\n编辑 主题配置文件`themes/*/_config.yml`， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname。count 用于指定是否显示评论数量。\n\n```\ndisqus:\n  enable: false\n  shortname:\n  count: true\n```\n\n#### 数据统计与分析\n\n|                                                   | 推荐指数 | 优点                                           | 缺点   |\n| ------------------------------------------------- | -------- | ---------------------------------------------- | ------ |\n| [不蒜子](http://ibruce.info/2015/04/04/busuanzi/) | 4        | 可直接将访问次数显示在您在网页上（也可不显示） | 只计数 |\n| 百度统计                                          | 3        |                                                | 收录慢 |\n\n##### 不蒜子\n\n编辑 主题配置文件 `themes/*/_config.yml`中的`busuanzi_count`的配置项即可。\n\n* 当`enable: true`时，代表开启全局开关。\n* 若`site_uv`（本站访客数）、`site_pv`（本站访客数）、`page_pv`（本文总阅读量）的值均为`false`时，不蒜子仅作记录而不会在页面上显示。\n\n注意：\n\n```\n不蒜子官方因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！\n```\n\n解决办法：\n\n1. 找到主题调用不蒜子的swig文件。一般在”\\themes*\\layout_third-party\\analytics\\busuanzi-counter.swig”\n\n2. 更改域名\n\n   ```\n   把原有的：\n   <script async src=\"\u0001\u0001//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"></script>\n   域名改一下即可：\n   <script async src=\"\u0001\u0001//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"></script>\n   ```\n\n##### 百度统计\n\n1. 登录 [百度统计](http://tongji.baidu.com/)，定位到站点的代码获取页面\n\n2. 复制统计脚本 id，如图：\n\n   [![img](analytics-baidu-id.png)](http://theme-next.iissnan.com/uploads/five-minutes-setup/analytics-baidu-id.png)\n\n3. 编辑 主题配置文件`themes/*/_config.yml`，修改字段 `google_analytics`，值设置成你的统计脚本 id。\n\n#### 内容分享服务\n\n|                                                              | 推荐指数 | 优点 | 缺点                          |\n| ------------------------------------------------------------ | -------- | ---- | ----------------------------- |\n| [百度分享](http://share.baidu.com/)                          | 4        | 稳定 | 不太美观                      |\n| [need-more-share2](https://github.com/revir/need-more-share2) | 4        | 美观 | 更新不及时（比如微信分享API） |\n\n##### 百度分享\n\n编辑 主题配置文件，添加/修改字段 `baidushare`，值为 `true`即可。\n\n```\n# 百度分享服务\nbaidushare: true\n```\n\n##### need-more-share2\n\n编辑 主题配置文件，添加/修改字段 `needmoreshare2`，值为 `true`即可。\n\n```\nneedmoreshare2:\n  enable: true\n```\n\n#### 搜索服务\n\n|              | 推荐指数 | 优点     | 缺点   |\n| ------------ | -------- | -------- | ------ |\n| Local Search | 4        | 配置方便 |        |\n| Swiftype     | 2        |          | 需注册 |\n| Algolia      | 2        |          | 需注册 |\n\n##### Local Search\n\n添加百度/谷歌/本地 自定义站点内容搜索\n\n1. 安装 `hexo-generator-searchdb`，在站点的根目录下执行以下命令：\n\n   ```\n   $ npm install hexo-generator-searchdb --save\n   ```\n\n2. 编辑 站点配置文件，新增以下内容到任意位置：\n\n   ```\n   search:\n     path: search.xml\n     field: post\n     format: html\n     limit: 10000\n   ```\n\n3. 编辑 主题配置文件，启用本地搜索功能：\n\n   ```\n   # Local search\n   local_search:\n     enable: true\n   ```\n\n### 错误分析\n\n如果你使用Hexo遇到同样的问题,这里有一些常见问题的解决方案。\n\n#### YAML Parsing Error\n\n```\nJS-YAML: incomplete explicit mapping pair; a key node is missed at line 18, column 29:\n      last_updated: Last updated: %s\n```\n\n1. 参数中包含冒号，请用加引号，如`Last updated: %s`\n\n```\nJS-YAML: bad indentation of a mapping entry at line 18, column 31:\n      last_updated：\"Last updated: %s\"\n```\n\n1. 字段后面的冒号必须为**英文冒号**，如：last_updated:\n2. 字段冒号后面必须跟一个空格，如：last_updated: “Last updated: %s”\n\n#### EMFILE Error\n\n```\nError: EMFILE, too many open files\n```\n\n生成大量的文件时，可能遇到EMFILE错误。\n\n可以运行以下命令来增加允许同步I / O操作的数量。\n\n```\n$ ulimit -n 10000\n```\n\n#### Process Out of Memory\n\n当`hexo g`时，遇到以下错误：\n\n```\nFATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory\n```\n\n如下，更改`hexo-cli`文件的第一行，来增大nodejs堆内存.该bug已在[新版本](https://github.com/hexojs/hexo/issues/1735)修复。\n\n```\n#!/usr/bin/env node --max_old_space_size=8192\n```\n\n#### Git Deployment Problems\n\n1. **RPC failed**\n\n   ```\n   error: RPC failed; result=22, HTTP code = 403\n   \n   fatal: 'username.github.io' does not appear to be a git repository\n   ```\n\n   确保你有你的电脑上设置git正确或尝试使用HTTPS存储库URL。\n\n1. **Error: ENOENT: no such file or directory**\n\n这个需要有一定的git的知识，因为可能是由于写错了标签,类别,或文件名，导致本地和github冲突了，Git不能自动合并这一变化所以它打破了自动分支。\n\n**解决办法：**\n\n1. 检查文章的标签和类别,确保本地和github上是相同的。\n2. 合并分支（Commit）。\n3. 清除，重构。在站点目录下，命令行（即Git Bash）运行`hexo clean`和`hexo g`\n4. 手动将站点目录下的`public`文件夹复制到您的桌面\n5. 从你的master分支切换到部署在本地分支。\n6. 从桌面复制`public`文件夹到本地分支。\n7. 合并分支到github（Commit）。\n8. 切回master分支。\n\n#### Server Problems\n\n```\nError: listen EADDRINUSE\n```\n\n你可能使用相同的端口，同时开启了两个Hexo服务器。如果需要同时开启，可以尝试修改端口设置：\n\n```\n$ hexo server -p 5000\n```\n\n#### Plugin Installation Problems\n\n```\nnpm ERR! node-waf configure build\n```\n\n这个错误可能发生在试图安装一个用Cc++或另一个javascript语言编写的插件。确保您已经安装了正确的编译器在您的计算机上。\n\n#### Error with DTrace (Mac OS X)\n\n```\n{ [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n```\n\nDTrace安装可能有问题，重装:\n\n```\n$ npm install hexo --no-optional\n```\n\n详见 [#1326](https://github.com/hexojs/hexo/issues/1326#issuecomment-113871796)\n\n#### Iterate Data Model on Jade or Swig\n\nHexo使用仓库的数据模型。这不是一个数组,所以你可能需要将对象转换为iterable。\n\n```\n{% for post in site.posts.toArray() %}\n{% endfor %}\n```\n\n#### Data Not Updated\n\n一些数据不能更新或新生成的文件的最后一个版本完全相同。清理缓存，再试一次：\n\n```\n$ hexo clean\n```\n\n#### No command is executed\n\n那个不能使用除`help`、`init`和`version`以外的命令行（即Git Bash）时, 有可能时站点目录下的`package.json`文件，缺少`hexo` ，如下:\n\n```\n{\n  \"hexo\": {\n    \"version\": \"3.2.2\"\n  }\n}\n```\n\n#### Escape Contents\n\nHexo使用Nunjucks渲染的页面. `{ { } }`或`{ % % }`将解析和可能会引起麻烦， 如果要在博文中出现，必须使用三引号：\n\n```\nHello {{ sensitive }}\n```\n\n```\n#### ENOSPC Error (Linux)\n\n如果运行命令`$ hexo server` 返回一个错误:\nError: watch ENOSPC …\n可以通过运行`$ npm dedupe`或者以下命令行（即Git Bash）：\n$ echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p\n来增加测试时，你可以看见的文件数量。\n```\n\n\n\n```\n#### EMPERM Error (Windows Subsystem for Linux)\n\n如果在Windows Subsystem for Linux，运行命令`$ hexo server` 返回这个错误:\nError: watch /path/to/hexo/theme/ EMPERM\n\n因为目前在Windows Subsystem for Linux中，有些内容更改时，还不能实时更新到hexo服务器。\n所以需要重新编译，再启动服务器：\n$ hexo generate\n$ hexo server -s\n```\n\n\n\n```\n#### Template render error\n\n有时运行命令`$ hexo generate` 返回一个错误:\nFATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nTemplate render error: (unknown path)\n\n这意味着有些认不出来单词在你的文件，并且很可能在你的新博文,或者配置文件`_config.yml`中，比如缩进错误：\n```\n\n\n\n### 常用操作\n\n#### 创建文章\n\n命令：\n\n```\n$ hexo new [layout] <title>\n```\n\n参数说明：\n\n* [layout]可以为以下三种：\n\n| 参数名 | 功能                    | 文章路径       |\n| ------ | ----------------------- | -------------- |\n| post   | 新建博文                | source/_posts  |\n| page   | 新建页面（如404，分类） | source         |\n| draft  | 草稿                    | source/_drafts |\n\n草稿可通过一下命令发布：\n\n```\n$ hexo publish [layout] <title>\n```\n\n* title注意：\n\n  不是博文标题，\n\n  是博文markdown文件的名字，\n\n  也是博文链接的后缀（如`https://www.simon96.online/2018/10/12/hexo-tutorial/`中的hexo-tutorial）\n\n#### 文章模版\n\n* 创建模版\n\n  在新建文章时，Hexo 会根据 `scaffolds` 文件夹内相对应的文件来建立文件，例如：\n\n  ```\n  $ hexo new blog “simon”\n  ```\n\n   在执行这行指令时，Hexo 会尝试在 `scaffolds` 文件夹中寻找 `blog.md`，并根据其内容建立文章。\n\n* 修改参数\n\n  以下是您可以在模版中使用的变量：\n\n| 变量   | 描述         |\n| ------ | ------------ |\n| layout | 布局         |\n| title  | 标题         |\n| date   | 文件建立日期 |\n\n#### Front-matter\n\n就是博文最上方以 `---` 分隔的那部分。\n\n默认可以使用的Front-matter：\n\n| 参数         | 描述                 | 默认值       |\n| ------------ | -------------------- | ------------ |\n| `layout`     | 布局                 |              |\n| `title`      | 标题                 |              |\n| `date`       | 建立日期             | 文件建立日期 |\n| `updated`    | 更新日期             | 文件更新日期 |\n| `comments`   | 开启文章的评论功能   | true         |\n| `tags`       | 标签（不适用于分页） |              |\n| `categories` | 分类（不适用于分页） |              |\n| `permalink`  | 覆盖文章网址         |              |\n\n------\n\n\n\n","tags":["hexo"],"categories":["hexo"]},{"title":"Hello World","url":"%2Fposts%2F1243066710%2F","content":"欢迎来到[Hexo](https://hexo.io/)！这是你的第一篇文章。查看[文档](https://hexo.io/docs/)以获取更多信息。如果您在使用Hexo时遇到任何问题，可以在[故障排除中](https://hexo.io/docs/troubleshooting.html)找到答案，或者您可以在[GitHub上](https://github.com/hexojs/hexo/issues)询问我。 \n\n## 快速开始\n\n### 创建一个新帖子\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\n更多信息：[写作](https://hexo.io/docs/writing.html) \n\n### 运行服务器\n\n``` bash\n$ hexo server\n```\n\n更多信息：[服务器](https://hexo.io/docs/server.html) \n\n### 生成静态文件\n\n``` bash\n$ hexo generate\n```\n\n更多信息：[生成](https://hexo.io/docs/generating.html) \n\n### 部署到远程站点\n\n``` bash\n$ hexo deploy\n```\n\n更多信息：[部署](https://hexo.io/docs/deployment.html) ","tags":["test2"],"categories":["hexo"]}]